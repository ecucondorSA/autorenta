# Análisis de Código: Flujos de Locador y Locatario hasta Checkout

Este informe recorre los puntos clave del código que soporta la experiencia de un locador al publicar y gestionar un vehículo, y del locatario desde la búsqueda hasta el checkout. Cada observación referencia el archivo y la línea relevante para facilitar futuras iteraciones.

## 1. Experiencia del Locador

- **Publicación del vehículo**. La página de publicación define un `FormGroup` exhaustivo para datos técnicos, precios y políticas (`apps/web/src/app/features/cars/publish/publish-car.page.ts:52`). Antes de persistir el auto se geocodifica la dirección con un primer intento completo y un fallback a la ciudad (`apps/web/src/app/features/cars/publish/publish-car.page.ts:237`). La creación y el procesamiento de imágenes se delegan al servicio de autos, que obliga a optimizar y subir cada foto antes de registrar la entrada en Supabase (`apps/web/src/app/core/services/cars.service.ts:19`).
- **Dificultades al publicar**. El formulario no expone un campo `value_usd`, lo que obliga a estimaciones posteriores para seguros y pricing (mismo bloque en `publish-car.page.ts:52`). Si la geocodificación falla el sistema rellena coordenadas genéricas de Montevideo, lo que puede ubicar mal al auto (`apps/web/src/app/features/cars/publish/publish-car.page.ts:277`). Durante la carga de fotos la falta de un control de errores bloqueante deja al locador sin feedback cuando una imagen no se sube correctamente (`apps/web/src/app/core/services/cars.service.ts:37`).
- **Gestión de reservas y contacto**. La vista de reservas del dueño usa confirmaciones nativas (`confirm`/`alert`) para cambiar estados, lo que rompe consistencia visual y accesibilidad (`apps/web/src/app/features/bookings/owner-bookings/owner-bookings.page.ts:134`). Ese mismo componente todavía muestra el `renter_id` en lugar del nombre/contacto del locatario porque `getRenterInfo` es un TODO (`apps/web/src/app/features/bookings/owner-bookings/owner-bookings.page.ts:183`), aun cuando el servicio ya expone un método para obtener email y teléfono del propietario/locatario (`apps/web/src/app/core/services/bookings.service.ts:820`). El chat embebido mantiene la conversación en tiempo real, pero mezcla `signal` con `ngModel`, lo que sobrescribe la señal al primer input (`apps/web/src/app/shared/components/booking-chat/booking-chat.component.ts:30` y `apps/web/src/app/shared/components/booking-chat/booking-chat.component.html:138`).
- **Recomendaciones para el locador**. Exponer `value_usd` con autocompletado almacenado, reemplazar `alert/confirm` por un modal coherente y consumir `getOwnerContact` para mostrar datos reales del locatario cerrarían los mayores huecos. Además, ajustar el binding del chat a `[(ngModel)]="newMessage()"` con un setter evitaría que el input pierda reactividad.

## 2. Experiencia del Locatario

- **Descubrir y seleccionar autos**. La vista de mapa/lista inicial recupera inventario y aplica filtros reactivos sobre señales (`apps/web/src/app/features/cars/list/cars-list.page.ts:434`). Cuando el usuario define fechas se llama a la RPC `get_available_cars`, pero luego se dispara una consulta por auto para traer fotos, multiplicando la latencia en mercados con mucho inventario (`apps/web/src/app/core/services/cars.service.ts:398`). El carrusel económico reutiliza `<app-car-card>` para mantener precios dinámicos, aunque el auto-scroll depende de timers que siguen activos si la página se oculta (`apps/web/src/app/features/cars/list/cars-list.page.ts:507`).
- **Evaluar el detalle del vehículo**. El detalle calcula tarifas totales a partir de las fechas seleccionadas; si faltan datos loguea advertencias en consola pero no comunica nada al usuario (`apps/web/src/app/features/cars/detail/car-detail.page.ts:70`). Al pulsar “Solicitar reserva” solo se navega al checkout con parámetros en query-string; aún no existe un booking real en la base, lo que permite que la disponibilidad cambie entre pantallas (`apps/web/src/app/features/cars/detail/car-detail.page.ts:341`).
- **Checkout y pago**. La página consolidada de pago concentra FX, riesgo y upgrades de cobertura, pero sigue tratando el objeto `car` como `any`, lo que complica validar campos requeridos (`apps/web/src/app/features/bookings/booking-detail-payment/booking-detail-payment.page.ts:133`). El servicio de pagos crea intents con conversiones estimadas (multiplicar o dividir por 1000), lo que es insuficiente para contabilidad real y puede romper si cambian monedas (`apps/web/src/app/core/services/payments.service.ts:25`). Aunque el flujo nuevo debería terminar aquí, todavía existe la página `checkout` marcada como deprecada; si el router la expone se reintroduce el recorrido en dos pasos que confunde a los usuarios (`apps/web/src/app/features/bookings/checkout/checkout.page.ts:1`).
- **Observaciones finales**. Consolidar definitivamente el flujo (eliminando la ruta deprecada), reemplazar los cálculos de cambio duro por datos de `FxService`, y crear el booking en cuanto el locatario pulse “Solicitar reserva” reducirían las ventanas de error. Añadir una confirmación post-pago consistente y enlazar directamente al chat (`apps/web/src/app/shared/components/booking-chat/booking-chat.component.ts:124`) facilitaría la coordinación entre partes.

---

**Siguientes pasos sugeridos**
- Priorizar la exposición de datos financieros reales en publication/checkout para cerrar disparidades de seguro y cobro.
- Unificar el sistema de comunicación (obtener contacto + chat) para evitar que el locador dependa de identificadores internos.
- Revisar la carga de inventario para limitar llamadas por auto y mejorar tiempos en ciudades con alta oferta.
