import { Component, Input, OnInit, OnDestroy, signal, computed, ViewChild, ElementRef } from '@angular/core';
import { CommonModule } from '@angular/common';
import { IonicModule } from '@ionic/angular';
import { FormsModule } from '@angular/forms';
import { ChatV3Service, ChatMessage, ChatThread } from '../../../../core/services/chat-v3.service';
import { NotificationManagerService } from '../../../../core/services/notification-manager.service';

@Component({
  selector: 'app-chat-thread-v3',
  standalone: true,
  imports: [CommonModule, IonicModule, FormsModule],
  template: `
    <div class="chat-container">
      <!-- Chat Header -->
      <div class="chat-header">
        <div class="chat-info">
          <img [src]="thread()?.carImage" alt="Car" class="car-thumbnail" />
          <div class="thread-details">
            <h3>{{ thread()?.carName }}</h3>
            <div class="participants">
              @for (participant of thread()?.participants; track participant.userId) {
                <span class="participant-status">
                  <span [class.online]="participant.isOnline" class="status-dot"></span>
                  {{ participant.name }}
                  @if (!participant.isOnline && participant.lastSeen) {
                    <span class="last-seen">{{ formatLastSeen(participant.lastSeen) }}</span>
                  }
                </span>
              }
            </div>
          </div>
        </div>

        <div class="chat-actions">
          <ion-button fill="clear" (click)="startVideoCall()">
            <ion-icon name="videocam-outline" slot="icon-only"></ion-icon>
          </ion-button>
          <ion-button fill="clear" (click)="openThreadOptions()">
            <ion-icon name="ellipsis-vertical" slot="icon-only"></ion-icon>
          </ion-button>
        </div>
      </div>

      <!-- Messages List -->
      <div class="messages-container" #messagesContainer>
        @if (isLoading()) {
          <div class="loading-state">
            <ion-spinner name="crescent"></ion-spinner>
          </div>
        } @else {
          <div class="messages-list">
            @for (message of messages(); track message.id) {
              <div
                class="message-wrapper"
                [class.is-mine]="isMyMessage(message)"
                [class.is-theirs]="!isMyMessage(message)"
              >
                @if (!isMyMessage(message)) {
                  <img
                    [src]="message.senderAvatar || '/assets/default-avatar.png'"
                    [alt]="message.senderName"
                    class="sender-avatar"
                  />
                }

                <div class="message-bubble">
                  @if (message.replyTo) {
                    <div class="reply-preview">
                      <ion-icon name="return-down-forward-outline"></ion-icon>
                      <span>Responde a un mensaje anterior</span>
                    </div>
                  }

                  @switch (message.messageType) {
                    @case ('text') {
                      <p class="message-content">{{ message.content }}</p>
                    }
                    @case ('image') {
                      <img
                        [src]="message.mediaUrl"
                        alt="Imagen"
                        class="message-image"
                        (click)="openImageViewer(message.mediaUrl!)"
                      />
                      @if (message.content) {
                        <p class="message-caption">{{ message.content }}</p>
                      }
                    }
                    @case ('video') {
                      <video
                        [src]="message.mediaUrl"
                        controls
                        class="message-video"
                      ></video>
                      @if (message.content) {
                        <p class="message-caption">{{ message.content }}</p>
                      }
                    }
                    @case ('voice') {
                      <div class="voice-message">
                        <ion-button fill="clear" (click)="playVoice(message)">
                          <ion-icon name="play-outline" slot="icon-only"></ion-icon>
                        </ion-button>
                        <div class="voice-waveform"></div>
                        <span class="voice-duration">
                          {{ formatDuration(message.mediaMetadata?.duration || 0) }}
                        </span>
                      </div>
                    }
                    @case ('location') {
                      <div class="location-message">
                        <ion-icon name="location" class="location-icon"></ion-icon>
                        <div class="location-details">
                          <strong>Ubicación compartida</strong>
                          <p>{{ message.mediaMetadata?.location?.address || 'Ver en mapa' }}</p>
                        </div>
                        <ion-button
                          size="small"
                          fill="outline"
                          (click)="openMap(message.mediaMetadata?.location!)"
                        >
                          Ver
                        </ion-button>
                      </div>
                    }
                    @case ('file') {
                      <div class="file-message">
                        <ion-icon name="document-outline" class="file-icon"></ion-icon>
                        <div class="file-details">
                          <strong>{{ message.mediaMetadata?.fileName }}</strong>
                          <span class="file-size">
                            {{ formatFileSize(message.mediaMetadata?.fileSize || 0) }}
                          </span>
                        </div>
                        <ion-button size="small" fill="clear">
                          <ion-icon name="download-outline" slot="icon-only"></ion-icon>
                        </ion-button>
                      </div>
                    }
                  }

                  <div class="message-meta">
                    <span class="message-time">{{ formatTime(message.createdAt) }}</span>
                    @if (isMyMessage(message)) {
                      <span class="message-status">
                        @switch (message.status) {
                          @case ('sending') {
                            <ion-icon name="time-outline" class="status-icon"></ion-icon>
                          }
                          @case ('sent') {
                            <ion-icon name="checkmark-outline" class="status-icon"></ion-icon>
                          }
                          @case ('delivered') {
                            <ion-icon name="checkmark-done-outline" class="status-icon"></ion-icon>
                          }
                          @case ('read') {
                            <ion-icon name="checkmark-done-outline" class="status-icon read"></ion-icon>
                          }
                          @case ('failed') {
                            <ion-icon name="alert-circle-outline" class="status-icon error"></ion-icon>
                          }
                        }
                      </span>
                    }
                  </div>
                </div>
              </div>
            }

            @if (isTyping()) {
              <div class="typing-indicator">
                <span></span>
                <span></span>
                <span></span>
              </div>
            }
          </div>
        }
      </div>

      <!-- Message Composer -->
      <div class="message-composer">
        @if (replyingTo()) {
          <div class="reply-bar">
            <ion-icon name="return-down-forward-outline"></ion-icon>
            <span>Respondiendo a mensaje</span>
            <ion-button fill="clear" size="small" (click)="cancelReply()">
              <ion-icon name="close-outline" slot="icon-only"></ion-icon>
            </ion-button>
          </div>
        }

        @if (attachmentPreview()) {
          <div class="attachment-preview">
            @switch (attachmentType()) {
              @case ('image') {
                <img [src]="attachmentPreview()!" alt="Preview" class="preview-image" />
              }
              @case ('video') {
                <video [src]="attachmentPreview()!" class="preview-video"></video>
              }
              @case ('file') {
                <div class="file-preview">
                  <ion-icon name="document-outline"></ion-icon>
                  <span>{{ selectedFile()?.name }}</span>
                </div>
              }
            }
            <ion-button fill="clear" size="small" (click)="removeAttachment()">
              <ion-icon name="close-circle" slot="icon-only"></ion-icon>
            </ion-button>
          </div>
        }

        <div class="composer-toolbar">
          <!-- Attachment Options -->
          <ion-button fill="clear" (click)="toggleAttachmentMenu()">
            <ion-icon name="add-circle-outline" slot="icon-only"></ion-icon>
          </ion-button>

          @if (showAttachmentMenu()) {
            <div class="attachment-menu">
              <ion-button fill="clear" (click)="selectImage()">
                <ion-icon name="image-outline"></ion-icon>
                Foto
              </ion-button>
              <ion-button fill="clear" (click)="selectVideo()">
                <ion-icon name="videocam-outline"></ion-icon>
                Video
              </ion-button>
              <ion-button fill="clear" (click)="selectFile()">
                <ion-icon name="document-outline"></ion-icon>
                Archivo
              </ion-button>
              <ion-button fill="clear" (click)="shareLocation()">
                <ion-icon name="location-outline"></ion-icon>
                Ubicación
              </ion-button>
            </div>
          }

          <!-- Text Input -->
          <ion-textarea
            [(ngModel)]="messageText"
            (ngModelChange)="onTyping()"
            (keydown.enter)="onEnterKey($event)"
            placeholder="Escribe un mensaje..."
            [autoGrow]="true"
            [rows]="1"
            class="message-input"
          ></ion-textarea>

          <!-- Voice/Send Button -->
          @if (messageText().trim() || attachmentPreview()) {
            <ion-button
              fill="clear"
              (click)="sendMessage()"
              [disabled]="isSending()"
              class="send-btn"
            >
              <ion-icon name="send" slot="icon-only"></ion-icon>
            </ion-button>
          } @else {
            <ion-button
              fill="clear"
              (click)="recordVoice()"
              [class.recording]="isRecording()"
            >
              <ion-icon name="mic-outline" slot="icon-only"></ion-icon>
            </ion-button>
          }
        </div>

        @if (isRecording()) {
          <div class="recording-indicator">
            <span class="recording-dot"></span>
            <span class="recording-time">{{ recordingTime() }}</span>
            <ion-button fill="clear" size="small" (click)="cancelRecording()">
              Cancelar
            </ion-button>
            <ion-button fill="clear" size="small" (click)="stopRecording()">
              <ion-icon name="checkmark" slot="icon-only"></ion-icon>
            </ion-button>
          </div>
        }
      </div>
    </div>
  `,
  styles: [`
    .chat-container {
      display: flex;
      flex-direction: column;
      height: 100%;
      background: #f5f5f5;
    }

    .chat-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem;
      background: white;
      border-bottom: 1px solid #e5e7eb;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
    }

    .chat-info {
      display: flex;
      gap: 0.75rem;
      align-items: center;
    }

    .car-thumbnail {
      width: 48px;
      height: 48px;
      border-radius: 8px;
      object-fit: cover;
    }

    .thread-details {
      h3 {
        font-size: 1rem;
        font-weight: 600;
        margin-bottom: 0.25rem;
      }
    }

    .participants {
      display: flex;
      gap: 1rem;
      font-size: 0.75rem;
      color: #6b7280;
    }

    .participant-status {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #9ca3af;

      &.online {
        background: #10b981;
      }
    }

    .last-seen {
      font-size: 0.7rem;
      color: #9ca3af;
    }

    .chat-actions {
      display: flex;
      gap: 0.5rem;
    }

    .messages-container {
      flex: 1;
      overflow-y: auto;
      padding: 1rem;
      scroll-behavior: smooth;
    }

    .loading-state {
      display: flex;
      justify-content: center;
      padding: 2rem;
    }

    .messages-list {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .message-wrapper {
      display: flex;
      gap: 0.5rem;
      align-items: flex-end;

      &.is-mine {
        flex-direction: row-reverse;
      }
    }

    .sender-avatar {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      object-fit: cover;
    }

    .message-bubble {
      max-width: 70%;
      padding: 0.75rem;
      border-radius: 12px;
      background: white;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);

      .is-mine & {
        background: linear-gradient(135deg, #3b82f6, #2563eb);
        color: white;
      }
    }

    .reply-preview {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem;
      background: rgba(0, 0, 0, 0.05);
      border-left: 3px solid #3b82f6;
      border-radius: 4px;
      margin-bottom: 0.5rem;
      font-size: 0.75rem;

      ion-icon {
        font-size: 1rem;
      }
    }

    .message-content {
      margin: 0;
      white-space: pre-wrap;
      word-wrap: break-word;
      line-height: 1.5;
    }

    .message-image {
      width: 100%;
      max-width: 300px;
      border-radius: 8px;
      cursor: pointer;
      margin-bottom: 0.5rem;
    }

    .message-video {
      width: 100%;
      max-width: 300px;
      border-radius: 8px;
      margin-bottom: 0.5rem;
    }

    .message-caption {
      margin: 0.5rem 0 0;
      font-size: 0.875rem;
    }

    .voice-message {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      padding: 0.5rem;

      .voice-waveform {
        flex: 1;
        height: 32px;
        background: linear-gradient(90deg, #3b82f6 0%, #3b82f6 50%, #e5e7eb 50%);
        border-radius: 4px;
      }

      .voice-duration {
        font-size: 0.75rem;
        color: #6b7280;
      }
    }

    .location-message,
    .file-message {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      padding: 0.5rem;

      .location-icon,
      .file-icon {
        font-size: 2rem;
        color: #3b82f6;
      }

      .location-details,
      .file-details {
        flex: 1;

        strong {
          display: block;
          font-size: 0.875rem;
          margin-bottom: 0.25rem;
        }

        p, .file-size {
          font-size: 0.75rem;
          color: #6b7280;
          margin: 0;
        }
      }
    }

    .message-meta {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-top: 0.25rem;
      font-size: 0.7rem;
      color: #9ca3af;

      .is-mine & {
        color: rgba(255, 255, 255, 0.7);
        justify-content: flex-end;
      }
    }

    .status-icon {
      font-size: 0.875rem;

      &.read {
        color: #3b82f6;
      }

      &.error {
        color: #ef4444;
      }
    }

    .typing-indicator {
      display: flex;
      gap: 4px;
      padding: 1rem;
      background: white;
      border-radius: 12px;
      width: fit-content;

      span {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: #9ca3af;
        animation: typing 1.4s infinite;

        &:nth-child(2) {
          animation-delay: 0.2s;
        }

        &:nth-child(3) {
          animation-delay: 0.4s;
        }
      }
    }

    @keyframes typing {
      0%, 60%, 100% {
        transform: translateY(0);
        opacity: 0.7;
      }
      30% {
        transform: translateY(-10px);
        opacity: 1;
      }
    }

    .message-composer {
      background: white;
      border-top: 1px solid #e5e7eb;
      padding: 0.75rem;
    }

    .reply-bar {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem;
      background: #eff6ff;
      border-left: 3px solid #3b82f6;
      border-radius: 4px;
      margin-bottom: 0.5rem;
      font-size: 0.875rem;
    }

    .attachment-preview {
      position: relative;
      margin-bottom: 0.5rem;
      padding: 0.5rem;
      background: #f9fafb;
      border-radius: 8px;

      .preview-image,
      .preview-video {
        max-width: 200px;
        max-height: 150px;
        border-radius: 6px;
      }

      .file-preview {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        font-size: 0.875rem;
      }

      ion-button {
        position: absolute;
        top: 0;
        right: 0;
      }
    }

    .composer-toolbar {
      display: flex;
      align-items: flex-end;
      gap: 0.5rem;
      position: relative;
    }

    .attachment-menu {
      position: absolute;
      bottom: 100%;
      left: 0;
      background: white;
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      padding: 0.5rem;
      margin-bottom: 0.5rem;
      display: flex;
      flex-direction: column;
      gap: 0.25rem;

      ion-button {
        justify-content: flex-start;
        font-size: 0.875rem;
      }
    }

    .message-input {
      flex: 1;
      --padding-start: 0.75rem;
      --padding-end: 0.75rem;
      background: #f9fafb;
      border-radius: 20px;
    }

    .send-btn {
      --color: #3b82f6;
    }

    .recording {
      --color: #ef4444;
      animation: pulse 1.5s infinite;
    }

    @keyframes pulse {
      0%, 100% {
        opacity: 1;
      }
      50% {
        opacity: 0.5;
      }
    }

    .recording-indicator {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      padding: 0.75rem;
      background: #fef2f2;
      border-radius: 8px;
      margin-top: 0.5rem;
    }

    .recording-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #ef4444;
      animation: pulse 1.5s infinite;
    }

    .recording-time {
      font-weight: 600;
      color: #ef4444;
    }
  `]
})
export class ChatThreadV3Component implements OnInit, OnDestroy {
  @Input() threadId!: string;
  @ViewChild('messagesContainer') messagesContainer!: ElementRef;

  thread = signal<ChatThread | null>(null);
  messages = signal<ChatMessage[]>([]);
  isLoading = signal(true);
  isSending = signal(false);
  isTyping = signal(false);
  isRecording = signal(false);

  messageText = signal('');
  replyingTo = signal<string | null>(null);
  showAttachmentMenu = signal(false);
  attachmentPreview = signal<string | null>(null);
  attachmentType = signal<'image' | 'video' | 'file' | null>(null);
  selectedFile = signal<File | null>(null);
  recordingTime = signal('0:00');

  private typingTimeout: any;
  private recordingInterval: any;
  private recordingStartTime = 0;

  constructor(
    private chatService: ChatV3Service,
    private notifications: NotificationManagerService
  ) {}

  async ngOnInit() {
    await this.loadThread();
    await this.loadMessages();
  }

  ngOnDestroy() {
    if (this.typingTimeout) clearTimeout(this.typingTimeout);
    if (this.recordingInterval) clearInterval(this.recordingInterval);
  }

  async loadThread() {
    // TODO: Load thread details
    this.isLoading.set(true);
    const threads = await this.chatService.getThreadsForUser();
    const thread = threads.find(t => t.id === this.threadId);
    if (thread) {
      this.thread.set(thread);
    }
    this.isLoading.set(false);
  }

  async loadMessages() {
    const messages = await this.chatService.getMessagesForThread(this.threadId);
    this.messages.set(messages);
    this.scrollToBottom();
  }

  isMyMessage(message: ChatMessage): boolean {
    // TODO: Get current user ID and compare
    return message.senderId === 'user-2';
  }

  onTyping() {
    if (this.typingTimeout) clearTimeout(this.typingTimeout);

    // TODO: Send typing indicator to other participants via realtime

    this.typingTimeout = setTimeout(() => {
      // Stop typing indicator
    }, 2000);
  }

  onEnterKey(event: KeyboardEvent) {
    if (event.shiftKey) {
      return; // Allow new line with Shift+Enter
    }
    event.preventDefault();
    this.sendMessage();
  }

  async sendMessage() {
    const text = this.messageText().trim();

    if (!text && !this.selectedFile()) {
      return;
    }

    this.isSending.set(true);

    try {
      if (this.selectedFile()) {
        await this.chatService.sendMediaMessage(
          this.threadId,
          this.selectedFile()!,
          this.attachmentType()!
        );
        this.removeAttachment();
      } else {
        await this.chatService.sendTextMessage(
          this.threadId,
          text,
          this.replyingTo() || undefined
        );
      }

      this.messageText.set('');
      this.replyingTo.set(null);
      await this.loadMessages();
    } catch (error) {
      console.error('Error sending message:', error);
      this.notifications.error('Error', 'No se pudo enviar el mensaje');
    } finally {
      this.isSending.set(false);
    }
  }

  toggleAttachmentMenu() {
    this.showAttachmentMenu.update(v => !v);
  }

  selectImage() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = 'image/*';
    input.onchange = (e: any) => {
      const file = e.target?.files?.[0];
      if (file) {
        this.selectedFile.set(file);
        this.attachmentType.set('image');
        this.attachmentPreview.set(URL.createObjectURL(file));
      }
    };
    input.click();
    this.showAttachmentMenu.set(false);
  }

  selectVideo() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = 'video/*';
    input.onchange = (e: any) => {
      const file = e.target?.files?.[0];
      if (file) {
        this.selectedFile.set(file);
        this.attachmentType.set('video');
        this.attachmentPreview.set(URL.createObjectURL(file));
      }
    };
    input.click();
    this.showAttachmentMenu.set(false);
  }

  selectFile() {
    const input = document.createElement('input');
    input.type = 'file';
    input.onchange = (e: any) => {
      const file = e.target?.files?.[0];
      if (file) {
        this.selectedFile.set(file);
        this.attachmentType.set('file');
        this.attachmentPreview.set('file');
      }
    };
    input.click();
    this.showAttachmentMenu.set(false);
  }

  async shareLocation() {
    if (!navigator.geolocation) {
      this.notifications.warning('Ubicación', 'Geolocalización no disponible en este dispositivo');
      return;
    }

    navigator.geolocation.getCurrentPosition(
      async (position) => {
        const location = {
          lat: position.coords.latitude,
          lng: position.coords.longitude
        };

        try {
          await this.chatService.sendLocationMessage(this.threadId, location);
          await this.loadMessages();
        } catch (error) {
          this.notifications.error('Error', 'No se pudo compartir la ubicación');
        }
      },
      (error) => {
        this.notifications.error('Error', 'No se pudo obtener tu ubicación');
      }
    );

    this.showAttachmentMenu.set(false);
  }

  removeAttachment() {
    this.selectedFile.set(null);
    this.attachmentType.set(null);
    this.attachmentPreview.set(null);
  }

  cancelReply() {
    this.replyingTo.set(null);
  }

  async recordVoice() {
    // TODO: Implement voice recording
    this.isRecording.set(true);
    this.recordingStartTime = Date.now();

    this.recordingInterval = setInterval(() => {
      const elapsed = Math.floor((Date.now() - this.recordingStartTime) / 1000);
      const minutes = Math.floor(elapsed / 60);
      const seconds = elapsed % 60;
      this.recordingTime.set(`${minutes}:${seconds.toString().padStart(2, '0')}`);
    }, 100);
  }

  cancelRecording() {
    this.isRecording.set(false);
    if (this.recordingInterval) {
      clearInterval(this.recordingInterval);
    }
    this.recordingTime.set('0:00');
  }

  async stopRecording() {
    this.isRecording.set(false);
    if (this.recordingInterval) {
      clearInterval(this.recordingInterval);
    }

    // TODO: Save recorded audio and send
    this.notifications.info('Grabación de voz', 'Esta función estará disponible próximamente');
    this.recordingTime.set('0:00');
  }

  async startVideoCall() {
    try {
      const roomId = await this.chatService.startVideoCall(this.threadId);
      // TODO: Navigate to video call screen with roomId
      console.log('Video call room:', roomId);
    } catch (error) {
      this.notifications.error('Error', 'No se pudo iniciar la videollamada');
    }
  }

  openThreadOptions() {
    // TODO: Show thread options (mute, block, report, etc.)
  }

  openImageViewer(url: string) {
    // TODO: Open full-screen image viewer
    window.open(url, '_blank');
  }

  playVoice(message: ChatMessage) {
    // TODO: Play voice message
  }

  openMap(location: { lat: number; lng: number; address?: string }) {
    // TODO: Open map view
    window.open(`https://www.google.com/maps?q=${location.lat},${location.lng}`, '_blank');
  }

  formatTime(date: Date): string {
    return new Intl.DateTimeFormat('es-AR', {
      hour: '2-digit',
      minute: '2-digit'
    }).format(new Date(date));
  }

  formatLastSeen(date: Date): string {
    const now = new Date();
    const diff = now.getTime() - new Date(date).getTime();
    const minutes = Math.floor(diff / 60000);

    if (minutes < 1) return 'ahora';
    if (minutes < 60) return `hace ${minutes}m`;

    const hours = Math.floor(minutes / 60);
    if (hours < 24) return `hace ${hours}h`;

    return 'ayer';
  }

  formatDuration(seconds: number): string {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  }

  formatFileSize(bytes: number): string {
    if (bytes < 1024) return `${bytes} B`;
    if (bytes < 1048576) return `${(bytes / 1024).toFixed(1)} KB`;
    return `${(bytes / 1048576).toFixed(1)} MB`;
  }

  private scrollToBottom() {
    setTimeout(() => {
      if (this.messagesContainer) {
        const element = this.messagesContainer.nativeElement;
        element.scrollTop = element.scrollHeight;
      }
    }, 100);
  }
}
