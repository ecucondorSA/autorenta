
> autorenta-web@0.1.0 lint
> node_modules/.bin/ng lint --format json


Linting "web"...
[{"filePath":"/home/edu/autorenta/apps/web/src/app/app.component.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`./core/guided-tour` import should occur after import of `@core/services/infrastructure/pwa.service`","line":27,"column":1,"nodeType":"ImportDeclaration","endLine":27,"endColumn":56,"fix":{"range":[618,1661],"text":"import { AssetPreloaderService } from '@core/services/ui/asset-preloader.service';\nimport { AuthService } from '@core/services/auth/auth.service';\nimport { BookingApprovalService } from '@core/services/bookings/booking-approval.service';\nimport { CarsCompareService } from '@core/services/cars/cars-compare.service';\nimport { DebugService } from '@core/services/admin/debug.service';\nimport { HapticFeedbackService } from '@core/services/ui/haptic-feedback.service';\nimport { LocaleManagerService } from '@core/services/ui/locale-manager.service';\nimport { MapboxPreloaderService } from '@core/services/geo/mapbox-preloader.service';\nimport { MobileBottomNavPortalService } from '@core/services/ui/mobile-bottom-nav-portal.service';\nimport { ProfileService, UserProfile } from '@core/services/auth/profile.service';\nimport { PushNotificationService } from '@core/services/infrastructure/push-notification.service';\nimport { PwaService } from '@core/services/infrastructure/pwa.service';\nimport { GuidedTourService } from './core/guided-tour';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { NgOptimizedImage } from '@angular/common';\nimport {\n  ChangeDetectionStrategy,\n  Component,\n  DestroyRef,\n  ElementRef,\n  OnInit,\n  ViewChild,\n  computed,\n  inject,\n  signal,\n} from '@angular/core';\nimport { takeUntilDestroyed } from '@angular/core/rxjs-interop';\nimport {\n  ActivatedRoute,\n  ChildrenOutletContexts,\n  NavigationEnd,\n  Router,\n  RouterLink,\n  RouterLinkActive,\n  RouterOutlet,\n} from '@angular/router';\nimport { Capacitor } from '@capacitor/core';\nimport { StatusBar, Style } from '@capacitor/status-bar';\nimport { TranslateModule } from '@ngx-translate/core';\nimport { filter } from 'rxjs';\nimport { GuidedTourService } from './core/guided-tour';\nimport { AssetPreloaderService } from '@core/services/ui/asset-preloader.service';\nimport { AuthService } from '@core/services/auth/auth.service';\nimport { BookingApprovalService } from '@core/services/bookings/booking-approval.service';\nimport { CarsCompareService } from '@core/services/cars/cars-compare.service';\nimport { DebugService } from '@core/services/admin/debug.service';\nimport { HapticFeedbackService } from '@core/services/ui/haptic-feedback.service';\nimport { LocaleManagerService } from '@core/services/ui/locale-manager.service';\nimport { MapboxPreloaderService } from '@core/services/geo/mapbox-preloader.service';\nimport { MobileBottomNavPortalService } from '@core/services/ui/mobile-bottom-nav-portal.service';\nimport { ProfileService, UserProfile } from '@core/services/auth/profile.service';\nimport { PushNotificationService } from '@core/services/infrastructure/push-notification.service';\nimport { PwaService } from '@core/services/infrastructure/pwa.service';\nimport { FooterComponent } from './shared/components/footer/footer.component';\nimport { HelpButtonComponent } from './shared/components/help-button/help-button.component';\nimport { LanguageSelectorComponent } from './shared/components/language-selector/language-selector.component';\nimport { NotificationsComponent } from './shared/components/notifications/notifications.component';\nimport { PendingReviewsBannerComponent } from './shared/components/pending-reviews-banner/pending-reviews-banner.component';\nimport { PwaInstallBannerComponent } from './shared/components/pwa-install-banner/pwa-install-banner.component';\nimport { PwaTitlebarComponent } from './shared/components/pwa-titlebar/pwa-titlebar.component';\nimport { PwaUpdatePromptComponent } from './shared/components/pwa-update-prompt/pwa-update-prompt.component';\nimport { ShareButtonComponent } from './shared/components/share-button/share-button.component';\n\nimport { DebugPanelComponent } from './shared/components/debug-panel/debug-panel.component';\nimport { HeaderIconComponent } from './shared/components/header-icon/header-icon.component';\nimport { IconComponent } from './shared/components/icon/icon.component';\nimport { MobileMenuDrawerComponent } from './shared/components/mobile-menu-drawer/mobile-menu-drawer.component';\nimport { SplashScreenComponent } from './shared/components/splash-screen/splash-screen.component';\nimport { VerificationBadgeComponent } from './shared/components/verification-badge/verification-badge.component';\nimport { VerificationPromptBannerComponent } from './shared/components/verification-prompt-banner/verification-prompt-banner.component';\nimport { ClickOutsideDirective } from './shared/directives/click-outside.directive';\nimport { OfflineBannerComponent } from './shared/components/offline-banner/offline-banner.component';\n\nimport { routeAnimations } from './core/animations/route-animations'; // Importar animaciones\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  imports: [\n    NgOptimizedImage,\n    RouterOutlet,\n    RouterLink,\n    RouterLinkActive,\n    TranslateModule,\n    PendingReviewsBannerComponent,\n    VerificationPromptBannerComponent,\n    PwaInstallBannerComponent,\n    PwaUpdatePromptComponent,\n    PwaTitlebarComponent,\n    VerificationBadgeComponent,\n    LanguageSelectorComponent,\n    HelpButtonComponent,\n    NotificationsComponent,\n    ShareButtonComponent,\n    FooterComponent,\n    IconComponent,\n    SplashScreenComponent,\n    MobileMenuDrawerComponent,\n    HeaderIconComponent,\n    ClickOutsideDirective,\n    DebugPanelComponent,\n    OfflineBannerComponent\n  ],\n  templateUrl: './app.component.html',\n  styles: [\n    `\n      :host {\n        display: block;\n        /* Asegurar que app-root no cree nuevo stacking context */\n        transform: none !important;\n        will-change: auto !important;\n        isolation: auto !important;\n      }\n\n      /* Fix for bottom nav bar - ensure body doesn't have transform */\n      :host-context(body) {\n        transform: none !important;\n      }\n\n      /* Custom scrollbar para el dropdown del perfil */\n      [data-profile-menu]::-webkit-scrollbar {\n        width: 6px;\n      }\n\n      [data-profile-menu]::-webkit-scrollbar-track {\n        background: transparent;\n      }\n\n      [data-profile-menu]::-webkit-scrollbar-thumb {\n        background: rgba(0, 0, 0, 0.2);\n        border-radius: 3px;\n      }\n\n      [data-profile-menu]::-webkit-scrollbar-thumb:hover {\n        background: #7B7B7B;\n      }\n\n\n\n      /* Firefox scrollbar */\n      [data-profile-menu] {\n        scrollbar-width: thin;\n        scrollbar-color: rgba(0, 0, 0, 0.2) transparent;\n      }\n\n\n\n      /* Header en home: usa colores de tokens, sin forzar blanco ni gradientes */\n      .header-transparent {\n        color: var(--text-primary) !important;\n        background: rgba(255, 255, 255, 0.12);\n        backdrop-filter: blur(18px);\n        border: 1px solid rgba(255, 255, 255, 0.25);\n        box-shadow: 0 24px 60px rgba(0, 0, 0, 0.25);\n      }\n\n      .header-transparent * {\n        color: inherit !important;\n      }\n\n      .header-transparent svg {\n        stroke: currentColor !important;\n      }\n\n      .header-transparent img {\n        filter: none !important;\n      }\n\n      .header-transparent .nav-link,\n      .header-transparent .nav-link-primary,\n      .header-transparent .nav-link-highlight,\n      .header-transparent .icon-button {\n        color: var(--text-primary) !important;\n      }\n\n      .header-transparent .nav-link:hover,\n      .header-transparent .nav-link-primary:hover,\n      .header-transparent .icon-button:hover {\n        background-color: var(--surface-secondary);\n      }\n\n      .header-transparent .nav-link-highlight {\n        background: var(--warning-300);\n        color: var(--text-primary);\n        box-shadow: none;\n      }\n    `,\n  ],\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  animations: [routeAnimations], // Registrar la animación\n})\nexport class AppComponent implements OnInit {\n  // ... imports anteriores ...\n\n  // Método para detectar la animación de la ruta\n  prepareRoute(outlet: RouterOutlet) {\n    return outlet && outlet.activatedRouteData && outlet.activatedRouteData['animation'];\n  }\n\n\n  private readonly authService = inject(AuthService);\n  private readonly profileService = inject(ProfileService);\n  private readonly assetPreloader = inject(AssetPreloaderService);\n  private readonly mapboxPreloader = inject(MapboxPreloaderService);\n  private readonly debugService = inject(DebugService); // Initialize early for e2e tests\n  private readonly bookingApprovalService = inject(BookingApprovalService);\n\n  readonly userEmail = this.authService.userEmail;\n  private readonly compareService = inject(CarsCompareService);\n  private readonly pwaService = inject(PwaService);\n  private readonly guidedTour = inject(GuidedTourService);\n  private readonly localeManager = inject(LocaleManagerService);\n  private readonly pushNotificationService = inject(PushNotificationService);\n  private readonly router = inject(Router);\n  private readonly activatedRoute = inject(ActivatedRoute);\n  private readonly destroyRef = inject(DestroyRef);\n  private readonly mobileBottomNavPortal: MobileBottomNavPortalService = inject(\n    MobileBottomNavPortalService,\n  );\n  private readonly contexts = inject(ChildrenOutletContexts);\n  private readonly hapticService = inject(HapticFeedbackService); // Injected HapticFeedbackService\n  private readonly isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';\n\n  readonly isAuthenticatedSig = this.authService.isAuthenticated;\n  // ... (resto de readonly signals) ...\n\n  triggerHapticFeedback(): void {\n    this.hapticService.selection();\n  }\n  readonly compareCountSig = computed(() => this.compareService.count());\n  readonly sidebarOpen = signal(false);\n  readonly profileMenuOpen = signal(false);\n  readonly mobileMenuDrawerOpen = signal(false);\n\n  // Legacy binding placeholder: UI no longer uses dark mode toggle, keep for template compatibility\n  readonly darkMode = false;\n\n  readonly fullBleedLayout = signal(false);\n  readonly hideFooter = signal(false);\n  readonly hideMobileNav = signal(false);\n  readonly userProfile = signal<UserProfile | null>(null);\n  readonly isOnVerificationPage = signal(false);\n  readonly isHomePage = signal(false); // Header transparente en homepage\n  readonly pendingApprovalCount = signal(0); // Contador de solicitudes pendientes para propietarios\n\n  @ViewChild('menuButton', { read: ElementRef }) menuButton?: ElementRef<HTMLButtonElement>;\n  @ViewChild('sidebarPanel', { read: ElementRef }) sidebarPanel?: ElementRef<HTMLElement>;\n  @ViewChild('profileButton', { read: ElementRef }) profileButton?: ElementRef<HTMLButtonElement>;\n\n  /**\n   * Elements to exclude from profile menu click-outside detection\n   */\n  get profileMenuExcludedElements(): HTMLElement[] {\n    return this.profileButton?.nativeElement ? [this.profileButton.nativeElement] : [];\n  }\n\n  year = new Date().getFullYear();\n\n\n  toggleSidebar(): void {\n    this.sidebarOpen.update((v) => !v);\n    this.syncSidebarSideEffects(this.sidebarOpen());\n  }\n\n  closeSidebar(): void {\n    this.sidebarOpen.set(false);\n    this.syncSidebarSideEffects(false);\n  }\n\n  async signOut(): Promise<void> {\n    await this.authService.signOut();\n    this.closeProfileMenu();\n    this.router.navigate(['/']);\n  }\n\n  onSidebarKeydown(event: KeyboardEvent): void {\n    if (event.key === 'Escape') {\n      this.closeSidebar();\n    }\n  }\n\n\n\n  toggleProfileMenu(): void {\n    this.profileMenuOpen.update((v) => !v);\n  }\n\n  closeProfileMenu(): void {\n    this.profileMenuOpen.set(false);\n  }\n\n  openMobileMenuDrawer(): void {\n    this.mobileMenuDrawerOpen.set(true);\n  }\n\n  closeMobileMenuDrawer(): void {\n    this.mobileMenuDrawerOpen.set(false);\n  }\n\n  ngOnInit(): void {\n    // SSR-safe: Only run browser-specific initialization in browser\n    if (!this.isBrowser) {\n      return;\n    }\n\n    this.handleOAuthCallbackRedirect();\n    this.initializeTheme();\n    this.initializeLayoutWatcher();\n    this.loadUserProfile();\n    this.loadPendingApprovalCount();\n    this.pushNotificationService.initializePushNotifications();\n    this.initializeProfileMenuCloseOnNavigation();\n    this.checkVerificationPage(this.router.url);\n\n    // Configurar Edge-to-Edge en móvil\n    if (Capacitor.isNativePlatform()) {\n      try {\n        void StatusBar.setOverlaysWebView({ overlay: true });\n        void StatusBar.setStyle({ style: Style.Light }); // O Dark según el tema\n      } catch (e) {\n        console.warn('StatusBar not available', e);\n      }\n    }\n\n    // Renderizar barra inferior movil directamente en body para evitar issues de stacking\n    this.mobileBottomNavPortal.create();\n    this.mobileBottomNavPortal.setHidden(this.hideMobileNav());\n    this.destroyRef.onDestroy(() => this.mobileBottomNavPortal.destroy());\n\n    // Subscribe to mobile menu drawer open event\n    this.mobileBottomNavPortal.menuOpen$\n      .pipe(takeUntilDestroyed(this.destroyRef))\n      .subscribe(() => this.openMobileMenuDrawer());\n  }\n\n  private initializeTheme(): void {\n    if (!this.isBrowser) {\n      return;\n    }\n    localStorage.setItem('theme', 'light');\n    document.documentElement.classList.remove('dark');\n    window.dispatchEvent(new CustomEvent('autorenta:theme-change', { detail: { dark: false } }));\n  }\n\n  private initializeLayoutWatcher(): void {\n    this.syncLayoutFromRoute(this.activatedRoute);\n    this.router.events\n      .pipe(\n        filter((event): event is NavigationEnd => event instanceof NavigationEnd),\n        takeUntilDestroyed(this.destroyRef),\n      )\n      .subscribe(() => {\n        this.syncLayoutFromRoute(this.activatedRoute);\n        this.checkVerificationPage(this.router.url);\n      });\n  }\n\n  private initializeProfileMenuCloseOnNavigation(): void {\n    this.router.events\n      .pipe(\n        filter((event) => event instanceof NavigationEnd),\n        takeUntilDestroyed(this.destroyRef),\n      )\n      .subscribe(() => {\n        this.profileMenuOpen.set(false);\n      });\n  }\n\n  private syncLayoutFromRoute(route: ActivatedRoute): void {\n    let current: ActivatedRoute | null = route;\n\n    while (current?.firstChild) {\n      current = current.firstChild;\n    }\n\n    const layout = current?.snapshot.data?.['layout'];\n    this.fullBleedLayout.set(layout === 'full-bleed');\n\n    this.hideFooter.set(Boolean(current?.snapshot.data?.['hideFooter']));\n    this.hideMobileNav.set(Boolean(current?.snapshot.data?.['hideMobileNav']));\n    this.mobileBottomNavPortal.setHidden(this.hideMobileNav());\n\n    // Detectar si estamos en el homepage para header transparente\n    const currentUrl = this.router.url.split('?')[0]; // Ignorar query params\n    const isHome = currentUrl === '/' || currentUrl === '';\n    this.isHomePage.set(isHome);\n  }\n\n  private syncSidebarSideEffects(open: boolean): void {\n    if (!this.isBrowser) {\n      return;\n    }\n\n    document.documentElement.classList.toggle('overflow-hidden', open);\n\n    if (open) {\n      queueMicrotask(() => {\n        const target = this.getSidebarFocusableElements()[0] ?? this.sidebarPanel?.nativeElement;\n        target?.focus({ preventScroll: true });\n      });\n    } else {\n      queueMicrotask(() => this.menuButton?.nativeElement.focus());\n    }\n  }\n\n  private getSidebarFocusableElements(): HTMLElement[] {\n    if (!this.sidebarPanel) {\n      return [];\n    }\n\n    const focusableSelectors = [\n      'a[href]',\n      'button:not([disabled])',\n      'textarea:not([disabled])',\n      'input:not([disabled])',\n      'select:not([disabled])',\n      '[tabindex]:not([tabindex=\"-1\"])',\n    ].join(',');\n\n    return Array.from(\n      this.sidebarPanel.nativeElement.querySelectorAll<HTMLElement>(focusableSelectors),\n    ).filter((element) => !element.hasAttribute('disabled') && element.tabIndex !== -1);\n  }\n\n  private initializeWelcomeTour(): void {\n    // NEW TOUR SYSTEM: Tours with autoStart: true will start automatically\n    // No manual initialization needed! TourOrchestrator handles it.\n\n    // Enable debug mode in development\n    if (!this.isBrowser) {\n      return;\n    }\n\n    const isDev = !window.location.hostname.includes('autorentar.com');\n    if (isDev) {\n      this.guidedTour.enableDebug();\n    }\n\n    // Tours are now managed by TourOrchestrator based on:\n    // - autoStart flag in TourDefinition\n    // - Guards (isHomePage, hasInventory, etc.)\n    // - Triggers (route patterns, custom events)\n    // - Throttle periods (won't show if already completed recently)\n  }\n\n  private async loadUserProfile(): Promise<void> {\n    if (!this.isAuthenticatedSig()) {\n      return;\n    }\n\n    try {\n      const profile = await this.profileService.getCurrentProfile();\n      this.userProfile.set(profile);\n    } catch {\n      // Silently fail - avatar will show placeholder\n    }\n  }\n\n  private async loadPendingApprovalCount(): Promise<void> {\n    if (!this.isAuthenticatedSig()) {\n      this.pendingApprovalCount.set(0);\n      return;\n    }\n\n    try {\n      const pendingApprovals = await this.bookingApprovalService.getPendingApprovals();\n      this.pendingApprovalCount.set(pendingApprovals.length);\n    } catch {\n      // Silently fail - badge will not show\n      this.pendingApprovalCount.set(0);\n    }\n  }\n\n  private checkVerificationPage(url: string): void {\n    // Hide verification banner on verification-related pages to avoid layout conflicts\n    const verificationRoutes = [\n      '/profile/verification',\n      '/verification',\n      '/verification/upload-documents',\n    ];\n\n    const isOnVerificationPage = verificationRoutes.some((route) => url.includes(route));\n\n    this.isOnVerificationPage.set(isOnVerificationPage);\n  }\n\n  /**\n   * Detecta tokens de OAuth en el hash de la URL y redirige a /auth/callback si es necesario\n   * Esto maneja el caso donde Supabase redirige a la raíz (/) en lugar de /auth/callback\n   */\n  private handleOAuthCallbackRedirect(): void {\n    if (!this.isBrowser) {\n      return;\n    }\n\n    // Verificar si hay tokens de OAuth en el hash (access_token, refresh_token, etc.)\n    const hash = window.location.hash;\n    const hasOAuthTokens =\n      hash.includes('access_token=') ||\n      hash.includes('refresh_token=') ||\n      hash.includes('provider_token=');\n\n    // Solo redirigir si estamos en la raíz y no ya en /auth/callback\n    const isRoot = window.location.pathname === '/' || window.location.pathname === '';\n    const isNotCallback = !window.location.pathname.includes('/auth/callback');\n\n    if (hasOAuthTokens && isRoot && isNotCallback) {\n      // Redirigir a /auth/callback preservando el hash\n      void this.router.navigate(['/auth/callback'], {\n        fragment: hash.substring(1), // Remover el '#' del hash\n        replaceUrl: true, // Reemplazar en el historial para evitar loops\n      });\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/app.config.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`@core/services/admin/debug.service` import should occur before import of `./app.routes`","line":31,"column":1,"nodeType":"ImportDeclaration","endLine":31,"endColumn":67,"fix":{"range":[834,1282],"text":"import { DebugService } from '@core/services/admin/debug.service';\nimport { routes } from './app.routes';\nimport { authRefreshInterceptor } from './core/interceptors/auth-refresh.interceptor';\nimport { httpCacheInterceptor } from './core/interceptors/http-cache.interceptor';\nimport { httpErrorInterceptor } from './core/interceptors/http-error.interceptor';\nimport { SupabaseAuthInterceptor } from './core/interceptors/supabase-auth.interceptor';\n"}},{"ruleId":"import/order","severity":1,"message":"`@core/services/infrastructure/logger.service` import should occur before import of `./app.routes`","line":32,"column":1,"nodeType":"ImportDeclaration","endLine":32,"endColumn":78,"fix":{"range":[834,1360],"text":"import { LoggerService } from '@core/services/infrastructure/logger.service';\nimport { routes } from './app.routes';\nimport { authRefreshInterceptor } from './core/interceptors/auth-refresh.interceptor';\nimport { httpCacheInterceptor } from './core/interceptors/http-cache.interceptor';\nimport { httpErrorInterceptor } from './core/interceptors/http-error.interceptor';\nimport { SupabaseAuthInterceptor } from './core/interceptors/supabase-auth.interceptor';\nimport { DebugService } from '@core/services/admin/debug.service';\n"}},{"ruleId":"import/order","severity":1,"message":"`@core/services/infrastructure/global-error-handler` import should occur before import of `./app.routes`","line":33,"column":1,"nodeType":"ImportDeclaration","endLine":33,"endColumn":89,"fix":{"range":[834,1449],"text":"import { GlobalErrorHandler } from '@core/services/infrastructure/global-error-handler';\nimport { routes } from './app.routes';\nimport { authRefreshInterceptor } from './core/interceptors/auth-refresh.interceptor';\nimport { httpCacheInterceptor } from './core/interceptors/http-cache.interceptor';\nimport { httpErrorInterceptor } from './core/interceptors/http-error.interceptor';\nimport { SupabaseAuthInterceptor } from './core/interceptors/supabase-auth.interceptor';\nimport { DebugService } from '@core/services/admin/debug.service';\nimport { LoggerService } from '@core/services/infrastructure/logger.service';\n"}},{"ruleId":"import/order","severity":1,"message":"`@core/services/infrastructure/performance-monitoring.service` import should occur before import of `./app.routes`","line":34,"column":1,"nodeType":"ImportDeclaration","endLine":34,"endColumn":109,"fix":{"range":[834,1558],"text":"import { PerformanceMonitoringService } from '@core/services/infrastructure/performance-monitoring.service';\nimport { routes } from './app.routes';\nimport { authRefreshInterceptor } from './core/interceptors/auth-refresh.interceptor';\nimport { httpCacheInterceptor } from './core/interceptors/http-cache.interceptor';\nimport { httpErrorInterceptor } from './core/interceptors/http-error.interceptor';\nimport { SupabaseAuthInterceptor } from './core/interceptors/supabase-auth.interceptor';\nimport { DebugService } from '@core/services/admin/debug.service';\nimport { LoggerService } from '@core/services/infrastructure/logger.service';\nimport { GlobalErrorHandler } from '@core/services/infrastructure/global-error-handler';\n"}},{"ruleId":"import/order","severity":1,"message":"`@core/services/infrastructure/supabase-client.service` import should occur before import of `./app.routes`","line":35,"column":1,"nodeType":"ImportDeclaration","endLine":35,"endColumn":95,"fix":{"range":[834,1653],"text":"import { SupabaseClientService } from '@core/services/infrastructure/supabase-client.service';\nimport { routes } from './app.routes';\nimport { authRefreshInterceptor } from './core/interceptors/auth-refresh.interceptor';\nimport { httpCacheInterceptor } from './core/interceptors/http-cache.interceptor';\nimport { httpErrorInterceptor } from './core/interceptors/http-error.interceptor';\nimport { SupabaseAuthInterceptor } from './core/interceptors/supabase-auth.interceptor';\nimport { DebugService } from '@core/services/admin/debug.service';\nimport { LoggerService } from '@core/services/infrastructure/logger.service';\nimport { GlobalErrorHandler } from '@core/services/infrastructure/global-error-handler';\nimport { PerformanceMonitoringService } from '@core/services/infrastructure/performance-monitoring.service';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":5,"source":"import { IMAGE_LOADER, type ImageLoaderConfig, isPlatformBrowser } from '@angular/common';\nimport { HttpClient, provideHttpClient, withFetch, withInterceptors } from '@angular/common/http';\nimport {\n  APP_INITIALIZER,\n  ApplicationConfig,\n  ErrorHandler,\n  importProvidersFrom,\n  inject,\n  isDevMode,\n  LOCALE_ID,\n  PLATFORM_ID,\n  provideZonelessChangeDetection,\n} from '@angular/core';\nimport { provideAnimationsAsync } from '@angular/platform-browser/animations/async';\nimport {\n  NoPreloading,\n  provideRouter,\n  withInMemoryScrolling,\n  withPreloading,\n  withViewTransitions,\n} from '@angular/router';\nimport { provideServiceWorker } from '@angular/service-worker';\nimport { provideIonicAngular } from '@ionic/angular/standalone';\nimport { TranslateLoader, TranslateModule } from '@ngx-translate/core';\nimport { of } from 'rxjs';\nimport { routes } from './app.routes';\nimport { authRefreshInterceptor } from './core/interceptors/auth-refresh.interceptor';\nimport { httpCacheInterceptor } from './core/interceptors/http-cache.interceptor';\nimport { httpErrorInterceptor } from './core/interceptors/http-error.interceptor';\nimport { SupabaseAuthInterceptor } from './core/interceptors/supabase-auth.interceptor';\nimport { DebugService } from '@core/services/admin/debug.service';\nimport { LoggerService } from '@core/services/infrastructure/logger.service';\nimport { GlobalErrorHandler } from '@core/services/infrastructure/global-error-handler';\nimport { PerformanceMonitoringService } from '@core/services/infrastructure/performance-monitoring.service';\nimport { SupabaseClientService } from '@core/services/infrastructure/supabase-client.service';\nimport { routeReuseStrategyProvider } from './core/strategies/custom-route-reuse.strategy';\n\n/**\n * Inicializa el servicio de monitoreo de performance\n * Solo en development mode\n */\nfunction initializePerformanceMonitoring(\n  _perfService: PerformanceMonitoringService,\n  logger: LoggerService,\n) {\n  return () => {\n    if (isDevMode()) {\n      logger.debug('Performance Monitoring initialized', 'AppConfig');\n    }\n  };\n}\n\n/**\n * Inicializa el DebugService para e2e tests\n * Expone window.__AR_DEBUG__ para acceso desde tests\n * Nota: Llamamos exposeForE2E() explícitamente porque con SSR+hydration\n * el constructor puede ejecutarse en el servidor donde window no existe\n */\nfunction initializeDebugService(debugService: DebugService) {\n  return () => {\n    // Solo exponer en el cliente (browser)\n    if (typeof window !== 'undefined') {\n      debugService.exposeForE2E();\n    }\n  };\n}\n\nfunction autorentaImageLoader(config: ImageLoaderConfig): string {\n  const src = config.src;\n\n  // Local assets (and most relative URLs) should remain unchanged\n  if (!src || src.startsWith('/') || src.startsWith('data:') || src.startsWith('blob:')) {\n    return src;\n  }\n\n  // Only apply transformations to known providers\n  if (!src.includes('unsplash.com') && !src.includes('images.unsplash.com')) {\n    return src;\n  }\n\n  try {\n    const url = new URL(src);\n    const width = config.width ?? 800;\n\n    url.searchParams.set('w', String(width));\n    if (!url.searchParams.has('q')) url.searchParams.set('q', '80');\n    if (!url.searchParams.has('auto')) url.searchParams.set('auto', 'format');\n    if (!url.searchParams.has('fit')) url.searchParams.set('fit', 'crop');\n\n    return url.toString();\n  } catch {\n    return src;\n  }\n}\n\nexport const appConfig: ApplicationConfig = {\n  providers: [\n    { provide: IMAGE_LOADER, useValue: autorentaImageLoader },\n    // ✅ Zoneless Change Detection - removes Zone.js (~35KB savings)\n    // Works with Angular 20+ and Ionic 8+ (signals-based)\n    provideZonelessChangeDetection(),\n    provideIonicAngular({ mode: 'md' }),\n    provideRouter(\n      routes,\n      // Cambiamos a NoPreloading para reducir descarga inicial en móvil; prefetch selectivo se puede habilitar con quicklink\n      withPreloading(NoPreloading),\n      // Note: withEnabledBlockingInitialNavigation removed - can cause SSR timeout\n      withInMemoryScrolling({\n        scrollPositionRestoration: 'enabled',\n        anchorScrolling: 'enabled',\n      }),\n      // ✅ Native-like Page Transitions\n      withViewTransitions(),\n    ),\n    provideHttpClient(\n      withFetch(),\n      withInterceptors([\n        SupabaseAuthInterceptor,\n        authRefreshInterceptor,\n        httpCacheInterceptor, // ✅ P1-021: HTTP caching\n        httpErrorInterceptor,\n      ]),\n    ),\n    // ✅ Async Animations - better initial load performance than standard animations\n    provideAnimationsAsync(),\n\n    provideServiceWorker('ngsw-worker.js', {\n      enabled: !isDevMode(),\n      registrationStrategy: 'registerWhenStable:30000',\n    }),\n    SupabaseClientService.forRoot(),\n    { provide: LOCALE_ID, useValue: 'es-AR' },\n    importProvidersFrom(\n      TranslateModule.forRoot({\n        loader: {\n          provide: TranslateLoader,\n          useFactory: () => {\n            const http = inject(HttpClient);\n            const platformId = inject(PLATFORM_ID);\n            const isBrowser = isPlatformBrowser(platformId);\n\n            return {\n              getTranslation: (lang: string) => {\n                // During SSR, return empty translations to avoid HTTP timeout\n                if (!isBrowser) {\n                  return of({});\n                }\n                // In browser, load translations via HTTP\n                return http.get(`./assets/i18n/${lang}.json`);\n              },\n            };\n          },\n        },\n        // Use fallbackLang instead of deprecated defaultLanguage\n        fallbackLang: 'es',\n      })\n    ),\n    // ✅ Route Reuse Strategy - keeps Marketplace & Map in memory for instant navigation\n    routeReuseStrategyProvider,\n    // ✅ Global Error Handler (handles Sentry internally)\n    { provide: ErrorHandler, useClass: GlobalErrorHandler },\n    // ✅ Performance Monitoring (solo en desarrollo)\n    isDevMode()\n      ? {\n        provide: APP_INITIALIZER,\n        useFactory: initializePerformanceMonitoring,\n        deps: [PerformanceMonitoringService, LoggerService],\n        multi: true,\n      }\n      : [],\n    // ✅ Debug Service initialization (para e2e tests)\n    // Siempre inicializar para exponer window.__AR_DEBUG__\n    {\n      provide: APP_INITIALIZER,\n      useFactory: initializeDebugService,\n      deps: [DebugService],\n      multi: true,\n    },\n  ],\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/core/services/admin/admin.service.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`@core/services/infrastructure/logger.service` import should occur before type import of `../types/admin.types`","line":44,"column":1,"nodeType":"ImportDeclaration","endLine":44,"endColumn":78,"fix":{"range":[833,1233],"text":"import { LoggerService } from '@core/services/infrastructure/logger.service';\nimport type {\n  AdminRole,\n  AdminUser,\n  AdminUserInsert,\n  AdminUserUpdate,\n  AdminAuditLog,\n  AdminPermission,\n  AdminActionContext,\n  AdminUserWithProfile,\n} from '../types/admin.types';\nimport {\n  RefundRequest,\n  ProcessRefundParams,\n  ProcessRefundResult,\n  WithdrawalRequest,\n  Car,\n  Booking,\n} from '../models';\n"}},{"ruleId":"import/order","severity":1,"message":"`@core/services/infrastructure/supabase-client.service` import should occur before type import of `../types/admin.types`","line":45,"column":1,"nodeType":"ImportDeclaration","endLine":45,"endColumn":88,"fix":{"range":[833,1321],"text":"import { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\nimport type {\n  AdminRole,\n  AdminUser,\n  AdminUserInsert,\n  AdminUserUpdate,\n  AdminAuditLog,\n  AdminPermission,\n  AdminActionContext,\n  AdminUserWithProfile,\n} from '../types/admin.types';\nimport {\n  RefundRequest,\n  ProcessRefundParams,\n  ProcessRefundResult,\n  WithdrawalRequest,\n  Car,\n  Booking,\n} from '../models';\nimport { LoggerService } from '@core/services/infrastructure/logger.service';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"/**\n * AdminService - Role-Based Access Control & Audit Logging\n * Created: 2025-11-07\n * Issue: #123 - Admin Authentication & Role-Based Access Control\n *\n * This service provides:\n * 1. Admin role checking (super_admin, operations, support, finance)\n * 2. Permission-based authorization\n * 3. Automatic audit logging for all admin actions\n * 4. Admin user management (grant/revoke roles)\n *\n * Usage:\n * ```typescript\n * // Check if user is admin\n * const isAdmin = await adminService.isAdmin();\n *\n * // Check specific permission\n * const canApprove = await adminService.hasPermission('approve_verifications');\n *\n * // Log an action (automatic with decorator, or manual)\n * await adminService.logAction('approve_verification', 'user_verification', verificationId);\n * ```\n */\n\nimport { Injectable, inject } from '@angular/core';\nimport type {\n  AdminRole,\n  AdminUser,\n  AdminUserInsert,\n  AdminUserUpdate,\n  AdminAuditLog,\n  AdminPermission,\n  AdminActionContext,\n  AdminUserWithProfile,\n} from '../types/admin.types';\nimport {\n  RefundRequest,\n  ProcessRefundParams,\n  ProcessRefundResult,\n  WithdrawalRequest,\n  Car,\n  Booking,\n} from '../models';\nimport { LoggerService } from '@core/services/infrastructure/logger.service';\nimport { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\n\n// Import ADMIN_PERMISSIONS constant\nconst PERMISSIONS_MATRIX: Record<AdminRole, AdminPermission[]> = {\n  super_admin: [\n    'view_users',\n    'edit_users',\n    'suspend_users',\n    'delete_users',\n    'view_verifications',\n    'approve_verifications',\n    'reject_verifications',\n    'view_bookings',\n    'edit_bookings',\n    'cancel_bookings',\n    'view_payments',\n    'process_refunds',\n    'view_wallet_transactions',\n    'view_cars',\n    'approve_cars',\n    'suspend_cars',\n    'view_audit_log',\n    'manage_admins',\n    'grant_admin_roles',\n    'revoke_admin_roles',\n  ],\n  operations: [\n    'view_users',\n    'edit_users',\n    'suspend_users',\n    'view_verifications',\n    'approve_verifications',\n    'reject_verifications',\n    'view_bookings',\n    'edit_bookings',\n    'cancel_bookings',\n    'view_cars',\n    'approve_cars',\n    'suspend_cars',\n  ],\n  support: ['view_users', 'view_verifications', 'view_bookings', 'view_cars'],\n  finance: [\n    'view_users',\n    'view_bookings',\n    'view_payments',\n    'process_refunds',\n    'view_wallet_transactions',\n  ],\n};\n\n// Verification-related interfaces\nexport interface VerificationQueueItem {\n  user_id: string;\n  full_name: string;\n  email: string;\n  current_level: number;\n\n  // Level 2 verification data\n  document_type?: string;\n  document_number?: string;\n  document_front_url?: string;\n  document_back_url?: string;\n  document_verified_at?: string;\n  document_ai_score?: number;\n\n  // Level 3 verification data\n  selfie_url?: string;\n  selfie_verified_at?: string;\n  face_match_score?: number;\n  liveness_score?: number;\n\n  // Manual review data\n  manual_review_required: boolean;\n  manual_review_decision?: 'APPROVED' | 'REJECTED' | 'PENDING';\n  manual_review_notes?: string;\n  manual_reviewed_by?: string;\n  manual_reviewed_at?: string;\n\n  // Metadata\n  created_at: string;\n  updated_at: string;\n\n  // Extracted data\n  extracted_full_name?: string;\n  extracted_birth_date?: string;\n}\n\nexport interface VerificationStats {\n  total_users: number;\n  pending_reviews: number;\n  approved_today: number;\n  rejected_today: number;\n  level_1_users: number;\n  level_2_users: number;\n  level_3_users: number;\n  pending_level_2: number;\n  pending_level_3: number;\n}\n\nexport interface AdminVerificationResponse {\n  success: boolean;\n  user_id: string;\n  user_email: string;\n  user_name: string;\n  [key: string]: unknown;\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class AdminService {\n  private readonly supabase = injectSupabase();\n  private readonly logger = inject(LoggerService);\n\n  // Cache for admin roles (cleared on auth state change)\n  private rolesCache: AdminRole[] | null = null;\n  private rolesCacheUserId: string | null = null;\n\n  // ============================================================================\n  // ROLE & PERMISSION CHECKING\n  // ============================================================================\n\n  /**\n   * Check if current user is an admin (has any admin role)\n   */\n  async isAdmin(): Promise<boolean> {\n    try {\n      const {\n        data: { user },\n      } = await this.supabase.auth.getUser();\n      if (!user) return false;\n\n      const { data, error } = await this.supabase.rpc('is_admin', {\n        check_user_id: user['id'],\n      });\n\n      if (error) {\n        this.logger['error']('Error checking admin status', 'AdminService', error);\n        return false;\n      }\n\n      return data === true;\n    } catch (error) {\n      this.logger['error']('Error checking admin status', 'AdminService', error as Error);\n      return false;\n    }\n  }\n\n  /**\n   * Check if current user has specific admin role\n   */\n  async hasRole(role: AdminRole): Promise<boolean> {\n    try {\n      const roles = await this.getAdminRoles();\n      return roles.includes(role);\n    } catch (error) {\n      this.logger['error'](`Error checking role ${role}`, 'AdminService', error as Error);\n      return false;\n    }\n  }\n\n  /**\n   * Check if current user has specific permission\n   */\n  async hasPermission(permission: AdminPermission): Promise<boolean> {\n    try {\n      const roles = await this.getAdminRoles();\n\n      // Check if any of user's roles has this permission\n      return roles.some((role) => PERMISSIONS_MATRIX[role]?.includes(permission));\n    } catch (error) {\n      this.logger['error'](`Error checking permission ${permission}`, 'AdminService', error as Error);\n      return false;\n    }\n  }\n\n  /**\n   * Get all admin roles for current user\n   */\n  async getAdminRoles(): Promise<AdminRole[]> {\n    try {\n      const {\n        data: { user },\n      } = await this.supabase.auth.getUser();\n      if (!user) return [];\n\n      // Use cache if available for same user\n      if (this.rolesCache && this.rolesCacheUserId === user['id']) {\n        return this.rolesCache;\n      }\n\n      const { data, error } = await this.supabase.rpc('get_admin_roles', {\n        check_user_id: user['id'],\n      });\n\n      if (error) {\n        this.logger['error']('Error fetching admin roles', 'AdminService', error);\n        return [];\n      }\n\n      // Update cache\n      this.rolesCache = (data as AdminRole[]) ?? [];\n      this.rolesCacheUserId = user['id'];\n\n      return this.rolesCache;\n    } catch (error) {\n      this.logger['error']('Error fetching admin roles', 'AdminService', error as Error);\n      return [];\n    }\n  }\n\n  /**\n   * Get all permissions for current user (union of all role permissions)\n   */\n  async getPermissions(): Promise<AdminPermission[]> {\n    const roles = await this.getAdminRoles();\n    const permissions = new Set<AdminPermission>();\n\n    roles.forEach((role) => {\n      PERMISSIONS_MATRIX[role]?.forEach((perm) => permissions.add(perm));\n    });\n\n    return Array.from(permissions);\n  }\n\n  /**\n   * Clear roles cache (call on auth state change)\n   */\n  clearCache(): void {\n    this.rolesCache = null;\n    this.rolesCacheUserId = null;\n  }\n\n  // ============================================================================\n  // AUDIT LOGGING\n  // ============================================================================\n\n  /**\n   * Log an admin action to audit trail\n   */\n  async logAction(context: AdminActionContext): Promise<string | null> {\n    try {\n      const {\n        data: { user },\n      } = await this.supabase.auth.getUser();\n      if (!user) {\n        this.logger.warn('Attempted to log action without authenticated user', 'AdminService');\n        return null;\n      }\n\n      const { data, error } = await this.supabase.rpc('log_admin_action', {\n        p_action: context.action,\n        p_resource_type: context.resourceType,\n        p_resource_id: context.resourceId ?? null,\n        p_details: context.details ?? null,\n        p_ip_address: context.ipAddress ?? null,\n        p_user_agent: context.userAgent ?? null,\n      });\n\n      if (error) {\n        this.logger['error']('Error logging admin action', 'AdminService', error);\n        return null;\n      }\n\n      return data as string;\n    } catch (error) {\n      this.logger['error']('Error logging admin action', 'AdminService', error as Error);\n      return null;\n    }\n  }\n\n  /**\n   * Get audit log entries (super admin only)\n   */\n  async getAuditLog(filters?: {\n    adminUserId?: string;\n    action?: string;\n    resourceType?: string;\n    limit?: number;\n    offset?: number;\n  }): Promise<AdminAuditLog[]> {\n    try {\n      // Check permission\n      const hasPermission = await this.hasPermission('view_audit_log');\n      if (!hasPermission) {\n        throw new Error('Insufficient permissions to view audit log');\n      }\n\n      let query = this.supabase\n        .from('admin_audit_log')\n        .select('*')\n        .order('created_at', { ascending: false })\n        .limit(filters?.limit ?? 100);\n\n      if (filters?.adminUserId) {\n        query = query.eq('admin_user_id', filters.adminUserId);\n      }\n      if (filters?.action) {\n        query = query.eq('action', filters.action);\n      }\n      if (filters?.resourceType) {\n        query = query.eq('resource_type', filters.resourceType);\n      }\n      if (filters?.offset) {\n        query = query.range(filters.offset, filters.offset + (filters.limit ?? 100) - 1);\n      }\n\n      const { data, error } = await query;\n\n      if (error) throw error;\n      return (data ?? []) as AdminAuditLog[];\n    } catch (error) {\n      this.logger['error']('Error fetching audit log', 'AdminService', error as Error);\n      throw error;\n    }\n  }\n\n  // ============================================================================\n  // ADMIN USER MANAGEMENT\n  // ============================================================================\n\n  /**\n   * Grant admin role to user (super admin only)\n   */\n  async grantAdminRole(userId: string, role: AdminRole, notes?: string): Promise<AdminUser | null> {\n    try {\n      // Check permission\n      const hasPermission = await this.hasPermission('grant_admin_roles');\n      if (!hasPermission) {\n        throw new Error('Insufficient permissions to grant admin roles');\n      }\n\n      const {\n        data: { user },\n      } = await this.supabase.auth.getUser();\n      if (!user) throw new Error('Not authenticated');\n\n      const adminUser: AdminUserInsert = {\n        user_id: userId,\n        role,\n        granted_by: user['id'],\n        notes: notes ?? null,\n      };\n\n      const { data, error } = await this.supabase\n        .from('admin_users')\n        .insert(adminUser)\n        .select()\n        .single();\n\n      if (error) throw error;\n\n      // Log action\n      await this.logAction({\n        action: 'grant_admin_role',\n        resourceType: 'admin_user',\n        resourceId: data['id'],\n        details: { userId, role, notes },\n      });\n\n      return data as AdminUser;\n    } catch (error) {\n      this.logger['error']('Error granting admin role', 'AdminService', error as Error);\n      throw error;\n    }\n  }\n\n  /**\n   * Revoke admin role from user (super admin only)\n   */\n  async revokeAdminRole(adminUserId: string, reason?: string): Promise<void> {\n    try {\n      // Check permission\n      const hasPermission = await this.hasPermission('revoke_admin_roles');\n      if (!hasPermission) {\n        throw new Error('Insufficient permissions to revoke admin roles');\n      }\n\n      const {\n        data: { user },\n      } = await this.supabase.auth.getUser();\n      if (!user) throw new Error('Not authenticated');\n\n      const update: AdminUserUpdate = {\n        revoked_at: new Date().toISOString(),\n        revoked_by: user['id'],\n        notes: reason ?? null,\n      };\n\n      const { error } = await this.supabase\n        .from('admin_users')\n        .update(update)\n        .eq('id', adminUserId)\n        .is('revoked_at', null); // Only revoke active roles\n\n      if (error) throw error;\n\n      // Log action\n      await this.logAction({\n        action: 'revoke_admin_role',\n        resourceType: 'admin_user',\n        resourceId: adminUserId,\n        details: { reason },\n      });\n    } catch (error) {\n      this.logger['error']('Error revoking admin role', 'AdminService', error as Error);\n      throw error;\n    }\n  }\n\n  /**\n   * List all admin users (super admin only)\n   */\n  async listAdminUsers(includeRevoked = false): Promise<AdminUserWithProfile[]> {\n    try {\n      // Check permission\n      const hasPermission = await this.hasPermission('manage_admins');\n      if (!hasPermission) {\n        throw new Error('Insufficient permissions to view admin users');\n      }\n\n      let query = this.supabase\n        .from('admin_users')\n        .select(\n          `\n          *,\n          profile:profiles!admin_users_user_id_fkey(full_name, email, avatar_url),\n          granted_by_profile:profiles!admin_users_granted_by_fkey(full_name, email)\n        `,\n        )\n        .order('created_at', { ascending: false });\n\n      if (!includeRevoked) {\n        query = query.is('revoked_at', null);\n      }\n\n      const { data, error } = await query;\n\n      if (error) throw error;\n      return (data ?? []) as AdminUserWithProfile[];\n    } catch (error) {\n      this.logger['error']('Error listing admin users', 'AdminService', error as Error);\n      throw error;\n    }\n  }\n\n  // ============================================================================\n  // EXISTING ADMIN OPERATIONS (with audit logging added)\n  // ============================================================================\n\n  /**\n   * Approve a car listing\n   */\n  async approveCar(carId: string): Promise<void> {\n    // Check permission\n    const hasPermission = await this.hasPermission('approve_cars');\n    if (!hasPermission) {\n      throw new Error('Insufficient permissions to approve cars');\n    }\n\n    const { error } = await this.supabase.from('cars').update({ status: 'active' }).eq('id', carId);\n\n    if (error) throw error;\n\n    // Log action\n    await this.logAction({\n      action: 'approve_car',\n      resourceType: 'car',\n      resourceId: carId,\n    });\n  }\n\n  /**\n   * List pending car approvals\n   */\n  async listPendingCars(): Promise<Car[]> {\n    // Check permission\n    const hasPermission = await this.hasPermission('view_cars');\n    if (!hasPermission) {\n      throw new Error('Insufficient permissions to view cars');\n    }\n\n    const { data, error } = await this.supabase\n      .from('cars')\n      .select('*, car_photos(*)')\n      .eq('status', 'pending')\n      .order('created_at', { ascending: false });\n\n    if (error) throw error;\n    return (data ?? []) as Car[];\n  }\n\n  /**\n   * List recent bookings\n   */\n  async listRecentBookings(limit = 20): Promise<Booking[]> {\n    // Check permission\n    const hasPermission = await this.hasPermission('view_bookings');\n    if (!hasPermission) {\n      throw new Error('Insufficient permissions to view bookings');\n    }\n\n    const { data, error } = await this.supabase\n      .from('bookings')\n      .select('*, cars(*), profiles(*)')\n      .order('created_at', { ascending: false })\n      .limit(limit);\n\n    if (error) throw error;\n    return (data ?? []) as Booking[];\n  }\n\n  /**\n   * Approve withdrawal request\n   */\n  async approveWithdrawal(requestId: string, adminNotes?: string): Promise<void> {\n    // Check permission\n    const hasPermission = await this.hasPermission('process_refunds');\n    if (!hasPermission) {\n      throw new Error('Insufficient permissions to approve withdrawals');\n    }\n\n    const { error } = await this.supabase.rpc('wallet_approve_withdrawal', {\n      p_request_id: requestId,\n      p_admin_notes: adminNotes,\n    });\n\n    if (error) throw error;\n\n    // Log action\n    await this.logAction({\n      action: 'approve_withdrawal',\n      resourceType: 'withdrawal_request',\n      resourceId: requestId,\n      details: { adminNotes },\n    });\n  }\n\n  /**\n   * Complete withdrawal request\n   */\n  async completeWithdrawal(\n    requestId: string,\n    providerTransactionId: string,\n    providerMetadata?: Record<string, unknown>,\n  ): Promise<void> {\n    // Check permission\n    const hasPermission = await this.hasPermission('process_refunds');\n    if (!hasPermission) {\n      throw new Error('Insufficient permissions to complete withdrawals');\n    }\n\n    const { error } = await this.supabase.rpc('wallet_complete_withdrawal', {\n      p_request_id: requestId,\n      p_provider_transaction_id: providerTransactionId,\n      p_provider_metadata: providerMetadata,\n    });\n\n    if (error) throw error;\n\n    // Log action\n    await this.logAction({\n      action: 'complete_withdrawal',\n      resourceType: 'withdrawal_request',\n      resourceId: requestId,\n      details: { providerTransactionId, providerMetadata },\n    });\n  }\n\n  /**\n   * Fail withdrawal request\n   */\n  async failWithdrawal(requestId: string, failureReason: string): Promise<void> {\n    // Check permission\n    const hasPermission = await this.hasPermission('process_refunds');\n    if (!hasPermission) {\n      throw new Error('Insufficient permissions to fail withdrawals');\n    }\n\n    const { error } = await this.supabase.rpc('wallet_fail_withdrawal', {\n      p_request_id: requestId,\n      p_failure_reason: failureReason,\n    });\n\n    if (error) throw error;\n\n    // Log action\n    await this.logAction({\n      action: 'fail_withdrawal',\n      resourceType: 'withdrawal_request',\n      resourceId: requestId,\n      details: { failureReason },\n    });\n  }\n\n  /**\n   * Reject withdrawal request\n   */\n  async rejectWithdrawal(requestId: string, rejectionReason: string): Promise<void> {\n    // Check permission\n    const hasPermission = await this.hasPermission('process_refunds');\n    if (!hasPermission) {\n      throw new Error('Insufficient permissions to reject withdrawals');\n    }\n\n    const {\n      data: { user },\n    } = await this.supabase.auth.getUser();\n    if (!user) throw new Error('Not authenticated');\n\n    const { error } = await this.supabase\n      .from('withdrawal_requests')\n      .update({\n        status: 'rejected',\n        rejection_reason: rejectionReason,\n        approved_by: user['id'],\n        approved_at: new Date().toISOString(),\n        updated_at: new Date().toISOString(),\n      })\n      .eq('id', requestId);\n\n    if (error) throw error;\n\n    // Log action\n    await this.logAction({\n      action: 'reject_withdrawal',\n      resourceType: 'withdrawal_request',\n      resourceId: requestId,\n      details: { rejectionReason },\n    });\n  }\n\n  /**\n   * List withdrawal requests with optional status filter\n   */\n  async listWithdrawalRequests(status?: string): Promise<WithdrawalRequest[]> {\n    // Check permission\n    const hasPermission = await this.hasPermission('view_payments');\n    if (!hasPermission) {\n      throw new Error('Insufficient permissions to view withdrawal requests');\n    }\n\n    let query = this.supabase\n      .from('withdrawal_requests')\n      .select(\n        `\n        *,\n        user:profiles!withdrawal_requests_user_id_fkey(full_name, email:auth.users(email)),\n        bank_account:bank_accounts(*)\n      `,\n      )\n      .order('created_at', { ascending: false });\n\n    if (status) {\n      query = query.eq('status', status);\n    }\n\n    const { data, error } = await query;\n    if (error) throw error;\n\n    return (data ?? []).map((item) => {\n      const typedItem = item as unknown as WithdrawalRequest & {\n        user?: { full_name?: string | null; email?: Array<{ email: string }> };\n      };\n      const { user, ...rest } = typedItem;\n      return {\n        ...rest,\n        user_name: user?.['full_name'] ?? undefined,\n        user_email: user?.['email']?.[0]?.['email'] ?? undefined,\n        bank_account: typedItem.bank_account,\n      } as WithdrawalRequest;\n    });\n  }\n\n  // ============================================\n  // VERIFICATION MANAGEMENT (Issue #125)\n  // ============================================\n\n  /**\n   * Get pending verifications with filters\n   * @param verificationType - 'level_2', 'level_3', or null for all\n   * @param status - 'PENDING', 'APPROVED', 'REJECTED', or null for all\n   * @param limit - Number of records to return (default 20)\n   * @param offset - Pagination offset (default 0)\n   */\n  async getPendingVerifications(\n    verificationType?: string,\n    status: string = 'PENDING',\n    limit: number = 20,\n    offset: number = 0,\n  ): Promise<VerificationQueueItem[]> {\n    const { data, error } = await this.supabase.rpc('admin_get_pending_verifications', {\n      p_verification_type: verificationType || null,\n      p_status: status,\n      p_limit: limit,\n      p_offset: offset,\n    });\n\n    if (error) throw error;\n    return (data ?? []) as VerificationQueueItem[];\n  }\n\n  /**\n   * Get verification statistics for admin dashboard\n   */\n  async getVerificationStats(): Promise<VerificationStats> {\n    const { data, error } = await this.supabase.rpc('admin_get_verification_stats');\n\n    if (error) throw error;\n    return data as VerificationStats;\n  }\n\n  /**\n   * Approve a user's verification\n   * @param userId - User ID to approve\n   * @param verificationLevel - 2 or 3\n   * @param notes - Optional admin notes\n   */\n  async approveVerification(\n    userId: string,\n    verificationLevel: number,\n    notes?: string,\n  ): Promise<AdminVerificationResponse> {\n    const { data, error } = await this.supabase.rpc('admin_approve_verification', {\n      p_user_id: userId,\n      p_verification_level: verificationLevel,\n      p_notes: notes || null,\n    });\n\n    if (error) throw error;\n\n    // Send approval email\n    const response = data as AdminVerificationResponse;\n    if (response.success && response.user_email) {\n      await this.sendVerificationApprovedEmail(response);\n    }\n\n    return response;\n  }\n\n  /**\n   * Reject a user's verification\n   * @param userId - User ID to reject\n   * @param verificationLevel - 2 or 3\n   * @param reason - Required rejection reason\n   */\n  async rejectVerification(\n    userId: string,\n    verificationLevel: number,\n    reason: string,\n  ): Promise<AdminVerificationResponse> {\n    if (!reason || reason.trim() === '') {\n      throw new Error('El motivo de rechazo es obligatorio');\n    }\n\n    const { data, error } = await this.supabase.rpc('admin_reject_verification', {\n      p_user_id: userId,\n      p_verification_level: verificationLevel,\n      p_reason: reason,\n    });\n\n    if (error) throw error;\n\n    // Send rejection email\n    const response = data as AdminVerificationResponse;\n    if (response.success && response.user_email) {\n      await this.sendVerificationRejectedEmail(response, reason);\n    }\n\n    return response;\n  }\n\n  /**\n   * Flag a verification as suspicious\n   * @param userId - User ID to flag\n   * @param notes - Reason for flagging\n   */\n  async flagVerificationSuspicious(\n    userId: string,\n    notes: string,\n  ): Promise<AdminVerificationResponse> {\n    const { data, error } = await this.supabase.rpc('admin_flag_verification_suspicious', {\n      p_user_id: userId,\n      p_notes: notes,\n    });\n\n    if (error) throw error;\n    return data as AdminVerificationResponse;\n  }\n\n  /**\n   * Request additional documents from user\n   * @param userId - User ID\n   * @param requestedDocs - Description of what documents are needed\n   */\n  async requestAdditionalDocuments(\n    userId: string,\n    requestedDocs: string,\n  ): Promise<AdminVerificationResponse> {\n    if (!requestedDocs || requestedDocs.trim() === '') {\n      throw new Error('La descripción de documentos requeridos es obligatoria');\n    }\n\n    const { data, error } = await this.supabase.rpc('admin_request_additional_documents', {\n      p_user_id: userId,\n      p_requested_docs: requestedDocs,\n    });\n\n    if (error) throw error;\n\n    // TODO: Send email notification to user about additional documents request\n    return data as AdminVerificationResponse;\n  }\n\n  /**\n   * Get public URL for identity document\n   * @param filePath - Path to file (userId/filename)\n   */\n  getIdentityDocumentUrl(filePath: string): string {\n    const { data } = this.supabase.storage.from('identity-documents').getPublicUrl(filePath);\n    return data.publicUrl;\n  }\n\n  // ============================================\n  // PRIVATE HELPER METHODS\n  // ============================================\n\n  /**\n   * Send verification approved email via Edge Function\n   */\n  private async sendVerificationApprovedEmail(response: AdminVerificationResponse): Promise<void> {\n    try {\n      const { error } = await this.supabase.functions.invoke('send-verification-approved-email', {\n        body: {\n          user_id: response['user_id'],\n          user_email: response.user_email,\n          user_name: response.user_name,\n          approved_level: response['approved_level'],\n          previous_level: response['previous_level'],\n          notes: response['notes'],\n        },\n      });\n\n      if (error) {\n        console.error('Error sending approval email:', error);\n        // Don't throw - email is not critical for the approval process\n      }\n    } catch (error) {\n      console.error('Failed to send approval email:', error);\n      // Don't throw - email is not critical\n    }\n  }\n\n  /**\n   * Send verification rejected email via Edge Function\n   */\n  private async sendVerificationRejectedEmail(\n    response: AdminVerificationResponse,\n    reason: string,\n  ): Promise<void> {\n    try {\n      const { error } = await this.supabase.functions.invoke('send-verification-rejected-email', {\n        body: {\n          user_id: response['user_id'],\n          user_email: response.user_email,\n          user_name: response.user_name,\n          rejected_level: response['rejected_level'],\n          reason: reason,\n        },\n      });\n\n      if (error) {\n        console.error('Error sending rejection email:', error);\n        // Don't throw - email is not critical\n      }\n    } catch (error) {\n      console.error('Failed to send rejection email:', error);\n      // Don't throw - email is not critical\n    }\n  }\n\n  // ============================================\n  // REFUND MANAGEMENT\n  // ============================================\n\n  async listRefundRequests(status?: string): Promise<RefundRequest[]> {\n    const { data, error } = await this.supabase.rpc('admin_get_refund_requests', {\n      p_status: status || null,\n      p_limit: 100,\n      p_offset: 0,\n    });\n\n    if (error) throw error;\n    return (data ?? []) as RefundRequest[];\n  }\n\n  async getRefundRequestById(requestId: string): Promise<RefundRequest | null> {\n    const { data, error } = await this.supabase\n      .from('refund_requests')\n      .select(\n        `\n        *,\n        user:profiles!refund_requests_user_id_fkey(full_name, email:auth.users(email)),\n        booking:bookings(total_amount, total_cents, currency, car:cars(title))\n      `,\n      )\n      .eq('id', requestId)\n      .single();\n\n    if (error) {\n      if (error.code === 'PGRST116') return null; // Not found\n      throw error;\n    }\n\n    // Flatten nested data\n    const typedData = data as unknown as Record<string, unknown>;\n    const user = typedData['user'] as Record<string, unknown>;\n    const booking = typedData['booking'] as Record<string, unknown>;\n    const car = booking?.['car'] as Record<string, unknown>;\n\n    return {\n      ...typedData,\n      user_name: user?.['full_name'],\n      user_email: ((user?.['email'] as Array<{ email: string }>) ?? [])[0]?.['email'],\n      booking_total: booking?.['total_amount'] ?? (booking?.['total_cents'] as number) / 100,\n      car_title: car?.['title'],\n    } as RefundRequest;\n  }\n\n  async searchBookingsForRefund(\n    query: string,\n  ): Promise<Array<Booking & { can_refund: boolean; refund_eligible_amount: number }>> {\n    // Search by booking ID or user email\n    let bookingsQuery = this.supabase\n      .from('bookings')\n      .select(\n        `\n        *,\n        car:cars(title, brand_text_backup, model_text_backup),\n        renter:profiles!bookings_renter_id_fkey(full_name, email:auth.users(email)),\n        refund_requests(id, status, refund_amount)\n      `,\n      )\n      .order('created_at', { ascending: false })\n      .limit(20);\n\n    // If query looks like a UUID, search by ID\n    // Matches UUID v4 format: 8-4-4-4-12 hexadecimal characters with hyphens\n    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;\n    if (uuidRegex.test(query)) {\n      bookingsQuery = bookingsQuery.eq('id', query);\n    }\n\n    const { data, error } = await bookingsQuery;\n\n    if (error) throw error;\n\n    // Process and enrich with refund eligibility\n    return ((data ?? []) as unknown[]).map((item) => {\n      const typedItem = item as Record<string, unknown>;\n      const totalAmount =\n        (typedItem['total_amount'] as number) ?? (typedItem['total_cents'] as number) / 100;\n      const refundRequests = (typedItem['refund_requests'] as Array<Record<string, unknown>>) ?? [];\n\n      // Calculate already refunded amount\n      const refundedAmount = refundRequests\n        .filter((r) => r['status'] !== 'rejected' && r['status'] !== 'failed')\n        .reduce((sum, r) => sum + ((r['refund_amount'] as number) ?? 0), 0);\n\n      const canRefund =\n        typedItem['payment_status'] === 'paid' ||\n        typedItem['payment_status'] === 'approved' ||\n        typedItem['status'] === 'confirmed';\n\n      return {\n        ...typedItem,\n        can_refund: canRefund && refundedAmount < totalAmount,\n        refund_eligible_amount: totalAmount - refundedAmount,\n      } as Booking & { can_refund: boolean; refund_eligible_amount: number };\n    });\n  }\n\n  async processRefund(params: ProcessRefundParams): Promise<ProcessRefundResult> {\n    const { data, error } = await this.supabase.rpc('admin_process_refund', {\n      p_booking_id: params.booking_id,\n      p_refund_amount: params.refund_amount,\n      p_destination: params.destination,\n      p_reason: params.reason || null,\n    });\n\n    if (error) throw error;\n\n    return data as ProcessRefundResult;\n  }\n\n  async rejectRefund(requestId: string, rejectionReason: string): Promise<void> {\n    const {\n      data: { user },\n    } = await this.supabase.auth.getUser();\n    if (!user) throw new Error('Usuario no autenticado');\n\n    const { error } = await this.supabase\n      .from('refund_requests')\n      .update({\n        status: 'rejected',\n        rejection_reason: rejectionReason,\n        rejected_by: user['id'],\n        rejected_at: new Date().toISOString(),\n        updated_at: new Date().toISOString(),\n      })\n      .eq('id', requestId);\n\n    if (error) throw error;\n  }\n\n  // ============================================================================\n  // RPC INTEGRATIONS - Account Suspension & Debt Management\n  // ============================================================================\n\n  /**\n   * Obtiene usuarios con deuda (balance negativo)\n   * Para el panel de administración de suspensiones\n   */\n  async getUsersWithDebt(options?: {\n    minDays?: number;\n    limit?: number;\n    offset?: number;\n  }): Promise<{\n    users: Array<{\n      userId: string;\n      fullName: string;\n      email: string;\n      balanceCents: number;\n      debtStartDate: string;\n      daysSinceDebt: number;\n      isSuspended: boolean;\n      suspendedAt: string | null;\n      suspensionReason: string | null;\n    }>;\n    total: number;\n  }> {\n    try {\n      // Check permission\n      const hasPermission = await this.hasPermission('view_users');\n      if (!hasPermission) {\n        throw new Error('Insufficient permissions to view users with debt');\n      }\n\n      const { data, error } = await this.supabase.rpc('get_users_with_debt', {\n        p_min_days: options?.minDays ?? 0,\n        p_limit: options?.limit ?? 50,\n        p_offset: options?.offset ?? 0,\n      });\n\n      if (error) throw error;\n\n      return {\n        users: (data?.users ?? []).map((u: Record<string, unknown>) => ({\n          userId: u['user_id'] as string,\n          fullName: u['full_name'] as string,\n          email: u['email'] as string,\n          balanceCents: u['balance_cents'] as number,\n          debtStartDate: u['debt_start_date'] as string,\n          daysSinceDebt: u['days_since_debt'] as number,\n          isSuspended: u['is_suspended'] as boolean,\n          suspendedAt: u['suspended_at'] as string | null,\n          suspensionReason: u['suspension_reason'] as string | null,\n        })),\n        total: data?.total ?? 0,\n      };\n    } catch (error) {\n      this.logger['error']('Error fetching users with debt', 'AdminService', error as Error);\n      throw error;\n    }\n  }\n\n  /**\n   * Suspende manualmente una cuenta por deuda\n   */\n  async suspendAccountForDebt(\n    userId: string,\n    reason: string,\n  ): Promise<{ success: boolean; error?: string }> {\n    try {\n      const hasPermission = await this.hasPermission('suspend_users');\n      if (!hasPermission) {\n        throw new Error('Insufficient permissions to suspend users');\n      }\n\n      const { error } = await this.supabase.rpc('suspend_account_manual', {\n        p_user_id: userId,\n        p_reason: reason,\n      });\n\n      if (error) throw error;\n\n      // Log action\n      await this.logAction({\n        action: 'suspend_account',\n        resourceType: 'user',\n        resourceId: userId,\n        details: { reason },\n      });\n\n      return { success: true };\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error['message'] : 'Error al suspender cuenta',\n      };\n    }\n  }\n\n  /**\n   * Reactiva una cuenta suspendida (después de pagar deuda)\n   */\n  async unsuspendAccount(userId: string): Promise<{ success: boolean; error?: string }> {\n    try {\n      const hasPermission = await this.hasPermission('suspend_users');\n      if (!hasPermission) {\n        throw new Error('Insufficient permissions to unsuspend users');\n      }\n\n      const { error } = await this.supabase.rpc('unsuspend_account', {\n        p_user_id: userId,\n      });\n\n      if (error) throw error;\n\n      // Log action\n      await this.logAction({\n        action: 'unsuspend_account',\n        resourceType: 'user',\n        resourceId: userId,\n      });\n\n      return { success: true };\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error['message'] : 'Error al reactivar cuenta',\n      };\n    }\n  }\n\n  /**\n   * Verifica si un usuario puede operar (no está suspendido)\n   */\n  async canUserOperate(userId?: string): Promise<{\n    canOperate: boolean;\n    reason?: string;\n    suspendedAt?: string;\n  }> {\n    try {\n      const { data, error } = await this.supabase.rpc('can_user_operate', {\n        p_user_id: userId || null,\n      });\n\n      if (error) throw error;\n\n      return {\n        canOperate: data?.can_operate ?? true,\n        reason: data?.reason,\n        suspendedAt: data?.['suspended_at'],\n      };\n    } catch {\n      return { canOperate: true }; // Default to allowing operation on error\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/core/services/admin/dashboard.service.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`../models/dashboard.model` type import should occur after import of `@core/services/infrastructure/logger.service`","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":86,"fix":{"range":[228,480],"text":"import { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\nimport { LoggerService } from '@core/services/infrastructure/logger.service';\nimport type { DashboardStats, DashboardStatsCache } from '../models/dashboard.model';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { Injectable, signal, inject } from '@angular/core';\nimport { SupabaseClient } from '@supabase/supabase-js';\nimport { Observable, from, of, throwError } from 'rxjs';\nimport { map, catchError, tap } from 'rxjs/operators';\nimport type { DashboardStats, DashboardStatsCache } from '../models/dashboard.model';\nimport { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\nimport { LoggerService } from '@core/services/infrastructure/logger.service';\n\n/**\n * Dashboard Statistics Service\n *\n * Handles fetching and caching of owner dashboard statistics\n * from the dashboard-stats Edge Function.\n */\n@Injectable({\n  providedIn: 'root',\n})\nexport class DashboardService {\n  private readonly supabase: SupabaseClient = injectSupabase();\n  private readonly logger = inject(LoggerService);\n\n  // Cache TTL: 5 minutes\n  private readonly CACHE_TTL_MS = 5 * 60 * 1000;\n\n  // Cache storage\n  private readonly cache = signal<DashboardStatsCache | null>(null);\n  readonly loading = signal(false);\n  readonly error = signal<{ message: string } | null>(null);\n\n  /**\n   * Get dashboard statistics\n   *\n   * Implements caching with TTL. If cache is valid, returns cached data.\n   * Otherwise, fetches fresh data from Edge Function.\n   *\n   * @param forceRefresh - Force refresh even if cache is valid\n   * @returns Observable<DashboardStats>\n   */\n  getDashboardStats(forceRefresh: boolean = false): Observable<DashboardStats> {\n    // Check cache validity\n    const cachedData = this.cache();\n    const now = Date.now();\n\n    if (!forceRefresh && cachedData && now - cachedData.timestamp < this.CACHE_TTL_MS) {\n      this.logger.info('Dashboard stats: Using cached data');\n      return of(cachedData.data);\n    }\n\n    // Fetch fresh data\n    this.loading.set(true);\n    this.error.set(null);\n\n    return from(this.fetchDashboardStats()).pipe(\n      tap((stats) => {\n        // Update cache\n        this.cache.set({\n          data: stats,\n          timestamp: now,\n          ttl: this.CACHE_TTL_MS,\n        });\n        this.logger.info('Dashboard stats: Cache updated');\n      }),\n      catchError((_err) => {\n        this.handleError(_err, 'Error al obtener estadísticas del dashboard');\n        return throwError(() => _err);\n      }),\n      map((stats) => {\n        this.loading.set(false);\n        return stats;\n      }),\n    );\n  }\n\n  /**\n   * Clear cache\n   * Useful when user performs actions that might affect stats\n   */\n  clearCache(): void {\n    this.cache.set(null);\n    this.logger.info('Dashboard stats: Cache cleared');\n  }\n\n  /**\n   * Private: Fetch dashboard stats from Edge Function\n   */\n  private async fetchDashboardStats(): Promise<DashboardStats> {\n    const {\n      data: { session },\n    } = await this.supabase.auth.getSession();\n\n    if (!session) {\n      throw new Error('Usuario no autenticado');\n    }\n\n    const response = await this.supabase.functions.invoke('dashboard-stats', {\n      headers: {\n        Authorization: `Bearer ${session.access_token}`,\n      },\n    });\n\n    if (response.error) {\n      throw new Error(response.error.message || 'Error al obtener estadísticas');\n    }\n\n    return response.data as DashboardStats;\n  }\n\n  /**\n   * Private: Error handler\n   */\n  private handleError(err: unknown, defaultMessage: string): void {\n    const errorMessage = err instanceof Error ? err.message : defaultMessage;\n    this.error.set({ message: errorMessage });\n    this.logger.error(defaultMessage, String(err));\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/core/services/auth/auth.service.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`../../../environments/environment` import should occur after import of `@core/services/infrastructure/supabase-client.service`","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":65,"fix":{"range":[255,631],"text":"import { getErrorMessage } from '../utils/type-guards';\nimport { LoggerService } from '@core/services/infrastructure/logger.service';\nimport { RateLimiterService } from '@core/services/infrastructure/rate-limiter.service';\nimport { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\nimport { environment } from '../../../environments/environment';\n"}},{"ruleId":"import/order","severity":1,"message":"`../utils/type-guards` import should occur after import of `@core/services/infrastructure/supabase-client.service`","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":56,"fix":{"range":[320,631],"text":"import { LoggerService } from '@core/services/infrastructure/logger.service';\nimport { RateLimiterService } from '@core/services/infrastructure/rate-limiter.service';\nimport { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\nimport { getErrorMessage } from '../utils/type-guards';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import { isPlatformBrowser } from '@angular/common';\nimport { Injectable, OnDestroy, PLATFORM_ID, computed, inject, signal } from '@angular/core';\nimport { Router } from '@angular/router';\nimport { AuthChangeEvent, Session } from '@supabase/supabase-js';\nimport { environment } from '../../../environments/environment';\nimport { getErrorMessage } from '../utils/type-guards';\nimport { LoggerService } from '@core/services/infrastructure/logger.service';\nimport { RateLimiterService } from '@core/services/infrastructure/rate-limiter.service';\nimport { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\n\ninterface AuthState {\n  session: Session | null;\n  loading: boolean;\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class AuthService implements OnDestroy {\n  private readonly supabase = injectSupabase();\n  private readonly platformId = inject(PLATFORM_ID);\n  private readonly isBrowser = isPlatformBrowser(this.platformId);\n  private readonly TIKTOK_STATE_KEY = 'tiktok_oauth_state';\n\n  constructor(\n    private readonly router: Router,\n    private readonly logger: LoggerService,\n    private readonly rateLimiter: RateLimiterService,\n  ) {\n    // SSR-safe: Only initialize auth in browser\n    if (this.isBrowser) {\n      void this.ensureSession();\n      this.listenToAuthChanges();\n    }\n  }\n\n  /**\n    * Supabase client (SSR-safe)\n    * - Browser: real client\n    * - SSR: stub client that returns empty results\n   */\n  private readonly state = signal<AuthState>({ session: null, loading: true });\n  private restoreSessionPromise: Promise<void> | null = null;\n  private authSubscription: { data: { subscription: { unsubscribe: () => void } } } | null = null;\n\n  readonly sessionSignal = computed(() => this.state().session);\n  readonly session$ = computed(() => this.state().session);\n  readonly isAuthenticated = computed(() => !!this.state().session);\n  readonly loading = computed(() => this.state().loading);\n  readonly userEmail = computed(() => this.state().session?.user?.email);\n\n  ngOnDestroy(): void {\n    this.authSubscription?.data.subscription.unsubscribe();\n  }\n\n  async ensureSession(): Promise<Session | null> {\n    this.logger.debug('ensureSession called', 'AuthService', {\n      loading: this.state().loading,\n      hasSession: !!this.state().session,\n    });\n    if (!this.state().loading) {\n      return this.state().session;\n    }\n    if (!this.restoreSessionPromise) {\n      this.logger.debug('ensureSession: waiting for loadSession...', 'AuthService');\n      this.restoreSessionPromise = this.loadSession().finally(() => {\n        this.restoreSessionPromise = null;\n      });\n    }\n    await this.restoreSessionPromise;\n    this.logger.debug('ensureSession: resolved', 'AuthService', {\n      hasSession: !!this.state().session,\n    });\n    return this.state().session;\n  }\n\n  /**\n   * ✅ FIX P0.1: Obtener usuario autenticado con email\n   */\n  async getCurrentUser(): Promise<{ id: string; email: string } | null> {\n    const session = await this.ensureSession();\n    if (!session?.user) return null;\n\n    return {\n      id: session.user.id,\n      email: session.user.email || '',\n    };\n  }\n\n  // ============================================================================\n  // 🚀 PERF: Cached User Methods\n  // These methods use the cached session instead of making API calls.\n  // Services should use these instead of supabase.auth.getUser() directly.\n  // ============================================================================\n\n  /**\n   * 🚀 PERF: Get cached user ID without API call\n   * Returns null if not authenticated or session not yet loaded.\n   * Use this instead of: (await supabase.auth.getUser()).data.user?.id\n   *\n   * @example\n   * // Before (makes API call each time):\n   * const userId = (await this.supabase.auth.getUser()).data.user?.id;\n   *\n   * // After (uses cached session):\n   * const userId = await this.authService.getCachedUserId();\n   */\n  async getCachedUserId(): Promise<string | null> {\n    const session = await this.ensureSession();\n    return session?.user?.id ?? null;\n  }\n\n  /**\n   * 🚀 PERF: Synchronous cached user ID (returns null if session not loaded yet)\n   * Use for non-critical checks where you don't want to wait for session load.\n   */\n  getCachedUserIdSync(): string | null {\n    return this.state().session?.user?.id ?? null;\n  }\n\n  /**\n   * 🚀 PERF: Get full user object from cached session\n   * Returns the Supabase User object without making an API call.\n   */\n  async getCachedUser(): Promise<{ id: string; email?: string; phone?: string } | null> {\n    const session = await this.ensureSession();\n    if (!session?.user) return null;\n\n    return {\n      id: session.user.id,\n      email: session.user.email,\n      phone: session.user.phone,\n    };\n  }\n\n  private async loadSession(): Promise<void> {\n    this.logger.debug('loadSession: starting...', 'AuthService');\n    const {\n      data: { session },\n      error,\n    } = await this.supabase.auth.getSession();\n\n    this.logger.debug('loadSession: getSession result', 'AuthService', {\n      hasSession: !!session,\n      error: error?.message,\n    });\n\n    if (error) {\n      this.logger.error(\n        'Failed to load session',\n        'AuthService',\n        error instanceof Error ? error : new Error(getErrorMessage(error)),\n      );\n    }\n    this.state.set({ session: session ?? null, loading: false });\n  }\n\n  async refreshSession(): Promise<Session | null> {\n    this.logger.debug('refreshSession called', 'AuthService');\n    const { data, error } = await this.supabase.auth.refreshSession();\n    if (error) {\n      this.logger.warn('Failed to refresh session', 'AuthService', error);\n      this.logger.debug('refreshSession failed', 'AuthService', { message: error.message });\n      return null;\n    }\n    if (data.session) {\n      this.logger.debug('refreshSession success', 'AuthService');\n      this.state.set({ session: data.session, loading: false });\n    }\n    return data.session;\n  }\n\n  private listenToAuthChanges(): void {\n    this.authSubscription = this.supabase.auth.onAuthStateChange(\n      (event: AuthChangeEvent, session: Session | null) => {\n        this.logger.debug('onAuthStateChange', 'AuthService', {\n          event,\n          hasSession: !!session,\n        });\n        this.state.set({ session: session ?? null, loading: false });\n      },\n    );\n  }\n\n  async signUp(email: string, password: string, fullName: string, phone?: string): Promise<void> {\n    const { error } = await this.supabase.auth.signUp({\n      email,\n      password,\n      options: {\n        data: {\n          full_name: fullName,\n          phone: phone || null,\n          default_currency: environment.defaultCurrency,\n        },\n      },\n    });\n    if (error) {\n      throw this.mapError(error);\n    }\n\n    // Note: CompleteRegistration tracking moved to register component to avoid circular dependency\n  }\n\n  async signIn(email: string, password: string): Promise<void> {\n    // P0-015: Check rate limit before attempting login\n    if (!this.rateLimiter.isAllowed('login', email)) {\n      this.rateLimiter.logViolation('login', email);\n      throw new Error(this.rateLimiter.getErrorMessage('login', email));\n    }\n\n    const { error } = await this.supabase.auth.signInWithPassword({ email, password });\n\n    // Record attempt regardless of success/failure\n    this.rateLimiter.recordAttempt('login', email);\n\n    if (error) {\n      throw this.mapError(error);\n    }\n  }\n\n  /**\n   * Inicia sesión con Google usando Supabase OAuth\n   * Redirige al usuario a la página de autenticación de Google\n   */\n  async signInWithGoogle(): Promise<void> {\n    if (!this.isBrowser) {\n      throw new Error('OAuth solo disponible en browser');\n    }\n    const { error } = await this.supabase.auth.signInWithOAuth({\n      provider: 'google',\n      options: {\n        redirectTo: `${window.location.origin}/auth/callback`,\n        queryParams: {\n          access_type: 'offline',\n          prompt: 'consent',\n        },\n      },\n    });\n\n    if (error) {\n      throw this.mapError(error);\n    }\n  }\n\n  /**\n   * Inicia sesión con TikTok usando OAuth custom\n   * Redirige al usuario a TikTok para autenticación\n   */\n  async signInWithTikTok(): Promise<void> {\n    if (!this.isBrowser) {\n      throw new Error('OAuth solo disponible en browser');\n    }\n    const TIKTOK_CLIENT_ID = environment.tiktok?.clientId;\n    if (!TIKTOK_CLIENT_ID) {\n      throw new Error('TikTok Client ID no configurado');\n    }\n\n    const redirectUri = `${window.location.origin}/auth/callback`;\n    const scope = 'user.info.basic';\n    const state = this.generateRandomState();\n\n    // Guardar state en sessionStorage para validación\n    sessionStorage.setItem(this.TIKTOK_STATE_KEY, state);\n\n    // Construir URL de TikTok\n    const tiktokAuthUrl = new URL('https://www.tiktok.com/v2/oauth/authorize/');\n    tiktokAuthUrl.searchParams.set('client_key', TIKTOK_CLIENT_ID);\n    tiktokAuthUrl.searchParams.set('redirect_uri', redirectUri);\n    tiktokAuthUrl.searchParams.set('response_type', 'code');\n    tiktokAuthUrl.searchParams.set('scope', scope);\n    tiktokAuthUrl.searchParams.set('state', state);\n\n    // Redirigir a TikTok\n    window.location.href = tiktokAuthUrl.toString();\n  }\n\n  /**\n   * Maneja el callback de TikTok OAuth\n   * Intercambia el código por sesión de usuario\n   */\n  async handleTikTokCallback(code: string): Promise<{ data: Session | null; error: Error | null }> {\n    if (!this.isBrowser) {\n      return { data: null, error: new Error('OAuth callback solo disponible en browser') };\n    }\n    try {\n      // Validar state para seguridad (CSRF protection)\n      const savedState = sessionStorage.getItem(this.TIKTOK_STATE_KEY);\n      sessionStorage.removeItem(this.TIKTOK_STATE_KEY);\n\n      if (!savedState) {\n        return {\n          data: null,\n          error: new Error('OAuth state no encontrado. Por favor intenta nuevamente.'),\n        };\n      }\n\n      // Llamar Edge Function para intercambiar código\n      const response = await fetch(\n        `${environment.supabaseUrl}/functions/v1/tiktok-oauth-callback`,\n        {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n            Authorization: `Bearer ${environment.supabaseAnonKey}`,\n            apikey: environment.supabaseAnonKey,\n          },\n          body: JSON.stringify({ code }),\n        },\n      );\n\n      const data = await response.json();\n\n      if (!response.ok || !data.success) {\n        return {\n          data: null,\n          error: new Error(data.error || 'Error al procesar autenticación de TikTok'),\n        };\n      }\n\n      // Si la función devolvió una sesión válida, establecerla en Supabase SDK\n      if (data.session) {\n        // CRÍTICO: Usar setSession para que Supabase SDK maneje tokens y RLS funcione\n        const { error: setSessionError } = await this.supabase.auth.setSession({\n          access_token: data.session.access_token,\n          refresh_token: data.session.refresh_token,\n        });\n\n        if (setSessionError) {\n          return {\n            data: null,\n            error: new Error(`Error estableciendo sesión: ${setSessionError.message}`),\n          };\n        }\n\n        // El onAuthStateChange actualizará automáticamente el state signal\n        return {\n          data: data.session,\n          error: null,\n        };\n      }\n\n      return {\n        data: null,\n        error: new Error('No se recibió sesión válida'),\n      };\n    } catch (err) {\n      return {\n        data: null,\n        error: err instanceof Error ? err : new Error('Error procesando callback de TikTok'),\n      };\n    }\n  }\n\n  /**\n   * Genera un estado aleatorio para protección CSRF\n   */\n  private generateRandomState(): string {\n    const array = new Uint8Array(32);\n    crypto.getRandomValues(array);\n    return Array.from(array, (byte) => byte.toString(16).padStart(2, '0')).join('');\n  }\n\n  /**\n   * Maneja el callback de OAuth procesando los tokens del hash\n   * Supabase detecta automáticamente tokens en URL fragments (#access_token=...)\n   */\n  async handleOAuthCallback(): Promise<{ data: Session | null; error: Error | null }> {\n    if (!this.isBrowser) {\n      return { data: null, error: new Error('OAuth callback solo disponible en browser') };\n    }\n    try {\n      // Verificar si hay un hash en la URL (tokens de OAuth)\n      const hash = window.location.hash;\n\n      if (!hash && !window.location.search.includes('code=')) {\n        // No hay tokens ni código - puede ser un error\n        const urlParams = new URLSearchParams(window.location.search);\n        const errorParam = urlParams.get('error');\n\n        if (errorParam) {\n          return {\n            data: null,\n            error: new Error(`OAuth error: ${errorParam}`),\n          };\n        }\n      }\n\n      // getSession() automáticamente detecta y procesa tokens en el hash de la URL\n      // También puede procesar tokens de query params si Supabase los maneja\n      const { data, error } = await this.supabase.auth.getSession();\n\n      if (error) {\n        // Mejorar mensajes de error comunes\n        if (error.message?.includes('bad_oauth_state') || error.message?.includes('state')) {\n          return {\n            data: null,\n            error: new Error('La sesión de autenticación expiró. Por favor intentá nuevamente.'),\n          };\n        }\n        return { data: null, error };\n      }\n\n      if (data.session) {\n        // Actualizar el state con la nueva sesión\n        this.state.set({ session: data.session, loading: false });\n      }\n\n      return { data: data.session, error: null };\n    } catch (err) {\n      const error = err instanceof Error ? err : new Error('Unknown OAuth callback error');\n      return { data: null, error };\n    }\n  }\n\n  async signOut(): Promise<void> {\n    const { error } = await this.supabase.auth.signOut();\n    if (error) {\n      throw this.mapError(error);\n    }\n    // Redirect to home page after successful logout\n    await this.router.navigate(['/']);\n  }\n\n  async resetPassword(email: string, redirectTo?: string): Promise<void> {\n    // P0-015: Check rate limit for password reset\n    if (!this.rateLimiter.isAllowed('passwordReset', email)) {\n      this.rateLimiter.logViolation('passwordReset', email);\n      throw new Error(this.rateLimiter.getErrorMessage('passwordReset', email));\n    }\n\n    const { error } = await this.supabase.auth.resetPasswordForEmail(email, {\n      redirectTo,\n    });\n\n    // Record attempt\n    this.rateLimiter.recordAttempt('passwordReset', email);\n\n    if (error) {\n      throw this.mapError(error);\n    }\n  }\n\n  /**\n   * Update user password\n   */\n  async updatePassword(newPassword: string): Promise<void> {\n    const { error } = await this.supabase.auth.updateUser({\n      password: newPassword,\n    });\n    if (error) {\n      throw this.mapError(error);\n    }\n  }\n\n  private mapError(error: Error & { status?: number }): Error {\n    if (error?.message?.toLowerCase().includes('failed to fetch')) {\n      return new Error(\n        'No se pudo contactar con Supabase. Verifica tu conexión y las variables NG_APP_SUPABASE_URL / NG_APP_SUPABASE_ANON_KEY.',\n      );\n    }\n    return error;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/core/services/auth/onboarding.service.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`@core/services/infrastructure/analytics.service` import should occur before import of `../../../environments/environment`","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":84,"fix":{"range":[182,387],"text":"import { AnalyticsService } from '@core/services/infrastructure/analytics.service';\nimport { environment } from '../../../environments/environment';\nimport { ProfileStore } from '../stores/profile.store';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { Injectable, inject, signal, computed } from '@angular/core';\nimport { createClient, SupabaseClient } from '@supabase/supabase-js';\nimport { Router } from '@angular/router';\nimport { environment } from '../../../environments/environment';\nimport { ProfileStore } from '../stores/profile.store';\nimport { AnalyticsService } from '@core/services/infrastructure/analytics.service';\n\n/**\n * Onboarding MVP Service\n *\n * Manages the simplified onboarding flow for new users.\n *\n * Features:\n * - Initial goal selection (publish, rent, both)\n * - Hardcoded checklist for locador and locatario\n * - Progress tracking with analytics\n * - Navigation helpers\n */\n\nexport type PrimaryGoal = 'publish' | 'rent' | 'both' | null;\n\nexport interface OnboardingStep {\n  key: string;\n  title: string;\n  completed: boolean;\n  action: string; // Route to navigate\n}\n\nexport interface OnboardingStatus {\n  userId: string;\n  role: string | null;\n  primaryGoal: PrimaryGoal;\n  showInitialModal: boolean;\n  onboardingStatus: string | null;\n  locadorSteps: OnboardingStep[];\n  locatarioSteps: OnboardingStep[];\n  activeChecklist: 'locador' | 'locatario' | 'both' | null;\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class OnboardingService {\n  private readonly router = inject(Router);\n  private readonly analytics = inject(AnalyticsService);\n  private readonly profileStore = inject(ProfileStore);\n  private readonly supabase: SupabaseClient;\n\n  // State\n  readonly onboardingStatus = signal<OnboardingStatus | null>(null);\n  readonly isLoading = signal(false);\n  readonly error = signal<string | null>(null);\n\n  // Computed\n  readonly showInitialModal = computed(() => this.onboardingStatus()?.showInitialModal ?? false);\n  readonly primaryGoal = computed(() => this.onboardingStatus()?.primaryGoal ?? null);\n  readonly locadorSteps = computed(() => this.onboardingStatus()?.locadorSteps ?? []);\n  readonly locatarioSteps = computed(() => this.onboardingStatus()?.locatarioSteps ?? []);\n  readonly activeChecklist = computed(() => this.onboardingStatus()?.activeChecklist ?? null);\n\n  // Progress computed\n  readonly locadorProgress = computed(() => {\n    const steps = this.locadorSteps();\n    if (steps.length === 0) return 0;\n    const completed = steps.filter((s) => s.completed).length;\n    return Math.round((completed / steps.length) * 100);\n  });\n\n  readonly locatarioProgress = computed(() => {\n    const steps = this.locatarioSteps();\n    if (steps.length === 0) return 0;\n    const completed = steps.filter((s) => s.completed).length;\n    return Math.round((completed / steps.length) * 100);\n  });\n\n  readonly isOnboardingComplete = computed(() => {\n    const checklist = this.activeChecklist();\n    if (!checklist) return true;\n\n    if (checklist === 'both') {\n      return this.locadorProgress() === 100 && this.locatarioProgress() === 100;\n    }\n\n    if (checklist === 'locador') {\n      return this.locadorProgress() === 100;\n    }\n\n    if (checklist === 'locatario') {\n      return this.locatarioProgress() === 100;\n    }\n\n    return false;\n  });\n\n  constructor() {\n    this.supabase = createClient(environment.supabaseUrl, environment.supabaseAnonKey);\n  }\n\n  /**\n   * Load onboarding status from database\n   */\n  async loadOnboardingStatus(): Promise<void> {\n    this.isLoading.set(true);\n    this.error.set(null);\n\n    try {\n      const { data, error } = await this.supabase.rpc('get_onboarding_status');\n\n      if (error) {\n        console.error('Error loading onboarding status:', error);\n        this.error.set(error.message);\n        return;\n      }\n\n      if (data) {\n        this.onboardingStatus.set(data as OnboardingStatus);\n\n        // Track analytics\n        if (data.showInitialModal) {\n          this.analytics.trackEvent('onboarding_modal_shown', {\n            userId: data.userId,\n          });\n        }\n      }\n    } catch (err) {\n      console.error('Error loading onboarding status:', err);\n      this.error.set('Error cargando estado de onboarding');\n    } finally {\n      this.isLoading.set(false);\n    }\n  }\n\n  /**\n   * Set primary goal and redirect\n   */\n  async setPrimaryGoal(goal: 'publish' | 'rent' | 'both'): Promise<void> {\n    this.isLoading.set(true);\n    this.error.set(null);\n\n    try {\n      const { data, error } = await this.supabase.rpc('set_primary_goal', {\n        p_goal: goal,\n      });\n\n      if (error) {\n        console.error('Error setting primary goal:', error);\n        this.error.set(error.message);\n        return;\n      }\n\n      if (data && data.success) {\n        // Track analytics\n        this.analytics.trackEvent('onboarding_goal_selected', {\n          goal,\n          timestamp: new Date().toISOString(),\n        });\n\n        // Reload onboarding status\n        await this.loadOnboardingStatus();\n\n        // Navigate based on goal\n        this.navigateToFirstStep(goal);\n      } else {\n        this.error.set(data?.error || 'Error guardando objetivo');\n      }\n    } catch (err) {\n      console.error('Error setting primary goal:', err);\n      this.error.set('Error guardando objetivo');\n    } finally {\n      this.isLoading.set(false);\n    }\n  }\n\n  /**\n   * Navigate to first step based on goal\n   */\n  private navigateToFirstStep(goal: 'publish' | 'rent' | 'both'): void {\n    // Check if profile is complete first\n    const profile = this.profileStore.profile();\n    const hasBasicProfile = profile?.full_name && profile?.phone;\n\n    if (!hasBasicProfile) {\n      this.router.navigate(['/profile']);\n      return;\n    }\n\n    // Navigate based on goal\n    switch (goal) {\n      case 'publish':\n        this.router.navigate(['/cars/publish']);\n        break;\n      case 'rent':\n        this.router.navigate(['/marketplace']);\n        break;\n      case 'both':\n        // Fall back to the marketplace landing where both experiences converge\n        this.router.navigate(['/']);\n        break;\n    }\n  }\n\n  /**\n   * Get next pending step for a checklist\n   */\n  getNextStep(checklist: 'locador' | 'locatario'): OnboardingStep | null {\n    const steps = checklist === 'locador' ? this.locadorSteps() : this.locatarioSteps();\n    return steps.find((s) => !s.completed) || null;\n  }\n\n  /**\n   * Navigate to a step's action\n   */\n  navigateToStep(step: OnboardingStep): void {\n    this.analytics.trackEvent('onboarding_step_clicked', {\n      step: step.key,\n      title: step.title,\n      route: step.action,\n    });\n\n    this.router.navigateByUrl(step.action);\n  }\n\n  /**\n   * Track step completion (called from components)\n   */\n  trackStepCompletion(stepKey: string): void {\n    this.analytics.trackEvent('onboarding_step_completed', {\n      step: stepKey,\n      timestamp: new Date().toISOString(),\n    });\n  }\n\n  /**\n   * Dismiss initial modal (without selecting goal)\n   */\n  async dismissInitialModal(): Promise<void> {\n    this.analytics.trackEvent('onboarding_modal_dismissed', {\n      timestamp: new Date().toISOString(),\n    });\n\n    // Just close the modal, don't set a goal\n    // User can set it later from profile\n  }\n\n  /**\n   * Reset onboarding (for testing/admin)\n   */\n  async resetOnboarding(): Promise<void> {\n    try {\n      const { error } = await this.supabase\n        .from('profiles')\n        .update({\n          primary_goal: null,\n          onboarding: 'incomplete',\n        })\n        .eq('id', this.profileStore.profile()?.id);\n\n      if (error) {\n        console.error('Error resetting onboarding:', error);\n        return;\n      }\n\n      await this.loadOnboardingStatus();\n    } catch (err) {\n      console.error('Error resetting onboarding:', err);\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/core/services/auth/profile.service.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`../models` import should occur after import of `@core/services/infrastructure/supabase-client.service`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":10,"endColumn":20,"fix":{"range":[89,376],"text":"import { LoggerService } from '@core/services/infrastructure/logger.service';\nimport { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\nimport {\n  DocumentKind,\n  NotificationPrefs,\n  ProfileAudit,\n  Role,\n  UserDocument,\n  UserProfile,\n} from '../models';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { Injectable, inject } from '@angular/core';\nimport { v4 as uuidv4 } from 'uuid';\nimport {\n  DocumentKind,\n  NotificationPrefs,\n  ProfileAudit,\n  Role,\n  UserDocument,\n  UserProfile,\n} from '../models';\nimport { LoggerService } from '@core/services/infrastructure/logger.service';\nimport { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\n\n// Re-export UserProfile for convenience\nexport type { UserProfile };\n\nexport interface UpdateProfileData {\n  full_name?: string;\n  role?: Role;\n  avatar_url?: string;\n  phone?: string;\n  whatsapp?: string;\n  dni?: string;\n  gov_id_type?: string;\n  gov_id_number?: string;\n  driver_license_number?: string;\n  driver_license_country?: string;\n  driver_license_expiry?: string;\n  driver_license_class?: string;\n  driver_license_professional?: boolean;\n  driver_license_points?: number | null;\n  date_of_birth?: string | null; // ISO date string YYYY-MM-DD\n  address_line1?: string;\n  address_line2?: string;\n  city?: string;\n  state?: string;\n  postal_code?: string;\n  country?: string;\n  timezone?: string;\n  locale?: string;\n  currency?: string;\n  marketing_opt_in?: boolean;\n  notif_prefs?: NotificationPrefs;\n  tos_accepted_at?: boolean;\n  preferred_search_radius_km?: number | null;\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class ProfileService {\n  private readonly logger = inject(LoggerService);\n  private readonly supabase = injectSupabase();\n\n  async getCurrentProfile(): Promise<UserProfile | null> {\n    const {\n      data: { user },\n    } = await this.supabase.auth.getUser();\n\n    if (!user) {\n      throw new Error('Usuario no autenticado - getUser() retornó null');\n    }\n\n    const { data, error } = await this.supabase\n      .from('profiles')\n      .select('*')\n      .eq('id', user['id'])\n      .single();\n\n    if (error) {\n      if (error.code === 'PGRST116') {\n        return this.createProfile(user['id'], user['email'] ?? '');\n      }\n\n      if (error.code === '42501') {\n        throw new Error(\n          `RLS Policy violation: Usuario ${user['id']} no tiene acceso a su propio perfil. Error: ${error['message']}`,\n        );\n      }\n\n      throw new Error(`Error cargando perfil (${error.code}): ${error['message']}`);\n    }\n\n    return data as UserProfile;\n  }\n\n  async getProfileById(userId: string): Promise<UserProfile | null> {\n    const { data, error } = await this.supabase\n      .from('profiles')\n      .select('*')\n      .eq('id', userId)\n      .single();\n\n    if (error) {\n      if (error.code === 'PGRST116') return null;\n      throw error;\n    }\n\n    return data as UserProfile;\n  }\n\n  async updateProfile(updates: UpdateProfileData): Promise<UserProfile> {\n    const {\n      data: { user },\n    } = await this.supabase.auth.getUser();\n\n    if (!user) {\n      throw new Error('Usuario no autenticado');\n    }\n\n    const payload: Record<string, unknown> = { ...updates };\n\n    if (updates['tos_accepted_at'] === true) {\n      payload['tos_accepted_at'] = new Date().toISOString();\n    } else {\n      delete payload['tos_accepted_at'];\n    }\n\n    const { data, error } = await this.supabase\n      .from('profiles')\n      .update(payload)\n      .eq('id', user['id'])\n      .select()\n      .single();\n\n    if (error) {\n      throw error;\n    }\n\n    return data as UserProfile;\n  }\n\n  async uploadAvatar(file: File): Promise<string> {\n    const {\n      data: { user },\n    } = await this.supabase.auth.getUser();\n\n    if (!user) {\n      throw new Error('Usuario no autenticado');\n    }\n\n    const allowedTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/webp'];\n    if (!allowedTypes.includes(file.type)) {\n      throw new Error('Formato no permitido. Use JPG, PNG o WEBP');\n    }\n\n    if (file.size > 2 * 1024 * 1024) {\n      throw new Error('La imagen no debe superar 2MB');\n    }\n\n    const extension = file.name.split('.').pop() ?? 'jpg';\n    const filename = `${uuidv4()}.${extension}`;\n    const filePath = `${user['id']}/${filename}`;\n\n    const { error: uploadError } = await this.supabase.storage\n      .from('avatars')\n      .upload(filePath, file, {\n        cacheControl: '3600',\n        upsert: false,\n      });\n\n    if (uploadError) {\n      throw uploadError;\n    }\n\n    const {\n      data: { publicUrl },\n    } = this.supabase.storage.from('avatars').getPublicUrl(filePath);\n\n    await this.updateProfile({ avatar_url: publicUrl });\n\n    return publicUrl;\n  }\n\n  async deleteAvatar(): Promise<void> {\n    const profile = await this.getCurrentProfile();\n\n    if (!profile?.avatar_url) {\n      return;\n    }\n\n    const url = new URL(profile.avatar_url);\n    const pathParts = url.pathname.split('/avatars/');\n    if (pathParts.length > 1) {\n      const storagePath = pathParts[1];\n      await this.supabase.storage.from('avatars').remove([storagePath]);\n    }\n\n    await this.updateProfile({ avatar_url: '' });\n  }\n\n  private async createProfile(userId: string, email: string): Promise<UserProfile> {\n    const newProfile: Partial<UserProfile> = {\n      id: userId,\n      full_name: email.split('@')[0],\n      role: 'renter',\n      country: 'AR',\n    };\n\n    const { data, error } = await this.supabase\n      .from('profiles')\n      .insert(newProfile)\n      .select()\n      .single();\n\n    if (error) {\n      throw new Error(\n        `Error creando perfil (${error.code}): ${error['message']}. Details: ${error.details}. Hint: ${error.hint}`,\n      );\n    }\n\n    this.logger.debug('✅ Perfil creado:', {\n      id: data?.['id'],\n      full_name: data?.['full_name'],\n    });\n\n    return data as UserProfile;\n  }\n\n  async canPublishCars(): Promise<boolean> {\n    const profile = await this.getCurrentProfile();\n    return profile?.['role'] === 'owner' || profile?.['role'] === 'both';\n  }\n\n  async canBookCars(): Promise<boolean> {\n    const profile = await this.getCurrentProfile();\n    return profile?.['role'] === 'renter' || profile?.['role'] === 'both';\n  }\n\n  async getMe(): Promise<UserProfile> {\n    const { data, error } = await this.supabase.from('me_profile').select('*').single();\n\n    if (error) {\n      throw error;\n    }\n\n    return data as UserProfile;\n  }\n\n  async safeUpdateProfile(updates: UpdateProfileData): Promise<UserProfile> {\n    const { data, error } = await this.supabase.rpc('update_my_profile', {\n      payload: updates,\n    });\n\n    if (error) {\n      throw error;\n    }\n\n    return data as UserProfile;\n  }\n\n  async uploadDocument(file: File, kind: DocumentKind): Promise<UserDocument> {\n    const {\n      data: { user },\n    } = await this.supabase.auth.getUser();\n\n    if (!user) {\n      throw new Error('Usuario no autenticado');\n    }\n\n    const allowedTypes = ['image/jpeg', 'image/jpg', 'image/png', 'application/pdf'];\n    if (!allowedTypes.includes(file.type)) {\n      throw new Error('Formato no permitido. Use JPG, PNG o PDF');\n    }\n\n    if (file.size > 5 * 1024 * 1024) {\n      throw new Error('El archivo no debe superar 5MB');\n    }\n\n    const extension = file.name.split('.').pop() ?? 'jpg';\n    const filename = `${uuidv4()}-${kind}.${extension}`;\n    const filePath = `${user['id']}/${filename}`;\n\n    const { error: uploadError } = await this.supabase.storage\n      .from('documents')\n      .upload(filePath, file, {\n        cacheControl: '3600',\n        upsert: false,\n      });\n\n    if (uploadError) {\n      throw uploadError;\n    }\n\n    const { data, error: insertError } = await this.supabase\n      .from('user_documents')\n      .insert({\n        user_id: user['id'],\n        kind,\n        storage_path: filePath,\n        status: 'pending',\n      })\n      .select()\n      .single();\n\n    if (insertError) {\n      await this.supabase.storage.from('documents').remove([filePath]);\n      throw insertError;\n    }\n\n    try {\n      await this.supabase.functions.invoke('verify-user-docs', {\n        body: {\n          document_id: data['id'],\n          kind,\n          trigger: 'document-upload',\n        },\n      });\n    } catch (verificationError) {\n      console.warn('Document verification failed (non-blocking):', verificationError);\n    }\n\n    return data as UserDocument;\n  }\n\n  async getMyDocuments(): Promise<UserDocument[]> {\n    const {\n      data: { user },\n    } = await this.supabase.auth.getUser();\n\n    if (!user) {\n      throw new Error('Usuario no autenticado');\n    }\n\n    const { data, error } = await this.supabase\n      .from('user_documents')\n      .select('*')\n      .eq('user_id', user['id'])\n      .order('created_at', { ascending: false });\n\n    if (error) {\n      throw error;\n    }\n\n    return (data as UserDocument[]) ?? [];\n  }\n\n  async getDocument(documentId: string): Promise<UserDocument | null> {\n    const { data, error } = await this.supabase\n      .from('user_documents')\n      .select('*')\n      .eq('id', documentId)\n      .single();\n\n    if (error) {\n      if (error.code === 'PGRST116') return null;\n      throw error;\n    }\n\n    return data as UserDocument;\n  }\n\n  async deleteDocument(documentId: string): Promise<void> {\n    const document = await this.getDocument(documentId);\n\n    if (!document) {\n      throw new Error('Documento no encontrado');\n    }\n\n    await this.supabase.storage.from('documents').remove([document.storage_path]);\n\n    const { error } = await this.supabase.from('user_documents').delete().eq('id', documentId);\n\n    if (error) {\n      throw error;\n    }\n  }\n\n  async getDocumentSignedUrl(storagePath: string): Promise<string> {\n    const { data, error } = await this.supabase.storage\n      .from('documents')\n      .createSignedUrl(storagePath, 3600);\n\n    if (error) {\n      throw error;\n    }\n\n    return data.signedUrl;\n  }\n\n  async hasCompletedOnboarding(): Promise<boolean> {\n    try {\n      const profile = await this.getCurrentProfile();\n      return profile?.onboarding === 'complete';\n    } catch (error) {\n      console.warn('[ProfileService] Error checking onboarding status:', error);\n      return false;\n    }\n  }\n\n  async hasAcceptedTOS(): Promise<boolean> {\n    const profile = await this.getMe();\n    return profile['tos_accepted_at'] !== null;\n  }\n\n  async completeOnboarding(): Promise<void> {\n    const {\n      data: { user },\n    } = await this.supabase.auth.getUser();\n\n    if (!user) {\n      throw new Error('Usuario no autenticado');\n    }\n\n    const { error } = await this.supabase\n      .from('profiles')\n      .update({ onboarding: 'complete' })\n      .eq('id', user['id']);\n\n    if (error) {\n      console['error']('Error completing onboarding:', error);\n      throw error;\n    }\n  }\n\n  async acceptTOS(): Promise<void> {\n    const {\n      data: { user },\n    } = await this.supabase.auth.getUser();\n\n    if (!user) {\n      throw new Error('Usuario no autenticado');\n    }\n\n    const { error } = await this.supabase\n      .from('profiles')\n      .update({ tos_accepted_at: new Date().toISOString() })\n      .eq('id', user['id']);\n\n    if (error) {\n      throw error;\n    }\n  }\n\n  async getAuditLog(): Promise<ProfileAudit[]> {\n    const {\n      data: { user },\n    } = await this.supabase.auth.getUser();\n\n    if (!user) {\n      throw new Error('Usuario no autenticado');\n    }\n\n    const { data, error } = await this.supabase\n      .from('profile_audit_log')\n      .select('*')\n      .eq('user_id', user['id'])\n      .order('created_at', { ascending: false })\n      .limit(50);\n\n    if (error) {\n      throw error;\n    }\n\n    return (data as ProfileAudit[]) ?? [];\n  }\n\n  async requestDataExport(): Promise<void> {\n    const {\n      data: { user },\n    } = await this.supabase.auth.getUser();\n\n    if (!user) {\n      throw new Error('Usuario no autenticado');\n    }\n\n    await this.supabase.functions.invoke('export-user-data', {\n      body: { user_id: user['id'] },\n    });\n  }\n\n  async requestAccountDeletion(reason?: string): Promise<void> {\n    const {\n      data: { user },\n    } = await this.supabase.auth.getUser();\n\n    if (!user) {\n      throw new Error('Usuario no autenticado');\n    }\n\n    const { error } = await this.supabase.from('account_deletion_requests').insert({\n      user_id: user['id'],\n      reason: reason ?? 'User requested deletion',\n      status: 'pending',\n    });\n\n    if (error) {\n      throw error;\n    }\n  }\n\n  /**\n   * Registra una infracción (strike) contra un usuario\n   * Útil para penalizar dueños por autos sucios o cancelaciones injustificadas\n   */\n  async addStrike(userId: string, reason: string, bookingId?: string): Promise<void> {\n    try {\n      // Intentar insertar en tabla de strikes\n      // Nota: Si la tabla no existe, esto fallará silenciosamente en el catch\n      const { error } = await this.supabase.from('user_strikes').insert({\n        user_id: userId,\n        reason,\n        booking_id: bookingId,\n        created_at: new Date().toISOString(),\n      });\n\n      if (error) {\n        console.warn('Could not record strike (table might not exist):', error['message']);\n      } else {\n        this.logger.debug(`Strike added to user ${userId}: ${reason}`);\n      }\n    } catch (err) {\n      console['error']('Error adding strike:', err);\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/core/services/auth/rbac.service.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`@core/services/infrastructure/supabase-client.service` import should occur before type import of `../models`","line":4,"column":1,"nodeType":"ImportDeclaration","endLine":4,"endColumn":88,"fix":{"range":[70,272],"text":"import { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\nimport type { AdminAuditLog } from '../models';\nimport type { AdminRole, AdminUser } from '../types/admin.types';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { Injectable, inject, signal, computed } from '@angular/core';\nimport type { AdminAuditLog } from '../models';\nimport type { AdminRole, AdminUser } from '../types/admin.types';\nimport { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\nimport { AuthService } from './auth.service';\n\n/**\n * RBAC Service - Role-Based Access Control\n *\n * Manages admin roles, permissions, and audit logging for admin operations.\n * Supports both new RBAC system and legacy is_admin flag for backward compatibility.\n *\n * @example\n * ```typescript\n * const rbac = inject(RBACService);\n *\n * // Check if user has a specific role\n * if (await rbac.hasRole('super_admin')) {\n *   // Allow access\n * }\n *\n * // Check if user has any admin role\n * if (await rbac.isAdmin()) {\n *   // Allow access\n * }\n *\n * // Log an admin action\n * await rbac.logAction('user_view', 'user', userId, null, { reason: 'Support ticket' });\n * ```\n */\n@Injectable({\n  providedIn: 'root',\n})\nexport class RBACService {\n  private readonly supabase = injectSupabase();\n  private readonly authService = inject(AuthService);\n\n  // Cached user roles\n  private readonly userRolesSignal = signal<AdminUser[]>([]);\n  private readonly loadingSignal = signal<boolean>(false);\n\n  // Computed properties\n  readonly userRoles = computed(() => this.userRolesSignal());\n  readonly loading = computed(() => this.loadingSignal());\n  readonly isAdmin = computed(() => this.userRolesSignal().length > 0);\n  readonly isSuperAdmin = computed(() =>\n    this.userRolesSignal().some((r) => r.role === 'super_admin'),\n  );\n  readonly isOperations = computed(() =>\n    this.userRolesSignal().some((r) => r.role === 'operations'),\n  );\n  readonly isSupport = computed(() => this.userRolesSignal().some((r) => r.role === 'support'));\n  readonly isFinance = computed(() => this.userRolesSignal().some((r) => r.role === 'finance'));\n\n  /**\n   * Load current user's admin roles\n   */\n  async loadUserRoles(): Promise<AdminUser[]> {\n    this.loadingSignal.set(true);\n    try {\n      const user = await this.authService.ensureSession();\n      if (!user?.user?.id) {\n        this.userRolesSignal.set([]);\n        return [];\n      }\n\n      const { data, error } = await this.supabase\n        .from('admin_user_roles')\n        .select('*')\n        .eq('user_id', user.user.id)\n        .eq('is_active', true)\n        .or(`expires_at.is.null,expires_at.gt.${new Date().toISOString()}`);\n\n      if (error) throw error;\n\n      this.userRolesSignal.set(data as AdminUser[]);\n      return data as AdminUser[];\n    } catch (error) {\n      console.error('Error loading user roles:', error);\n      this.userRolesSignal.set([]);\n      return [];\n    } finally {\n      this.loadingSignal.set(false);\n    }\n  }\n\n  /**\n   * Check if current user has a specific admin role\n   */\n  async hasRole(role: AdminRole): Promise<boolean> {\n    const roles = this.userRolesSignal();\n    if (roles.length === 0) {\n      await this.loadUserRoles();\n    }\n\n    return this.userRolesSignal().some((r) => r.role === role);\n  }\n\n  /**\n   * Check if current user has any of the specified roles\n   */\n  async hasAnyRole(roles: AdminRole[]): Promise<boolean> {\n    const userRoles = this.userRolesSignal();\n    if (userRoles.length === 0) {\n      await this.loadUserRoles();\n    }\n\n    return this.userRolesSignal().some((r) => roles.includes(r.role));\n  }\n\n  /**\n   * Check if current user has all of the specified roles\n   */\n  async hasAllRoles(roles: AdminRole[]): Promise<boolean> {\n    const userRoles = this.userRolesSignal();\n    if (userRoles.length === 0) {\n      await this.loadUserRoles();\n    }\n\n    return roles.every((role) => this.userRolesSignal().some((r) => r.role === role));\n  }\n\n  /**\n   * Check if current user is any type of admin (new RBAC or legacy)\n   */\n  async checkIsAdmin(): Promise<boolean> {\n    // Check new RBAC first\n    const roles = this.userRolesSignal();\n    if (roles.length === 0) {\n      await this.loadUserRoles();\n    }\n\n    if (this.userRolesSignal().length > 0) {\n      return true;\n    }\n\n    // Fallback to legacy is_admin check\n    try {\n      const { data } = await this.supabase.rpc('is_admin');\n      return data === true;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Log an admin action to the audit trail\n   */\n  async logAction(\n    action: string,\n    resourceType: string,\n    resourceId: string | null = null,\n    changes: { before?: unknown; after?: unknown } | null = null,\n    metadata: Record<string, unknown> | null = null,\n  ): Promise<string | null> {\n    try {\n      const { data, error } = await this.supabase.rpc('log_admin_action', {\n        p_action: action,\n        p_resource_type: resourceType,\n        p_resource_id: resourceId,\n        p_changes: changes as never,\n        p_metadata: metadata as never,\n      });\n\n      if (error) {\n        console.error('Error logging admin action:', error);\n        return null;\n      }\n\n      return data as string;\n    } catch (error) {\n      console.error('Error logging admin action:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Get audit logs with filters\n   */\n  async getAuditLogs(params: {\n    limit?: number;\n    offset?: number;\n    action?: string;\n    resourceType?: string;\n    resourceId?: string;\n    adminUserId?: string;\n    startDate?: string;\n    endDate?: string;\n  }): Promise<{ data: AdminAuditLog[]; count: number }> {\n    try {\n      let query = this.supabase\n        .from('admin_audit_logs')\n        .select('*', { count: 'exact' })\n        .order('created_at', { ascending: false });\n\n      if (params.action) {\n        query = query.eq('action', params.action);\n      }\n\n      if (params.resourceType) {\n        query = query.eq('resource_type', params.resourceType);\n      }\n\n      if (params.resourceId) {\n        query = query.eq('resource_id', params.resourceId);\n      }\n\n      if (params.adminUserId) {\n        query = query.eq('admin_user_id', params.adminUserId);\n      }\n\n      if (params.startDate) {\n        query = query.gte('created_at', params.startDate);\n      }\n\n      if (params.endDate) {\n        query = query.lte('created_at', params.endDate);\n      }\n\n      if (params.limit) {\n        query = query.limit(params.limit);\n      }\n\n      if (params.offset) {\n        query = query.range(params.offset, params.offset + (params.limit ?? 50) - 1);\n      }\n\n      const { data, error, count } = await query;\n\n      if (error) throw error;\n\n      return {\n        data: (data as AdminAuditLog[]) ?? [],\n        count: count ?? 0,\n      };\n    } catch (error) {\n      console.error('Error fetching audit logs:', error);\n      return { data: [], count: 0 };\n    }\n  }\n\n  /**\n   * Grant an admin role to a user (super_admin only)\n   */\n  async grantRole(\n    userId: string,\n    role: AdminRole,\n    expiresAt: string | null = null,\n  ): Promise<boolean> {\n    if (!(await this.hasRole('super_admin'))) {\n      throw new Error('Only super admins can grant roles');\n    }\n\n    try {\n      const user = await this.authService.ensureSession();\n      if (!user?.user?.id) {\n        throw new Error('Not authenticated');\n      }\n\n      const { error } = await this.supabase.from('admin_user_roles').insert({\n        user_id: userId,\n        role,\n        granted_by: user.user.id,\n        expires_at: expiresAt,\n        is_active: true,\n      });\n\n      if (error) throw error;\n\n      // Log the action\n      await this.logAction('role_grant', 'admin_user_role', userId, null, {\n        role,\n        expires_at: expiresAt,\n      });\n\n      return true;\n    } catch (error) {\n      console.error('Error granting role:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Revoke an admin role from a user (super_admin only)\n   */\n  async revokeRole(userId: string, role: AdminRole): Promise<boolean> {\n    if (!(await this.hasRole('super_admin'))) {\n      throw new Error('Only super admins can revoke roles');\n    }\n\n    try {\n      const { error } = await this.supabase\n        .from('admin_user_roles')\n        .update({ is_active: false })\n        .eq('user_id', userId)\n        .eq('role', role);\n\n      if (error) throw error;\n\n      // Log the action\n      await this.logAction('role_revoke', 'admin_user_role', userId, null, { role });\n\n      return true;\n    } catch (error) {\n      console.error('Error revoking role:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Get role display name\n   */\n  getRoleDisplayName(role: AdminRole): string {\n    const roleNames: Record<AdminRole, string> = {\n      super_admin: 'Super Administrator',\n      operations: 'Operations Manager',\n      support: 'Support Specialist',\n      finance: 'Finance Manager',\n    };\n    return roleNames[role];\n  }\n\n  /**\n   * Get role description\n   */\n  getRoleDescription(role: AdminRole): string {\n    const roleDescriptions: Record<AdminRole, string> = {\n      super_admin:\n        'Full access to all admin features including user management and system configuration',\n      operations: 'Manage withdrawals, verifications, bookings, and operational tasks',\n      support: 'User support, content moderation, and customer service',\n      finance: 'Payment investigation, refunds, accounting, and financial operations',\n    };\n    return roleDescriptions[role];\n  }\n\n  /**\n   * Get role permissions\n   */\n  getRolePermissions(role: AdminRole): string[] {\n    const rolePermissions: Record<AdminRole, string[]> = {\n      super_admin: ['*'],\n      operations: ['withdrawals:*', 'verifications:*', 'bookings:*', 'cars:*'],\n      support: ['users:view', 'bookings:view', 'reviews:moderate', 'support:*'],\n      finance: ['payments:*', 'refunds:*', 'accounting:*', 'reports:*'],\n    };\n    return rolePermissions[role];\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/core/services/bookings/booking-cancellation.service.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`@core/services/infrastructure/supabase-client.service` import should occur before import of `../models`","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":88,"fix":{"range":[52,298],"text":"import { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\nimport { Booking } from '../models';\nimport { environment } from '../../../environments/environment';\nimport { getErrorMessage } from '../utils/type-guards';\n"}},{"ruleId":"import/order","severity":1,"message":"`@core/services/infrastructure/logger.service` import should occur before import of `../models`","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":8,"endColumn":78,"fix":{"range":[52,514],"text":"import { LoggerService } from '@core/services/infrastructure/logger.service';\nimport { Booking } from '../models';\nimport { environment } from '../../../environments/environment';\nimport { getErrorMessage } from '../utils/type-guards';\nimport { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\nimport { BookingWalletService } from './booking-wallet.service';\nimport { BookingValidationService } from './booking-validation.service';\n"}},{"ruleId":"import/order","severity":1,"message":"`@core/services/payments/wallet.service` import should occur before import of `../models`","line":9,"column":1,"nodeType":"ImportDeclaration","endLine":9,"endColumn":72,"fix":{"range":[52,619],"text":"import { WalletService } from '@core/services/payments/wallet.service'; // NUEVO: Importar WalletService\nimport { Booking } from '../models';\nimport { environment } from '../../../environments/environment';\nimport { getErrorMessage } from '../utils/type-guards';\nimport { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\nimport { BookingWalletService } from './booking-wallet.service';\nimport { BookingValidationService } from './booking-validation.service';\nimport { LoggerService } from '@core/services/infrastructure/logger.service';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":3,"source":"import { Injectable, inject } from '@angular/core';\nimport { Booking } from '../models';\nimport { environment } from '../../../environments/environment';\nimport { getErrorMessage } from '../utils/type-guards';\nimport { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\nimport { BookingWalletService } from './booking-wallet.service';\nimport { BookingValidationService } from './booking-validation.service';\nimport { LoggerService } from '@core/services/infrastructure/logger.service';\nimport { WalletService } from '@core/services/payments/wallet.service'; // NUEVO: Importar WalletService\n\n/**\n * Service for booking cancellation\n * Handles cancellation logic, refund processing, and wallet unlocking\n */\n@Injectable({\n  providedIn: 'root',\n})\nexport class BookingCancellationService {\n  private readonly supabase = injectSupabase();\n  private readonly bookingWalletService = inject(BookingWalletService);\n  private readonly validationService = inject(BookingValidationService);\n  private readonly logger = inject(LoggerService);\n  private readonly walletService = inject(WalletService); // NUEVO: Inyectar WalletService\n\n  /**\n   * ✅ SPRINT 3: Cancel a booking\n   *\n   * Validates that the booking:\n   * - Belongs to the current user\n   * - Is in 'confirmed' or 'pending' status\n   * - Has at least 24h before start (optional, configurable)\n   *\n   * @param booking - Booking to cancel\n   * @param force - Force cancellation without validating time (admin use)\n   * @returns Promise with operation result\n   */\n  async cancelBooking(\n    booking: Booking,\n    force: boolean = false,\n    refundDestination: 'wallet' | 'card' = 'card', // NUEVO: Destino del reembolso\n  ): Promise<{ success: boolean; error?: string }> {\n    try {\n      // 1. Validate status\n      const statusValidation = this.validationService.validateCancellationStatus(booking);\n      if (!statusValidation.allowed) {\n        return {\n          success: false,\n          error: statusValidation['error'],\n        };\n      }\n\n      // 2. Validate timing (24h before)\n      const timingValidation = this.validationService.validateCancellationTiming(booking, force);\n      if (!timingValidation.allowed) {\n        return {\n          success: false,\n          error: timingValidation['error'],\n        };\n      }\n\n      // 3. Update status to 'cancelled'\n      const { error } = await this.supabase\n        .from('bookings')\n        .update({\n          status: 'cancelled',\n          updated_at: new Date().toISOString(),\n          cancelled_by_role: 'renter',\n        })\n        .eq('id', booking['id']);\n\n      if (error) {\n        return {\n          success: false,\n          error: 'Error al cancelar la reserva. Intenta de nuevo.',\n        };\n      }\n\n      // 4. ✅ P0-021 FIX: Process automatic refund if booking was paid\n      // Always process refund for confirmed or in_progress bookings\n      // If refund fails, log error but don't block cancellation\n      if (booking['status'] === 'confirmed' || booking['status'] === 'in_progress') {\n        try {\n          await this.processRefund(booking, force, refundDestination);\n        } catch (refundError) {\n          this.logger['error'](\n            'Refund failed during cancellation - booking still cancelled',\n            'BookingCancellationService',\n            refundError instanceof Error ? refundError : new Error(getErrorMessage(refundError)),\n          );\n          // ✅ P0-021: Log error but continue - cancellation should not fail if refund fails\n          // Admin will be notified via Sentry and can process refund manually\n        }\n      }\n\n      // 5. Unlock wallet funds if locked\n      await this.bookingWalletService.unlockFundsForCancellation(booking, 'Cancelled by user');\n\n      return { success: true };\n    } catch (error: unknown) {\n      const errorMessage = error instanceof Error ? error['message'] : 'Error inesperado al cancelar';\n      return {\n        success: false,\n        error: errorMessage,\n      };\n    }\n  }\n\n  /**\n   * Legacy cancellation method\n   * Deprecated: Use cancelBooking for new code\n   */\n  async cancelBookingLegacy(booking: Booking, reason?: string): Promise<void> {\n    // 1. Unlock wallet funds if locked\n    if (booking.wallet_status === 'locked' && booking.wallet_lock_transaction_id) {\n      await this.bookingWalletService.unlockFundsForCancellation(booking, reason);\n    }\n\n    // 2. Cancel the booking\n    const { error } = await this.supabase\n      .from('bookings')\n      .update({\n        status: 'cancelled',\n        cancelled_at: new Date().toISOString(),\n        cancellation_reason: reason ?? 'Cancelled by user',\n        cancelled_by_role: 'renter',\n        wallet_status: booking.wallet_status === 'locked' ? 'refunded' : booking.wallet_status,\n      })\n      .eq('id', booking['id']);\n\n    if (error) throw error;\n  }\n\n  /**\n   * Process refund for cancelled booking\n   */\n  /**\n   * Process refund for cancelled booking\n   * @param booking - The booking being cancelled\n   * @param force - If true, bypasses time validations (admin)\n   * @param refundDestination - Where to send the refund: 'wallet' or 'card'\n   */\n  private async processRefund(\n    booking: Booking,\n    force: boolean,\n    refundDestination: 'wallet' | 'card',\n  ): Promise<void> {\n    try {\n      // 1. Calcular el monto del reembolso según la política\n      const { refundType, refundAmount } = this.calculateRefund(booking, force);\n\n      // Si no hay monto a reembolsar, salir\n      if (!refundAmount || refundAmount <= 0) {\n        this.logger.info(\n          'No refund amount calculated, skipping refund process',\n          'BookingCancellationService',\n          { bookingId: booking['id'] },\n        );\n        return;\n      }\n\n      // 2. Procesar reembolso según el destino\n      if (refundDestination === 'wallet') {\n        // Reembolsar a la wallet del usuario\n        if (!booking['user_id']) {\n          throw new Error('Booking has no user_id for wallet refund');\n        }\n        await this.walletService.depositFunds(\n          booking['user_id'],\n          Math.round(refundAmount * 100), // Convertir a centavos\n          `Reembolso por cancelación de reserva ${booking['id'].substring(0, 8)}`,\n          booking['id'], // referenceId\n        );\n        this.logger.info(\n          `Refunded ${refundAmount} ${booking['currency']} to user wallet`,\n          'BookingCancellationService',\n          { bookingId: booking['id'] },\n        );\n      } else {\n        // Reembolsar a la tarjeta (MercadoPago)\n        const metadata = booking.metadata;\n        const mercadopagoPaymentId = metadata?.['mercadopago_payment_id'];\n\n        if (typeof mercadopagoPaymentId !== 'string') {\n          this.logger.warn('No MercadoPago payment ID found for card refund');\n          return;\n        }\n\n        // Get auth token (needed for Edge Function invocation)\n        const {\n          data: { session },\n        } = await this.supabase.auth.getSession();\n        if (!session?.access_token) {\n          this.logger.warn('No auth token available for refund processing');\n          return;\n        }\n\n        // Call Edge Function for refunds\n        const refundResponse = await fetch(\n          `${environment.supabaseUrl}/functions/v1/mercadopago-process-refund`,\n          {\n            method: 'POST',\n            headers: {\n              Authorization: `Bearer ${session.access_token}`,\n              'Content-Type': 'application/json',\n            },\n            body: JSON.stringify({\n              booking_id: booking['id'],\n              refund_type: refundType,\n              amount: refundAmount, // Pasar el monto específico\n              mercadopago_payment_id: mercadopagoPaymentId,\n              reason: 'Cancelación de reserva',\n            }),\n          },\n        );\n\n        if (!refundResponse.ok) {\n          const errorData = await refundResponse.json().catch(() => ({}));\n          this.logger['error'](\n            'Error processing refund via MercadoPago API',\n            'BookingCancellationService',\n            new Error(JSON.stringify(errorData)),\n          );\n          throw new Error(errorData['message'] || 'Error en reembolso con MercadoPago');\n        } else {\n          const refundData = await refundResponse.json();\n          this.logger.info('MercadoPago refund processed successfully', refundData);\n        }\n      }\n    } catch (refundError) {\n      this.logger['error'](\n        'Error during refund process',\n        'BookingCancellationService',\n        refundError instanceof Error ? refundError : new Error(getErrorMessage(refundError)),\n      );\n      throw refundError; // Re-throw para que el caller pueda manejarlo\n    }\n  }\n\n  /**\n   * Calculate refund amount based on cancellation policy\n   */\n  private calculateRefund(\n    booking: Booking,\n    force: boolean,\n  ): { refundType: 'full' | 'partial'; refundAmount?: number } {\n    if (force) {\n      return { refundType: 'full' };\n    }\n\n    const startDate = new Date(booking.start_at);\n    const now = new Date();\n    const hoursUntilStart = (startDate.getTime() - now.getTime()) / (1000 * 60 * 60);\n    const totalAmount = parseFloat(booking['total_amount']?.toString() || '0');\n\n    // Less than 24h: 25% penalty\n    if (hoursUntilStart < 24) {\n      const cancellationFee = totalAmount * 0.25;\n      const refundAmount = totalAmount - cancellationFee;\n      return { refundType: 'partial', refundAmount };\n    }\n\n    // Less than 48h: 10% penalty\n    if (hoursUntilStart < 48) {\n      const cancellationFee = totalAmount * 0.1;\n      const refundAmount = totalAmount - cancellationFee;\n      return { refundType: 'partial', refundAmount };\n    }\n\n    // More than 48h: full refund\n    return { refundType: 'full' };\n  }\n\n  /**\n   * Procesa la cancelación por \"No Show\" (No presentación)\n   * Aplica una multa del 40% al inquilino\n   */\n  async processNoShow(booking: Booking): Promise<{ success: boolean; error?: string }> {\n    try {\n      // 1. Actualizar estado a 'cancelled' con razón 'no_show'\n      const { error } = await this.supabase\n        .from('bookings')\n        .update({\n          status: 'cancelled',\n          updated_at: new Date().toISOString(),\n          cancellation_reason: 'no_show',\n          cancelled_by_role: 'system',\n        })\n        .eq('id', booking['id']);\n\n      if (error) {\n        return { success: false, error: 'Error al procesar No Show' };\n      }\n\n      // 2. Procesar reembolso parcial (60% refund, 40% multa)\n      // Si está pagada, reembolsar solo el 60%\n      if (booking['status'] === 'confirmed' && booking['total_amount']) {\n        const totalAmount = parseFloat(booking['total_amount'].toString());\n        const penaltyAmount = totalAmount * 0.4; // Multa del 40%\n        const refundAmount = totalAmount - penaltyAmount;\n\n        // Llamar a función de reembolso parcial\n        // Nota: Usamos refundType 'partial' y pasamos el monto a devolver\n        const metadata = booking.metadata;\n        const paymentId = metadata?.['mercadopago_payment_id'];\n\n        if (paymentId) {\n          await this.callRefundApi(booking['id'], paymentId as string, refundAmount);\n        }\n      }\n\n      // 3. Desbloquear wallet si corresponde (la garantía se libera íntegra en No Show)\n      await this.bookingWalletService.unlockFundsForCancellation(booking, 'No Show cancellation');\n\n      return { success: true };\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error['message'] : 'Error en proceso de No Show',\n      };\n    }\n  }\n\n  private async callRefundApi(bookingId: string, paymentId: string, amount: number) {\n    const {\n      data: { session },\n    } = await this.supabase.auth.getSession();\n    if (!session?.access_token) return;\n\n    await fetch(`${environment.supabaseUrl}/functions/v1/mercadopago-process-refund`, {\n      method: 'POST',\n      headers: {\n        Authorization: `Bearer ${session.access_token}`,\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({\n        booking_id: bookingId,\n        mercadopago_payment_id: paymentId,\n        refund_type: 'partial',\n        amount: amount,\n        reason: 'No Show penalty (40%)',\n      }),\n    });\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/core/services/bookings/booking-completion.service.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`@core/services/auth/driver-profile.service` import should occur before import of `../models`","line":7,"column":1,"nodeType":"ImportDeclaration","endLine":7,"endColumn":83,"fix":{"range":[146,387],"text":"import { DriverProfileService } from '@core/services/auth/driver-profile.service';\nimport { Booking } from '../models';\nimport { getErrorMessage } from '../utils/type-guards';\nimport { BookingWalletService } from './booking-wallet.service';\n"}},{"ruleId":"import/order","severity":1,"message":"`@core/services/infrastructure/logger.service` import should occur before import of `../models`","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":8,"endColumn":78,"fix":{"range":[146,465],"text":"import { LoggerService } from '@core/services/infrastructure/logger.service';\nimport { Booking } from '../models';\nimport { getErrorMessage } from '../utils/type-guards';\nimport { BookingWalletService } from './booking-wallet.service';\nimport { DriverProfileService } from '@core/services/auth/driver-profile.service';\n"}},{"ruleId":"import/order","severity":1,"message":"`@core/services/payments/payments.service` import should occur before import of `../models`","line":9,"column":1,"nodeType":"ImportDeclaration","endLine":9,"endColumn":76,"fix":{"range":[146,576],"text":"import { PaymentsService } from '@core/services/payments/payments.service'; // NUEVO: Importar PaymentsService\nimport { Booking } from '../models';\nimport { getErrorMessage } from '../utils/type-guards';\nimport { BookingWalletService } from './booking-wallet.service';\nimport { DriverProfileService } from '@core/services/auth/driver-profile.service';\nimport { LoggerService } from '@core/services/infrastructure/logger.service';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":3,"source":"import { Injectable, inject } from '@angular/core';\nimport { firstValueFrom, from } from 'rxjs';\nimport { ignoreElements } from 'rxjs/operators';\nimport { Booking } from '../models';\nimport { getErrorMessage } from '../utils/type-guards';\nimport { BookingWalletService } from './booking-wallet.service';\nimport { DriverProfileService } from '@core/services/auth/driver-profile.service';\nimport { LoggerService } from '@core/services/infrastructure/logger.service';\nimport { PaymentsService } from '@core/services/payments/payments.service'; // NUEVO: Importar PaymentsService\n\n/**\n * Service for managing booking completion\n * Handles completion with/without damages and driver class updates\n */\n@Injectable({\n  providedIn: 'root',\n})\nexport class BookingCompletionService {\n  private readonly bookingWalletService = inject(BookingWalletService);\n  private readonly driverProfileService = inject(DriverProfileService);\n  private readonly logger = inject(LoggerService);\n  private readonly paymentsService = inject(PaymentsService); // NUEVO: Inyectar PaymentsService\n\n  /**\n   * Complete booking without damages (clean booking)\n   * This will:\n   * 1. Release security deposit\n   * 2. Update driver class (improve for clean booking)\n   */\n  async completeBookingClean(\n    booking: Booking,\n    onUpdateBooking: (bookingId: string, updates: Partial<Booking>) => Promise<Booking>,\n  ): Promise<{ success: boolean; error?: string }> {\n    try {\n      // 1. Liberar depósito de seguridad (Wallet o MP Pre-Auth)\n      if (booking.payment_method === 'credit_card' && booking.mp_security_deposit_order_id) {\n        // Liberar pre-autorización de MercadoPago\n        await this.paymentsService.releaseMpPreAuth(\n          booking.mp_security_deposit_order_id,\n          'Garantía liberada: Reserva completada sin daños',\n        );\n        await onUpdateBooking(booking.id, {\n          deposit_status: 'released',\n        });\n      } else if (booking.wallet_status === 'locked') {\n        // Liberar fondos de Wallet\n        const releaseResult = await this.bookingWalletService.releaseSecurityDeposit(\n          booking,\n          'Reserva completada sin daños',\n        );\n\n        if (!releaseResult.ok) {\n          return { success: false, error: releaseResult.error };\n        }\n\n        await onUpdateBooking(booking.id, {\n          wallet_status: 'refunded',\n        });\n      }\n\n      // 2. Marcar reserva como completada\n      await onUpdateBooking(booking.id, {\n        status: 'completed',\n      });\n\n      // 3. Actualizar clase del conductor (mejora por reserva limpia)\n      if (booking.user_id) {\n        try {\n          await firstValueFrom(\n            from(\n              this.driverProfileService.updateClassOnEvent({\n                eventType: 'booking_completed',\n                userId: booking.user_id,\n                claimWithFault: false,\n                claimSeverity: 0,\n              }),\n            ).pipe(ignoreElements()),\n          );\n          this.logger.info(`Driver class updated for clean booking ${booking.id}`);\n        } catch (classError) {\n          // No fallar la finalización si la actualización de clase falla\n          this.logger.error(\n            'Failed to update driver class',\n            'BookingCompletionService',\n            classError instanceof Error ? classError : new Error(getErrorMessage(classError)),\n          );\n        }\n      }\n\n      return { success: true };\n    } catch (err) {\n      return {\n        success: false,\n        error: err instanceof Error ? err.message : 'Error al completar reserva sin daños',\n      };\n    }\n  }\n\n  /**\n   * Complete booking with damages\n   * This will:\n   * 1. Deduct damage amount from security deposit\n   * 2. Update driver class (worsen for claim with fault)\n   */\n  async completeBookingWithDamages(\n    booking: Booking,\n    totalChargesCents: number, // Ahora representa cargos totales (daños + combustible + multas)\n    description: string, // Descripción consolidada de los cargos\n    claimSeverity: number = 0, // 1=minor, 2=moderate, 3=major (0 si solo combustible/multa)\n    onUpdateBooking: (bookingId: string, updates: Partial<Booking>) => Promise<Booking>,\n  ): Promise<{ success: boolean; remaining_deposit?: number; error?: string }> {\n    try {\n      let remainingDepositCents: number | undefined;\n\n      // 1. Deducir de la garantía (MP Pre-Auth o Wallet)\n      if (booking.payment_method === 'credit_card' && booking.mp_security_deposit_order_id) {\n        // Capturar monto de la pre-autorización de MercadoPago\n        await this.paymentsService.captureMpPreAuth(\n          booking.mp_security_deposit_order_id,\n          totalChargesCents,\n          description,\n        );\n        // Suponemos que MP libera el resto automáticamente si la captura es parcial\n        remainingDepositCents = 0; // O la diferencia si se puede obtener de MP\n        await onUpdateBooking(booking.id, {\n          deposit_status: 'charged', // Marcar como cargado\n        });\n      } else if (booking.wallet_status === 'locked') {\n        // Deducir de Wallet\n        const deductResult = await this.bookingWalletService.deductFromSecurityDeposit(\n          booking,\n          totalChargesCents,\n          description,\n        );\n\n        if (!deductResult.ok) {\n          return {\n            success: false,\n            error: deductResult.error,\n          };\n        }\n        remainingDepositCents = deductResult.remaining_deposit ?? 0;\n        await onUpdateBooking(booking.id, {\n          wallet_status: remainingDepositCents > 0 ? 'partially_charged' : 'charged',\n        });\n      } else {\n        return { success: false, error: 'Método de depósito no soportado o no bloqueado' };\n      }\n\n      // 2. Marcar reserva como completada\n      await onUpdateBooking(booking.id, {\n        status: 'completed',\n      });\n\n      // 3. Actualizar clase del conductor (si hubo daños)\n      if (booking.user_id && claimSeverity > 0) {\n        try {\n          await firstValueFrom(\n            from(\n              this.driverProfileService.updateClassOnEvent({\n                eventType: 'booking_completed',\n                userId: booking.user_id,\n                claimWithFault: true,\n                claimSeverity: claimSeverity,\n              }),\n            ).pipe(ignoreElements()),\n          );\n          this.logger.info(`Driver class updated for claim on booking ${booking.id}`);\n        } catch (classError) {\n          // No fallar la finalización si la actualización de clase falla\n          this.logger.error(\n            'Failed to update driver class',\n            'BookingCompletionService',\n            classError instanceof Error ? classError : new Error(getErrorMessage(classError)),\n          );\n        }\n      }\n\n      return {\n        success: true,\n        remaining_deposit: remainingDepositCents,\n      };\n    } catch (err) {\n      return {\n        success: false,\n        error: err instanceof Error ? err.message : 'Error al completar reserva con cargos',\n      };\n    }\n  }\n\n  /**\n   * Check-out Inteligente (Smart Checkout)\n   * Procesa el cierre de reserva considerando:\n   * - Diferencia de combustible\n   * - Daños reportados\n   * - Multas tardías (TODO: mecanismo de retención parcial)\n   */\n  async finishBookingWithInspection(\n    booking: Booking,\n    inspectionData: {\n      fuelDifferenceCents: number;\n      damageAmountCents: number;\n      damageDescription?: string;\n      lateFeesCents?: number;\n    },\n    onUpdateBooking: (bookingId: string, updates: Partial<Booking>) => Promise<Booking>,\n  ): Promise<{ success: boolean; remaining_deposit?: number; error?: string }> {\n    const totalCharges =\n      (inspectionData.fuelDifferenceCents || 0) +\n      (inspectionData.damageAmountCents || 0) +\n      (inspectionData.lateFeesCents || 0);\n\n    // Caso 1: Cierre limpio (sin cargos extra)\n    if (totalCharges === 0) {\n      return this.completeBookingClean(booking, onUpdateBooking);\n    }\n\n    // Caso 2: Con cargos - Marcar como pendiente de resolución de disputa\n    const descriptionParts = [];\n    if (inspectionData.fuelDifferenceCents > 0) {\n      descriptionParts.push(\n        `Combustible: $${(inspectionData.fuelDifferenceCents / 100).toFixed(2)}`,\n      );\n    }\n    if (inspectionData.damageAmountCents > 0) {\n      descriptionParts.push(`Daños: $${(inspectionData.damageAmountCents / 100).toFixed(2)}`);\n    }\n    if (inspectionData.lateFeesCents && inspectionData.lateFeesCents > 0) {\n      descriptionParts.push(`Recargos: $${(inspectionData.lateFeesCents / 100).toFixed(2)}`);\n    }\n\n    const description = `Cargos al cierre: ${descriptionParts.join(', ')}`;\n\n    // Actualizar la reserva para reflejar los cargos pendientes de disputa\n    await onUpdateBooking(booking.id, {\n      status: 'pending_dispute_resolution', // Nuevo estado\n      dispute_open_at: new Date().toISOString(),\n      owner_damage_amount: inspectionData.damageAmountCents,\n      owner_damage_description: inspectionData.damageDescription,\n      // Almacenar otros cargos en metadata si no hay columnas dedicadas\n      metadata: {\n        ...(booking.metadata || {}),\n        pending_fuel_charge: inspectionData.fuelDifferenceCents,\n        pending_late_fee_charge: inspectionData.lateFeesCents,\n        total_pending_charges_cents: totalCharges,\n      },\n      // La deducción/captura real se hará después de la resolución de la disputa\n    });\n\n    this.logger.info(\n      `Booking ${booking.id} marked as pending_dispute_resolution with charges.`,\n      'BookingCompletionService',\n      {\n        totalCharges,\n        description,\n      },\n    );\n\n    return {\n      success: true,\n      error: 'Cargos reportados. Pendiente de resolución de disputa.',\n      remaining_deposit: booking.deposit_amount_cents || 0, // El depósito sigue retenido\n    };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/core/services/bookings/booking-flow-logger.service.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`@core/services/infrastructure/logger.service` import should occur before type import of `../models`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":78,"fix":{"range":[52,178],"text":"import { LoggerService } from '@core/services/infrastructure/logger.service';\nimport type { BookingStatus } from '../models';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { Injectable, inject } from '@angular/core';\nimport type { BookingStatus } from '../models';\nimport { LoggerService } from '@core/services/infrastructure/logger.service';\n\n/**\n * BookingFlowLoggerService\n *\n * Servicio especializado para logging del flujo de booking.\n * Centraliza el logging para facilitar debugging y monitoreo.\n */\n@Injectable({\n  providedIn: 'root',\n})\nexport class BookingFlowLoggerService {\n  private readonly logger = inject(LoggerService);\n  // import.meta.env may not have type definitions in this TS config used by the Angular\n  // template/type checker plugin. Cast to unknown to avoid \"Property 'env' does not exist on type 'ImportMeta'\".\n  private readonly isDevelopment = !(import.meta as unknown as { env?: { PROD?: boolean } }).env\n    ?.PROD;\n\n  /**\n   * Log de transición de estado\n   */\n  logStatusTransition(\n    bookingId: string,\n    from: BookingStatus,\n    to: BookingStatus,\n    userId: string,\n    metadata?: Record<string, unknown>,\n  ): void {\n    if (!this.isDevelopment) return;\n\n    console.group(`🔄 Booking Status Transition: ${bookingId}`);\n    this.logger.debug('From:', from);\n    this.logger.debug('To:', to);\n    this.logger.debug('User:', userId);\n    if (metadata) {\n      this.logger.debug('Metadata:', metadata);\n    }\n    console.groupEnd();\n  }\n\n  /**\n   * Log de acción realizada\n   */\n  logAction(\n    bookingId: string,\n    action: string,\n    userId: string,\n    success: boolean,\n    error?: string,\n  ): void {\n    if (!this.isDevelopment) return;\n\n    const emoji = success ? '✅' : '❌';\n    this.logger.debug(`${emoji} Booking Action: ${action}`, {\n      bookingId,\n      userId,\n      success,\n      error,\n    });\n  }\n\n  /**\n   * Log de validación\n   */\n  logValidation(bookingId: string, validation: string, passed: boolean, reason?: string): void {\n    if (!this.isDevelopment) return;\n\n    const emoji = passed ? '✅' : '⚠️';\n    this.logger.debug(`${emoji} Validation: ${validation}`, {\n      bookingId,\n      passed,\n      reason,\n    });\n  }\n\n  /**\n   * Log de error en el flujo\n   */\n  logError(\n    bookingId: string,\n    context: string,\n    error: Error | unknown,\n    metadata?: Record<string, unknown>,\n  ): void {\n    console.error(`❌ Booking Flow Error [${context}]:`, {\n      bookingId,\n      error: error instanceof Error ? error.message : String(error),\n      stack: error instanceof Error ? error.stack : undefined,\n      metadata,\n    });\n  }\n\n  /**\n   * Log de métricas de performance\n   */\n  logPerformance(\n    bookingId: string,\n    operation: string,\n    duration: number,\n    metadata?: Record<string, unknown>,\n  ): void {\n    if (!this.isDevelopment) return;\n\n    this.logger.debug(`⏱️ Performance [${operation}]:`, {\n      bookingId,\n      duration: `${duration}ms`,\n      metadata,\n    });\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/core/services/bookings/booking-flow.service.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`@core/services/auth/auth.service` import should occur before type import of `../models`","line":4,"column":1,"nodeType":"ImportDeclaration","endLine":4,"endColumn":64,"fix":{"range":[94,215],"text":"import { AuthService } from '@core/services/auth/auth.service';\nimport type { Booking, BookingStatus } from '../models';\n"}},{"ruleId":"import/order","severity":1,"message":"`@core/services/verification/fgo-v1-1.service` import should occur before type import of `../models`","line":9,"column":1,"nodeType":"ImportDeclaration","endLine":9,"endColumn":79,"fix":{"range":[94,570],"text":"import { FgoV1_1Service } from '@core/services/verification/fgo-v1-1.service';\nimport type { Booking, BookingStatus } from '../models';\nimport { AuthService } from '@core/services/auth/auth.service';\nimport { BookingConfirmationService } from './booking-confirmation.service';\nimport { isValidStatusTransition } from './booking-flow-helpers';\nimport { BookingNotificationsService } from './booking-notifications.service';\nimport { BookingsService } from './bookings.service';\n"}},{"ruleId":"import/order","severity":1,"message":"`@core/services/cars/reviews.service` import should occur before type import of `../models`","line":10,"column":1,"nodeType":"ImportDeclaration","endLine":10,"endColumn":70,"fix":{"range":[94,640],"text":"import { ReviewsService } from '@core/services/cars/reviews.service';\nimport type { Booking, BookingStatus } from '../models';\nimport { AuthService } from '@core/services/auth/auth.service';\nimport { BookingConfirmationService } from './booking-confirmation.service';\nimport { isValidStatusTransition } from './booking-flow-helpers';\nimport { BookingNotificationsService } from './booking-notifications.service';\nimport { BookingsService } from './bookings.service';\nimport { FgoV1_1Service } from '@core/services/verification/fgo-v1-1.service';\n"}},{"ruleId":"import/order","severity":1,"message":"`@core/services/infrastructure/user-notifications.service` import should occur before type import of `../models`","line":11,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":97,"fix":{"range":[94,737],"text":"import { NotificationsService } from '@core/services/infrastructure/user-notifications.service';\nimport type { Booking, BookingStatus } from '../models';\nimport { AuthService } from '@core/services/auth/auth.service';\nimport { BookingConfirmationService } from './booking-confirmation.service';\nimport { isValidStatusTransition } from './booking-flow-helpers';\nimport { BookingNotificationsService } from './booking-notifications.service';\nimport { BookingsService } from './bookings.service';\nimport { FgoV1_1Service } from '@core/services/verification/fgo-v1-1.service';\nimport { ReviewsService } from '@core/services/cars/reviews.service';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":4,"source":"import { Injectable, inject } from '@angular/core';\nimport { Router } from '@angular/router';\nimport type { Booking, BookingStatus } from '../models';\nimport { AuthService } from '@core/services/auth/auth.service';\nimport { BookingConfirmationService } from './booking-confirmation.service';\nimport { isValidStatusTransition } from './booking-flow-helpers';\nimport { BookingNotificationsService } from './booking-notifications.service';\nimport { BookingsService } from './bookings.service';\nimport { FgoV1_1Service } from '@core/services/verification/fgo-v1-1.service';\nimport { ReviewsService } from '@core/services/cars/reviews.service';\nimport { NotificationsService } from '@core/services/infrastructure/user-notifications.service';\n\n/**\n * BookingFlowService\n *\n * Servicio centralizado que coordina el flujo completo de contratación:\n * - Transiciones de estado\n * - Check-in y Check-out\n * - Notificaciones automáticas\n * - Navegación contextual\n * - Validaciones de flujo\n *\n * @example\n * ```typescript\n * // En un componente\n * constructor(private bookingFlow: BookingFlowService) {}\n *\n * async onApproveBooking(bookingId: string) {\n *   await this.bookingFlow.approveBooking(bookingId);\n * }\n * ```\n */\n@Injectable({\n  providedIn: 'root',\n})\nexport class BookingFlowService {\n  private readonly bookingsService = inject(BookingsService);\n  private readonly fgoService = inject(FgoV1_1Service);\n  private readonly confirmationService = inject(BookingConfirmationService);\n  private readonly reviewsService = inject(ReviewsService);\n  private readonly notificationsService = inject(NotificationsService);\n  private readonly bookingNotifications = inject(BookingNotificationsService);\n  private readonly authService = inject(AuthService);\n  private readonly router = inject(Router);\n\n  /**\n   * Obtiene las acciones disponibles para un booking según su estado y el rol del usuario\n   */\n  async getAvailableActions(\n    booking: Booking,\n    _userRole: 'owner' | 'renter' | 'both',\n  ): Promise<BookingAction[]> {\n    const actions: BookingAction[] = [];\n    const status = booking.status;\n    const currentUserId = this.authService.session$()?.user?.id;\n\n    if (!currentUserId) return actions;\n\n    const isOwner = booking.owner_id === currentUserId;\n    const isRenter = booking.renter_id === currentUserId;\n\n    // FASE 1: PENDING - Esperando aprobación\n    if (status === 'pending') {\n      if (isOwner) {\n        actions.push({\n          label: 'Aprobar Reserva',\n          action: 'approve',\n          route: `/bookings/owner/${booking.id}`,\n          variant: 'primary',\n          icon: 'checkmark-circle',\n        });\n        actions.push({\n          label: 'Rechazar',\n          action: 'reject',\n          route: `/bookings/owner/${booking.id}`,\n          variant: 'danger',\n          icon: 'close-circle',\n        });\n      }\n      if (isRenter) {\n        actions.push({\n          label: 'Completar Pago',\n          action: 'pay',\n          route: `/bookings/${booking.id}/detail-payment`,\n          variant: 'primary',\n          icon: 'card',\n        });\n        actions.push({\n          label: 'Cancelar Solicitud',\n          action: 'cancel',\n          route: `/bookings/${booking.id}`,\n          variant: 'secondary',\n          icon: 'close',\n        });\n      }\n    }\n\n    // FASE 2: CONFIRMED - Pago completado, listo para check-in\n    if (status === 'confirmed') {\n      if (isOwner) {\n        actions.push({\n          label: 'Realizar Check-In',\n          action: 'owner-check-in',\n          route: `/bookings/${booking.id}/owner-check-in`,\n          variant: 'primary',\n          icon: 'checkmark-done',\n          description: 'Inspección pre-entrega del vehículo',\n        });\n      }\n      if (isRenter) {\n        actions.push({\n          label: 'Ver Detalles',\n          action: 'view',\n          route: `/bookings/${booking.id}`,\n          variant: 'secondary',\n          icon: 'eye',\n        });\n      }\n    }\n\n    // FASE 3: IN_PROGRESS - Alquiler activo\n    if (status === 'in_progress') {\n      if (isRenter) {\n        actions.push({\n          label: 'Realizar Check-Out',\n          action: 'renter-check-out',\n          route: `/bookings/${booking.id}/check-out`,\n          variant: 'primary',\n          icon: 'log-out',\n          description: 'Devolución del vehículo',\n        });\n      }\n      if (isOwner) {\n        actions.push({\n          label: 'Ver Ubicación',\n          action: 'track',\n          route: `/bookings/${booking.id}`,\n          variant: 'secondary',\n          icon: 'location',\n        });\n      }\n    }\n\n    // FASE 4: COMPLETED - Finalizado, disponible para reseñas\n    if (status === 'completed') {\n      const canReview = await this.canLeaveReview(booking, currentUserId);\n      if (canReview.canReview) {\n        actions.push({\n          label: 'Dejar Reseña',\n          action: 'review',\n          route: `/bookings/${booking.id}`,\n          variant: 'primary',\n          icon: 'star',\n          description: canReview.description,\n        });\n      }\n    }\n\n    return actions;\n  }\n\n  /**\n   * Verifica si el usuario puede dejar una reseña\n   * Comprueba:\n   * 1. Estado del booking es 'completed'\n   * 2. Está dentro de la ventana de 14 días\n   * 3. El usuario no ha dejado una reseña ya (via ReviewsService)\n   */\n  private async canLeaveReview(\n    booking: Booking,\n    _userId: string,\n  ): Promise<{\n    canReview: boolean;\n    description?: string;\n  }> {\n    if (booking.status !== 'completed') {\n      return { canReview: false };\n    }\n\n    // Verificar ventana de 14 días\n    const completedDate = booking.updated_at ? new Date(booking.updated_at) : null;\n    if (!completedDate) {\n      return { canReview: false };\n    }\n\n    const daysSinceCompleted = Math.floor(\n      (Date.now() - completedDate.getTime()) / (1000 * 60 * 60 * 24),\n    );\n    if (daysSinceCompleted > 14) {\n      return {\n        canReview: false,\n        description: 'Período de reseñas expirado (14 días)',\n      };\n    }\n\n    // Verificar con ReviewsService si el usuario ya dejó reseña\n    try {\n      const canReviewAccordingToService = await this.reviewsService.canReviewBooking(booking.id);\n      if (!canReviewAccordingToService) {\n        return {\n          canReview: false,\n          description: 'Ya has dejado tu reseña para esta reserva',\n        };\n      }\n    } catch (error) {\n      // Si hay error en la verificación, permitir ver la acción pero dejar que el servicio maneje el error al guardar\n      console.warn('Error checking review status:', error);\n    }\n\n    return {\n      canReview: true,\n      description: `Tienes ${14 - daysSinceCompleted} días restantes para dejar tu reseña`,\n    };\n  }\n\n  /**\n   * Obtiene el siguiente paso recomendado en el flujo\n   */\n  async getNextStep(booking: Booking, _userRole: 'owner' | 'renter'): Promise<NextStep | null> {\n    const status = booking.status;\n    const currentUserId = this.authService.session$()?.user?.id;\n    if (!currentUserId) return null;\n\n    const isOwner = booking.owner_id === currentUserId;\n    const isRenter = booking.renter_id === currentUserId;\n\n    // Flujo del Locador\n    if (isOwner) {\n      if (status === 'pending') {\n        return {\n          title: 'Revisar Solicitud',\n          description: 'Un locatario quiere alquilar tu auto. Revisa y aprueba la solicitud.',\n          action: 'Aprobar o Rechazar',\n          route: `/bookings/owner/${booking.id}`,\n          priority: 'high',\n        };\n      }\n      if (status === 'confirmed') {\n        return {\n          title: 'Realizar Check-In',\n          description: 'Inspecciona el vehículo antes de entregarlo al locatario.',\n          action: 'Iniciar Check-In',\n          route: `/bookings/${booking.id}/owner-check-in`,\n          priority: 'high',\n        };\n      }\n      if (status === 'in_progress') {\n        return {\n          title: 'Esperando Devolución',\n          description: 'El locatario está usando el vehículo. Prepárate para el check-out.',\n          action: 'Ver Detalles',\n          route: `/bookings/owner/${booking.id}`,\n          priority: 'medium',\n        };\n      }\n      if (status === 'completed') {\n        const canReview = await this.canLeaveReview(booking, currentUserId);\n        if (canReview.canReview) {\n          return {\n            title: 'Dejar Reseña',\n            description: 'Califica tu experiencia con el locatario.',\n            action: 'Escribir Reseña',\n            route: `/bookings/owner/${booking.id}`,\n            priority: 'low',\n          };\n        }\n      }\n    }\n\n    // Flujo del Locatario\n    if (isRenter) {\n      if (status === 'pending') {\n        return {\n          title: 'Completar Pago',\n          description:\n            'Tu solicitud está pendiente de aprobación. Completa el pago cuando sea aprobada.',\n          action: 'Ver Estado',\n          route: `/bookings/${booking.id}`,\n          priority: 'medium',\n        };\n      }\n      if (status === 'confirmed') {\n        return {\n          title: 'Esperando entrega',\n          description:\n            'El locador realizará el check-in. Luego podrás documentar la recepción del vehículo.',\n          action: 'Ver Detalles',\n          route: `/bookings/${booking.id}`,\n          priority: 'medium',\n        };\n      }\n      if (status === 'in_progress') {\n        return {\n          title: 'Realizar Check-Out',\n          description: 'Cuando devuelvas el vehículo, completa el check-out.',\n          action: 'Iniciar Check-Out',\n          route: `/bookings/${booking.id}/check-out`,\n          priority: 'high',\n        };\n      }\n      if (status === 'completed') {\n        const canReview = await this.canLeaveReview(booking, currentUserId);\n        if (canReview.canReview) {\n          return {\n            title: 'Dejar Reseña',\n            description: 'Califica tu experiencia con el locador y el vehículo.',\n            action: 'Escribir Reseña',\n            route: `/bookings/${booking.id}`,\n            priority: 'low',\n          };\n        }\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Navega al siguiente paso del flujo\n   */\n  async navigateToNextStep(booking: Booking): Promise<void> {\n    // Prefer synchronous session; fall back to async call to ensure session is restored\n    const session = this.authService.session$();\n    let currentUserId = session?.user?.id;\n    if (!currentUserId) {\n      const currentUser = await this.authService.getCurrentUser();\n      if (!currentUser) {\n        await this.router.navigate(['/auth/login']);\n        return;\n      }\n      currentUserId = currentUser.id;\n    }\n\n    const userRole = this.getUserRole(booking, currentUserId);\n    const nextStep = await this.getNextStep(booking, userRole);\n    if (nextStep) {\n      await this.router.navigate([nextStep.route]);\n    } else {\n      // Fallback: go to booking detail\n      await this.router.navigate(['/bookings', booking.id]);\n    }\n  }\n\n  /**\n   * Determina el rol del usuario en relación al booking\n   */\n  private getUserRole(booking: Booking, userId: string): 'owner' | 'renter' {\n    if (booking.owner_id === userId) return 'owner';\n    if (booking.renter_id === userId) return 'renter';\n    throw new Error('User is not part of this booking');\n  }\n\n  /**\n   * Obtiene el estado visual del booking para mostrar en UI\n   */\n  getBookingStatusInfo(booking: Booking): BookingStatusInfo {\n    const status = booking.status;\n    const statusMap: Record<BookingStatus, BookingStatusInfo> = {\n      pending: {\n        label: 'Pendiente',\n        color: 'warning',\n        icon: 'time-outline',\n        description: 'Esperando aprobación del dueño',\n      },\n      confirmed: {\n        label: 'Confirmada',\n        color: 'success',\n        icon: 'checkmark-circle-outline',\n        description: '¡Todo listo! Coordiná la entrega con el dueño',\n      },\n      in_progress: {\n        label: 'En curso',\n        color: 'primary',\n        icon: 'car-sport-outline',\n        description: 'Disfrutá tu viaje',\n      },\n      completed: {\n        label: 'Completada',\n        color: 'success',\n        icon: 'flag-outline',\n        description: 'El alquiler finalizó correctamente',\n      },\n      cancelled: {\n        label: 'Cancelada',\n        color: 'danger',\n        icon: 'close-circle-outline',\n        description: 'La reserva fue cancelada',\n      },\n      expired: {\n        label: 'Expirada',\n        color: 'medium',\n        icon: 'hourglass-outline',\n        description: 'La solicitud expiró',\n      },\n      no_show: {\n        label: 'No show',\n        color: 'danger',\n        icon: 'alert-circle-outline',\n        description: 'El conductor no se presentó',\n      },\n      pending_payment: {\n        label: 'Pago pendiente',\n        color: 'warning',\n        icon: 'card-outline',\n        description: 'Esperando el pago para confirmar',\n      },\n      rejected: {\n        label: 'Rechazada',\n        color: 'danger',\n        icon: 'close-circle-outline',\n        description: 'La solicitud fue rechazada',\n      },\n      pending_dispute_resolution: {\n        label: 'En disputa',\n        color: 'danger',\n        icon: 'alert-circle-outline',\n        description: 'El equipo de soporte está revisando el caso',\n      },\n      pending_review: {\n        label: 'En Revisión Final',\n        color: 'warning',\n        icon: 'search-outline',\n        description: 'Esperando confirmación post-alquiler o reporte de incidentes',\n      },\n      disputed: {\n        label: 'En Disputa',\n        color: 'danger',\n        icon: 'hammer-outline',\n        description: 'Hay una disputa activa. Caso en revisión.',\n      },\n      resolved: {\n        label: 'Disputa Resuelta',\n        color: 'success',\n        icon: 'checkmark-circle-outline',\n        description: 'Disputa resuelta. Fondos en proceso de liberación.',\n      },\n      cancelled_renter: {\n        label: 'Cancelada por Locatario',\n        color: 'danger',\n        icon: 'close-circle-outline',\n        description: 'La reserva fue cancelada por el locatario',\n      },\n      cancelled_owner: {\n        label: 'Cancelada por Anfitrión',\n        color: 'danger',\n        icon: 'close-circle-outline',\n        description: 'La reserva fue cancelada por el anfitrión',\n      },\n      cancelled_system: {\n        label: 'Cancelada por Sistema',\n        color: 'danger',\n        icon: 'alert-circle-outline',\n        description: 'La reserva fue cancelada automáticamente por el sistema',\n      },\n    };\n\n    return (\n      statusMap[status] || {\n        label: status,\n        color: 'medium',\n        icon: 'help-circle',\n        description: '',\n      }\n    );\n  }\n\n  /**\n   * Valida si una transición desde el estado actual del booking hacia el target es permitida.\n   * Esta función es una pequeña envoltura usada por guards y componentes que esperan\n   * recibir un objeto con la forma { valid: boolean; error?: string }\n   */\n  validateStatusTransition(\n    booking: Booking,\n    target: BookingStatus,\n  ): { valid: boolean; error?: string } {\n    const result = isValidStatusTransition(booking.status, target);\n    return { valid: result.valid, error: result.reason };\n  }\n}\n\n/**\n * Interfaz para acciones disponibles en un booking\n */\nexport interface BookingAction {\n  label: string;\n  action: string;\n  route: string;\n  variant: 'primary' | 'secondary' | 'danger' | 'success';\n  icon: string;\n  description?: string;\n}\n\n/**\n * Interfaz para el siguiente paso en el flujo\n */\nexport interface NextStep {\n  title: string;\n  description: string;\n  action: string;\n  route: string;\n  priority: 'high' | 'medium' | 'low';\n}\n\n/**\n * Información del estado del booking para UI\n */\nexport interface BookingStatusInfo {\n  label: string;\n  color: 'primary' | 'success' | 'warning' | 'danger' | 'medium';\n  icon: string;\n  description: string;\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/core/services/bookings/booking-initiation.service.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`@core/services/auth/auth.service` import should occur before import of `../../features/bookings/components/booking-location-form/booking-location-form.component`","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":64,"fix":{"range":[160,389],"text":"import { AuthService } from '@core/services/auth/auth.service';\nimport { BookingLocationData } from '../../features/bookings/components/booking-location-form/booking-location-form.component';\nimport { Booking } from '../models';\n"}},{"ruleId":"import/order","severity":1,"message":"`@core/services/cars/cars.service` import should occur before import of `../../features/bookings/components/booking-location-form/booking-location-form.component`","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":8,"endColumn":64,"fix":{"range":[160,507],"text":"import { CarsService } from '@core/services/cars/cars.service';\nimport { BookingLocationData } from '../../features/bookings/components/booking-location-form/booking-location-form.component';\nimport { Booking } from '../models';\nimport { AuthService } from '@core/services/auth/auth.service';\nimport { BookingsService } from './bookings.service';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import { isPlatformBrowser } from '@angular/common';\nimport { Injectable, inject, PLATFORM_ID } from '@angular/core';\nimport { Router } from '@angular/router';\nimport { BookingLocationData } from '../../features/bookings/components/booking-location-form/booking-location-form.component';\nimport { Booking } from '../models';\nimport { AuthService } from '@core/services/auth/auth.service';\nimport { BookingsService } from './bookings.service';\nimport { CarsService } from '@core/services/cars/cars.service';\n\n/**\n * Fachada ligera para centralizar el inicio de una reserva desde la UI.\n * No pretende duplicar la lógica de negocio (esa queda en BookingsService),\n * sino ofrecer un único punto para: auth-check, revalidación de disponibilidad\n * y llamada a creación de reserva con una API consistente para la UI.\n */\n@Injectable({ providedIn: 'root' })\nexport class BookingInitiationService {\n  private readonly auth = inject(AuthService);\n  private readonly bookings = inject(BookingsService);\n  private readonly cars = inject(CarsService);\n  private readonly router = inject(Router);\n  private readonly platformId = inject(PLATFORM_ID);\n  private readonly isBrowser = isPlatformBrowser(this.platformId);\n\n  private inProgress = false;\n\n  /**\n   * Inicia una reserva desde la vista de detalle del auto.\n   * Retorna el mismo shape que createBookingWithValidation para mínima fricción.\n   */\n  async startFromCar(\n    carId: string,\n    startDate: string,\n    endDate: string,\n    locationData?: BookingLocationData,\n  ): Promise<{ success: boolean; booking?: Booking; error?: string; canWaitlist?: boolean }> {\n    if (this.inProgress) return { success: false, error: 'in_progress' };\n    this.inProgress = true;\n\n    try {\n      // Auth check - redirigir si no autenticado\n      const isAuth = await this.auth.isAuthenticated();\n      if (!isAuth) {\n        // Guardar intento breve para UX (opcional)\n        if (this.isBrowser) {\n          sessionStorage.setItem(\n            'booking_intent',\n            JSON.stringify({ carId, startDate, endDate, locationData }),\n          );\n        }\n        await this.router.navigate(['/auth/login'], {\n          queryParams: { returnUrl: this.router.url },\n        });\n        return { success: false, error: 'not_authenticated' };\n      }\n\n      // Revalidar disponibilidad (best-effort)\n      try {\n        const available = await this.cars.isCarAvailable(carId, startDate, endDate);\n        if (!available) {\n          // Intentar sugerencias / waitlist no lo hacemos aquí para mantener API simple\n          return { success: false, error: 'not_available', canWaitlist: true };\n        }\n      } catch (err) {\n        // Si falla la revalidación, no bloqueamos el flujo; dejamos que BookingsService valide\n        console.warn('[BookingInitiation] Availability check failed, continuing', err);\n      }\n\n      // Delegar la creación validada a BookingsService\n      const result = await this.bookings.createBookingWithValidation(\n        carId,\n        startDate,\n        endDate,\n        locationData,\n      );\n\n      return result;\n    } catch (err: unknown) {\n      return { success: false, error: err instanceof Error ? err.message : String(err) };\n    } finally {\n      this.inProgress = false;\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/core/services/bookings/booking-logic.test.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`../types/supabase-types` type import should occur after import of `@core/services/payments/wallet.service`","line":2,"column":1,"nodeType":"ImportDeclaration","endLine":2,"endColumn":56,"fix":{"range":[49,420],"text":"import { BookingsService } from '@core/services/bookings/bookings.service';\nimport { SupabaseClientService } from '@core/services/infrastructure/supabase-client.service';\nimport { PwaService } from '@core/services/infrastructure/pwa.service';\nimport { WalletService } from '@core/services/payments/wallet.service';\nimport type { Booking } from '../types/supabase-types';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { TestBed } from '@angular/core/testing';\nimport type { Booking } from '../types/supabase-types';\nimport { BookingsService } from '@core/services/bookings/bookings.service';\nimport { SupabaseClientService } from '@core/services/infrastructure/supabase-client.service';\nimport { PwaService } from '@core/services/infrastructure/pwa.service';\nimport { WalletService } from '@core/services/payments/wallet.service';\n\ndescribe('Booking Logic Integration', () => {\n  let service: BookingsService;\n  let supabase: any;\n  let pwaService: jasmine.SpyObj<PwaService>;\n  let walletService: jasmine.SpyObj<WalletService>;\n\n  beforeEach(() => {\n    supabase = {\n      rpc: jasmine.createSpy('rpc'),\n      auth: jasmine.createSpyObj('auth', ['getUser']),\n      from: jasmine.createSpy('from'),\n    };\n    pwaService = jasmine.createSpyObj<PwaService>('PwaService', ['setAppBadge', 'clearAppBadge']);\n    walletService = jasmine.createSpyObj<WalletService>('WalletService', [\n      'unlockFunds',\n      'lockFunds',\n    ]);\n\n    TestBed.configureTestingModule({\n      providers: [\n        BookingsService,\n        {\n          provide: SupabaseClientService,\n          useValue: { getClient: () => supabase },\n        },\n        { provide: PwaService, useValue: pwaService },\n        { provide: WalletService, useValue: walletService },\n      ],\n    });\n\n    service = TestBed.inject(BookingsService);\n  });\n\n  it('should be created', () => {\n    expect(service).toBeTruthy();\n  });\n\n  describe('createBookingWithValidation', () => {\n    const carId = 'test-car-id';\n    const startDate = '2025-12-01T10:00:00Z';\n    const endDate = '2025-12-05T10:00:00Z';\n\n    it('should create a booking when the car is available', async () => {\n      const newBookingId = 'new-booking-123';\n      const mockBooking: Booking = {\n        id: newBookingId,\n        car_id: carId,\n        status: 'pending',\n        user_id: 'test-user-id',\n        renter_id: 'test-user-id',\n        start_at: startDate,\n        end_at: endDate,\n        total_amount: 1000,\n        currency: 'ARS',\n        created_at: new Date().toISOString(),\n      } as unknown as Booking;\n\n      // Mock RPC calls\n      supabase.rpc.and.callFake(async (method: string, params: unknown) => {\n        if (method === 'is_car_available') {\n          return { data: true, error: null };\n        }\n        if (method === 'request_booking') {\n          return { data: { id: newBookingId }, error: null };\n        }\n        if (method === 'pricing_recalculate') {\n          return { data: null, error: null };\n        }\n        return { data: null, error: new Error(`Unknown RPC: ${method}`) };\n      });\n\n      // Mock getBookingById which is called after creation\n      const _fromSpy = supabase.from.and.returnValue({\n        select: (columns: string) => ({\n          eq: (column: string, value: unknown) => ({\n            single: async () => ({ data: mockBooking, error: null }),\n          }),\n        }),\n      } as any);\n\n      const result = await service.createBookingWithValidation(carId, startDate, endDate);\n\n      expect(result.success).toBe(true);\n      expect(result.booking?.id).toBe(mockBooking.id);\n      expect(result.booking?.car_id).toBe(mockBooking.car_id);\n      expect(result.booking?.status).toBe(mockBooking.status);\n      expect(supabase.rpc).toHaveBeenCalledWith('is_car_available', {\n        p_car_id: carId,\n        p_start_date: startDate,\n        p_end_date: endDate,\n      });\n      expect(supabase.rpc).toHaveBeenCalledWith('request_booking', {\n        p_car_id: carId,\n        p_start: startDate,\n        p_end: endDate,\n      });\n    });\n\n    it('should not create a booking when the car is unavailable', async () => {\n      // Mock is_car_available to return false\n      supabase.rpc\n        .withArgs('is_car_available', jasmine.any(Object))\n        .and.resolveTo({ data: false, error: null });\n\n      const result = await service.createBookingWithValidation(carId, startDate, endDate);\n\n      expect(result.success).toBe(false);\n      expect(result.error).toBe(\n        'El auto no está disponible para esas fechas. Por favor elige otras fechas.',\n      );\n      expect(result.booking).toBeUndefined();\n\n      // Verify that request_booking was not called\n      expect(supabase.rpc).not.toHaveBeenCalledWith('request_booking', jasmine.any(Object));\n    });\n\n    it('should return an error if start date is not before end date', async () => {\n      const invalidEndDate = '2025-11-30T10:00:00Z'; // Before start date\n      const result = await service.createBookingWithValidation(carId, startDate, invalidEndDate);\n\n      expect(result.success).toBe(false);\n      expect(result.error).toBe('La fecha de inicio debe ser anterior a la fecha de fin');\n      expect(supabase.rpc).not.toHaveBeenCalled();\n    });\n\n    it('debería verificar correctamente la disponibilidad de un coche', async () => {\n      const newBookingId = 'new-booking-456';\n      const mockBooking: Booking = {\n        id: newBookingId,\n        car_id: carId,\n        status: 'pending',\n        user_id: 'test-user-id',\n        renter_id: 'test-user-id',\n        start_at: '2026-01-01T10:00:00Z',\n        end_at: '2026-01-05T10:00:00Z',\n        total_amount: 1000,\n        currency: 'ARS',\n        created_at: new Date().toISOString(),\n      } as unknown as Booking;\n\n      supabase.rpc.and.callFake(async (method: string, params: unknown) => {\n        if (method === 'is_car_available') {\n          return { data: true, error: null };\n        }\n        if (method === 'request_booking') {\n          return { data: { id: newBookingId }, error: null };\n        }\n        if (method === 'pricing_recalculate') {\n          return { data: null, error: null };\n        }\n        return { data: null, error: new Error(`Unknown RPC: ${method}`) };\n      });\n\n      const _fromSpy = supabase.from.and.returnValue({\n        select: (columns: string) => ({\n          eq: (column: string, value: unknown) => ({\n            single: async () => ({ data: mockBooking, error: null }),\n          }),\n        }),\n      } as any);\n\n      const result = await service.createBookingWithValidation(\n        carId,\n        '2026-01-01T10:00:00Z',\n        '2026-01-05T10:00:00Z',\n      );\n\n      expect(result.success).toBe(true);\n      expect(supabase.rpc).toHaveBeenCalledWith('is_car_available', {\n        p_car_id: carId,\n        p_start_date: '2026-01-01T10:00:00Z',\n        p_end_date: '2026-01-05T10:00:00Z',\n      });\n    });\n\n    it('no debería permitir crear una reserva duplicada', async () => {\n      const firstBookingId = 'booking-dupe-1';\n      const firstBooking: Booking = {\n        id: firstBookingId,\n        car_id: carId,\n        status: 'confirmed',\n        user_id: 'test-user-id',\n        renter_id: 'test-user-id',\n        start_at: '2026-02-01T10:00:00Z',\n        end_at: '2026-02-05T10:00:00Z',\n        total_amount: 1000,\n        currency: 'ARS',\n        created_at: new Date().toISOString(),\n      } as unknown as Booking;\n\n      // First call is successful\n      let callCount = 0;\n      supabase.rpc.and.callFake(async (method: string, params: unknown) => {\n        if (method === 'is_car_available' && callCount === 0) {\n          return { data: true, error: null };\n        }\n        if (method === 'is_car_available' && callCount > 0) {\n          return { data: false, error: null };\n        }\n        if (method === 'request_booking') {\n          callCount++;\n          return { data: { id: firstBookingId }, error: null };\n        }\n        if (method === 'pricing_recalculate') {\n          return { data: null, error: null };\n        }\n        return { data: null, error: new Error(`Unknown RPC: ${method}`) };\n      });\n\n      supabase.from.and.returnValue({\n        select: () => ({\n          eq: () => ({\n            single: async () => ({ data: firstBooking, error: null }),\n          }),\n        }),\n      } as any);\n\n      const result1 = await service.createBookingWithValidation(\n        carId,\n        '2026-02-01T10:00:00Z',\n        '2026-02-05T10:00:00Z',\n      );\n      expect(result1.success).toBe(true);\n      expect(result1.booking?.id).toBe(firstBooking.id);\n\n      // Second call with overlapping dates should fail\n      const result2 = await service.createBookingWithValidation(\n        carId,\n        '2026-02-03T10:00:00Z',\n        '2026-02-07T10:00:00Z',\n      );\n\n      expect(result2.success).toBe(false);\n      expect(result2.error).toContain('El auto no está disponible');\n    });\n  });\n\n  /**\n   * SPRINT 2 - Test 2.3: Prevención de doble reserva (CRÍTICO)\n   *\n   * Tests mejorados para verificar que el sistema previene correctamente\n   * reservas solapadas y que los mensajes de error son descriptivos\n   */\n  describe('Prevención de doble reserva - CRÍTICO', () => {\n    const carId = 'test-car-prevent-double';\n\n    it('✅ Primera reserva debe ser exitosa', async () => {\n      const bookingId = 'first-booking-ok';\n      const mockBooking: Booking = {\n        id: bookingId,\n        car_id: carId,\n        status: 'confirmed',\n        user_id: 'user-1',\n        renter_id: 'user-1',\n        start_at: '2026-03-01T10:00:00Z',\n        end_at: '2026-03-05T18:00:00Z',\n        total_amount: 20000,\n        currency: 'ARS',\n        created_at: new Date().toISOString(),\n      } as unknown as Booking;\n\n      supabase.rpc.and.callFake(async (method: string) => {\n        if (method === 'is_car_available') {\n          return { data: true, error: null };\n        }\n        if (method === 'request_booking') {\n          return { data: { id: bookingId }, error: null };\n        }\n        if (method === 'pricing_recalculate') {\n          return { data: null, error: null };\n        }\n        return { data: null, error: new Error(`Unknown RPC: ${method}`) };\n      });\n\n      supabase.from.and.returnValue({\n        select: () => ({\n          eq: () => ({\n            single: async () => ({ data: mockBooking, error: null }),\n          }),\n        }),\n      } as any);\n\n      const result = await service.createBookingWithValidation(\n        carId,\n        '2026-03-01T10:00:00Z',\n        '2026-03-05T18:00:00Z',\n      );\n\n      expect(result.success).toBe(true);\n      expect(result.booking?.id).toBe(bookingId);\n      expect(result.booking?.status).toBe('confirmed');\n    });\n\n    it('❌ Segunda reserva SOLAPADA debe fallar', async () => {\n      // Primera reserva: 1-5 marzo\n      // Segunda reserva intentada: 3-7 marzo (solapa con la primera)\n\n      supabase.rpc.and.callFake(async (method: string) => {\n        if (method === 'is_car_available') {\n          // Retorna false porque ya hay una reserva en ese periodo\n          return { data: false, error: null };\n        }\n        return { data: null, error: new Error(`Unknown RPC: ${method}`) };\n      });\n\n      const result = await service.createBookingWithValidation(\n        carId,\n        '2026-03-03T10:00:00Z',\n        '2026-03-07T18:00:00Z',\n      );\n\n      expect(result.success).toBe(false);\n      expect(result.error).toBeDefined();\n      expect(result.error).toContain('no está disponible');\n      expect(result.booking).toBeUndefined();\n\n      // Verificar que NO se intentó crear la reserva\n      expect(supabase.rpc).not.toHaveBeenCalledWith('request_booking', jasmine.any(Object));\n    });\n\n    it('✅ Reservas SECUENCIALES (no solapadas) deben ser exitosas', async () => {\n      // Primera reserva: 1-5 marzo\n      // Segunda reserva: 6-10 marzo (NO solapa)\n\n      const booking1Id = 'seq-booking-1';\n      const booking2Id = 'seq-booking-2';\n\n      let callCount = 0;\n\n      supabase.rpc.and.callFake(async (method: string) => {\n        if (method === 'is_car_available') {\n          return { data: true, error: null };\n        }\n        if (method === 'request_booking') {\n          callCount++;\n          return { data: { id: callCount === 1 ? booking1Id : booking2Id }, error: null };\n        }\n        if (method === 'pricing_recalculate') {\n          return { data: null, error: null };\n        }\n        return { data: null, error: new Error(`Unknown RPC: ${method}`) };\n      });\n\n      supabase.from.and.callFake(\n        () =>\n          ({\n            select: () => ({\n              eq: () => ({\n                single: async () => ({\n                  data: {\n                    id: callCount === 1 ? booking1Id : booking2Id,\n                    car_id: carId,\n                    status: 'confirmed',\n                    user_id: 'user-1',\n                    renter_id: 'user-1',\n                    start_at: callCount === 1 ? '2026-03-01T10:00:00Z' : '2026-03-06T10:00:00Z',\n                    end_at: callCount === 1 ? '2026-03-05T18:00:00Z' : '2026-03-10T18:00:00Z',\n                    total_amount: 20000,\n                    currency: 'ARS',\n                    created_at: new Date().toISOString(),\n                  },\n                  error: null,\n                }),\n              }),\n            }),\n          }) as any,\n      );\n\n      // Primera reserva: 1-5 marzo\n      const result1 = await service.createBookingWithValidation(\n        carId,\n        '2026-03-01T10:00:00Z',\n        '2026-03-05T18:00:00Z',\n      );\n\n      expect(result1.success).toBe(true);\n      expect(result1.booking?.id).toBe(booking1Id);\n\n      // Segunda reserva: 6-10 marzo (NO solapa)\n      const result2 = await service.createBookingWithValidation(\n        carId,\n        '2026-03-06T10:00:00Z',\n        '2026-03-10T18:00:00Z',\n      );\n\n      expect(result2.success).toBe(true);\n      expect(result2.booking?.id).toBe(booking2Id);\n    });\n\n    it('❌ Error debe ser descriptivo y útil para el usuario', async () => {\n      supabase.rpc.and.callFake(async (method: string) => {\n        if (method === 'is_car_available') {\n          return { data: false, error: null };\n        }\n        return { data: null, error: null };\n      });\n\n      const result = await service.createBookingWithValidation(\n        carId,\n        '2026-04-01T10:00:00Z',\n        '2026-04-05T18:00:00Z',\n      );\n\n      expect(result.success).toBe(false);\n      expect(result.error).toBeDefined();\n\n      // Verificar que el mensaje es descriptivo\n      const errorMsg = result.error!.toLowerCase();\n      expect(\n        errorMsg.includes('no está disponible') ||\n          errorMsg.includes('no disponible') ||\n          errorMsg.includes('ocupado'),\n      ).toBe(true);\n\n      // NO debe ser un error genérico\n      expect(errorMsg).not.toContain('unknown error');\n      expect(errorMsg).not.toContain('undefined');\n    });\n\n    it('❌ Solape PARCIAL al inicio debe fallar', async () => {\n      // Reserva existente: 1-5 marzo\n      // Nueva reserva: 28 feb - 3 marzo (solapa al inicio)\n\n      supabase.rpc.and.callFake(async (method: string) => {\n        if (method === 'is_car_available') {\n          return { data: false, error: null };\n        }\n        return { data: null, error: null };\n      });\n\n      const result = await service.createBookingWithValidation(\n        carId,\n        '2026-02-28T10:00:00Z',\n        '2026-03-03T18:00:00Z',\n      );\n\n      expect(result.success).toBe(false);\n      expect(result.error).toContain('no está disponible');\n    });\n\n    it('❌ Solape PARCIAL al final debe fallar', async () => {\n      // Reserva existente: 1-5 marzo\n      // Nueva reserva: 4-8 marzo (solapa al final)\n\n      supabase.rpc.and.callFake(async (method: string) => {\n        if (method === 'is_car_available') {\n          return { data: false, error: null };\n        }\n        return { data: null, error: null };\n      });\n\n      const result = await service.createBookingWithValidation(\n        carId,\n        '2026-03-04T10:00:00Z',\n        '2026-03-08T18:00:00Z',\n      );\n\n      expect(result.success).toBe(false);\n      expect(result.error).toContain('no está disponible');\n    });\n\n    it('❌ Solape COMPLETO (reserva dentro de otra) debe fallar', async () => {\n      // Reserva existente: 1-10 marzo\n      // Nueva reserva: 3-7 marzo (completamente dentro)\n\n      supabase.rpc.and.callFake(async (method: string) => {\n        if (method === 'is_car_available') {\n          return { data: false, error: null };\n        }\n        return { data: null, error: null };\n      });\n\n      const result = await service.createBookingWithValidation(\n        carId,\n        '2026-03-03T10:00:00Z',\n        '2026-03-07T18:00:00Z',\n      );\n\n      expect(result.success).toBe(false);\n      expect(result.error).toContain('no está disponible');\n    });\n\n    it('✅ Mismo día inicio/fin de reserva anterior debe permitir nueva reserva', async () => {\n      // Reserva existente: 1-5 marzo, termina a las 18:00\n      // Nueva reserva: 5 marzo a las 18:00 - 10 marzo\n      // Esto es válido si is_car_available lo permite\n\n      const bookingId = 'same-day-transition';\n\n      supabase.rpc.and.callFake(async (method: string) => {\n        if (method === 'is_car_available') {\n          // La RPC verifica rangos y permite si no hay solape real\n          return { data: true, error: null };\n        }\n        if (method === 'request_booking') {\n          return { data: { id: bookingId }, error: null };\n        }\n        if (method === 'pricing_recalculate') {\n          return { data: null, error: null };\n        }\n        return { data: null, error: null };\n      });\n\n      supabase.from.and.returnValue({\n        select: () => ({\n          eq: () => ({\n            single: async () => ({\n              data: {\n                id: bookingId,\n                car_id: carId,\n                status: 'confirmed',\n                user_id: 'user-1',\n                renter_id: 'user-1',\n                start_at: '2026-03-05T18:00:00Z',\n                end_at: '2026-03-10T18:00:00Z',\n                total_amount: 25000,\n                currency: 'ARS',\n                created_at: new Date().toISOString(),\n              },\n              error: null,\n            }),\n          }),\n        }),\n      } as any);\n\n      const result = await service.createBookingWithValidation(\n        carId,\n        '2026-03-05T18:00:00Z',\n        '2026-03-10T18:00:00Z',\n      );\n\n      expect(result.success).toBe(true);\n      expect(result.booking?.id).toBe(bookingId);\n    });\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/core/services/bookings/booking-notifications.service.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`@core/services/infrastructure/supabase-client.service` import should occur before type import of `../models`","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":88,"fix":{"range":[128,314],"text":"import { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\nimport type { Booking } from '../models';\nimport { getErrorMessage } from '../utils/type-guards';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { LoggerService } from '@core/services/infrastructure/logger.service';\nimport {Injectable, inject} from '@angular/core';\nimport type { Booking } from '../models';\nimport { getErrorMessage } from '../utils/type-guards';\nimport { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\n\n/**\n * BookingNotificationsService\n *\n * Servicio especializado para crear notificaciones automáticas\n * cuando cambia el estado de un booking o se realizan acciones importantes.\n *\n * Integrado con el flujo completo de contratación.\n */\n@Injectable({\n  providedIn: 'root',\n})\nexport class BookingNotificationsService {\n  private readonly logger = inject(LoggerService);\n  private readonly supabase = injectSupabase();\n\n  /**\n   * Notifica cuando un booking cambia de estado\n   */\n  async notifyStatusChange(booking: Booking, oldStatus: string, newStatus: string): Promise<void> {\n    try {\n      // Obtener información del auto y usuarios\n      const { data: bookingData, error: bookingError } = await this.supabase\n        .from('bookings')\n        .select(\n          '*, cars(title, brand, model), renter:profiles!bookings_renter_id_fkey(full_name), owner:profiles!bookings_owner_id_fkey(full_name)',\n        )\n        .eq('id', booking.id)\n        .single();\n\n      if (bookingError || !bookingData) {\n        console.error('Error fetching booking data for notification:', bookingError);\n        return;\n      }\n\n      const carTitle =\n        bookingData.cars?.title || `${bookingData.cars?.brand} ${bookingData.cars?.model}`;\n      const renterName = bookingData.renter?.full_name || 'el locatario';\n\n      // Notificar según el cambio de estado\n      switch (newStatus) {\n        case 'confirmed':\n          // Notificar al locatario que su reserva fue confirmada\n          await this.createNotification({\n            user_id: booking.renter_id,\n            type: 'payment_successful',\n            title: '¡Reserva Confirmada!',\n            body: `Tu reserva de ${carTitle} ha sido confirmada. Preparate para el check-in.`,\n            cta_link: `/bookings/${booking.id}`,\n            metadata: {\n              booking_id: booking.id,\n              car_id: booking.car_id,\n              status: newStatus,\n            },\n          });\n\n          // Notificar al locador que el pago fue completado\n          await this.createNotification({\n            user_id: booking.owner_id,\n            type: 'payment_successful',\n            title: 'Pago Recibido',\n            body: `${renterName} completó el pago de la reserva de ${carTitle}.`,\n            cta_link: `/bookings/owner/${booking.id}`,\n            metadata: {\n              booking_id: booking.id,\n              car_id: booking.car_id,\n              status: newStatus,\n            },\n          });\n          break;\n\n        case 'in_progress':\n          // Notificar al locatario que el alquiler comenzó\n          await this.createNotification({\n            user_id: booking.renter_id,\n            type: 'generic_announcement',\n            title: '¡Alquiler Iniciado!',\n            body: `El check-in de ${carTitle} ha sido completado. ¡Disfrutá tu viaje!`,\n            cta_link: `/bookings/${booking.id}`,\n            metadata: {\n              booking_id: booking.id,\n              car_id: booking.car_id,\n              status: newStatus,\n            },\n          });\n\n          // Notificar al locador\n          await this.createNotification({\n            user_id: booking.owner_id,\n            type: 'generic_announcement',\n            title: 'Alquiler en Curso',\n            body: `El alquiler de ${carTitle} con ${renterName} ha comenzado.`,\n            cta_link: `/bookings/owner/${booking.id}`,\n            metadata: {\n              booking_id: booking.id,\n              car_id: booking.car_id,\n              status: newStatus,\n            },\n          });\n          break;\n\n        case 'completed':\n          // Notificar al locatario que puede dejar reseña\n          await this.createNotification({\n            user_id: booking.renter_id,\n            type: 'generic_announcement',\n            title: 'Reserva Completada',\n            body: `Tu reserva de ${carTitle} ha finalizado. Dejá tu reseña para ayudar a otros usuarios.`,\n            cta_link: `/bookings/${booking.id}`,\n            metadata: {\n              booking_id: booking.id,\n              car_id: booking.car_id,\n              status: newStatus,\n              can_review: true,\n            },\n          });\n\n          // Notificar al locador sobre ganancias\n          await this.createNotification({\n            user_id: booking.owner_id,\n            type: 'payout_successful',\n            title: 'Reserva Completada - Ganancias Disponibles',\n            body: `La reserva de ${carTitle} con ${renterName} ha finalizado. Tus ganancias están disponibles en tu wallet.`,\n            cta_link: `/bookings/owner/${booking.id}`,\n            metadata: {\n              booking_id: booking.id,\n              car_id: booking.car_id,\n              status: newStatus,\n              can_review: true,\n              earnings_available: true,\n            },\n          });\n          break;\n\n        case 'cancelled':\n          // Notificar a ambas partes\n          if (oldStatus === 'pending') {\n            // Cancelación de solicitud pendiente\n            await this.createNotification({\n              user_id: booking.renter_id,\n              type: 'booking_cancelled_for_renter',\n              title: 'Reserva Cancelada',\n              body: `Tu solicitud de reserva para ${carTitle} ha sido cancelada.`,\n              cta_link: `/bookings`,\n              metadata: {\n                booking_id: booking.id,\n                car_id: booking.car_id,\n                status: newStatus,\n              },\n            });\n\n            await this.createNotification({\n              user_id: booking.owner_id,\n              type: 'booking_cancelled_for_owner',\n              title: 'Solicitud Cancelada',\n              body: `La solicitud de reserva para ${carTitle} ha sido cancelada.`,\n              cta_link: `/bookings/owner`,\n              metadata: {\n                booking_id: booking.id,\n                car_id: booking.car_id,\n                status: newStatus,\n              },\n            });\n          }\n          break;\n\n        default:\n          // No notification for other status changes\n          this.logger.debug(`[BookingNotifications] No notification configured for status: ${newStatus}`);\n          break;\n      }\n    } catch (error) {\n      console.error('Error creating status change notification:', error);\n      // No lanzar error para no bloquear el flujo principal\n    }\n  }\n\n  /**\n   * Notifica cuando se requiere acción del usuario (check-in, check-out, etc.)\n   */\n  async notifyActionRequired(\n    booking: Booking,\n    action: 'check_in' | 'check_out' | 'review' | 'approve' | 'payment',\n    targetUserId: string,\n  ): Promise<void> {\n    try {\n      const { data: bookingData, error } = await this.supabase\n        .from('bookings')\n        .select('*, cars(title, brand, model)')\n        .eq('id', booking.id)\n        .single();\n\n      if (error || !bookingData) {\n        console.error('Error fetching booking data:', error);\n        return;\n      }\n\n      const carTitle =\n        bookingData.cars?.title || `${bookingData.cars?.brand} ${bookingData.cars?.model}`;\n\n      const notifications: Record<string, { title: string; body: string; cta_link: string }> = {\n        check_in: {\n          title: 'Check-In Requerido',\n          body: `Es hora de realizar el check-in para ${carTitle}. Inspeccioná el vehículo antes de entregarlo.`,\n          cta_link: `/bookings/${booking.id}/owner-check-in`,\n        },\n        check_out: {\n          title: 'Check-Out Requerido',\n          body: `Completá el check-out de ${carTitle} para finalizar la reserva.`,\n          cta_link: `/bookings/${booking.id}/check-out`,\n        },\n        review: {\n          title: 'Dejá tu Reseña',\n          body: `Tu reserva de ${carTitle} ha finalizado. Compartí tu experiencia.`,\n          cta_link: `/bookings/${booking.id}`,\n        },\n        approve: {\n          title: 'Nueva Solicitud de Reserva',\n          body: `Tenés una nueva solicitud de reserva para ${carTitle}. Revisala y aprobala.`,\n          cta_link: `/bookings/owner/${booking.id}`,\n        },\n        payment: {\n          title: 'Pago Pendiente',\n          body: `Completá el pago para confirmar tu reserva de ${carTitle}.`,\n          cta_link: `/bookings/${booking.id}/detail-payment`,\n        },\n      };\n\n      const notification = notifications[action];\n      if (!notification) return;\n\n      await this.createNotification({\n        user_id: targetUserId,\n        type: 'generic_announcement',\n        title: notification.title,\n        body: notification.body,\n        cta_link: notification.cta_link,\n        metadata: {\n          booking_id: booking.id,\n          car_id: booking.car_id,\n          action_required: action,\n        },\n      });\n    } catch (error) {\n      console.error('Error creating action required notification:', error);\n    }\n  }\n\n  /**\n   * Notifica al propietario cuando el locatario solicita una extensión.\n   */\n  async notifyExtensionRequested(\n    booking: Booking,\n    newEndAt: string,\n    renterMessage?: string,\n  ): Promise<void> {\n    try {\n      const { data: car, error: carError } = await this.supabase\n        .from('cars')\n        .select('id, title, brand, model, owner_id')\n        .eq('id', booking.car_id)\n        .single();\n\n      if (carError || !car?.owner_id) return;\n\n      const { data: renter } = await this.supabase\n        .from('profiles')\n        .select('full_name')\n        .eq('id', booking.renter_id)\n        .single();\n\n      const carTitle = car.title || `${car.brand} ${car.model}`;\n      const renterName = renter?.full_name || 'El locatario';\n      const formattedDate = new Date(newEndAt).toLocaleDateString('es-AR');\n\n      await this.createNotification({\n        user_id: car.owner_id,\n        type: 'generic_announcement',\n        title: 'Solicitud de extensión',\n        body: `${renterName} solicita extender la reserva de ${carTitle} hasta ${formattedDate}.`,\n        cta_link: `/bookings/owner/${booking.id}`,\n        metadata: {\n          booking_id: booking.id,\n          car_id: booking.car_id,\n          new_end_at: newEndAt,\n          renter_message: renterMessage || null,\n        },\n      });\n    } catch (error) {\n      this.logger.warn('Error creating extension request notification', 'BookingNotifications', error);\n    }\n  }\n\n  /**\n   * Notifica al locatario cuando el propietario rechaza la extensión.\n   */\n  async notifyExtensionRejected(booking: Booking, reason: string): Promise<void> {\n    try {\n      const { data: car } = await this.supabase\n        .from('cars')\n        .select('title, brand, model')\n        .eq('id', booking.car_id)\n        .single();\n\n      const carTitle = car?.title || `${car?.brand ?? ''} ${car?.model ?? ''}`.trim() || 'tu auto';\n\n      await this.createNotification({\n        user_id: booking.renter_id,\n        type: 'generic_announcement',\n        title: 'Extensión rechazada',\n        body: `Tu solicitud de extensión para ${carTitle} fue rechazada. Motivo: ${reason}`,\n        cta_link: `/bookings/${booking.id}`,\n        metadata: {\n          booking_id: booking.id,\n          car_id: booking.car_id,\n          reason,\n        },\n      });\n    } catch (error) {\n      this.logger.warn('Error creating extension rejection notification', 'BookingNotifications', error);\n    }\n  }\n\n  /**\n   * Notifica cuando se completa un check-in o check-out\n   */\n  async notifyInspectionCompleted(\n    booking: Booking,\n    inspectionType: 'check_in' | 'check_out',\n    completedByUserId: string,\n  ): Promise<void> {\n    try {\n      const { data: bookingData, error } = await this.supabase\n        .from('bookings')\n        .select(\n          '*, cars(title, brand, model), renter:profiles!bookings_renter_id_fkey(full_name), owner:profiles!bookings_owner_id_fkey(full_name)',\n        )\n        .eq('id', booking.id)\n        .single();\n\n      if (error || !bookingData) return;\n\n      const carTitle =\n        bookingData.cars?.title || `${bookingData.cars?.brand} ${bookingData.cars?.model}`;\n      const isOwner = completedByUserId === booking.owner_id;\n      const otherUserName = isOwner ? bookingData.renter?.full_name : bookingData.owner?.full_name;\n\n      if (inspectionType === 'check_in') {\n        // Notificar al locatario que puede hacer su check-in\n        await this.createNotification({\n          user_id: booking.renter_id,\n          type: 'inspection_reminder',\n          title: 'Check-In del Locador Completado',\n          body: `El locador completó el check-in de ${carTitle}. Ahora es tu turno de confirmar la recepción.`,\n          cta_link: `/bookings/${booking.id}/check-in`,\n          metadata: {\n            booking_id: booking.id,\n            car_id: booking.car_id,\n            inspection_type: 'check_in',\n          },\n        });\n      } else if (inspectionType === 'check_out') {\n        // Notificar al locador que el locatario completó el check-out\n        await this.createNotification({\n          user_id: booking.owner_id,\n          type: 'inspection_reminder',\n          title: 'Check-Out del Locatario Completado',\n          body: `${otherUserName} completó el check-out de ${carTitle}. Revisá el estado del vehículo.`,\n          cta_link: `/bookings/${booking.id}/owner-check-out`,\n          metadata: {\n            booking_id: booking.id,\n            car_id: booking.car_id,\n            inspection_type: 'check_out',\n          },\n        });\n      }\n    } catch (error) {\n      console.error('Error creating inspection notification:', error);\n    }\n  }\n\n  /**\n   * Notifica cuando se puede dejar una reseña (14 días después de completed)\n   */\n  async notifyReviewAvailable(booking: Booking, userId: string): Promise<void> {\n    try {\n      const { data: bookingData, error } = await this.supabase\n        .from('bookings')\n        .select('*, cars(title, brand, model)')\n        .eq('id', booking.id)\n        .single();\n\n      if (error || !bookingData) return;\n\n      const carTitle =\n        bookingData.cars?.title || `${bookingData.cars?.brand} ${bookingData.cars?.model}`;\n\n      await this.createNotification({\n        user_id: userId,\n        type: 'generic_announcement',\n        title: 'Dejá tu Reseña',\n        body: `Tu reserva de ${carTitle} ha finalizado. Compartí tu experiencia para ayudar a otros usuarios.`,\n        cta_link: `/bookings/${booking.id}`,\n        metadata: {\n          booking_id: booking.id,\n          car_id: booking.car_id,\n          review_available: true,\n        },\n      });\n    } catch (error) {\n      console.error('Error creating review notification:', error);\n    }\n  }\n\n  /**\n   * Helper para crear notificaciones en la base de datos\n   */\n  private async createNotification(data: {\n    user_id?: string;\n    type: string;\n    title: string;\n    body: string;\n    cta_link?: string;\n    metadata?: Record<string, unknown>;\n  }): Promise<void> {\n    // If no user_id is provided, bail out early. This prevents passing\n    // `undefined` into the DB and satisfies callers that may have\n    // optional user ids on the booking model.\n    if (!data.user_id) {\n      console.warn('Skipping notification creation: missing user_id', data);\n      return;\n    }\n\n    const { error } = await this.supabase.from('notifications').insert({\n      user_id: data.user_id,\n      type: data.type,\n      title: data.title,\n      body: data.body,\n      cta_link: data.cta_link,\n      metadata: data.metadata || {},\n    });\n\n    if (error) {\n      console.error('Error creating notification:', error);\n      throw new Error(`Failed to create notification: ${getErrorMessage(error)}`);\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/core/services/bookings/booking-validation.service.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`../models` import should occur after import of `@core/services/infrastructure/logger.service`","line":2,"column":1,"nodeType":"ImportDeclaration","endLine":2,"endColumn":37,"fix":{"range":[52,346],"text":"import { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\nimport { ErrorHandlerService } from '@core/services/infrastructure/error-handler.service';\nimport { LoggerService } from '@core/services/infrastructure/logger.service';\nimport { Booking } from '../models';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { Injectable, inject } from '@angular/core';\nimport { Booking } from '../models';\nimport { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\nimport { ErrorHandlerService } from '@core/services/infrastructure/error-handler.service';\nimport { LoggerService } from '@core/services/infrastructure/logger.service';\n\n/**\n * Service for booking validation\n * Handles date validation, availability checking, and error message mapping\n */\n@Injectable({\n  providedIn: 'root',\n})\nexport class BookingValidationService {\n  private readonly supabase = injectSupabase();\n  private readonly errorHandler = inject(ErrorHandlerService);\n  private readonly logger = inject(LoggerService);\n\n  /**\n   * ✅ SPRINT 2 FIX: Create booking with availability validation\n   * This method validates BEFORE creating the booking\n   *\n   * @param carId - ID del auto a reservar\n   * @param startDate - Fecha inicio (ISO string)\n   * @param endDate - Fecha fin (ISO string)\n   * @param onRequestBooking - Callback to request booking\n   * @returns Promise with operation result\n   */\n  async createBookingWithValidation(\n    carId: string,\n    startDate: string,\n    endDate: string,\n    onRequestBooking: (carId: string, startDate: string, endDate: string) => Promise<Booking>,\n  ): Promise<{\n    success: boolean;\n    booking?: Booking;\n    error?: string;\n    canWaitlist?: boolean;\n  }> {\n    try {\n      // 1. Validate dates\n      const dateValidation = this.validateDates(startDate, endDate);\n      if (!dateValidation.valid) {\n        return {\n          success: false,\n          error: dateValidation.error,\n        };\n      }\n\n      // 2. Pre‑validar disponibilidad para ofrecer feedback inmediato (no bloqueante)\n      try {\n        const availability = await this.supabase.rpc('is_car_available', {\n          p_car_id: carId,\n          p_start_date: startDate,\n          p_end_date: endDate,\n        });\n\n        if (availability.error) {\n          // Log y continuar: no bloquear creación por error de RPC\n          this.errorHandler.handleBookingError(\n            availability.error,\n            'Availability check failed (non-blocking)',\n            false,\n          );\n        } else if (availability.data === false) {\n          const hasPendingBookings = await this.checkPendingBookings(carId, startDate, endDate);\n\n          return {\n            success: false,\n            error: hasPendingBookings\n              ? 'El auto está reservado temporalmente (pendiente de pago). Intenta con otras fechas o únete a la lista de espera.'\n              : 'El auto no está disponible para esas fechas. Por favor elige otras fechas.',\n            canWaitlist: true,\n          };\n        }\n      } catch (rpcError) {\n        // Fallback: registrar y seguir\n        this.errorHandler.handleBookingError(\n          rpcError,\n          'Availability pre-check crashed (non-blocking)',\n          false,\n        );\n      }\n\n      // 3. Attempt to create the booking\n      // This allows capturing the constraint error if there's a pending booking\n      // Availability validation is done inside request_booking\n      // If it fails, we check if it's due to a pending booking and activate waitlist\n      const booking = await onRequestBooking(carId, startDate, endDate);\n\n      return {\n        success: true,\n        booking: booking,\n      };\n    } catch (error: unknown) {\n      // Use ErrorHandlerService for consistent error handling\n      this.errorHandler.handleBookingError(error, 'Create booking with validation', false);\n\n      // Extract error message more robustly\n      let errorMessage = 'Error al crear la reserva';\n\n      if (error instanceof Error) {\n        errorMessage = error.message;\n      } else if (error && typeof error === 'object' && 'message' in error) {\n        errorMessage = String(error.message);\n      }\n\n      // Map Supabase error messages to friendlier messages\n      const errorLower = errorMessage.toLowerCase();\n      let canWaitlist = false;\n\n      // Check if error has canWaitlist property (passed from requestBooking)\n      if (error && typeof error === 'object' && 'canWaitlist' in error) {\n        canWaitlist = Boolean((error as unknown as { canWaitlist?: boolean }).canWaitlist);\n      }\n\n      // Detect errors that should activate waitlist\n      const isUnavailableError =\n        errorLower.includes('conflicting key') ||\n        errorLower.includes('exclusion constraint') ||\n        errorLower.includes('bookings_no_overlap') ||\n        errorLower.includes('no disponible en esas fechas') ||\n        errorLower.includes('auto no disponible en esas fechas') ||\n        errorLower.includes('auto no disponible');\n\n      if (isUnavailableError) {\n        // ✅ FIX 2025-11-06: Distinguir entre reserva pendiente y confirmada\n        const hasPendingBookings = await this.checkPendingBookings(carId, startDate, endDate);\n\n        if (hasPendingBookings) {\n          errorMessage =\n            'El auto está reservado temporalmente (pendiente de pago). Intenta con otras fechas o únete a la lista de espera.';\n        } else {\n          errorMessage =\n            'El auto no está disponible para esas fechas. Hay una reserva confirmada en ese período.';\n        }\n\n        canWaitlist = true;\n\n        // Log for debugging\n        this.logger.warn(\n          'Waitlist activated due to unavailable error: ' +\n            JSON.stringify({\n              originalError: errorMessage,\n              errorLower,\n              hasPendingBookings,\n              carId,\n              startDate,\n              endDate,\n            }),\n        );\n      } else if (errorLower.includes('no disponible') || errorLower.includes('not available')) {\n        // Check if there are pending bookings that could cause the conflict\n        const hasPendingBookings = await this.checkPendingBookings(carId, startDate, endDate);\n\n        if (hasPendingBookings) {\n          errorMessage =\n            'El auto está reservado temporalmente (pendiente de pago). Intenta con otras fechas o únete a la lista de espera.';\n          canWaitlist = true;\n        } else {\n          errorMessage =\n            'El auto no está disponible para esas fechas. Por favor elige otras fechas.';\n        }\n      } else {\n        // Map other common errors\n        errorMessage = this.mapErrorMessage(errorLower);\n      }\n\n      return {\n        success: false,\n        error: errorMessage,\n        canWaitlist,\n      };\n    }\n  }\n\n  /**\n   * Validate booking dates\n   */\n  private validateDates(startDate: string, endDate: string): { valid: boolean; error?: string } {\n    const start = new Date(startDate);\n    const end = new Date(endDate);\n\n    if (start >= end) {\n      return {\n        valid: false,\n        error: 'La fecha de inicio debe ser anterior a la fecha de fin',\n      };\n    }\n\n    if (start < new Date()) {\n      return {\n        valid: false,\n        error: 'La fecha de inicio no puede ser en el pasado',\n      };\n    }\n\n    return { valid: true };\n  }\n\n  /**\n   * Check if there are pending bookings that overlap with the requested dates\n   * ✅ FIX 2025-11-06: Corregida lógica de overlap (lt/gt en lugar de lte/gte)\n   * ✅ FIX 2025-11-06: Incluir 'pending_payment' en estados a verificar\n   * ✅ FIX 2025-12-17: Filter out expired bookings (expires_at < now)\n   */\n  private async checkPendingBookings(\n    carId: string,\n    startDate: string,\n    endDate: string,\n  ): Promise<boolean> {\n    try {\n      const now = new Date().toISOString();\n      const { data: pendingBookings } = await this.supabase\n        .from('bookings')\n        .select('id, status, expires_at')\n        .eq('car_id', carId)\n        .in('status', ['pending', 'pending_payment'])\n        .lt('start_at', endDate) // ✅ FIX: start_at < endDate (overlap correcto)\n        .gt('end_at', startDate) // ✅ FIX: end_at > startDate (overlap correcto)\n        .or(`expires_at.is.null,expires_at.gt.${now}`); // ✅ FIX: Only active (non-expired) bookings\n\n      return pendingBookings ? pendingBookings.length > 0 : false;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Map error messages to user-friendly messages\n   */\n  private mapErrorMessage(errorLower: string): string {\n    if (errorLower.includes('no autenticado') || errorLower.includes('not authenticated')) {\n      return 'Debes iniciar sesión para crear una reserva.';\n    }\n\n    if (errorLower.includes('propio auto') || errorLower.includes('own car')) {\n      return 'No puedes reservar tu propio auto.';\n    }\n\n    if (errorLower.includes('pasado') || errorLower.includes('past')) {\n      return 'No puedes reservar en el pasado. Por favor elige fechas futuras.';\n    }\n\n    if (errorLower.includes('fecha') || errorLower.includes('date')) {\n      return 'Las fechas seleccionadas no son válidas. Por favor verifica.';\n    }\n\n    return 'Error al crear la reserva';\n  }\n\n  /**\n   * Validate cancellation timing\n   * Returns true if cancellation is allowed (at least 24h before start)\n   */\n  validateCancellationTiming(\n    booking: Booking,\n    force: boolean = false,\n  ): {\n    allowed: boolean;\n    error?: string;\n  } {\n    if (force) {\n      return { allowed: true };\n    }\n\n    const startDate = new Date(booking.start_at);\n    const now = new Date();\n    const hoursUntilStart = (startDate.getTime() - now.getTime()) / (1000 * 60 * 60);\n\n    if (hoursUntilStart < 24) {\n      return {\n        allowed: false,\n        error: 'Solo puedes cancelar con al menos 24 horas de anticipación',\n      };\n    }\n\n    return { allowed: true };\n  }\n\n  /**\n   * Validate booking status for cancellation\n   */\n  validateCancellationStatus(booking: Booking): {\n    allowed: boolean;\n    error?: string;\n  } {\n    const validStatuses = ['confirmed', 'pending'];\n    if (!validStatuses.includes(booking.status)) {\n      return {\n        allowed: false,\n        error: `No se puede cancelar una reserva en estado \"${booking.status}\"`,\n      };\n    }\n\n    return { allowed: true };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/core/services/bookings/booking-wallet.service.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`../models` import should occur after import of `@core/services/payments/payments.service`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":37,"fix":{"range":[91,619],"text":"import { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\nimport { WalletService } from '@core/services/payments/wallet.service';\nimport { LoggerService } from '@core/services/infrastructure/logger.service';\nimport { CarOwnerNotificationsService } from './car-owner-notifications.service';\nimport { CarsService } from '@core/services/cars/cars.service';\nimport { PaymentsService } from '@core/services/payments/payments.service'; // NEW: Import PaymentsService\nimport { Booking } from '../models';\n"}},{"ruleId":"import/order","severity":1,"message":"`./car-owner-notifications.service` import should occur after import of `@core/services/payments/payments.service`","line":7,"column":1,"nodeType":"ImportDeclaration","endLine":7,"endColumn":82,"fix":{"range":[366,619],"text":"import { CarsService } from '@core/services/cars/cars.service';\nimport { PaymentsService } from '@core/services/payments/payments.service'; // NEW: Import PaymentsService\nimport { CarOwnerNotificationsService } from './car-owner-notifications.service';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import { Injectable, inject } from '@angular/core';\nimport { firstValueFrom } from 'rxjs';\nimport { Booking } from '../models';\nimport { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\nimport { WalletService } from '@core/services/payments/wallet.service';\nimport { LoggerService } from '@core/services/infrastructure/logger.service';\nimport { CarOwnerNotificationsService } from './car-owner-notifications.service';\nimport { CarsService } from '@core/services/cars/cars.service';\nimport { PaymentsService } from '@core/services/payments/payments.service'; // NEW: Import PaymentsService\n\n/**\n * Service for managing booking-related wallet operations\n * Handles security deposits, rental charges, and payment processing\n */\n@Injectable({\n  providedIn: 'root',\n})\nexport class BookingWalletService {\n  private readonly supabase = injectSupabase();\n  private readonly walletService = inject(WalletService);\n  private readonly logger = inject(LoggerService);\n  private readonly carOwnerNotifications = inject(CarOwnerNotificationsService);\n  private readonly carsService = inject(CarsService);\n  private readonly paymentsService = inject(PaymentsService); // NEW: Inject PaymentsService\n\n  /**\n   * Charge rental from user's wallet using the new ledger system\n   * This is called when a booking is completed and the owner wants to charge the renter\n   */\n  async chargeRentalFromWallet(\n    booking: Booking,\n    amountCents: number,\n    description?: string,\n  ): Promise<{ ok: boolean; error?: string }> {\n    try {\n      if (!booking.user_id) {\n        return { ok: false, error: 'Booking has no user_id' };\n      }\n\n      // Generate unique ref\n      const ref = `rental-${booking.id}-${Date.now()}`;\n\n      // Call wallet_charge_rental RPC function\n      const { error } = await this.supabase.rpc('wallet_charge_rental', {\n        p_user_id: booking.user_id,\n        p_booking_id: booking.id,\n        p_amount_cents: amountCents,\n        p_ref: ref,\n        p_meta: {\n          charged_at: new Date().toISOString(),\n          description: description || `Cargo por alquiler - Reserva ${booking.id.substring(0, 8)}`,\n          car_id: booking.car_id,\n        },\n      });\n\n      if (error) {\n        return { ok: false, error: error.message };\n      }\n\n      return { ok: true };\n    } catch (err) {\n      const errorMsg = err instanceof Error ? err.message : 'Error inesperado';\n      return { ok: false, error: errorMsg };\n    }\n  }\n\n  /**\n   * Process rental payment (receives payment from renter to owner)\n   * This is the counterpart - when the owner receives the payment for a completed rental\n   */\n  async processRentalPayment(\n    booking: Booking,\n    amountCents: number,\n    description?: string,\n  ): Promise<{ ok: boolean; error?: string }> {\n    try {\n      if (!booking.owner_id) {\n        return { ok: false, error: 'Booking has no owner_id' };\n      }\n\n      // Generate unique ref\n      const ref = `rental-payment-${booking.id}-${Date.now()}`;\n\n      // Insert rental_payment ledger entry manually\n      const { error } = await this.supabase.rpc('wallet_record_rental_payment', {\n        p_owner_id: booking.owner_id,\n        p_booking_id: booking.id,\n        p_amount_cents: amountCents,\n        p_ref: ref,\n        p_meta: {\n          received_at: new Date().toISOString(),\n          description: description || `Pago recibido - Reserva ${booking.id.substring(0, 8)}`,\n          car_id: booking.car_id,\n          renter_id: booking.user_id,\n        },\n      });\n\n      if (error) {\n        return { ok: false, error: error.message };\n      }\n\n      // ✅ NUEVO: Notificar al dueño del auto sobre el pago recibido\n      this.notifyOwnerOfPaymentReceived(booking, amountCents).catch((notificationError) => {\n        this.logger.warn(\n          'Failed to notify owner about payment received',\n          'BookingWalletService',\n          notificationError instanceof Error\n            ? notificationError\n            : new Error(String(notificationError)),\n        );\n      });\n\n      return { ok: true };\n    } catch (err) {\n      const errorMsg = err instanceof Error ? err.message : 'Error inesperado';\n      return { ok: false, error: errorMsg };\n    }\n  }\n\n  /**\n   * Lock security deposit (guarantee) when booking is confirmed\n   * The funds stay in the user's wallet but are marked as locked\n   */\n  async lockSecurityDeposit(\n    booking: Booking,\n    depositAmountCents: number,\n    paymentMethod: 'card' | 'wallet', // NUEVO: Método de pago\n    description?: string,\n  ): Promise<{ ok: boolean; transaction_id?: string; mp_order_id?: string; error?: string }> {\n    try {\n      if (!booking.user_id) {\n        return { ok: false, error: 'Booking has no user_id' };\n      }\n\n      // 1. Si es con Wallet: Usar lógica existente de bloqueo de fondos\n      if (paymentMethod === 'wallet') {\n        // Check if user has sufficient available balance\n        const { data: wallet, error: walletError } = await this.supabase\n          .from('user_wallets')\n          .select('available_balance')\n          .eq('user_id', booking.user_id)\n          .single();\n\n        if (walletError) {\n          return { ok: false, error: 'Error checking wallet balance' };\n        }\n\n        if (wallet.available_balance < depositAmountCents) {\n          return {\n            ok: false,\n            error: `Saldo insuficiente. Disponible: ${wallet.available_balance / 100}, Requerido: ${depositAmountCents / 100}`,\n          };\n        }\n\n        const lockResult = await firstValueFrom(\n          this.walletService.lockFunds(\n            booking.id,\n            depositAmountCents,\n            description || `Garantía bloqueada - Reserva ${booking.id.substring(0, 8)}`,\n          ),\n        );\n\n        if (!lockResult.success) {\n          return { ok: false, error: lockResult.message };\n        }\n\n        return {\n          ok: true,\n          transaction_id: lockResult.transaction_id ?? undefined,\n        };\n      }\n\n      // 2. Si es con Tarjeta: Crear pre-autorización de MercadoPago\n      if (paymentMethod === 'card') {\n        // Crear un PaymentIntent de tipo security_deposit\n        const intent = await this.paymentsService.createPaymentIntent({\n          bookingId: booking.id,\n          userId: booking.user_id,\n          amount: depositAmountCents / 100, // MP espera monto en la moneda base\n          currency: booking.currency || 'ARS',\n          intentType: 'security_deposit',\n          isPreAuth: true,\n          description:\n            description || `Pre-autorización Garantía Reserva ${booking.id.substring(0, 8)}`,\n        });\n\n        // Llamar a la RPC de Supabase para crear la pre-autorización en MP\n        const updatedIntent = await this.paymentsService.createMpPreAuthOrder(\n          intent.id,\n          depositAmountCents,\n          description || `Pre-autorización Garantía Reserva ${booking.id.substring(0, 8)}`,\n          booking.id,\n        );\n\n        // Actualizar el booking con el ID de la orden de MP\n        await this.supabase\n\n          .from('bookings')\n          .update({\n            mp_security_deposit_order_id: updatedIntent.mp_order_id,\n            deposit_status: 'locked', // Usar el nuevo estado de depósito\n            payment_method: 'credit_card',\n          })\n          .eq('id', booking.id);\n\n        return {\n          ok: true,\n          mp_order_id: updatedIntent.mp_order_id ?? undefined,\n        };\n      }\n\n      return { ok: false, error: 'Método de pago no soportado para garantía' };\n    } catch (err) {\n      const errorMsg = err instanceof Error ? err.message : 'Error inesperado';\n      this.logger.error(\n        'lockSecurityDeposit exception',\n        'BookingWalletService',\n        err instanceof Error ? err : new Error(errorMsg),\n      );\n      return { ok: false, error: errorMsg };\n    }\n  }\n\n  /**\n   * Release security deposit when rental ends without issues\n   */\n  async releaseSecurityDeposit(\n    booking: Booking,\n    description?: string,\n  ): Promise<{ ok: boolean; error?: string }> {\n    try {\n      if (booking.wallet_status !== 'locked') {\n        return { ok: false, error: 'No security deposit is locked for this booking' };\n      }\n\n      // Unlock funds\n      const unlockResult = await firstValueFrom(\n        this.walletService.unlockFunds(\n          booking.id,\n          description || `Garantía liberada - Sin daños - Reserva ${booking.id.substring(0, 8)}`,\n        ),\n      );\n\n      if (!unlockResult.success) {\n        return { ok: false, error: unlockResult.message };\n      }\n\n      return { ok: true };\n    } catch (err) {\n      const errorMsg = err instanceof Error ? err.message : 'Error inesperado';\n      return { ok: false, error: errorMsg };\n    }\n  }\n\n  /**\n   * Deduct from security deposit for damages\n   * P0-SECURITY: Uses atomic RPC function to prevent partial state\n   *\n   * All operations (deduct from renter, pay to owner, update booking)\n   * happen in a single database transaction. If any step fails,\n   * everything is rolled back automatically.\n   */\n  async deductFromSecurityDeposit(\n    booking: Booking,\n    damageAmountCents: number,\n    damageDescription: string,\n  ): Promise<{ ok: boolean; remaining_deposit?: number; error?: string }> {\n    try {\n      if (!booking.user_id || !booking.owner_id) {\n        return { ok: false, error: 'Booking missing user_id or owner_id' };\n      }\n\n      if (booking.wallet_status !== 'locked') {\n        return { ok: false, error: 'No security deposit is locked for this booking' };\n      }\n\n      // P0-SECURITY: Use atomic RPC function instead of multiple inserts\n      // This ensures all operations succeed or fail together\n      const { data, error } = await this.supabase.rpc('wallet_deduct_damage_atomic', {\n        p_booking_id: booking.id,\n        p_renter_id: booking.user_id,\n        p_owner_id: booking.owner_id,\n        p_damage_amount_cents: damageAmountCents,\n        p_damage_description: damageDescription,\n        p_car_id: booking.car_id,\n      });\n\n      if (error) {\n        this.logger.error('Atomic damage deduction failed', 'BookingWalletService', error as Error);\n        return { ok: false, error: error.message };\n      }\n\n      // Parse the JSONB result from the RPC\n      const result = data as {\n        ok: boolean;\n        remaining_deposit?: number;\n        damage_charged?: number;\n        original_deposit?: number;\n        error?: string;\n        error_code?: string;\n      };\n\n      if (!result.ok) {\n        return {\n          ok: false,\n          error: result.error || 'Error en transacción atómica de deducción',\n        };\n      }\n\n      this.logger.info(\n        `Atomic damage deduction successful: ${damageAmountCents / 100} charged, ` +\n          `${(result.remaining_deposit ?? 0) / 100} remaining`,\n      );\n\n      return {\n        ok: true,\n        remaining_deposit: result.remaining_deposit,\n      };\n    } catch (err) {\n      const errorMsg = err instanceof Error ? err.message : 'Error inesperado';\n      this.logger.error(\n        'deductFromSecurityDeposit exception',\n        'BookingWalletService',\n        err instanceof Error ? err : new Error(errorMsg),\n      );\n      return { ok: false, error: errorMsg };\n    }\n  }\n\n  /**\n   * Unlock wallet funds for a cancelled booking\n   */\n  async unlockFundsForCancellation(\n    booking: Booking,\n    reason?: string,\n  ): Promise<{ ok: boolean; error?: string }> {\n    try {\n      if (booking.wallet_status !== 'locked' || !booking.wallet_lock_transaction_id) {\n        return { ok: true }; // Nothing to unlock\n      }\n\n      const unlockResult = await firstValueFrom(\n        this.walletService.unlockFunds(\n          booking.id,\n          `Fondos desbloqueados por cancelación: ${reason ?? 'Cancelled by user'}`,\n        ),\n      );\n\n      if (!unlockResult.success) {\n        this.logger.error(\n          'Failed to unlock funds',\n          'BookingWalletService',\n          new Error(unlockResult.message),\n        );\n        return { ok: false, error: unlockResult.message };\n      }\n\n      return { ok: true };\n    } catch (err) {\n      const errorMsg = err instanceof Error ? err.message : 'Error inesperado';\n      return { ok: false, error: errorMsg };\n    }\n  }\n\n  /**\n   * Notifica al dueño del auto sobre un pago recibido\n   */\n  private async notifyOwnerOfPaymentReceived(booking: Booking, amountCents: number): Promise<void> {\n    try {\n      if (!booking.owner_id || !booking.car_id) return;\n\n      const amount = amountCents / 100; // Convertir centavos a pesos\n      const bookingUrl = `/bookings/owner/${booking.id}`;\n\n      this.carOwnerNotifications.notifyPaymentReceived(amount, booking.id, bookingUrl);\n    } catch (error) {\n      this.logger.warn(\n        'Failed to notify owner about payment received',\n        'BookingWalletService',\n        error instanceof Error ? error : new Error(String(error)),\n      );\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/core/services/bookings/bookings.service.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`@core/services/cars/cars.service` import should occur before import of `../models`","line":11,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":64,"fix":{"range":[52,736],"text":"import { CarsService } from '@core/services/cars/cars.service';\nimport { Booking, BookingExtensionRequest } from '../models';\nimport { getErrorMessage } from '../utils/type-guards';\nimport { BookingApprovalService } from './booking-approval.service';\nimport { BookingCancellationService } from './booking-cancellation.service';\nimport { BookingCompletionService } from './booking-completion.service';\nimport { BookingUtilsService } from './booking-utils.service';\nimport { BookingValidationService } from './booking-validation.service';\nimport { BookingWalletService } from './booking-wallet.service';\nimport { CarOwnerNotificationsService } from './car-owner-notifications.service';\n"}},{"ruleId":"import/order","severity":1,"message":"`@core/services/infrastructure/logger.service` import should occur before import of `../models`","line":14,"column":1,"nodeType":"ImportDeclaration","endLine":14,"endColumn":78,"fix":{"range":[52,949],"text":"import { LoggerService } from '@core/services/infrastructure/logger.service';\nimport { Booking, BookingExtensionRequest } from '../models';\nimport { getErrorMessage } from '../utils/type-guards';\nimport { BookingApprovalService } from './booking-approval.service';\nimport { BookingCancellationService } from './booking-cancellation.service';\nimport { BookingCompletionService } from './booking-completion.service';\nimport { BookingUtilsService } from './booking-utils.service';\nimport { BookingValidationService } from './booking-validation.service';\nimport { BookingWalletService } from './booking-wallet.service';\nimport { CarOwnerNotificationsService } from './car-owner-notifications.service';\nimport { CarsService } from '@core/services/cars/cars.service';\nimport { BookingNotificationsService } from './booking-notifications.service';\nimport { InsuranceService } from './insurance.service';\n"}},{"ruleId":"import/order","severity":1,"message":"`@core/services/auth/profile.service` import should occur before import of `../models`","line":15,"column":1,"nodeType":"ImportDeclaration","endLine":15,"endColumn":70,"fix":{"range":[52,1019],"text":"import { ProfileService } from '@core/services/auth/profile.service';\nimport { Booking, BookingExtensionRequest } from '../models';\nimport { getErrorMessage } from '../utils/type-guards';\nimport { BookingApprovalService } from './booking-approval.service';\nimport { BookingCancellationService } from './booking-cancellation.service';\nimport { BookingCompletionService } from './booking-completion.service';\nimport { BookingUtilsService } from './booking-utils.service';\nimport { BookingValidationService } from './booking-validation.service';\nimport { BookingWalletService } from './booking-wallet.service';\nimport { CarOwnerNotificationsService } from './car-owner-notifications.service';\nimport { CarsService } from '@core/services/cars/cars.service';\nimport { BookingNotificationsService } from './booking-notifications.service';\nimport { InsuranceService } from './insurance.service';\nimport { LoggerService } from '@core/services/infrastructure/logger.service';\n"}},{"ruleId":"import/order","severity":1,"message":"`@core/services/infrastructure/pwa.service` import should occur before import of `../models`","line":16,"column":1,"nodeType":"ImportDeclaration","endLine":16,"endColumn":72,"fix":{"range":[52,1091],"text":"import { PwaService } from '@core/services/infrastructure/pwa.service';\nimport { Booking, BookingExtensionRequest } from '../models';\nimport { getErrorMessage } from '../utils/type-guards';\nimport { BookingApprovalService } from './booking-approval.service';\nimport { BookingCancellationService } from './booking-cancellation.service';\nimport { BookingCompletionService } from './booking-completion.service';\nimport { BookingUtilsService } from './booking-utils.service';\nimport { BookingValidationService } from './booking-validation.service';\nimport { BookingWalletService } from './booking-wallet.service';\nimport { CarOwnerNotificationsService } from './car-owner-notifications.service';\nimport { CarsService } from '@core/services/cars/cars.service';\nimport { BookingNotificationsService } from './booking-notifications.service';\nimport { InsuranceService } from './insurance.service';\nimport { LoggerService } from '@core/services/infrastructure/logger.service';\nimport { ProfileService } from '@core/services/auth/profile.service';\n"}},{"ruleId":"import/order","severity":1,"message":"`@core/services/infrastructure/supabase-client.service` import should occur before import of `../models`","line":17,"column":1,"nodeType":"ImportDeclaration","endLine":17,"endColumn":88,"fix":{"range":[52,1179],"text":"import { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\nimport { Booking, BookingExtensionRequest } from '../models';\nimport { getErrorMessage } from '../utils/type-guards';\nimport { BookingApprovalService } from './booking-approval.service';\nimport { BookingCancellationService } from './booking-cancellation.service';\nimport { BookingCompletionService } from './booking-completion.service';\nimport { BookingUtilsService } from './booking-utils.service';\nimport { BookingValidationService } from './booking-validation.service';\nimport { BookingWalletService } from './booking-wallet.service';\nimport { CarOwnerNotificationsService } from './car-owner-notifications.service';\nimport { CarsService } from '@core/services/cars/cars.service';\nimport { BookingNotificationsService } from './booking-notifications.service';\nimport { InsuranceService } from './insurance.service';\nimport { LoggerService } from '@core/services/infrastructure/logger.service';\nimport { ProfileService } from '@core/services/auth/profile.service';\nimport { PwaService } from '@core/services/infrastructure/pwa.service';\n"}},{"ruleId":"import/order","severity":1,"message":"`@core/services/infrastructure/tiktok-events.service` import should occur before import of `../models`","line":18,"column":1,"nodeType":"ImportDeclaration","endLine":18,"endColumn":91,"fix":{"range":[52,1270],"text":"import { TikTokEventsService } from '@core/services/infrastructure/tiktok-events.service';\nimport { Booking, BookingExtensionRequest } from '../models';\nimport { getErrorMessage } from '../utils/type-guards';\nimport { BookingApprovalService } from './booking-approval.service';\nimport { BookingCancellationService } from './booking-cancellation.service';\nimport { BookingCompletionService } from './booking-completion.service';\nimport { BookingUtilsService } from './booking-utils.service';\nimport { BookingValidationService } from './booking-validation.service';\nimport { BookingWalletService } from './booking-wallet.service';\nimport { CarOwnerNotificationsService } from './car-owner-notifications.service';\nimport { CarsService } from '@core/services/cars/cars.service';\nimport { BookingNotificationsService } from './booking-notifications.service';\nimport { InsuranceService } from './insurance.service';\nimport { LoggerService } from '@core/services/infrastructure/logger.service';\nimport { ProfileService } from '@core/services/auth/profile.service';\nimport { PwaService } from '@core/services/infrastructure/pwa.service';\nimport { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\n"}},{"ruleId":"import/order","severity":1,"message":"`@core/services/payments/wallet.service` import should occur before import of `../models`","line":19,"column":1,"nodeType":"ImportDeclaration","endLine":19,"endColumn":72,"fix":{"range":[52,1342],"text":"import { WalletService } from '@core/services/payments/wallet.service';\nimport { Booking, BookingExtensionRequest } from '../models';\nimport { getErrorMessage } from '../utils/type-guards';\nimport { BookingApprovalService } from './booking-approval.service';\nimport { BookingCancellationService } from './booking-cancellation.service';\nimport { BookingCompletionService } from './booking-completion.service';\nimport { BookingUtilsService } from './booking-utils.service';\nimport { BookingValidationService } from './booking-validation.service';\nimport { BookingWalletService } from './booking-wallet.service';\nimport { CarOwnerNotificationsService } from './car-owner-notifications.service';\nimport { CarsService } from '@core/services/cars/cars.service';\nimport { BookingNotificationsService } from './booking-notifications.service';\nimport { InsuranceService } from './insurance.service';\nimport { LoggerService } from '@core/services/infrastructure/logger.service';\nimport { ProfileService } from '@core/services/auth/profile.service';\nimport { PwaService } from '@core/services/infrastructure/pwa.service';\nimport { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\nimport { TikTokEventsService } from '@core/services/infrastructure/tiktok-events.service';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":7,"source":"import { Injectable, inject } from '@angular/core';\nimport { Booking, BookingExtensionRequest } from '../models';\nimport { getErrorMessage } from '../utils/type-guards';\nimport { BookingApprovalService } from './booking-approval.service';\nimport { BookingCancellationService } from './booking-cancellation.service';\nimport { BookingCompletionService } from './booking-completion.service';\nimport { BookingUtilsService } from './booking-utils.service';\nimport { BookingValidationService } from './booking-validation.service';\nimport { BookingWalletService } from './booking-wallet.service';\nimport { CarOwnerNotificationsService } from './car-owner-notifications.service';\nimport { CarsService } from '@core/services/cars/cars.service';\nimport { BookingNotificationsService } from './booking-notifications.service';\nimport { InsuranceService } from './insurance.service';\nimport { LoggerService } from '@core/services/infrastructure/logger.service';\nimport { ProfileService } from '@core/services/auth/profile.service';\nimport { PwaService } from '@core/services/infrastructure/pwa.service';\nimport { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\nimport { TikTokEventsService } from '@core/services/infrastructure/tiktok-events.service';\nimport { WalletService } from '@core/services/payments/wallet.service';\n\nconst UUID_REGEX = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/;\n\ntype BookingWithMetadata = Booking & {\n  car?: { title?: string | null } | null;\n  price_per_day?: number | null;\n};\n\n/**\n * Core booking service\n * Handles CRUD operations and coordinates with specialized booking services\n * Refactored from 1,427 lines to ~400 lines by extracting responsibilities\n */\n@Injectable({\n  providedIn: 'root',\n})\nexport class BookingsService {\n  private readonly supabase = injectSupabase();\n  private readonly pwaService = inject(PwaService);\n  private readonly insuranceService = inject(InsuranceService);\n  private readonly logger = inject(LoggerService);\n  private readonly tiktokEvents = inject(TikTokEventsService);\n\n  // Specialized booking services\n  private readonly bookingWalletService = inject(BookingWalletService);\n  private readonly walletService = inject(WalletService);\n  private readonly approvalService = inject(BookingApprovalService);\n  private readonly completionService = inject(BookingCompletionService);\n  private readonly validationService = inject(BookingValidationService);\n  private readonly cancellationService = inject(BookingCancellationService);\n  private readonly utilsService = inject(BookingUtilsService);\n\n  // Notification services\n  private readonly carOwnerNotifications = inject(CarOwnerNotificationsService);\n  private readonly bookingNotifications = inject(BookingNotificationsService);\n  private readonly carsService = inject(CarsService);\n  private readonly profileService = inject(ProfileService);\n\n  // ============================================================================\n  // CORE CRUD OPERATIONS\n  // ============================================================================\n\n  /**\n   * Request a new booking\n   * ✅ NEW: Supports dynamic pricing with price locks\n   */\n  async requestBooking(\n    carId: string,\n    start: string,\n    end: string,\n    options?: {\n      useDynamicPricing?: boolean;\n      priceLockToken?: string;\n      dynamicPriceSnapshot?: Record<string, unknown>;\n    },\n  ): Promise<Booking> {\n    const { data, error } = await this.supabase.rpc('request_booking', {\n      p_car_id: carId,\n      p_start: start,\n      p_end: end,\n      // ✅ FIX: Add missing location parameters (defaults to null/false for basic booking)\n      p_pickup_lat: null,\n      p_pickup_lng: null,\n      p_dropoff_lat: null,\n      p_dropoff_lng: null,\n      p_delivery_required: false,\n      // ✅ DYNAMIC PRICING: Pass optional parameters\n      p_use_dynamic_pricing: options?.useDynamicPricing || false,\n      p_price_lock_token: options?.priceLockToken || null,\n      p_dynamic_price_snapshot: options?.dynamicPriceSnapshot || null,\n    });\n\n    if (error) {\n      const errorMessage = error.message || error.details || 'Error al crear la reserva';\n\n      this.logger.error(\n        'request_booking RPC failed: ' +\n        JSON.stringify({\n          error,\n          carId,\n          start,\n          end,\n          message: errorMessage,\n          code: error.code,\n          details: error.details,\n          hint: error.hint,\n        }),\n      );\n\n      // Fallback para entornos desactualizados o cambios de esquema\n      const needsFallback =\n        error.code === '42703' ||\n        errorMessage.toLowerCase().includes('pickup_lat') ||\n        errorMessage.toLowerCase().includes('faltan parámetros');\n\n      if (needsFallback) {\n        this.logger.warn(\n          'Falling back to direct booking insert (schema mismatch)',\n          'BookingsService',\n        );\n        return await this.fallbackDirectBookingInsert(carId, start, end);\n      }\n\n      throw new Error(errorMessage);\n    }\n\n    // ✅ DEBUG: Log the RPC response to understand what's returned\n    this.logger.info(\n      `request_booking RPC response: ${JSON.stringify({\n        data,\n        dataType: typeof data,\n        dataKeys: data ? Object.keys(data) : [],\n        hasId: data?.id !== undefined,\n        id: data?.id,\n        bookingId: data?.booking_id,\n      })}`,\n      'BookingsService',\n    );\n\n    const bookingId = this.utilsService.extractBookingId(data);\n    if (!bookingId) {\n      this.logger.error(\n        `Failed to extract booking ID from RPC response: ${JSON.stringify({\n          data,\n          dataType: typeof data,\n          dataKeys: data ? Object.keys(data) : [],\n        })}`,\n        'BookingsService',\n      );\n      throw new Error('request_booking did not return a booking id');\n    }\n\n    // ✅ P0-003 FIX: Activate insurance coverage with retry and BLOCK if fails\n    await this.activateInsuranceWithRetry(bookingId, []);\n\n    // Recalculate pricing breakdown\n    await this.recalculatePricing(bookingId);\n\n    // Fetch the updated booking\n    const updated = await this.getBookingById(bookingId);\n    const finalBooking = updated || { ...(data as Booking), id: bookingId };\n\n    // 🎯 TikTok Events: Track PlaceAnOrder\n    const placeOrderContentName = this.getBookingCarTitle(finalBooking);\n    void this.tiktokEvents.trackPlaceAnOrder({\n      contentId: finalBooking.car_id,\n      contentName: placeOrderContentName,\n      value: finalBooking.total_amount || 0,\n      currency: finalBooking.currency || 'ARS',\n    });\n\n    // ✅ NUEVO: Notificar al dueño del auto sobre la nueva solicitud de reserva\n    this.notifyOwnerOfNewBooking(finalBooking).catch((notificationError) => {\n      this.logger.warn(\n        'Failed to notify owner of new booking request',\n        'BookingsService',\n        notificationError instanceof Error\n          ? notificationError\n          : new Error(getErrorMessage(notificationError)),\n      );\n    });\n\n    return finalBooking;\n  }\n\n  /**\n   * Request a new booking with location data\n   * ✅ NEW: Supports pickup/dropoff locations and delivery fees\n   */\n  async requestBookingWithLocation(\n    carId: string,\n    start: string,\n    end: string,\n    locationData: {\n      pickupLat: number;\n      pickupLng: number;\n      dropoffLat: number;\n      dropoffLng: number;\n      deliveryRequired: boolean;\n      distanceKm: number;\n      deliveryFeeCents: number;\n      distanceTier: 'local' | 'regional' | 'long_distance';\n    },\n  ): Promise<Booking> {\n    const { data, error } = await this.supabase.rpc('request_booking', {\n      p_car_id: carId,\n      p_start: start,\n      p_end: end,\n      p_pickup_lat: locationData.pickupLat,\n      p_pickup_lng: locationData.pickupLng,\n      p_dropoff_lat: locationData.dropoffLat,\n      p_dropoff_lng: locationData.dropoffLng,\n      p_delivery_required: locationData.deliveryRequired,\n      p_delivery_distance_km: locationData.distanceKm,\n      p_delivery_fee_cents: locationData.deliveryFeeCents,\n      p_distance_risk_tier: locationData.distanceTier,\n    });\n\n    if (error) {\n      const errorMessage = error.message || error.details || 'Error al crear la reserva';\n\n      this.logger.error(\n        'requestBookingWithLocation RPC failed: ' +\n        JSON.stringify({\n          error,\n          carId,\n          start,\n          end,\n          locationData,\n          message: errorMessage,\n          code: error.code,\n          details: error.details,\n          hint: error.hint,\n        }),\n      );\n\n      throw new Error(errorMessage);\n    }\n\n    const bookingId = this.utilsService.extractBookingId(data);\n    if (!bookingId) {\n      throw new Error('request_booking did not return a booking id');\n    }\n\n    // ✅ P0-003 FIX: Activate insurance coverage with retry and BLOCK if fails\n    await this.activateInsuranceWithRetry(bookingId, []);\n\n    // Recalculate pricing breakdown\n    await this.recalculatePricing(bookingId);\n\n    // Fetch the updated booking\n    const updated = await this.getBookingById(bookingId);\n    const finalBooking = updated || { ...(data as Booking), id: bookingId };\n\n    // 🎯 TikTok Events: Track PlaceAnOrder\n    const placeOrderWithLocationContentName = this.getBookingCarTitle(finalBooking);\n    void this.tiktokEvents.trackPlaceAnOrder({\n      contentId: finalBooking.car_id,\n      contentName: placeOrderWithLocationContentName,\n      value: finalBooking.total_amount || 0,\n      currency: finalBooking.currency || 'ARS',\n    });\n\n    return finalBooking;\n  }\n\n  /**\n   * Get bookings for current user using the my_bookings view\n   * ✅ P1-025: Now supports pagination\n   */\n  async getMyBookings(options?: {\n    limit?: number;\n    offset?: number;\n    status?: string;\n  }): Promise<{ bookings: Booking[]; total: number }> {\n    const limit = options?.limit ?? 20; // Default: 20 items per page\n    const offset = options?.offset ?? 0;\n\n    let query = this.supabase\n      .from('my_bookings')\n      .select('*', { count: 'exact' })\n      .order('created_at', { ascending: false })\n      .range(offset, offset + limit - 1);\n\n    // Optional status filter\n    if (options?.status) {\n      query = query.eq('status', options.status);\n    }\n\n    const { data, error, count } = await query;\n\n    if (error) throw error;\n\n    const bookings = (data ?? []) as Booking[];\n    await this.updateAppBadge(bookings);\n\n    return {\n      bookings,\n      total: count ?? 0,\n    };\n  }\n\n  /**\n   * Get bookings for cars owned by current user\n   * ✅ P1-025: Now supports pagination\n   */\n  async getOwnerBookings(options?: {\n    limit?: number;\n    offset?: number;\n    status?: string;\n  }): Promise<{ bookings: Booking[]; total: number }> {\n    const limit = options?.limit ?? 20; // Default: 20 items per page\n    const offset = options?.offset ?? 0;\n\n    let query = this.supabase\n      .from('owner_bookings')\n      .select('*', { count: 'exact' })\n      .order('created_at', { ascending: false })\n      .range(offset, offset + limit - 1);\n\n    // Optional status filter\n    if (options?.status) {\n      query = query.eq('status', options.status);\n    }\n\n    const { data, error, count } = await query;\n\n    if (error) throw error;\n\n    return {\n      bookings: (data ?? []) as Booking[],\n      total: count ?? 0,\n    };\n  }\n\n  /**\n   * Get owner booking by ID (owner view only)\n   */\n  async getOwnerBookingById(bookingId: string): Promise<Booking | null> {\n    if (!UUID_REGEX.test(bookingId)) {\n      this.logger.warn(`getOwnerBookingById: invalid bookingId - ${bookingId}`);\n      return null;\n    }\n\n    return this.fetchBookingFromView('owner_bookings', bookingId);\n  }\n\n  async getRenterVerificationForOwner(bookingId: string): Promise<Record<string, unknown> | null> {\n    const { data, error } = await this.supabase.rpc('get_renter_verification_for_owner', {\n      p_booking_id: bookingId,\n    });\n\n    if (error) {\n      return null;\n    }\n\n    if (!data) return null;\n    return Array.isArray(data) ? (data[0] as Record<string, unknown> | null) : (data as Record<string, unknown> | null);\n  }\n\n  /**\n   * Get booking by ID with full details\n   * ✅ OPTIMIZED: Parallel loading of car details and insurance coverage\n   */\n  async getBookingById(bookingId: string): Promise<Booking | null> {\n    // Evita llamadas inválidas (previene 400 de PostgREST por UUID mal formado)\n    if (!UUID_REGEX.test(bookingId)) {\n      this.logger.warn(`getBookingById: invalid bookingId - ${bookingId}`);\n      return null;\n    }\n\n    const booking =\n      (await this.fetchBookingFromView('my_bookings', bookingId)) ??\n      (await this.fetchBookingFromView('owner_bookings', bookingId));\n\n    if (!booking) return null;\n\n    // ✅ OPTIMIZED: Load car details and insurance coverage in parallel\n    const loadPromises: Promise<void>[] = [];\n\n    if (booking?.car_id) {\n      loadPromises.push(this.loadCarDetails(booking));\n    }\n\n    if (booking?.insurance_coverage_id) {\n      loadPromises.push(this.loadInsuranceCoverage(booking));\n    }\n\n    if (loadPromises.length > 0) {\n      await Promise.all(loadPromises);\n    }\n\n    return booking;\n  }\n\n  private async fetchBookingFromView(\n    viewName: 'my_bookings' | 'owner_bookings',\n    bookingId: string,\n  ): Promise<Booking | null> {\n    const { data, error } = await this.supabase\n      .from(viewName)\n      .select('*')\n      .eq('id', bookingId)\n      .maybeSingle();\n\n    if (error) {\n      throw error;\n    }\n\n    return data as Booking;\n  }\n\n  /**\n   * Recalculate pricing breakdown for a booking\n   */\n  async recalculatePricing(bookingId: string): Promise<void> {\n    const { error } = await this.supabase.rpc('pricing_recalculate', {\n      p_booking_id: bookingId,\n    });\n\n    if (error) throw error;\n  }\n\n  /**\n   * Update booking fields\n   */\n  async updateBooking(bookingId: string, updates: Partial<Booking>): Promise<Booking> {\n    const { data, error } = await this.supabase\n      .from('bookings')\n      .update(updates)\n      .eq('id', bookingId)\n      .select()\n      .single();\n\n    if (error) throw error;\n    return data as Booking;\n  }\n\n  /**\n   * Mark booking as paid\n   */\n  async markAsPaid(bookingId: string, paymentIntentId: string): Promise<void> {\n    // Fetch booking details before updating\n    const booking = await this.getBookingById(bookingId);\n\n    const { error } = await this.supabase\n      .from('bookings')\n      .update({\n        status: 'confirmed',\n        payment_intent_id: paymentIntentId,\n        paid_at: new Date().toISOString(),\n      })\n      .eq('id', bookingId);\n\n    if (error) throw error;\n\n    // 🎯 TikTok Events: Track Purchase\n    if (booking) {\n      const purchaseContentName = this.getBookingCarTitle(booking);\n      void this.tiktokEvents.trackPurchase({\n        contentId: booking.car_id,\n        contentName: purchaseContentName,\n        value: booking.total_amount || 0,\n        currency: booking.currency || 'ARS',\n      });\n    }\n  }\n\n  /**\n   * Get owner contact information\n   */\n  async getOwnerContact(ownerId: string): Promise<{\n    success: boolean;\n    email?: string;\n    phone?: string;\n    name?: string;\n    error?: string;\n  }> {\n    try {\n      const { data, error } = await this.supabase\n        .from('profiles')\n        .select('email, phone, full_name')\n        .eq('id', ownerId)\n        .maybeSingle();\n\n      if (error || !data) {\n        return {\n          success: false,\n          error: 'No se pudo obtener información del propietario',\n        };\n      }\n\n      return {\n        success: true,\n        email: data.email,\n        phone: data.phone || undefined,\n        name: data.full_name || undefined,\n      };\n    } catch (_error) {\n      return {\n        success: false,\n        error: _error instanceof Error ? _error.message : 'Unknown error',\n      };\n    }\n  }\n\n  // ============================================================================\n  // ATOMIC BOOKING CREATION\n  // ============================================================================\n\n  /**\n   * Create booking atomically with risk snapshot\n   * Prevents \"phantom bookings\" using a single transaction\n   * ✅ NEW: Supports dynamic pricing with price locks\n   */\n  async createBookingAtomic(params: {\n    carId: string;\n    startDate: string;\n    endDate: string;\n    totalAmount: number;\n    currency: string;\n    paymentMode: string;\n    coverageUpgrade?: string;\n    authorizedPaymentId?: string;\n    walletLockId?: string;\n    distanceKm?: number;\n    distanceTier?: 'local' | 'regional' | 'long_distance';\n    deliveryFeeCents?: number;\n    // ✅ DYNAMIC PRICING: New parameters\n    useDynamicPricing?: boolean;\n    priceLockToken?: string;\n    dynamicPriceSnapshot?: Record<string, unknown>;\n    riskSnapshot: {\n      dailyPriceUsd: number;\n      securityDepositUsd: number;\n      vehicleValueUsd: number;\n      driverAge: number;\n      coverageType: string;\n      paymentMode: string;\n      totalUsd: number;\n      totalArs: number;\n      exchangeRate: number;\n    };\n  }): Promise<{\n    success: boolean;\n    bookingId?: string;\n    riskSnapshotId?: string;\n    error?: string;\n  }> {\n    try {\n      const user = await this.supabase.auth.getUser();\n      if (!user.data.user?.id) {\n        return {\n          success: false,\n          error: 'Usuario no autenticado',\n        };\n      }\n\n      const { data, error } = await this.supabase.rpc('create_booking_atomic', {\n        p_car_id: params.carId,\n        p_renter_id: user.data.user.id,\n        p_start_date: params.startDate,\n        p_end_date: params.endDate,\n        p_total_amount: params.totalAmount,\n        p_currency: params.currency,\n        p_payment_mode: params.paymentMode,\n        p_coverage_upgrade: params.coverageUpgrade || null,\n        p_authorized_payment_id: params.authorizedPaymentId || null,\n        p_wallet_lock_id: params.walletLockId || null,\n        p_risk_daily_price_usd: params.riskSnapshot.dailyPriceUsd,\n        p_risk_security_deposit_usd: params.riskSnapshot.securityDepositUsd,\n        p_risk_vehicle_value_usd: params.riskSnapshot.vehicleValueUsd,\n        p_risk_driver_age: params.riskSnapshot.driverAge,\n        p_risk_coverage_type: params.riskSnapshot.coverageType,\n        p_risk_payment_mode: params.riskSnapshot.paymentMode,\n        p_risk_total_usd: params.riskSnapshot.totalUsd,\n        p_risk_total_ars: params.riskSnapshot.totalArs,\n        p_risk_exchange_rate: params.riskSnapshot.exchangeRate,\n        p_distance_km: params.distanceKm || null,\n        p_distance_risk_tier: params.distanceTier || null,\n        p_delivery_fee_cents: params.deliveryFeeCents || 0,\n        // ✅ DYNAMIC PRICING: Pass new parameters\n        p_use_dynamic_pricing: params.useDynamicPricing || false,\n        p_price_lock_token: params.priceLockToken || null,\n        p_dynamic_price_snapshot: params.dynamicPriceSnapshot || null,\n      });\n\n      if (error) {\n        return {\n          success: false,\n          error: error instanceof Error ? error.message : 'Error al crear la reserva',\n        };\n      }\n\n      const result = Array.isArray(data) ? data[0] : data;\n\n      if (!result || !result.success) {\n        return {\n          success: false,\n          error: result?.error_message || 'Error desconocido al crear la reserva',\n        };\n      }\n\n      // ✅ P0-003: Insurance is mandatory — block booking if it fails\n      await this.activateInsuranceWithRetry(result.booking_id, []);\n\n      return {\n        success: true,\n        bookingId: result.booking_id,\n        riskSnapshotId: result.risk_snapshot_id,\n      };\n    } catch (error: unknown) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Error inesperado al crear la reserva',\n      };\n    }\n  }\n\n  // ============================================================================\n  // DELEGATED OPERATIONS (Use specialized services)\n  // ============================================================================\n\n  // Wallet Operations\n  async chargeRentalFromWallet(\n    bookingId: string,\n    amountCents: number,\n    _description?: string,\n  ): Promise<{ ok: boolean; error?: string }> {\n    const booking = await this.getBookingById(bookingId);\n    if (!booking) return { ok: false, error: 'Booking not found' };\n\n    const result = await this.bookingWalletService.chargeRentalFromWallet(\n      booking,\n      amountCents,\n      // description omitted to fix signature mismatch\n    );\n    if (result.ok) {\n      await this.updateBooking(bookingId, {\n        status: 'completed',\n        wallet_status: 'charged',\n        paid_at: new Date().toISOString(),\n      });\n    }\n    return result;\n  }\n\n  async processRentalPayment(\n    bookingId: string,\n    amountCents: number,\n    description?: string,\n  ): Promise<{ ok: boolean; error?: string }> {\n    const booking = await this.getBookingById(bookingId);\n    if (!booking) return { ok: false, error: 'Booking not found' };\n\n    return this.bookingWalletService.processRentalPayment(booking, amountCents, description);\n  }\n\n  async lockSecurityDeposit(\n    bookingId: string,\n    depositAmountCents: number,\n    description?: string,\n  ): Promise<{ ok: boolean; transaction_id?: string; error?: string }> {\n    const booking = await this.getBookingById(bookingId);\n    if (!booking) return { ok: false, error: 'Booking not found' };\n\n    const result = await this.bookingWalletService.lockSecurityDeposit(\n      booking,\n      depositAmountCents,\n      'wallet',\n      description,\n    );\n    if (result.ok) {\n      await this.updateBooking(bookingId, {\n        wallet_status: 'locked',\n        wallet_lock_transaction_id: result.transaction_id,\n      });\n    }\n    return result;\n  }\n\n  async releaseSecurityDeposit(\n    bookingId: string,\n    description?: string,\n  ): Promise<{ ok: boolean; error?: string }> {\n    const booking = await this.getBookingById(bookingId);\n    if (!booking) return { ok: false, error: 'Booking not found' };\n\n    const result = await this.bookingWalletService.releaseSecurityDeposit(booking, description);\n    if (result.ok) {\n      await this.updateBooking(bookingId, { wallet_status: 'refunded' });\n    }\n    return result;\n  }\n\n  async deductFromSecurityDeposit(\n    bookingId: string,\n    damageAmountCents: number,\n    damageDescription: string,\n  ): Promise<{ ok: boolean; remaining_deposit?: number; error?: string }> {\n    const booking = await this.getBookingById(bookingId);\n    if (!booking) return { ok: false, error: 'Booking not found' };\n\n    const result = await this.bookingWalletService.deductFromSecurityDeposit(\n      booking,\n      damageAmountCents,\n      damageDescription,\n    );\n\n    if (result.ok) {\n      const remainingDeposit = result.remaining_deposit ?? 0;\n      await this.updateBooking(bookingId, {\n        wallet_status: remainingDeposit > 0 ? 'partially_charged' : 'charged',\n      });\n    }\n\n    return result;\n  }\n\n  // Approval Operations\n  async getPendingApprovals(): Promise<Record<string, unknown>[]> {\n    return this.approvalService.getPendingApprovals();\n  }\n\n  async approveBooking(\n    bookingId: string,\n  ): Promise<{ success: boolean; error?: string; message?: string }> {\n    return this.approvalService.approveBooking(bookingId);\n  }\n\n  async rejectBooking(\n    bookingId: string,\n    reason?: string,\n  ): Promise<{ success: boolean; error?: string; message?: string }> {\n    return this.approvalService.rejectBooking(bookingId, reason);\n  }\n\n  async carRequiresApproval(carId: string): Promise<boolean> {\n    return this.approvalService.carRequiresApproval(carId);\n  }\n\n  // Completion Operations\n  async completeBookingClean(bookingId: string): Promise<{ success: boolean; error?: string }> {\n    const booking = await this.getBookingById(bookingId);\n    if (!booking) return { success: false, error: 'Booking not found' };\n\n    return this.completionService.completeBookingClean(booking, this.updateBooking.bind(this));\n  }\n\n  async completeBookingWithDamages(\n    bookingId: string,\n    damageAmountCents: number,\n    damageDescription: string,\n    claimSeverity: number = 1,\n  ): Promise<{ success: boolean; remaining_deposit?: number; error?: string }> {\n    const booking = await this.getBookingById(bookingId);\n    if (!booking) return { success: false, error: 'Booking not found' };\n\n    return this.completionService.completeBookingWithDamages(\n      booking,\n      damageAmountCents,\n      damageDescription,\n      claimSeverity,\n      this.updateBooking.bind(this),\n    );\n  }\n\n  // Validation Operations\n  async createBookingWithValidation(\n    carId: string,\n    startDate: string,\n    endDate: string,\n    locationData?: {\n      pickupLat: number;\n      pickupLng: number;\n      dropoffLat: number;\n      dropoffLng: number;\n      deliveryRequired: boolean;\n      distanceKm: number;\n      deliveryFeeCents: number;\n      distanceTier: 'local' | 'regional' | 'long_distance';\n    },\n  ): Promise<{\n    success: boolean;\n    booking?: Booking;\n    error?: string;\n    canWaitlist?: boolean;\n  }> {\n    // ✅ NEW: Use requestBookingWithLocation if location data is provided\n    const requestBookingCallback = locationData\n      ? (carId: string, startDate: string, endDate: string) =>\n        this.requestBookingWithLocation(carId, startDate, endDate, locationData)\n      : this.requestBooking.bind(this);\n\n    return this.validationService.createBookingWithValidation(\n      carId,\n      startDate,\n      endDate,\n      requestBookingCallback,\n    );\n  }\n\n  // Cancellation Operations\n  async cancelBooking(\n    bookingId: string,\n    force: boolean = false,\n  ): Promise<{ success: boolean; error?: string }> {\n    const booking = await this.getBookingById(bookingId);\n    if (!booking) return { success: false, error: 'Reserva no encontrada' };\n\n    return this.cancellationService.cancelBooking(booking, force);\n  }\n\n  async cancelBookingLegacy(bookingId: string, reason?: string): Promise<void> {\n    const booking = await this.getBookingById(bookingId);\n    if (!booking) throw new Error('Booking not found');\n\n    return this.cancellationService.cancelBookingLegacy(booking, reason);\n  }\n\n  // Extension Operations\n  /**\n   * Solicita una extensión de reserva.\n   * Crea una solicitud pendiente para aprobación del Owner.\n   */\n  async requestExtension(\n    bookingId: string,\n    newEndDate: Date,\n    renterMessage?: string,\n  ): Promise<{ success: boolean; error?: string; additionalCost?: number }> {\n    try {\n      const booking = await this.getBookingById(bookingId);\n      if (!booking) throw new Error('Reserva no encontrada');\n\n      if (newEndDate <= new Date(booking.end_at)) {\n        return { success: false, error: 'La nueva fecha debe ser posterior a la actual' };\n      }\n\n      const currentUser = (await this.supabase.auth.getUser()).data.user;\n      if (!currentUser || currentUser.id !== booking.renter_id) {\n        return { success: false, error: 'Solo el arrendatario puede solicitar una extensión.' };\n      }\n\n      // Calcular costo adicional ESTIMADO (puede variar al momento de la aprobación)\n      const currentEnd = new Date(booking.end_at);\n      const additionalDays = Math.ceil(\n        (newEndDate.getTime() - currentEnd.getTime()) / (1000 * 60 * 60 * 24),\n      );\n      if (additionalDays <= 0)\n        return { success: false, error: 'La nueva fecha debe ser posterior a la actual' };\n\n      const pricePerDay = this.getBookingPricePerDay(booking);\n      const estimatedAdditionalCostCents = Math.round(pricePerDay * additionalDays * 100);\n\n      // INSERT a new extension request\n      const { error: insertError } = await this.supabase\n        .from('booking_extension_requests')\n        .insert({\n          booking_id: booking.id,\n          renter_id: booking.renter_id,\n          owner_id: booking.owner_id || '', // owner_id is NOT NULL in DB, ensure it's set\n          original_end_at: booking.end_at,\n          new_end_at: newEndDate.toISOString(),\n          estimated_cost_amount: estimatedAdditionalCostCents / 100, // Store as actual amount\n          estimated_cost_currency: booking.currency,\n          renter_message: renterMessage || null,\n          request_status: 'pending',\n        })\n        .select('*')\n        .single();\n\n      if (insertError) throw insertError;\n\n      await this.bookingNotifications.notifyExtensionRequested(\n        booking,\n        newEndDate.toISOString(),\n        renterMessage,\n      );\n\n      return { success: true, additionalCost: estimatedAdditionalCostCents / 100 };\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Error al solicitar extensión',\n      };\n    }\n  }\n\n  /**\n   * Aprueba una solicitud de extensión de reserva.\n   * Extiende el booking y realiza el cobro.\n   */\n  async approveExtensionRequest(\n    requestId: string,\n    ownerResponse?: string,\n  ): Promise<{ success: boolean; error?: string }> {\n    try {\n      const existingRequest = await this.supabase\n        .from('booking_extension_requests')\n        .select('*')\n        .eq('id', requestId)\n        .single();\n\n      if (existingRequest.error || !existingRequest.data) {\n        throw new Error('Solicitud de extensión no encontrada.');\n      }\n\n      const request = existingRequest.data as BookingExtensionRequest;\n      if (request.request_status !== 'pending') {\n        throw new Error('La solicitud ya no está pendiente.');\n      }\n\n      const booking = await this.getBookingById(request.booking_id);\n      if (!booking) throw new Error('Reserva no encontrada');\n\n      const currentUser = (await this.supabase.auth.getUser()).data.user;\n      if (!currentUser || currentUser.id !== booking.owner_id) {\n        throw new Error('Solo el propietario puede aprobar una extensión.');\n      }\n\n      // 1. Cobrar el costo adicional al renter (assuming this logic is correct from original)\n      // This part needs to be carefully handled. The `additionalCost` in the request is estimated.\n      // Re-calculate the cost or trust the estimated one. For now, we trust the estimated one.\n      if (!request.estimated_cost_amount || !request.estimated_cost_currency) {\n        throw new Error('Faltan datos de costo estimado en la solicitud.');\n      }\n\n      // Assuming a new endpoint or helper is needed to process additional payment.\n      // For simplicity, let's assume `processRentalPayment` can handle additional charges.\n      const chargeResult = await this.bookingWalletService.processRentalPayment(\n        booking,\n        Math.round(request.estimated_cost_amount * 100), // Convert to cents\n        `Extensión de reserva #${booking.id} (${new Date(request.new_end_at).toLocaleDateString()})`,\n      );\n\n      if (!chargeResult.ok) {\n        throw new Error(`Fallo al cobrar extensión: ${chargeResult.error}`);\n      }\n\n      // 2. Actualizar la solicitud de extensión\n      const { error: updateRequestError } = await this.supabase\n        .from('booking_extension_requests')\n        .update({\n          request_status: 'approved',\n          responded_at: new Date().toISOString(),\n          owner_response: ownerResponse || null,\n        })\n        .eq('id', requestId);\n\n      if (updateRequestError) throw updateRequestError;\n\n      // 3. Actualizar la reserva con la nueva fecha y total\n      await this.updateBooking(booking.id, {\n        end_at: request.new_end_at,\n        total_amount: (booking.total_amount || 0) + request.estimated_cost_amount,\n      });\n\n      await this.extendInsuranceCoverageIfNeeded(booking.id, request.new_end_at);\n\n      return { success: true };\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Error al aprobar extensión',\n      };\n    }\n  }\n\n  /**\n   * Rechaza una solicitud de extensión de reserva.\n   */\n  async rejectExtensionRequest(\n    requestId: string,\n    reason: string,\n  ): Promise<{ success: boolean; error?: string }> {\n    try {\n      const existingRequest = await this.supabase\n        .from('booking_extension_requests')\n        .select('*')\n        .eq('id', requestId)\n        .single();\n\n      if (existingRequest.error || !existingRequest.data) {\n        throw new Error('Solicitud de extensión no encontrada.');\n      }\n\n      const request = existingRequest.data as BookingExtensionRequest;\n      if (request.request_status !== 'pending') {\n        throw new Error('La solicitud ya no está pendiente.');\n      }\n\n      const booking = await this.getBookingById(request.booking_id);\n      if (!booking) throw new Error('Reserva no encontrada');\n\n      const currentUser = (await this.supabase.auth.getUser()).data.user;\n      if (!currentUser || currentUser.id !== booking.owner_id) {\n        throw new Error('Solo el propietario puede rechazar una extensión.');\n      }\n\n      const { error: updateRequestError } = await this.supabase\n        .from('booking_extension_requests')\n        .update({\n          request_status: 'rejected',\n          responded_at: new Date().toISOString(),\n          owner_response: reason,\n        })\n        .eq('id', requestId);\n\n      if (updateRequestError) throw updateRequestError;\n\n      await this.bookingNotifications.notifyExtensionRejected(booking, reason);\n\n      return { success: true };\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Error al rechazar extensión',\n      };\n    }\n  }\n\n  private async extendInsuranceCoverageIfNeeded(\n    bookingId: string,\n    newEndAt: string,\n  ): Promise<void> {\n    try {\n      const { data: coverage, error } = await this.supabase\n        .from('booking_insurance_coverage')\n        .select('id, coverage_end')\n        .eq('booking_id', bookingId)\n        .eq('status', 'active')\n        .maybeSingle();\n\n      if (error) throw error;\n      if (!coverage) return;\n\n      const { error: updateError } = await this.supabase\n        .from('booking_insurance_coverage')\n        .update({\n          coverage_end: newEndAt,\n          updated_at: new Date().toISOString(),\n        })\n        .eq('id', coverage.id);\n\n      if (updateError) throw updateError;\n\n      this.logger.info('Insurance coverage extended', 'BookingsService', {\n        booking_id: bookingId,\n        new_end_at: newEndAt,\n      });\n    } catch (error) {\n      const message = error instanceof Error ? error.message : getErrorMessage(error);\n      this.logger.warn('Failed to extend insurance coverage; recorded issue', 'BookingsService', {\n        booking_id: bookingId,\n        new_end_at: newEndAt,\n        error: message,\n      });\n\n      try {\n        await this.createPaymentIssue({\n          booking_id: bookingId,\n          issue_type: 'insurance_extension_required',\n          severity: 'high',\n          description: 'Extensión de seguro pendiente luego de aprobar extensión de reserva',\n          metadata: {\n            new_end_at: newEndAt,\n            error: message,\n          },\n        });\n      } catch (issueError) {\n        this.logger.error('Failed to create insurance extension issue', 'BookingsService', issueError);\n      }\n    }\n  }\n\n\n  /**\n   * Rechaza el auto en el momento del retiro (Check-in)\n   * Caso de uso: Auto sucio, daños no reportados, no es el modelo correcto.\n   * Acción: Cancela reserva, reembolso 100% inmediato, penaliza al dueño.\n   */\n  async rejectCarAtPickup(\n    bookingId: string,\n    reason: string,\n    evidencePhotos: string[] = [],\n  ): Promise<{ success: boolean; error?: string }> {\n    try {\n      const booking = await this.getBookingById(bookingId);\n      if (!booking) throw new Error('Reserva no encontrada');\n\n      // 1. Cancelar la reserva con motivo especial\n      // Usamos force=true para bypassear reglas de tiempo (es una cancelación justificada)\n      await this.cancellationService.cancelBooking(booking, true);\n\n      // 2. Actualizar motivo específico y evidencia\n      await this.updateBooking(booking.id, {\n        cancellation_reason: `RECHAZADO EN CHECK-IN: ${reason}`,\n        cancelled_by_role: 'owner',\n        metadata: {\n          ...booking.metadata,\n          rejection_evidence: evidencePhotos,\n          rejected_at_pickup: true,\n        },\n      });\n\n      // 3. Registrar incidente para penalización del dueño (Strike)\n      await this.profileService.addStrike(\n        booking.owner_id || '',\n        'car_rejected_at_pickup',\n        booking.id,\n      );\n\n      this.logger.info(\n        `Car rejected at pickup for booking ${booking.id}`,\n        JSON.stringify({\n          reason,\n          photos: evidencePhotos.length,\n        }),\n      );\n\n      return { success: true };\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Error al rechazar vehículo',\n      };\n    }\n  }\n\n  /**\n   * Procesa una devolución anticipada (Early Return)\n   * Reembolsa los días no utilizados al locatario.\n   */\n  async processEarlyReturn(bookingId: string): Promise<{ success: boolean; error?: string }> {\n    try {\n      const booking = await this.getBookingById(bookingId);\n      if (!booking) throw new Error('Reserva no encontrada');\n\n      const now = new Date();\n      const endDate = new Date(booking.end_at);\n      const startDate = new Date(booking.start_at);\n\n      // Validar que sea realmente anticipada\n      if (now >= endDate) {\n        return { success: false, error: 'La reserva ya ha finalizado o está por finalizar' };\n      }\n\n      if (now < startDate) {\n        return { success: false, error: 'La reserva aún no ha comenzado' };\n      }\n\n      // Calcular días no utilizados (diferencia entre ahora y fin programado)\n      const msPerDay = 1000 * 60 * 60 * 24;\n      const remainingDays = Math.floor((endDate.getTime() - now.getTime()) / msPerDay);\n\n      if (remainingDays <= 0) {\n        return { success: false, error: 'No hay días completos para reembolsar' };\n      }\n\n      const pricePerDay = this.getBookingPricePerDay(booking);\n      const refundAmount = pricePerDay * remainingDays;\n\n      // Actualizar fecha de fin a \"ahora\"\n      await this.updateBooking(booking.id, {\n        end_at: now.toISOString(),\n        // total_amount se ajustará automáticamente o se deja como registro histórico\n        // Idealmente deberíamos actualizar total_amount = total_amount - refundAmount\n        total_amount: (booking.total_amount || 0) - refundAmount,\n      });\n\n      // Procesar reembolso\n      if (refundAmount > 0) {\n        // Reembolsar a wallet (o tarjeta si es posible, pero wallet es inmediato)\n        if (booking.user_id) {\n          await this.walletService.depositFunds(\n            booking.user_id,\n            Math.round(refundAmount * 100),\n            `Reembolso por devolución anticipada (${remainingDays} días)`,\n            booking.id,\n          );\n        }\n      }\n\n      return { success: true };\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Error al procesar devolución anticipada',\n      };\n    }\n  }\n\n  /**\n   * Reporta que el propietario no se presentó (Owner No-Show).\n   * Inicia el protocolo de no-show: cancela reserva, procesa reembolso y busca alternativas.\n   */\n  async reportOwnerNoShow(\n    bookingId: string,\n    details: string,\n    evidenceUrls: string[] = [],\n  ): Promise<{ success: boolean; error?: string }> {\n    try {\n      const { data, error } = await this.supabase.rpc('report_owner_no_show', {\n        p_booking_id: bookingId,\n        p_details: details,\n        p_evidence_urls: evidenceUrls,\n      });\n\n      if (error) throw error;\n\n      // The RPC should handle booking cancellation, refund, etc.\n      // This service method just reports the no-show.\n\n      return { success: true, ...data }; // Assuming RPC returns success/error/message\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Error al reportar no-show del propietario',\n      };\n    }\n  }\n\n  /**\n   * Reporta que el locatario no se presentó (Renter No-Show).\n   * Inicia el protocolo de no-show: marca reserva como cancelada, cobra penalidad al locatario.\n   */\n  async reportRenterNoShow(\n    bookingId: string,\n    details: string,\n    evidenceUrls: string[] = [],\n  ): Promise<{ success: boolean; error?: string }> {\n    try {\n      const { data, error } = await this.supabase.rpc('report_renter_no_show', {\n        p_booking_id: bookingId,\n        p_details: details,\n        p_evidence_urls: evidenceUrls,\n      });\n\n      if (error) throw error;\n\n      // The RPC should handle booking cancellation, penalty charges, etc.\n      // This service method just reports the no-show.\n\n      return { success: true, ...data }; // Assuming RPC returns success/error/message\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Error al reportar no-show del locatario',\n      };\n    }\n  }\n\n  /**\n   * Inicia una disputa sobre cargos adicionales\n   * Congela la transferencia de fondos al dueño hasta resolución.\n   */\n  async createDispute(\n    bookingId: string,\n    reason: string,\n    evidence?: string[],\n  ): Promise<{ success: boolean; error?: string }> {\n    try {\n      const user = await this.supabase.auth.getUser();\n      if (!user.data.user) throw new Error('No autenticado');\n\n      // Insertar disputa\n      const { error } = await this.supabase.from('booking_disputes').insert({\n        booking_id: bookingId,\n        opened_by: user.data.user.id,\n        reason,\n        evidence: evidence || [],\n        status: 'open',\n        created_at: new Date().toISOString(),\n      });\n\n      if (error) throw error;\n\n      // Marcar booking en estado de disputa (esto debería bloquear payouts automáticos en el backend)\n      await this.updateBooking(bookingId, {\n        status: 'pending_dispute_resolution', // Correct status for disputes\n        // metadata: { is_disputed: true } // Alternativa si no hay enum\n      });\n\n      return { success: true };\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Error al crear disputa',\n      };\n    }\n  }\n\n  // Utility Operations\n  getTimeUntilExpiration(booking: Booking): number | null {\n    return this.utilsService.getTimeUntilExpiration(booking);\n  }\n\n  formatTimeRemaining(milliseconds: number): string {\n    return this.utilsService.formatTimeRemaining(milliseconds);\n  }\n\n  isExpired(booking: Booking): boolean {\n    return this.utilsService.isExpired(booking);\n  }\n\n  /**\n   * Obtiene las solicitudes de extensión pendientes para una reserva.\n   */\n  async getPendingExtensionRequests(bookingId: string): Promise<BookingExtensionRequest[]> {\n    const { data, error } = await this.supabase\n      .from('booking_extension_requests')\n      .select('*')\n      .eq('booking_id', bookingId)\n      .eq('request_status', 'pending')\n      .order('requested_at', { ascending: false });\n\n    if (error) {\n      console.error('Error fetching pending extension requests:', error);\n      throw error;\n    }\n    return (data || []) as BookingExtensionRequest[];\n  }\n\n  /**\n   * Estima el costo adicional de una extensión de reserva.\n   * @param bookingId ID de la reserva.\n   * @param newEndDate Nueva fecha de fin de la reserva.\n   * @returns Costo estimado en `amount` y un posible `error`.\n   */\n  async estimateExtensionCost(\n    bookingId: string,\n    newEndDate: Date,\n  ): Promise<{ amount: number; currency: string; error?: string }> {\n    try {\n      const booking = await this.getBookingById(bookingId);\n      if (!booking) throw new Error('Reserva no encontrada');\n\n      if (newEndDate <= new Date(booking.end_at)) {\n        return { amount: 0, currency: booking.currency, error: 'La nueva fecha debe ser posterior a la actual' };\n      }\n\n      // Calcular días adicionales\n      const currentEnd = new Date(booking.end_at);\n      const additionalDays = Math.ceil(\n        (newEndDate.getTime() - currentEnd.getTime()) / (1000 * 60 * 60 * 24),\n      );\n      if (additionalDays <= 0)\n        return { amount: 0, currency: booking.currency, error: 'La nueva fecha debe ser posterior a la actual' };\n\n      // Obtener precio por día actual (utilizando el desglose de la reserva original)\n      const pricePerDay = this.getBookingPricePerDay(booking); // Assuming this helper exists and returns price per day in actual amount (not cents)\n\n      const estimatedAdditionalCost = pricePerDay * additionalDays;\n\n      return { amount: estimatedAdditionalCost, currency: booking.currency };\n    } catch (error) {\n      return {\n        amount: 0,\n        currency: 'ARS',\n        error: error instanceof Error ? error.message : 'Error al estimar el costo de extensión',\n      };\n    }\n  }\n\n\n  // Insurance Operations (delegation to InsuranceService)\n  async activateInsuranceCoverage(\n    bookingId: string,\n    addonIds: string[] = [],\n  ): Promise<{ success: boolean; coverage_id?: string; error?: string }> {\n    try {\n      const coverageId = await this.insuranceService.activateCoverage({\n        booking_id: bookingId,\n        addon_ids: addonIds,\n      });\n\n      return {\n        success: true,\n        coverage_id: coverageId,\n      };\n    } catch (error: unknown) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Error al activar cobertura de seguro',\n      };\n    }\n  }\n\n  async getBookingInsuranceSummary(bookingId: string) {\n    return this.insuranceService.getInsuranceSummary(bookingId);\n  }\n\n  async calculateInsuranceDeposit(carId: string): Promise<number> {\n    return this.insuranceService.calculateSecurityDeposit(carId);\n  }\n\n  async hasOwnerInsurance(carId: string): Promise<boolean> {\n    return this.insuranceService.hasOwnerInsurance(carId);\n  }\n\n  async getInsuranceCommissionRate(carId: string): Promise<number> {\n    return this.insuranceService.getCommissionRate(carId);\n  }\n\n  // ============================================================================\n  // PRIVATE HELPER METHODS\n  // ============================================================================\n\n  /**\n   * Update app badge with pending bookings count\n   */\n  private async updateAppBadge(bookings: Booking[]): Promise<void> {\n    const pendingCount = bookings.filter(\n      (b) => b.status === 'pending' || b.status === 'confirmed',\n    ).length;\n\n    if (pendingCount > 0) {\n      await this.pwaService.setAppBadge(pendingCount);\n    } else {\n      await this.pwaService.clearAppBadge();\n    }\n  }\n\n  /**\n   * Load car details for a booking\n   */\n  private async loadCarDetails(booking: Booking): Promise<void> {\n    try {\n      const { data: car, error: carError } = await this.supabase\n        .from('cars')\n        .select(\n          'id, title, brand, model, year, fuel_policy, mileage_limit, extra_km_price, allow_smoking, allow_pets, allow_rideshare, max_distance_km, car_photos(id, url, stored_path, position, sort_order, created_at)',\n        )\n        .eq('id', booking.car_id)\n        .single();\n\n      if (!carError && car) {\n        const rawPhotos = (car as unknown as { car_photos?: unknown }).car_photos;\n        const photos = Array.isArray(rawPhotos) ? (rawPhotos as Array<Record<string, unknown>>) : [];\n        const images = photos\n          .map((p) => {\n            const url = p['url'];\n            return typeof url === 'string' ? url : null;\n          })\n          .filter((url): url is string => Boolean(url));\n\n        (booking as Booking).car = {\n          ...(car as Partial<import('../models').Car>),\n          car_photos: photos as unknown as import('../models').CarPhoto[],\n          photos: photos as unknown as import('../models').CarPhoto[],\n          images,\n        } as Partial<import('../models').Car>;\n      } else if (carError) {\n        this.logger.error(\n          'Car query error',\n          'BookingsService',\n          carError instanceof Error ? carError : new Error(getErrorMessage(carError)),\n        );\n      }\n    } catch (carException) {\n      this.logger.error(\n        'Error loading car details',\n        'BookingsService',\n        carException instanceof Error ? carException : new Error(getErrorMessage(carException)),\n      );\n      throw new Error(\n        `Failed to load car details: ${carException instanceof Error ? carException.message : getErrorMessage(carException)}`,\n      );\n    }\n  }\n\n  /**\n   * Load insurance coverage for a booking\n   */\n  private async loadInsuranceCoverage(booking: Booking): Promise<void> {\n    try {\n      const { data: coverage, error: coverageError } = await this.supabase\n        .from('booking_insurance_coverage')\n        .select('*')\n        .eq('id', booking.insurance_coverage_id)\n        .single();\n\n      if (!coverageError && coverage) {\n        if (coverage.policy_id) {\n          const { data: policy, error: policyError } = await this.supabase\n            .from('insurance_policies')\n            .select('*')\n            .eq('id', coverage.policy_id)\n            .single();\n\n          if (!policyError && policy) {\n            (coverage as Record<string, unknown>)['policy'] = policy;\n          } else if (policyError) {\n            this.logger.error(\n              'Policy query error',\n              'BookingsService',\n              policyError instanceof Error ? policyError : new Error(getErrorMessage(policyError)),\n            );\n            throw new Error(`Failed to load policy: ${policyError.message}`);\n          }\n        }\n\n        (booking as Booking).insurance_coverage = coverage;\n      } else if (coverageError) {\n        this.logger.error(\n          'Coverage query error',\n          'BookingsService',\n          coverageError instanceof Error\n            ? coverageError\n            : new Error(getErrorMessage(coverageError)),\n        );\n        throw new Error(`Failed to load coverage: ${coverageError.message}`);\n      }\n    } catch (coverageException) {\n      this.logger.error(\n        'Error loading coverage details',\n        'BookingsService',\n        coverageException instanceof Error\n          ? coverageException\n          : new Error(getErrorMessage(coverageException)),\n      );\n      throw new Error(\n        `Failed to load insurance coverage: ${coverageException instanceof Error ? coverageException.message : getErrorMessage(coverageException)}`,\n      );\n    }\n  }\n\n  /**\n   * Notifica al dueño del auto sobre una nueva solicitud de reserva\n   */\n  private async notifyOwnerOfNewBooking(booking: Booking): Promise<void> {\n    try {\n      if (!booking.owner_id || !booking.car_id) return;\n\n      // Obtener información del auto y del locatario en paralelo\n      const [car, renter] = await Promise.all([\n        this.carsService.getCarById(booking.car_id),\n        this.profileService.getProfileById(booking.user_id || booking.renter_id || ''),\n      ]);\n\n      if (car && renter) {\n        const carName = car.title || `${car.brand || ''} ${car.model || ''}`.trim() || 'tu auto';\n        const renterName = renter.full_name || 'Un usuario';\n        const pricePerDay = this.getBookingPricePerDay(booking);\n        const bookingUrl = `/bookings/${booking.id}`;\n\n        this.carOwnerNotifications.notifyNewBookingRequest(\n          renterName,\n          carName,\n          pricePerDay,\n          bookingUrl,\n        );\n      }\n    } catch (error) {\n      this.logger.warn(\n        'Failed to notify owner of booking request',\n        'BookingsService',\n        error instanceof Error ? error : new Error(getErrorMessage(error)),\n      );\n    }\n  }\n\n  private getBookingCarTitle(booking: BookingWithMetadata): string {\n    const fallbackTitle = booking.car?.title?.trim();\n    return booking.car_title || fallbackTitle || 'Auto';\n  }\n\n  private getBookingPricePerDay(booking: BookingWithMetadata): number {\n    return typeof booking.price_per_day === 'number' ? (booking.price_per_day ?? 0) : 0;\n  }\n\n  /**\n   * Fallback: inserta directamente en bookings cuando el RPC request_booking falla\n   * por columnas faltantes (p.ej. pickup_lat) en entornos desactualizados.\n   */\n  private async fallbackDirectBookingInsert(\n    carId: string,\n    start: string,\n    end: string,\n  ): Promise<Booking> {\n    // Obtener usuario\n    const { data: userData, error: userError } = await this.supabase.auth.getUser();\n    if (userError || !userData.user?.id) {\n      throw new Error('Usuario no autenticado');\n    }\n    const renterId = userData.user.id;\n\n    // Obtener datos del auto para calcular total\n    const { data: car, error: carError } = await this.supabase\n      .from('cars')\n      .select('price_per_day, currency')\n      .eq('id', carId)\n      .single();\n\n    if (carError) {\n      throw new Error('No se pudo obtener el auto para calcular el total');\n    }\n\n    const pricePerDay = Number(car?.price_per_day ?? 0);\n    const currency = (car?.currency as string | null) || 'ARS';\n    const days = Math.max(\n      1,\n      Math.ceil(\n        (new Date(end).getTime() - new Date(start).getTime()) / (1000 * 60 * 60 * 24),\n      ),\n    );\n    const totalAmount = pricePerDay * days;\n\n    // Insert directo\n    const { data, error } = await this.supabase\n      .from('bookings')\n      .insert({\n        car_id: carId,\n        renter_id: renterId,\n        start_at: start,\n        end_at: end,\n        status: 'pending',\n        currency,\n        total_amount: totalAmount,\n      })\n      .select()\n      .single();\n\n    if (error || !data) {\n      throw new Error(error?.message || 'No se pudo crear la reserva (fallback)');\n    }\n\n    // Recalcular pricing\n    try {\n      await this.recalculatePricing(data.id);\n    } catch {\n      // no bloquear si falla el recalculo en fallback\n    }\n\n    return data as Booking;\n  }\n\n  // ============================================================================\n  // PAYMENT ISSUES (P0-002 FIX)\n  // ============================================================================\n\n  /**\n   * Create a payment issue record for manual review and background retry\n   *\n   * ✅ P0-002 FIX: Registro de fallos de wallet unlock para retry posterior\n   *\n   * Esta función guarda los errores críticos de pago/wallet en la tabla\n   * `payment_issues` para que un background job pueda reintentarlos.\n   *\n   * @param issue - Payment issue data\n   * @returns Promise<void>\n   */\n  async createPaymentIssue(issue: {\n    booking_id: string;\n    issue_type: string;\n    severity: 'low' | 'medium' | 'high' | 'critical';\n    description: string;\n    metadata?: Record<string, unknown>;\n    status?: 'pending_review' | 'in_progress' | 'resolved' | 'ignored';\n  }): Promise<void> {\n    const { error } = await this.supabase.from('payment_issues').insert({\n      booking_id: issue.booking_id,\n      issue_type: issue.issue_type,\n      severity: issue.severity,\n      description: issue.description,\n      metadata: issue.metadata || {},\n      status: issue.status || 'pending_review',\n      created_at: new Date().toISOString(),\n    });\n\n    if (error) {\n      this.logger.error('Failed to create payment issue record', 'BookingsService', error);\n      throw error;\n    }\n\n    this.logger.info('Payment issue created successfully', 'BookingsService', {\n      booking_id: issue.booking_id,\n      issue_type: issue.issue_type,\n      severity: issue.severity,\n    });\n  }\n\n  // ============================================================================\n  // INSURANCE ACTIVATION (P0-003 FIX)\n  // ============================================================================\n\n  /**\n   * Activate insurance coverage with retry logic and MANDATORY blocking\n   *\n   * ✅ P0-003 FIX: Insurance activation BLOCKS booking if it fails\n   *\n   * CRITICAL: This method will throw an error if insurance activation fails\n   * after all retries. This is MANDATORY for legal compliance - bookings\n   * CANNOT proceed without valid insurance coverage.\n   *\n   * Features:\n   * - 3 retry attempts with exponential backoff (1s, 2s, 4s)\n   * - Detailed logging of each attempt\n   * - Critical alerts to Sentry if all retries fail\n   * - BLOCKS booking creation if insurance fails\n   * - Auto-cancellation of booking if insurance fails\n   *\n   * Legal Requirements:\n   * - All bookings MUST have active insurance coverage\n   * - Violation of this requirement is ILLEGAL in most jurisdictions\n   * - Potential financial exposure: millions USD per incident\n   *\n   * @param bookingId - ID of the booking\n   * @param addonIds - Optional insurance addon IDs\n   * @throws Error if insurance activation fails after all retries\n   */\n  private async activateInsuranceWithRetry(\n    bookingId: string,\n    addonIds: string[] = [],\n  ): Promise<void> {\n    const maxRetries = 3;\n    let lastError: unknown;\n\n    for (let attempt = 1; attempt <= maxRetries; attempt++) {\n      try {\n        this.logger.info(\n          `Attempting insurance activation (attempt ${attempt}/${maxRetries})`,\n          'BookingsService',\n          { bookingId, addonIds, attempt },\n        );\n\n        // Attempt to activate insurance\n        await this.insuranceService.activateCoverage({\n          booking_id: bookingId,\n          addon_ids: addonIds,\n        });\n\n        this.logger.info('Insurance activated successfully', 'BookingsService', {\n          bookingId,\n          addonIds,\n          attempt,\n          totalAttempts: attempt,\n        });\n\n        // ✅ Success - insurance is active\n        return;\n      } catch (error) {\n        lastError = error;\n\n        this.logger.warn(\n          `Insurance activation failed (attempt ${attempt}/${maxRetries})`,\n          'BookingsService',\n          error instanceof Error ? error : new Error(getErrorMessage(error)),\n        );\n\n        // If not the last attempt, wait with exponential backoff\n        if (attempt < maxRetries) {\n          const delayMs = Math.pow(2, attempt - 1) * 1000; // 1s, 2s, 4s\n          await this.delay(delayMs);\n        }\n      }\n    }\n\n    // ❌ All retries failed - CRITICAL ERROR\n    await this.handleInsuranceActivationFailure(bookingId, addonIds, lastError);\n  }\n\n  /**\n   * Handle critical insurance activation failure\n   *\n   * Actions:\n   * 1. Log CRITICAL error to Sentry (legal compliance)\n   * 2. Auto-cancel the booking (cannot proceed without insurance)\n   * 3. Create compliance issue record for audit trail\n   * 4. Alert compliance team\n   *\n   * @param bookingId - ID of the booking\n   * @param addonIds - Insurance addon IDs that failed to activate\n   * @param error - Error that caused the failure\n   * @throws Error - Always throws to block booking creation\n   */\n  private async handleInsuranceActivationFailure(\n    bookingId: string,\n    addonIds: string[],\n    error: unknown,\n  ): Promise<never> {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    const errorStack = error instanceof Error ? error.stack : undefined;\n\n    // 1. ❌ CRITICAL LOG - Legal compliance violation\n    this.logger.critical(\n      'CRITICAL: Insurance activation failed - LEGAL COMPLIANCE VIOLATION',\n      'BookingsService',\n      error instanceof Error ? error : new Error(`Insurance activation failed: ${errorMessage}`),\n    );\n\n    // 2. Log detailed information for audit trail\n    this.logger.error(\n      'Insurance activation failure details (LEGAL COMPLIANCE)',\n      'BookingsService',\n      error instanceof Error ? error : new Error(errorMessage),\n    );\n\n    // 3. Auto-cancel booking due to system failure (insurance activation)\n    // ✅ ATOMICITY FIX: Use cancellation_reason to distinguish from user cancellations\n    // Note: 'failed' status not in DB enum, using 'cancelled' with distinct reason\n    try {\n      await this.updateBooking(bookingId, {\n        status: 'cancelled',\n        cancellation_reason: 'system_failure:insurance_activation_failed',\n        cancelled_at: new Date().toISOString(),\n        cancelled_by_role: 'system',\n      });\n\n      this.logger.info(\n        'Booking auto-cancelled due to insurance system failure',\n        'BookingsService',\n        {\n          bookingId,\n          status: 'cancelled',\n          reason: 'system_failure:insurance_activation_failed',\n          isSystemFailure: true,\n        },\n      );\n    } catch (cancelError) {\n      this.logger.error(\n        'Failed to auto-cancel booking after insurance failure',\n        'BookingsService',\n        cancelError instanceof Error ? cancelError : new Error(getErrorMessage(cancelError)),\n      );\n    }\n\n    // 4. Create compliance issue for audit trail\n    try {\n      await this.createPaymentIssue({\n        booking_id: bookingId,\n        issue_type: 'insurance_activation_failed',\n        severity: 'critical',\n        description: `LEGAL COMPLIANCE: Failed to activate insurance after ${3} retry attempts. Booking auto-cancelled.`,\n        metadata: {\n          addon_ids: addonIds,\n          error: errorMessage,\n          stack: errorStack,\n          timestamp: new Date().toISOString(),\n          retry_count: 3,\n          compliance_violation: true,\n          legal_risk: 'HIGH',\n        },\n        status: 'pending_review',\n      });\n    } catch (issueError) {\n      this.logger.error(\n        'Failed to create compliance issue record',\n        'BookingsService',\n        issueError instanceof Error ? issueError : new Error(getErrorMessage(issueError)),\n      );\n    }\n\n    // 5. ❌ THROW ERROR - BLOCK booking creation\n    throw new Error(\n      `CRITICAL: Cannot create booking without insurance coverage. ` +\n      `Insurance activation failed after 3 attempts. ` +\n      `Error: ${errorMessage}. ` +\n      `Booking has been auto-cancelled for legal compliance.`,\n    );\n  }\n\n  /**\n   * Utility: Delay execution for specified milliseconds\n   */\n  private delay(ms: number): Promise<void> {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n  }\n\n  // ============================================================================\n  // RPC INTEGRATIONS - Owner Cancellation & Penalties\n  // ============================================================================\n\n  /**\n   * Owner cancela una reserva con penalización automática\n   * - Reembolso 100% al renter\n   * - -10% visibilidad por 30 días\n   * - 3+ cancelaciones en 90 días = suspensión temporal\n   */\n  async ownerCancelBooking(\n    bookingId: string,\n    reason: string,\n  ): Promise<{ success: boolean; error?: string; penaltyApplied?: boolean }> {\n    try {\n      const { data, error } = await this.supabase.rpc('owner_cancel_booking', {\n        p_booking_id: bookingId,\n        p_reason: reason,\n      });\n\n      if (error) throw error;\n\n      return {\n        success: true,\n        penaltyApplied: data?.penalty_applied ?? true,\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Error al cancelar reserva',\n      };\n    }\n  }\n\n  /**\n   * Obtiene las penalizaciones activas del owner actual\n   */\n  async getOwnerPenalties(): Promise<{\n    visibilityPenaltyUntil: string | null;\n    visibilityFactor: number;\n    cancellationCount90d: number;\n    isSuspended: boolean;\n  } | null> {\n    try {\n      const { data, error } = await this.supabase.rpc('get_owner_penalties');\n\n      if (error) throw error;\n\n      return {\n        visibilityPenaltyUntil: data?.visibility_penalty_until || null,\n        visibilityFactor: data?.visibility_factor ?? 1.0,\n        cancellationCount90d: data?.cancellation_count_90d ?? 0,\n        isSuspended: data?.is_suspended ?? false,\n      };\n    } catch {\n      return null;\n    }\n  }\n\n  /**\n   * Obtiene el factor de visibilidad de un owner (para búsquedas)\n   * Factor entre 0.0 y 1.0 donde 1.0 = visibilidad completa\n   */\n  async getOwnerVisibilityFactor(ownerId?: string): Promise<number> {\n    try {\n      const { data, error } = await this.supabase.rpc('get_owner_visibility_factor', {\n        p_owner_id: ownerId || null,\n      });\n\n      if (error) throw error;\n\n      return data ?? 1.0;\n    } catch {\n      return 1.0; // Default to full visibility on error\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/core/services/bookings/insurance.service.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`@core/services/infrastructure/supabase-client.service` import should occur before import of `../models/insurance.model`","line":17,"column":1,"nodeType":"ImportDeclaration","endLine":17,"endColumn":88,"fix":{"range":[156,548],"text":"import { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\nimport {\n  InsurancePolicy,\n  BookingInsuranceCoverage,\n  InsuranceAddon,\n  BookingInsuranceAddon,\n  InsuranceClaim,\n  VehicleInspection,\n  InsuranceSummary,\n  ActivateInsuranceCoverageRequest,\n  ReportClaimRequest,\n  CreateInspectionRequest,\n  INSURER_DISPLAY_NAMES,\n} from '../models/insurance.model';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { Injectable } from '@angular/core';\nimport { Observable, from, map, catchError, of, shareReplay } from 'rxjs';\nimport { v4 as uuidv4 } from 'uuid';\nimport {\n  InsurancePolicy,\n  BookingInsuranceCoverage,\n  InsuranceAddon,\n  BookingInsuranceAddon,\n  InsuranceClaim,\n  VehicleInspection,\n  InsuranceSummary,\n  ActivateInsuranceCoverageRequest,\n  ReportClaimRequest,\n  CreateInspectionRequest,\n  INSURER_DISPLAY_NAMES,\n} from '../models/insurance.model';\nimport { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\n\n/**\n * Servicio de Seguros P2P\n * Gestiona todo lo relacionado con seguros: pólizas, coberturas, siniestros e inspecciones\n */\n@Injectable({\n  providedIn: 'root',\n})\nexport class InsuranceService {\n  private readonly supabase = injectSupabase();\n\n  // ✅ OPTIMIZED: Cached observables for static data\n  private addonsCache$: Observable<InsuranceAddon[]> | null = null;\n  private platformPolicyCache$: Observable<InsurancePolicy | null> | null = null;\n\n  // ============================================\n  // PÓLIZAS\n  // ============================================\n\n  /**\n   * Obtener todas las pólizas activas disponibles\n   */\n  getActivePolicies(): Observable<InsurancePolicy[]> {\n    return from(\n      this.supabase\n        .from('insurance_policies')\n        .select('*')\n        .eq('status', 'active')\n        .order('created_at', { ascending: false }),\n    ).pipe(\n      map(({ data, error }) => {\n        if (error) throw error;\n        return (data as InsurancePolicy[]) || [];\n      }),\n      catchError((_err) => {\n        return of([]);\n      }),\n    );\n  }\n\n  /**\n   * Obtener la póliza flotante activa de la plataforma\n   * ✅ OPTIMIZED: Uses shareReplay to cache static policy data\n   */\n  getPlatformFloatingPolicy(): Observable<InsurancePolicy | null> {\n    if (this.platformPolicyCache$) {\n      return this.platformPolicyCache$;\n    }\n\n    this.platformPolicyCache$ = from(\n      this.supabase\n        .from('insurance_policies')\n        .select('*')\n        .eq('policy_type', 'platform_floating')\n        .eq('status', 'active')\n        .single(),\n    ).pipe(\n      map(({ data, error }) => {\n        if (error) {\n          if (error.code === 'PGRST116') return null; // No encontrado\n          throw error;\n        }\n        return data as InsurancePolicy;\n      }),\n      catchError((_err) => {\n        this.platformPolicyCache$ = null; // Clear cache on error\n        return of(null);\n      }),\n      // ✅ Cache the result, share among subscribers\n      shareReplay({ bufferSize: 1, refCount: true }),\n    );\n\n    return this.platformPolicyCache$;\n  }\n\n  /**\n   * Obtener póliza propia de un propietario para un auto específico\n   */\n  getOwnerPolicy(carId: string): Observable<InsurancePolicy | null> {\n    return from(\n      this.supabase\n        .from('insurance_policies')\n        .select('*')\n        .eq('policy_type', 'owner_byoi')\n        .eq('car_id', carId)\n        .eq('status', 'active')\n        .single(),\n    ).pipe(\n      map(({ data, error }) => {\n        if (error) {\n          if (error.code === 'PGRST116') return null;\n          throw error;\n        }\n        return data as InsurancePolicy;\n      }),\n      catchError(() => of(null)),\n    );\n  }\n\n  /**\n   * Registrar póliza propia de propietario (BYOI)\n   */\n  async registerOwnerPolicy(policyData: Partial<InsurancePolicy>): Promise<InsurancePolicy> {\n    const { data, error } = await this.supabase\n      .from('insurance_policies')\n      .insert({\n        policy_type: 'owner_byoi',\n        status: 'pending_verification',\n        ...policyData,\n      })\n      .select()\n      .single();\n\n    if (error) throw error;\n    return data as InsurancePolicy;\n  }\n\n  /**\n   * Verificar póliza de propietario (solo admin)\n   */\n  async verifyOwnerPolicy(policyId: string, approved: boolean): Promise<void> {\n    const { error } = await this.supabase\n      .from('insurance_policies')\n      .update({\n        verified_by_admin: approved,\n        verification_date: new Date().toISOString(),\n        status: approved ? 'active' : 'cancelled',\n      })\n      .eq('id', policyId);\n\n    if (error) throw error;\n  }\n\n  // ============================================\n  // COBERTURAS\n  // ============================================\n\n  /**\n   * Activar cobertura de seguro para una reserva\n   */\n  async activateCoverage(request: ActivateInsuranceCoverageRequest): Promise<string> {\n    const { data, error } = await this.supabase.rpc('activate_insurance_coverage', {\n      p_booking_id: request.booking_id,\n      p_addon_ids: request.addon_ids || [],\n    });\n\n    if (error) throw error;\n    return data as string; // coverage_id\n  }\n\n  /**\n   * Obtener cobertura activa de una reserva\n   */\n  getBookingCoverage(bookingId: string): Observable<BookingInsuranceCoverage | null> {\n    return from(\n      this.supabase\n        .from('booking_insurance_coverage')\n        .select(\n          `\n          *,\n          policy:policy_id (*)\n        `,\n        )\n        .eq('booking_id', bookingId)\n        .eq('status', 'active')\n        .single(),\n    ).pipe(\n      map(({ data, error }) => {\n        if (error) {\n          if (error.code === 'PGRST116') return null;\n          throw error;\n        }\n        return data as BookingInsuranceCoverage;\n      }),\n      catchError(() => of(null)),\n    );\n  }\n\n  /**\n   * Obtener resumen de seguro para mostrar en UI\n   */\n  async getInsuranceSummary(bookingId: string): Promise<InsuranceSummary | null> {\n    // Obtener cobertura\n    const { data: coverage, error: covError } = await this.supabase\n      .from('booking_insurance_coverage')\n      .select(\n        `\n        *,\n        policy:policy_id (*)\n      `,\n      )\n      .eq('booking_id', bookingId)\n      .single();\n\n    if (covError || !coverage) return null;\n\n    // Obtener add-ons\n    const { data: addons } = await this.supabase\n      .from('booking_insurance_addons')\n      .select(\n        `\n        *,\n        addon:addon_id (*)\n      `,\n      )\n      .eq('booking_id', bookingId);\n\n    const policy = coverage.policy as InsurancePolicy;\n    const addonsList = (addons || []) as BookingInsuranceAddon[];\n\n    return {\n      has_coverage: true,\n      policy_type: policy.policy_type,\n      insurer: policy.insurer,\n      insurer_display_name: INSURER_DISPLAY_NAMES[policy.insurer],\n      liability_coverage: coverage.liability_coverage,\n      deductible_amount: coverage.deductible_amount,\n      daily_premium: coverage.daily_premium_charged\n        ? coverage.daily_premium_charged /\n          this.calculateRentalDays(coverage.coverage_start, coverage.coverage_end)\n        : undefined,\n      total_premium: coverage.daily_premium_charged || 0,\n      addons: addonsList.map((a) => ({\n        name: (a.addon as InsuranceAddon).name,\n        daily_cost: a.daily_cost,\n        total_cost: a.total_cost,\n      })),\n      security_deposit: coverage.deductible_amount,\n      certificate_number: coverage.certificate_number,\n      coverage_details: {\n        rc: true,\n        own_damage: policy.own_damage_coverage,\n        theft: policy.theft_coverage,\n        fire: policy.fire_coverage,\n        misappropriation: policy.misappropriation_coverage,\n        countries: ['Argentina'], // TODO: detectar add-on países limítrofes\n      },\n    };\n  }\n\n  private calculateRentalDays(start: string, end: string): number {\n    const startDate = new Date(start);\n    const endDate = new Date(end);\n    const diffTime = Math.abs(endDate.getTime() - startDate.getTime());\n    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));\n    return diffDays > 0 ? diffDays : 1;\n  }\n\n  // ============================================\n  // ADD-ONS\n  // ============================================\n\n  /**\n   * Obtener todos los add-ons disponibles\n   * ✅ OPTIMIZED: Uses shareReplay to cache static addon data\n   */\n  getAvailableAddons(): Observable<InsuranceAddon[]> {\n    if (this.addonsCache$) {\n      return this.addonsCache$;\n    }\n\n    this.addonsCache$ = from(\n      this.supabase\n        .from('insurance_addons')\n        .select('*')\n        .eq('active', true)\n        .order('daily_cost', { ascending: true }),\n    ).pipe(\n      map(({ data, error }) => {\n        if (error) throw error;\n        return (data as InsuranceAddon[]) || [];\n      }),\n      catchError((_err) => {\n        this.addonsCache$ = null; // Clear cache on error\n        return of([]);\n      }),\n      // ✅ Cache the result, share among subscribers\n      shareReplay({ bufferSize: 1, refCount: true }),\n    );\n\n    return this.addonsCache$;\n  }\n\n  /**\n   * Obtener add-ons contratados de una reserva\n   */\n  getBookingAddons(bookingId: string): Observable<BookingInsuranceAddon[]> {\n    return from(\n      this.supabase\n        .from('booking_insurance_addons')\n        .select(\n          `\n          *,\n          addon:addon_id (*)\n        `,\n        )\n        .eq('booking_id', bookingId),\n    ).pipe(\n      map(({ data, error }) => {\n        if (error) throw error;\n        return (data as BookingInsuranceAddon[]) || [];\n      }),\n      catchError(() => of([])),\n    );\n  }\n\n  // ============================================\n  // SINIESTROS (CLAIMS)\n  // ============================================\n\n  /**\n   * Subir foto de evidencia de siniestro\n   * Path: {user_id}/claim-evidence/{booking_id}/{uuid}.{ext}\n   */\n  async uploadClaimEvidence(file: File, bookingId: string): Promise<string> {\n    const userId = (await this.supabase.auth.getUser()).data['user']?.['id'];\n    if (!userId) throw new Error('Usuario no autenticado');\n\n    // Validar tipo de archivo\n    if (!file.type.startsWith('image/')) {\n      throw new Error('Solo se permiten imágenes');\n    }\n\n    // Validar tamaño (max 5MB)\n    if (file.size > 5 * 1024 * 1024) {\n      throw new Error('Imagen muy grande. Máximo 5MB');\n    }\n\n    // Obtener extensión del archivo\n    const extension = file.name.split('.').pop()?.toLowerCase() || 'jpg';\n\n    // Path: {userId}/claim-evidence/{bookingId}/{uuid}.{extension}\n    const filePath = `${userId}/claim-evidence/${bookingId}/${uuidv4()}.${extension}`;\n\n    const { error } = await this.supabase.storage.from('documents').upload(filePath, file, {\n      cacheControl: '3600',\n      upsert: false,\n    });\n\n    if (error) throw error;\n\n    // Retornar la ruta del archivo (sin bucket name)\n    return filePath;\n  }\n\n  /**\n   * Obtener URL pública de foto de evidencia\n   */\n  getClaimEvidenceUrl(filePath: string): string {\n    const { data } = this.supabase.storage.from('documents').getPublicUrl(filePath);\n    return data.publicUrl;\n  }\n\n  /**\n   * Reportar un siniestro\n   */\n  async reportClaim(request: ReportClaimRequest): Promise<string> {\n    const { data, error } = await this.supabase.rpc('report_insurance_claim', {\n      p_booking_id: request.booking_id,\n      p_claim_type: request.claim_type,\n      p_description: request['description'],\n      p_incident_date: request.incident_date,\n      p_location: request.location,\n      p_photos: request.photos || [],\n    });\n\n    if (error) throw error;\n    return data as string; // claim_id\n  }\n\n  /**\n   * Obtener siniestros de un usuario\n   */\n  getMyClaims(): Observable<InsuranceClaim[]> {\n    return from(\n      this.supabase.from('insurance_claims').select('*').order('created_at', { ascending: false }),\n    ).pipe(\n      map(({ data, error }) => {\n        if (error) throw error;\n        return (data as InsuranceClaim[]) || [];\n      }),\n      catchError((_err) => {\n        return of([]);\n      }),\n    );\n  }\n\n  /**\n   * Obtener un siniestro específico\n   */\n  getClaimById(claimId: string): Observable<InsuranceClaim | null> {\n    return from(this.supabase.from('insurance_claims').select('*').eq('id', claimId).single()).pipe(\n      map(({ data, error }) => {\n        if (error) {\n          if (error.code === 'PGRST116') return null;\n          throw error;\n        }\n        return data as InsuranceClaim;\n      }),\n      catchError(() => of(null)),\n    );\n  }\n\n  /**\n   * Actualizar estado de siniestro (solo admin)\n   */\n  async updateClaimStatus(\n    claimId: string,\n    status: InsuranceClaim['status'],\n    notes?: string,\n  ): Promise<void> {\n    const updateData: Record<string, unknown> = { status, updated_at: new Date().toISOString() };\n\n    if (notes) {\n      updateData['resolution_notes'] = notes;\n    }\n\n    if (status === 'closed') {\n      updateData['closed_at'] = new Date().toISOString();\n    }\n\n    const { error } = await this.supabase\n      .from('insurance_claims')\n      .update(updateData)\n      .eq('id', claimId);\n\n    if (error) throw error;\n  }\n\n  // ============================================\n  // INSPECCIONES\n  // ============================================\n\n  /**\n   * Crear inspección pre/post alquiler\n   */\n  async createInspection(request: CreateInspectionRequest): Promise<string> {\n    const { data, error } = await this.supabase\n      .from('vehicle_inspections')\n      .insert({\n        ...request,\n        inspector_id: (await this.supabase.auth.getUser()).data['user']?.['id'],\n        completed: !!request.signature_data,\n        signed_at: request.signature_data ? new Date().toISOString() : null,\n      })\n      .select()\n      .single();\n\n    if (error) throw error;\n    return (data as VehicleInspection)['id'];\n  }\n\n  /**\n   * Obtener inspecciones de una reserva\n   */\n  getBookingInspections(bookingId: string): Observable<VehicleInspection[]> {\n    return from(\n      this.supabase\n        .from('vehicle_inspections')\n        .select('*')\n        .eq('booking_id', bookingId)\n        .order('created_at', { ascending: true }),\n    ).pipe(\n      map(({ data, error }) => {\n        if (error) throw error;\n        return (data as VehicleInspection[]) || [];\n      }),\n      catchError(() => of([])),\n    );\n  }\n\n  /**\n   * Comparar inspecciones pre y post para detectar nuevos daños\n   */\n  async compareInspections(bookingId: string): Promise<{\n    new_damages: unknown[];\n    inspection_pre: VehicleInspection | null;\n    inspection_post: VehicleInspection | null;\n  }> {\n    const { data } = await this.supabase\n      .from('vehicle_inspections')\n      .select('*')\n      .eq('booking_id', bookingId)\n      .order('created_at', { ascending: true });\n\n    const inspections = (data || []) as VehicleInspection[];\n    const pre = inspections.find((i) => i.inspection_type === 'pre_rental') || null;\n    const post = inspections.find((i) => i.inspection_type === 'post_rental') || null;\n\n    let new_damages: unknown[] = [];\n\n    if (pre && post) {\n      const preDamages = pre.damages_detected || [];\n      const postDamages = post.damages_detected || [];\n\n      // Detectar daños que están en POST pero no en PRE\n      new_damages = postDamages.filter(\n        (postDmg) =>\n          !preDamages.some(\n            (preDmg) => preDmg.location === postDmg.location && preDmg.type === postDmg.type,\n          ),\n      );\n    }\n\n    return { new_damages, inspection_pre: pre, inspection_post: post };\n  }\n\n  // ============================================\n  // UTILIDADES\n  // ============================================\n\n  /**\n   * Calcular depósito de seguridad basado en valor del auto y póliza\n   */\n  async calculateSecurityDeposit(carId: string): Promise<number> {\n    const { data, error } = await this.supabase.rpc('calculate_deductible', {\n      p_car_id: carId,\n      p_policy_id: null, // usará póliza flotante por defecto\n    });\n\n    if (error) {\n      return 500000; // Fallback: $500k\n    }\n\n    return data as number;\n  }\n\n  /**\n   * Verificar si un auto tiene seguro propio (BYOI)\n   */\n  async hasOwnerInsurance(carId: string): Promise<boolean> {\n    const { data } = await this.supabase\n      .from('cars')\n      .select('has_owner_insurance')\n      .eq('id', carId)\n      .single();\n\n    return data?.has_owner_insurance || false;\n  }\n\n  /**\n   * Obtener comisión aplicable según tipo de seguro\n   * 25% para seguro flotante, 15% para seguro propio\n   */\n  async getCommissionRate(carId: string): Promise<number> {\n    const hasOwnInsurance = await this.hasOwnerInsurance(carId);\n    return hasOwnInsurance ? 0.15 : 0.25;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/core/services/bookings/marketplace-landing.service.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`@core/services/geo/distance-calculator.service` import should occur before type import of `../models/marketplace.model`","line":12,"column":1,"nodeType":"ImportDeclaration","endLine":12,"endColumn":92,"fix":{"range":[136,409],"text":"import { DistanceCalculatorService } from '@core/services/geo/distance-calculator.service';\nimport type {\n  CarWithDistance,\n  DateRange,\n  FilterState,\n  LocationCoords,\n  SortOption,\n  ViewMode,\n} from '../models/marketplace.model';\nimport type { Car } from '../models';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { isPlatformBrowser } from '@angular/common';\nimport { computed, inject, Injectable, PLATFORM_ID, signal } from '@angular/core';\nimport type {\n  CarWithDistance,\n  DateRange,\n  FilterState,\n  LocationCoords,\n  SortOption,\n  ViewMode,\n} from '../models/marketplace.model';\nimport type { Car } from '../models';\nimport { DistanceCalculatorService } from '@core/services/geo/distance-calculator.service';\n\n/**\n * MarketplaceLandingService - State management for landing page\n *\n * Manages:\n * - Search state (query, location, date range)\n * - Filter state (price, transmission, vehicle type, quick filters)\n * - View preferences (grid/list/map, sort order)\n * - User location\n */\n@Injectable({\n  providedIn: 'root',\n})\nexport class MarketplaceLandingService {\n  private readonly platformId = inject(PLATFORM_ID);\n  private readonly isBrowser = isPlatformBrowser(this.platformId);\n  private readonly distanceCalculator = inject(DistanceCalculatorService);\n\n  // ─── Search State ───────────────────────────────────────────────────────\n  readonly searchQuery = signal<string>('');\n  readonly selectedLocation = signal<string>('');\n  readonly dateRange = signal<DateRange>({ from: null, to: null });\n\n  // ─── Filter State ───────────────────────────────────────────────────────\n  readonly filters = signal<FilterState>({\n    dateRange: null,\n    priceRange: null,\n    vehicleTypes: null,\n    immediateOnly: false,\n    transmission: null,\n  });\n\n  readonly activeQuickFilters = signal<Set<string>>(new Set());\n\n  // ─── View State ─────────────────────────────────────────────────────────\n  readonly viewMode = signal<ViewMode>(this.loadViewMode());\n  readonly sortOrder = signal<SortOption>('distance');\n\n  // ─── Location State ─────────────────────────────────────────────────────\n  readonly userLocation = signal<LocationCoords | null>(null);\n  readonly locationAccuracy = signal<number | null>(null);\n  readonly lastLocationUpdate = signal<Date | null>(null);\n\n  // ─── Cars Data ──────────────────────────────────────────────────────────\n  readonly cars = signal<Car[]>([]);\n  readonly loading = signal<boolean>(false);\n  readonly error = signal<string | null>(null);\n\n  // ─── Computed: Active Filter Count ──────────────────────────────────────\n  readonly activeFilterCount = computed(() => {\n    let count = 0;\n    const f = this.filters();\n\n    if (f.priceRange) count++;\n    if (f.vehicleTypes && f.vehicleTypes.length > 0) count++;\n    if (f.immediateOnly) count++;\n    if (f.transmission && f.transmission.length > 0) count++;\n    count += this.activeQuickFilters().size;\n\n    return count;\n  });\n\n  // ─── Computed: Has Active Filters ───────────────────────────────────────\n  readonly hasActiveFilters = computed(() => this.activeFilterCount() > 0);\n\n  // ─── Computed: Cars with Distance ───────────────────────────────────────\n  readonly carsWithDistance = computed<CarWithDistance[]>(() => {\n    const carsList = this.cars();\n    const userLoc = this.userLocation();\n\n    if (!carsList.length || !userLoc) {\n      return carsList.map((car) => ({ ...car }));\n    }\n\n    return carsList.map((car) => {\n      if (!car.location_lat || !car.location_lng) {\n        return { ...car };\n      }\n\n      const distanceKm = this.distanceCalculator.calculateDistance(\n        userLoc.lat,\n        userLoc.lng,\n        car.location_lat,\n        car.location_lng,\n      );\n\n      let distanceText: string;\n      if (distanceKm < 1) {\n        distanceText = `${Math.round(distanceKm * 10) * 100}m`;\n      } else if (distanceKm < 10) {\n        distanceText = `${distanceKm.toFixed(1)}km`;\n      } else {\n        distanceText = `${Math.round(distanceKm)}km`;\n      }\n\n      return {\n        ...car,\n        distance: distanceKm,\n        distanceText,\n      };\n    });\n  });\n\n  // ─── Computed: Filtered & Sorted Cars ───────────────────────────────────\n  readonly visibleCars = computed(() => {\n    let cars = [...this.carsWithDistance()];\n    const filters = this.filters();\n    const quickFilters = this.activeQuickFilters();\n\n    // Apply filters\n    if (filters.priceRange) {\n      cars = cars.filter(\n        (c) =>\n          c.price_per_day >= filters.priceRange!.min && c.price_per_day <= filters.priceRange!.max,\n      );\n    }\n\n    if (filters.transmission && filters.transmission.length > 0) {\n      cars = cars.filter((c) => filters.transmission!.includes(c.transmission));\n    }\n\n    if (filters.immediateOnly) {\n      cars = cars.filter((c) => c.auto_approval);\n    }\n\n    // Apply quick filters\n    if (quickFilters.has('verified')) {\n      cars = cars.filter((c) => c.owner?.email_verified && c.owner?.phone_verified);\n    }\n\n    if (quickFilters.has('electric')) {\n      cars = cars.filter((c) => c.fuel_type === 'electric' || c.fuel === 'electric');\n    }\n\n    if (quickFilters.has('no-card')) {\n      cars = cars.filter(\n        (c) =>\n          c.payment_methods?.some((pm) =>\n            ['debit_card', 'cash', 'transfer', 'wallet'].includes(pm),\n          ) || !c.payment_methods?.includes('credit_card'),\n      );\n    }\n\n    // Apply sorting\n    const sort = this.sortOrder();\n    switch (sort) {\n      case 'distance':\n        cars = cars.sort((a, b) => {\n          const distA = a.distance ?? Number.MAX_VALUE;\n          const distB = b.distance ?? Number.MAX_VALUE;\n          return distA - distB;\n        });\n        break;\n\n      case 'price_asc':\n        cars = cars.sort((a, b) => a.price_per_day - b.price_per_day);\n        break;\n\n      case 'price_desc':\n        cars = cars.sort((a, b) => b.price_per_day - a.price_per_day);\n        break;\n\n      case 'rating':\n        cars = cars.sort((a, b) => {\n          const ratingA = a.rating_avg ?? 0;\n          const ratingB = b.rating_avg ?? 0;\n          return ratingB - ratingA;\n        });\n        break;\n\n      default:\n        // Keep default order\n        break;\n    }\n\n    return cars;\n  });\n\n  // ─── Computed: Stats ────────────────────────────────────────────────────\n  readonly statsData = computed(() => {\n    const cars = this.carsWithDistance();\n    const nearbyCars = cars.filter((c) => c.distance && c.distance < 5).length;\n    const avgPrice = this.calculateAveragePrice(cars);\n\n    return {\n      totalCars: cars.length,\n      nearbyCars,\n      avgPrice,\n      minPrice: cars.length > 0 ? Math.min(...cars.map((c) => c.price_per_day)) : 0,\n    };\n  });\n\n  // ─── Methods: Search ────────────────────────────────────────────────────\n  setSearchQuery(query: string): void {\n    this.searchQuery.set(query);\n  }\n\n  setLocation(location: string): void {\n    this.selectedLocation.set(location);\n  }\n\n  setDateRange(range: DateRange): void {\n    this.dateRange.set(range);\n  }\n\n  // ─── Methods: Filters ───────────────────────────────────────────────────\n  updateFilters(filters: Partial<FilterState>): void {\n    this.filters.update((current) => ({ ...current, ...filters }));\n  }\n\n  toggleQuickFilter(filterId: string): void {\n    this.activeQuickFilters.update((current) => {\n      const newSet = new Set(current);\n      if (newSet.has(filterId)) {\n        newSet.delete(filterId);\n      } else {\n        newSet.add(filterId);\n      }\n      return newSet;\n    });\n\n    // Sync with main filters if needed\n    if (filterId === 'immediate') {\n      this.filters.update((f) => ({\n        ...f,\n        immediateOnly: this.activeQuickFilters().has('immediate'),\n      }));\n    }\n  }\n\n  isQuickFilterActive(filterId: string): boolean {\n    return this.activeQuickFilters().has(filterId);\n  }\n\n  clearAllFilters(): void {\n    this.filters.set({\n      dateRange: null,\n      priceRange: null,\n      vehicleTypes: null,\n      immediateOnly: false,\n      transmission: null,\n    });\n    this.activeQuickFilters.set(new Set());\n  }\n\n  // ─── Methods: View ──────────────────────────────────────────────────────\n  setViewMode(mode: ViewMode): void {\n    this.viewMode.set(mode);\n    this.saveViewMode(mode);\n  }\n\n  setSortOrder(order: SortOption): void {\n    this.sortOrder.set(order);\n  }\n\n  // ─── Methods: Location ──────────────────────────────────────────────────\n  setUserLocation(coords: LocationCoords): void {\n    this.userLocation.set(coords);\n    this.lastLocationUpdate.set(new Date());\n  }\n\n  // ─── Methods: Cars Data ─────────────────────────────────────────────────\n  setCars(cars: Car[]): void {\n    this.cars.set(cars);\n  }\n\n  setLoading(loading: boolean): void {\n    this.loading.set(loading);\n  }\n\n  setError(error: string | null): void {\n    this.error.set(error);\n  }\n\n  // ─── Private Helpers ────────────────────────────────────────────────────\n  private calculateAveragePrice(cars: CarWithDistance[]): number {\n    if (cars.length === 0) return 0;\n    const sum = cars.reduce((acc, car) => acc + car.price_per_day, 0);\n    return Math.round(sum / cars.length);\n  }\n\n  private loadViewMode(): ViewMode {\n    if (!this.isBrowser) return 'list';\n    const stored = localStorage.getItem('autorenta-view-mode');\n    if (stored === 'grid' || stored === 'list' || stored === 'map') {\n      return stored;\n    }\n    return 'list';\n  }\n\n  private saveViewMode(mode: ViewMode): void {\n    if (!this.isBrowser) return;\n    localStorage.setItem('autorenta-view-mode', mode);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/core/services/bookings/marketplace-onboarding.service.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`../../../environments/environment` import should occur after import of `@core/services/infrastructure/encryption.service`","line":2,"column":1,"nodeType":"ImportDeclaration","endLine":2,"endColumn":65,"fix":{"range":[52,291],"text":"import { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\nimport { EncryptionService } from '@core/services/infrastructure/encryption.service';\nimport { environment } from '../../../environments/environment';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { Injectable, inject } from '@angular/core';\nimport { environment } from '../../../environments/environment';\nimport { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\nimport { EncryptionService } from '@core/services/infrastructure/encryption.service';\n\n/**\n * Estado de onboarding de Mercado Pago\n */\nexport interface MpOnboardingState {\n  id: string;\n  user_id: string;\n  state: string;\n  redirect_uri?: string;\n  expires_at: string;\n  completed: boolean;\n  completed_at?: string;\n  error?: string;\n  created_at: string;\n}\n\n/**\n * Datos del callback de OAuth\n */\nexport interface MpOAuthCallback {\n  code: string;\n  state: string;\n}\n\n/**\n * Respuesta del token exchange\n */\nexport interface MpTokenResponse {\n  access_token: string;\n  token_type: string;\n  expires_in: number;\n  scope: string;\n  user_id: string; // Este es el collector_id\n  refresh_token: string;\n  public_key: string;\n  live_mode: boolean;\n}\n\n/**\n * Estado de marketplace del usuario\n */\nexport interface MarketplaceStatus {\n  isApproved: boolean;\n  collectorId?: string;\n  completedAt?: string;\n  hasActiveTokens: boolean;\n}\n\n/**\n * Servicio para gestionar el onboarding de propietarios en Mercado Pago Marketplace\n *\n * Flujo:\n * 1. startOnboarding() - Genera URL OAuth y guarda state\n * 2. Usuario autoriza en Mercado Pago\n * 3. handleCallback() - Intercambia code por tokens y guarda collector_id\n * 4. Usuario puede recibir pagos split\n */\n@Injectable({\n  providedIn: 'root',\n})\nexport class MarketplaceOnboardingService {\n  private readonly supabase = injectSupabase();\n  private readonly encryptionService = inject(EncryptionService);\n\n  // URLs de Mercado Pago\n  private readonly MP_OAUTH_URL = 'https://auth.mercadopago.com.ar/authorization';\n  private readonly MP_TOKEN_URL = 'https://api.mercadopago.com/oauth/token';\n\n  // Credenciales (deben estar en environment)\n  // P0-027 FIX: CLIENT_ID is public (OK for frontend)\n  // CLIENT_SECRET is NEVER exposed to frontend - handled by backend Edge Function\n  private readonly CLIENT_ID = environment.mercadopagoClientId;\n  private readonly REDIRECT_URI = `${environment.appUrl}/mp-callback`;\n\n  // Scopes requeridos para marketplace\n  private readonly SCOPES = 'read write offline_access';\n\n  /**\n   * Inicia el flujo OAuth para vincular cuenta MP del propietario\n   *\n   * @param userId ID del usuario que va a vincular su cuenta\n   * @returns URL de autorización de Mercado Pago\n   */\n  async startOnboarding(userId: string): Promise<string> {\n    // Generar state único para CSRF protection\n    const state = this.generateSecureState();\n\n    // Calcular expiración (10 minutos)\n    const expiresAt = new Date(Date.now() + 10 * 60 * 1000).toISOString();\n\n    // Guardar state en BD\n    const { error: insertError } = await this.supabase.from('mp_onboarding_states').insert({\n      user_id: userId,\n      state,\n      redirect_uri: this.REDIRECT_URI,\n      expires_at: expiresAt,\n    });\n\n    if (insertError) {\n      throw new Error('No se pudo iniciar el proceso de vinculación');\n    }\n\n    // Construir URL de autorización\n    const authUrl = this.buildAuthorizationUrl(state);\n\n    return authUrl;\n  }\n\n  /**\n   * Maneja el callback de OAuth después de la autorización\n   *\n   * @param code Code de autorización\n   * @param state State para validación CSRF\n   * @returns Collector ID del vendedor\n   */\n  async handleCallback(code: string, state: string): Promise<string> {\n    try {\n      // 1. Validar y obtener state\n      const stateData = await this.validateState(state);\n\n      // 2. Intercambiar code por tokens\n      const tokenResponse = await this.exchangeCodeForToken(code);\n\n      // 3. Guardar datos en BD\n      await this.saveMarketplaceCredentials(stateData.user_id, tokenResponse);\n\n      // 4. Marcar state como completado\n      await this.completeOnboardingState(state);\n\n      return tokenResponse.user_id;\n    } catch (error) {\n      // Guardar error en state\n      if (state) {\n        await this.supabase\n          .from('mp_onboarding_states')\n          .update({\n            error: error instanceof Error ? error.message : 'Unknown error',\n          })\n          .eq('state', state);\n      }\n\n      throw error;\n    }\n  }\n\n  /**\n   * Obtiene el estado de marketplace del usuario\n   *\n   * @param userId ID del usuario\n   * @returns Estado de marketplace\n   */\n  async getMarketplaceStatus(userId: string): Promise<MarketplaceStatus> {\n    try {\n      const { data, error } = await this.supabase\n        .from('profiles')\n        .select(\n          'mercadopago_collector_id, mp_onboarding_completed, mp_onboarding_url, mercadopago_access_token_expires_at',\n        )\n        .eq('id', userId)\n        .maybeSingle();\n\n      if (error) {\n        return {\n          isApproved: false,\n          hasActiveTokens: false,\n        };\n      }\n\n      const hasActiveTokens = data?.mercadopago_access_token_expires_at\n        ? new Date(data.mercadopago_access_token_expires_at) > new Date()\n        : false;\n\n      return {\n        isApproved: data?.mp_onboarding_completed || false,\n        collectorId: data?.mercadopago_collector_id || undefined,\n        completedAt: undefined,\n        hasActiveTokens,\n      };\n    } catch {\n      return {\n        isApproved: false,\n        hasActiveTokens: false,\n      };\n    }\n  }\n\n  /**\n   * Verifica si el usuario puede listar autos (tiene MP vinculado)\n   * Usa la nueva RPC function que consulta mp_onboarding_states\n   *\n   * @param userId ID del usuario\n   * @returns true si puede listar\n   */\n  async canListCars(userId: string): Promise<boolean> {\n    try {\n      // Usar la nueva RPC function del migration 004\n      const { data, error } = await this.supabase.rpc('can_list_cars', {\n        p_user_id: userId,\n      });\n\n      if (error) {\n        return false;\n      }\n\n      return data === true;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Desvincula la cuenta de Mercado Pago\n   * (Requiere revocar tokens en MP)\n   *\n   * @param userId ID del usuario\n   */\n  async unlinkAccount(userId: string): Promise<void> {\n    // TODO: Revocar tokens en Mercado Pago API\n    // https://api.mercadopago.com/oauth/token/revoke\n\n    // Limpiar datos locales\n    const { error } = await this.supabase\n      .from('profiles')\n      .update({\n        mercadopago_collector_id: null,\n        mp_onboarding_completed: false,\n        mp_onboarding_url: null,\n        mercadopago_access_token: null,\n        mercadopago_refresh_token: null,\n        mercadopago_access_token_expires_at: null,\n      })\n      .eq('id', userId);\n\n    if (error) throw error;\n  }\n\n  /**\n   * Obtiene el access token desencriptado de un usuario\n   * Útil para hacer llamadas a la API de MercadoPago\n   *\n   * @param userId ID del usuario\n   * @returns Access token en plaintext o null si no existe\n   */\n  async getDecryptedAccessToken(userId: string): Promise<string | null> {\n    try {\n      const { data, error } = await this.supabase\n        .from('profiles')\n        .select('mercadopago_access_token')\n        .eq('id', userId)\n        .maybeSingle();\n\n      if (error || !data?.mercadopago_access_token) {\n        return null;\n      }\n\n      // Desencriptar token\n      return await this.encryptionService.decrypt(data.mercadopago_access_token);\n    } catch {\n      return null;\n    }\n  }\n\n  /**\n   * Obtiene el refresh token desencriptado de un usuario\n   * Útil para renovar el access token cuando expire\n   *\n   * @param userId ID del usuario\n   * @returns Refresh token en plaintext o null si no existe\n   */\n  async getDecryptedRefreshToken(userId: string): Promise<string | null> {\n    try {\n      const { data, error } = await this.supabase\n        .from('profiles')\n        .select('mercadopago_refresh_token')\n        .eq('id', userId)\n        .maybeSingle();\n\n      if (error || !data?.mercadopago_refresh_token) {\n        return null;\n      }\n\n      // Desencriptar token\n      return await this.encryptionService.decrypt(data.mercadopago_refresh_token);\n    } catch {\n      return null;\n    }\n  }\n\n  // ============================================================================\n  // MÉTODOS PRIVADOS\n  // ============================================================================\n\n  /**\n   * Genera un state seguro para OAuth\n   */\n  private generateSecureState(): string {\n    // Generar 32 bytes random en hex\n    const array = new Uint8Array(32);\n    crypto.getRandomValues(array);\n    return Array.from(array, (byte) => byte.toString(16).padStart(2, '0')).join('');\n  }\n\n  /**\n   * Construye la URL de autorización de Mercado Pago\n   */\n  private buildAuthorizationUrl(state: string): string {\n    const params = new URLSearchParams({\n      client_id: this.CLIENT_ID,\n      response_type: 'code',\n      platform_id: 'mp',\n      state: state,\n      redirect_uri: this.REDIRECT_URI,\n    });\n\n    return `${this.MP_OAUTH_URL}?${params.toString()}`;\n  }\n\n  /**\n   * Valida el state y obtiene los datos\n   */\n  private async validateState(state: string): Promise<MpOnboardingState> {\n    const { data, error } = await this.supabase\n      .from('mp_onboarding_states')\n      .select('*')\n      .eq('state', state)\n      .single();\n\n    if (error || !data) {\n      throw new Error('Estado de onboarding inválido o expirado');\n    }\n\n    // Verificar expiración\n    if (new Date(data.expires_at) < new Date()) {\n      throw new Error('El estado de onboarding ha expirado');\n    }\n\n    // Verificar que no esté ya completado\n    if (data.completed) {\n      throw new Error('Este onboarding ya fue completado');\n    }\n\n    return data as MpOnboardingState;\n  }\n\n  /**\n   * Intercambia el code por tokens de acceso\n   * P0-027 FIX: OAuth token exchange MUST happen on backend to protect CLIENT_SECRET\n   * This method is now deprecated - use backend Edge Function instead\n   * @deprecated Use mercadopago-oauth-callback Edge Function instead\n   */\n  private async exchangeCodeForToken(code: string): Promise<MpTokenResponse> {\n    // P0-027 FIX: Token exchange MUST be done server-side\n    // Call backend Edge Function that has access to CLIENT_SECRET\n    const { data, error } = await this.supabase.functions.invoke('mercadopago-oauth-callback', {\n      body: { code },\n    });\n\n    if (error || !data?.success) {\n      console.error('[MP OAuth] Error from backend:', error || data?.error);\n      throw new Error(data?.error || 'No se pudo completar la autorización con Mercado Pago');\n    }\n\n    // Backend returns the full token response\n    return data as unknown as MpTokenResponse;\n  }\n\n  /**\n   * Guarda las credenciales de marketplace en BD\n   * Los tokens se encriptan con AES-256-GCM antes de almacenarlos\n   */\n  private async saveMarketplaceCredentials(\n    userId: string,\n    tokenResponse: MpTokenResponse,\n  ): Promise<void> {\n    // Calcular expiración del token\n    const expiresAt = new Date(Date.now() + tokenResponse.expires_in * 1000).toISOString();\n\n    // ✅ ENCRIPTAR tokens antes de guardar\n    const encryptedAccessToken = await this.encryptionService.encrypt(tokenResponse.access_token);\n    const encryptedRefreshToken = await this.encryptionService.encrypt(tokenResponse.refresh_token);\n\n    const { error } = await this.supabase\n      .from('profiles')\n      .update({\n        mercadopago_collector_id: tokenResponse.user_id,\n        mp_onboarding_completed: true,\n        mercadopago_access_token: encryptedAccessToken,\n        mercadopago_refresh_token: encryptedRefreshToken,\n        mercadopago_access_token_expires_at: expiresAt,\n      })\n      .eq('id', userId);\n\n    if (error) {\n      throw new Error('No se pudieron guardar las credenciales');\n    }\n  }\n\n  /**\n   * Marca el state como completado\n   */\n  private async completeOnboardingState(state: string): Promise<void> {\n    const { error } = await this.supabase\n      .from('mp_onboarding_states')\n      .update({\n        completed: true,\n        completed_at: new Date().toISOString(),\n      })\n      .eq('state', state);\n\n    if (error) {\n      // No throw, esto no es crítico\n    }\n  }\n\n  /**\n   * Refresh access token (cuando expira)\n   * P0-027 FIX: Token refresh MUST happen on backend to protect CLIENT_SECRET\n   * @deprecated Use backend Edge Function for token refresh\n   */\n  private async refreshAccessToken(refreshToken: string): Promise<MpTokenResponse> {\n    // P0-027 FIX: Call backend to refresh token (CLIENT_SECRET is backend-only)\n    const { data, error } = await this.supabase.functions.invoke('mercadopago-refresh-token', {\n      body: { refresh_token: refreshToken },\n    });\n\n    if (error || !data?.success) {\n      console.error('[MP Refresh] Error from backend:', error || data?.error);\n      throw new Error(data?.error || 'Failed to refresh token');\n    }\n\n    return data as unknown as MpTokenResponse;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/core/services/bookings/messages.repo.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`@core/services/infrastructure/logger.service` import should occur before import of `../contracts/chat-message.schemas`","line":4,"column":1,"nodeType":"ImportDeclaration","endLine":4,"endColumn":78,"fix":{"range":[81,236],"text":"import { LoggerService } from '@core/services/infrastructure/logger.service';\nimport { ChatMessageInsertSchema } from '../contracts/chat-message.schemas';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { SupabaseClient } from '@supabase/supabase-js';\nimport { z } from 'zod';\nimport { ChatMessageInsertSchema } from '../contracts/chat-message.schemas';\nimport { LoggerService } from '@core/services/infrastructure/logger.service';\n\n// Mock for queueOffline\nconst logger = new LoggerService();\nconst queueOffline = (data: unknown) => {\n  logger.debug('Queuing offline', 'MessagesRepo', data);\n};\n\ntype RawInsertInput = z.input<typeof ChatMessageInsertSchema> & {\n  full_name?: unknown;\n};\n\nexport async function insertMessage(supabase: SupabaseClient, input: unknown) {\n  try {\n    // Strip full_name before validation (UI might send it but DB doesn't need it)\n    const payload: RawInsertInput = { ...(input as RawInsertInput) };\n    if ('full_name' in payload) {\n      delete payload.full_name;\n    }\n\n    const clean = ChatMessageInsertSchema.parse(payload);\n    const { data, error } = await supabase.from('messages').insert(clean).select('*').single();\n    if (error) {\n      // 400 por esquema/columna => colar offline y reintentar luego\n      if (error.code === '42703' || error.code === '42P01') {\n        await queueOffline({ kind: 'message', payload: clean });\n        return { kind: 'queued-offline', reason: error.code };\n      }\n      console.error('Error inserting message:', error);\n      throw error;\n    }\n    return { kind: 'ok', data };\n  } catch (error: unknown) {\n    // This will catch Zod errors\n    if (error instanceof z.ZodError) {\n      console.error('Validation error:', error.errors);\n      return { kind: 'validation-error', errors: error.errors };\n    }\n    throw error;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/core/services/bookings/messages.service.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`../repositories/messages.repository` import should occur after import of `@core/services/infrastructure/rate-limiter.service`","line":4,"column":1,"nodeType":"ImportDeclaration","endLine":8,"endColumn":46,"fix":{"range":[199,724],"text":"import { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\nimport { RealtimeConnectionService, ConnectionStatus } from '@core/services/infrastructure/realtime-connection.service';\nimport { OfflineMessagesService } from '@core/services/infrastructure/offline-messages.service';\nimport { RateLimiterService } from '@core/services/infrastructure/rate-limiter.service';\nimport {\n  MessagesRepository,\n  ConversationListOptions,\n  PaginatedConversations,\n} from '../repositories/messages.repository';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { isPlatformBrowser } from '@angular/common';\nimport { Injectable, signal, inject, OnDestroy, PLATFORM_ID } from '@angular/core';\nimport type { RealtimeChannel } from '@supabase/supabase-js';\nimport {\n  MessagesRepository,\n  ConversationListOptions,\n  PaginatedConversations,\n} from '../repositories/messages.repository';\nimport { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\nimport { RealtimeConnectionService, ConnectionStatus } from '@core/services/infrastructure/realtime-connection.service';\nimport { OfflineMessagesService } from '@core/services/infrastructure/offline-messages.service';\nimport { RateLimiterService } from '@core/services/infrastructure/rate-limiter.service';\n\nexport interface Message {\n  id: string;\n  booking_id: string | null;\n  car_id: string | null;\n  sender_id: string;\n  recipient_id: string;\n  body: string;\n  created_at: string;\n  read_at: string | null;\n  delivered_at: string | null;\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class MessagesService implements OnDestroy {\n  private readonly supabase = injectSupabase();\n  private readonly realtimeConnection = inject(RealtimeConnectionService);\n  private readonly offlineMessages = inject(OfflineMessagesService);\n  private readonly messagesRepository = inject(MessagesRepository);\n  private readonly platformId = inject(PLATFORM_ID);\n  private readonly isBrowser = isPlatformBrowser(this.platformId);\n\n  // Bound event handlers for proper cleanup\n  private readonly handleOnline = () => {\n    this.isOnline.set(true);\n    this.syncOfflineMessages();\n  };\n  private readonly handleOffline = () => {\n    this.isOnline.set(false);\n  };\n\n  constructor(private readonly rateLimiter: RateLimiterService) {\n    // Monitor network connectivity with bound handlers for cleanup (browser only)\n    if (this.isBrowser) {\n      window.addEventListener('online', this.handleOnline);\n      window.addEventListener('offline', this.handleOffline);\n    }\n  }\n\n  ngOnDestroy(): void {\n    if (this.isBrowser) {\n      window.removeEventListener('online', this.handleOnline);\n      window.removeEventListener('offline', this.handleOffline);\n    }\n    this.unsubscribe();\n    // Clean up all typing channels\n    this.typingChannels.forEach((channel) => {\n      this.supabase.removeChannel(channel);\n    });\n    this.typingChannels.clear();\n  }\n\n  private realtimeChannel?: RealtimeChannel;\n\n  // Online/offline status\n  readonly isOnline = signal<boolean>(typeof navigator !== 'undefined' ? navigator.onLine : true);\n  readonly isSyncing = signal<boolean>(false);\n\n  async listByBooking(bookingId: string): Promise<Message[]> {\n    const { data, error } = await this.supabase\n      .from('messages')\n      .select('*')\n      .eq('booking_id', bookingId)\n      .order('created_at', { ascending: true });\n    if (error) throw error;\n    return (data ?? []) as Message[];\n  }\n\n  async listByCar(carId: string): Promise<Message[]> {\n    const { data, error } = await this.supabase\n      .from('messages')\n      .select('*')\n      .eq('car_id', carId)\n      .order('created_at', { ascending: true });\n    if (error) throw error;\n    return (data ?? []) as Message[];\n  }\n\n  async listCarLeadsForOwner(ownerId: string): Promise<\n    Array<{\n      message: Message;\n      car: { id: string; title?: string | null };\n      otherUserId: string;\n    }>\n  > {\n    const { data, error } = await this.supabase\n      .from('messages')\n      .select(\n        `\n        id,\n        booking_id,\n        car_id,\n        sender_id,\n        recipient_id,\n        body,\n        created_at,\n        read_at,\n        delivered_at,\n        car:cars!inner(id,title,owner_id)\n      `,\n      )\n      .is('booking_id', null)\n      .not('car_id', 'is', null)\n      .eq('car.owner_id', ownerId)\n      .order('created_at', { ascending: false });\n\n    if (error) throw error;\n\n    const rows = (data ?? []) as unknown as Array<\n      Message & {\n        car: { id: string; title?: string | null; owner_id?: string | null };\n      }\n    >;\n\n    return rows\n      .map((row) => {\n        const otherId = row.sender_id === ownerId ? row.recipient_id : row.sender_id;\n        if (!otherId) {\n          return null;\n        }\n        return {\n          message: {\n            id: row.id,\n            booking_id: row.booking_id,\n            car_id: row.car_id,\n            sender_id: row.sender_id,\n            recipient_id: row.recipient_id,\n            body: row.body,\n            created_at: row.created_at,\n            read_at: row.read_at,\n            delivered_at: row.delivered_at,\n          } as Message,\n          car: { id: row.car?.id, title: row.car?.title ?? null },\n          otherUserId: otherId,\n        };\n      })\n      .filter((lead): lead is NonNullable<typeof lead> => lead !== null);\n  }\n\n  async sendMessage(params: {\n    recipientId: string;\n    body: string;\n    bookingId?: string;\n    carId?: string;\n  }): Promise<Message> {\n    if (!params.bookingId && !params.carId) {\n      throw new Error('Debes indicar bookingId o carId');\n    }\n\n    const {\n      data: { user },\n      error: authError,\n    } = await this.supabase.auth.getUser();\n    if (authError) throw authError;\n    if (!user?.id) throw new Error('Usuario no autenticado');\n\n    // P0-015: Check rate limit for messages\n    if (!this.rateLimiter.isAllowed('messageSend', user.id)) {\n      this.rateLimiter.logViolation('messageSend', user.id);\n      throw new Error(this.rateLimiter.getErrorMessage('messageSend', user.id));\n    }\n\n    // Try to send immediately\n    try {\n      this.rateLimiter.recordAttempt('messageSend', user.id);\n      const { data, error } = await this.supabase\n        .from('messages')\n        .insert({\n          booking_id: params.bookingId ?? null,\n          car_id: params.carId ?? null,\n          sender_id: user.id,\n          recipient_id: params.recipientId,\n          body: params.body,\n        })\n        .select('*')\n        .single<Message>();\n\n      if (error) throw error;\n      if (!data) {\n        throw new Error('No se pudo obtener el mensaje enviado');\n      }\n\n      return data;\n    } catch (_error) {\n      // Queue for retry when connection is restored\n      await this.offlineMessages.queueMessage({\n        bookingId: params.bookingId,\n        carId: params.carId,\n        recipientId: params.recipientId,\n        body: params.body,\n      });\n\n      // Re-throw so UI can show \"Sending...\" state\n      throw _error;\n    }\n  }\n\n  subscribeToBooking(\n    bookingId: string,\n    handler: (message: Message) => void,\n    onConnectionChange?: (status: ConnectionStatus) => void,\n  ): void {\n    this.unsubscribe();\n\n    // Use resilient connection service with auto-reconnect\n    this.realtimeChannel = this.realtimeConnection.subscribeWithRetry<Message>(\n      `booking-messages-${bookingId}`,\n      {\n        event: '*', // Listen to all events (INSERT, UPDATE)\n        schema: 'public',\n        table: 'messages',\n        filter: `booking_id=eq.${bookingId}`,\n      },\n      (payload) => {\n        handler(payload.new as Message);\n      },\n      onConnectionChange,\n    );\n  }\n\n  /**\n   * Subscribe to messages by car ID (for pre-booking chats)\n   */\n  subscribeToCar(\n    carId: string,\n    handler: (message: Message) => void,\n    onConnectionChange?: (status: ConnectionStatus) => void,\n  ): void {\n    this.unsubscribe();\n\n    // Use resilient connection service with auto-reconnect\n    this.realtimeChannel = this.realtimeConnection.subscribeWithRetry<Message>(\n      `car-messages-${carId}`,\n      {\n        event: '*', // Listen to all events (INSERT, UPDATE)\n        schema: 'public',\n        table: 'messages',\n        filter: `car_id=eq.${carId}`,\n      },\n      (payload) => {\n        handler(payload.new as Message);\n      },\n      onConnectionChange,\n    );\n  }\n\n  async markAsRead(messageId: string): Promise<void> {\n    const { error } = await this.supabase\n      .from('messages')\n      .update({ read_at: new Date().toISOString() })\n      .eq('id', messageId);\n    if (error) throw error;\n  }\n\n  async markAsDelivered(messageId: string): Promise<void> {\n    const { error } = await this.supabase\n      .from('messages')\n      .update({ delivered_at: new Date().toISOString() })\n      .eq('id', messageId)\n      .is('delivered_at', null);\n    if (error) throw error;\n  }\n\n  // 🚀 PERF: Cache typing channels to prevent leaks\n  private typingChannels = new Map<string, RealtimeChannel>();\n\n  // Typing indicator usando presence\n  /**\n   * Establece el estado de typing para un booking\n   */\n  async setTyping(bookingId: string, userId: string, isTyping: boolean): Promise<void>;\n  /**\n   * Establece el estado de typing para un car chat\n   */\n  async setTyping(\n    contextId: string,\n    userId: string,\n    isTyping: boolean,\n    type: 'car' | 'booking',\n  ): Promise<void>;\n  async setTyping(\n    contextId: string,\n    userId: string,\n    isTyping: boolean,\n    type?: 'car' | 'booking',\n  ): Promise<void> {\n    try {\n      // Determinar el nombre del canal según el tipo\n      const channelName = type === 'car' ? `presence-car-${contextId}` : `presence-${contextId}`;\n\n      // Reuse existing channel or create new one\n      let channel = this.typingChannels.get(channelName);\n\n      if (!channel) {\n        channel = this.supabase.channel(channelName, {\n          config: {\n            presence: {\n              key: userId,\n            },\n          },\n        });\n        await channel.subscribe();\n        this.typingChannels.set(channelName, channel);\n      }\n\n      if (isTyping) {\n        await channel.track({ user_id: userId, typing: true });\n      } else {\n        await channel.untrack();\n        // Clean up channel when user stops typing\n        this.typingChannels.delete(channelName);\n        await this.supabase.removeChannel(channel);\n      }\n    } catch {\n      // Don't throw - typing is not critical\n    }\n  }\n\n  /**\n   * Suscribe a cambios de typing para un booking\n   */\n  subscribeToTyping(bookingId: string, callback: (typingUsers: string[]) => void): RealtimeChannel;\n  /**\n   * Suscribe a cambios de typing para un car chat\n   */\n  subscribeToTyping(\n    contextId: string,\n    callback: (typingUsers: string[]) => void,\n    type: 'car' | 'booking',\n  ): RealtimeChannel;\n  subscribeToTyping(\n    contextId: string,\n    callback: (typingUsers: string[]) => void,\n    type?: 'car' | 'booking',\n  ): RealtimeChannel {\n    // Determinar el nombre del canal según el tipo\n    const channelName = type === 'car' ? `presence-car-${contextId}` : `presence-${contextId}`;\n\n    const channel = this.supabase\n      .channel(channelName, {\n        config: {\n          presence: {\n            key: 'typing',\n          },\n        },\n      })\n      .on('presence', { event: 'sync' }, () => {\n        try {\n          const state = channel.presenceState();\n          // Presence state is Record<string, unknown[]>\n          const typingUsers = Object.values(state)\n            .flat()\n            .filter(\n              (\n                presence,\n              ): presence is { typing?: boolean; user_id?: string; presence_ref: string } => {\n                return typeof presence === 'object' && presence !== null && 'typing' in presence;\n              },\n            )\n            .filter((presence) => presence.typing)\n            .map((presence) => presence.user_id)\n            .filter((id): id is string => typeof id === 'string');\n          callback(typingUsers);\n        } catch {\n          // Silently ignore typing errors\n        }\n      })\n      .subscribe((status) => {\n        if (status === 'SUBSCRIBED') {\n          console.debug('[Messages] Typing subscription active');\n        }\n      });\n\n    return channel;\n  }\n\n  /**\n   * Sync offline messages when connection is restored\n   */\n  private async syncOfflineMessages(): Promise<void> {\n    this.isSyncing.set(true);\n\n    try {\n      const pending = await this.offlineMessages.getMessagesForRetry();\n\n      for (const message of pending) {\n        // Check if we should retry this message (respects exponential backoff)\n        if (!this.offlineMessages.shouldRetry(message)) {\n          continue;\n        }\n\n        try {\n          const {\n            data: { user },\n          } = await this.supabase.auth.getUser();\n          if (!user?.id) {\n            continue;\n          }\n\n          // Attempt to send\n          const { error } = await this.supabase.from('messages').insert({\n            booking_id: message.bookingId ?? null,\n            car_id: message.carId ?? null,\n            sender_id: user.id,\n            recipient_id: message.recipientId,\n            body: message.body,\n          });\n\n          if (error) throw error;\n\n          // Success: remove from queue\n          await this.offlineMessages.removeMessage(message.id);\n        } catch {\n          // Increment retry counter\n          await this.offlineMessages.incrementRetry(message.id);\n\n          // If exceeded max retries, remove\n          if (message.retries + 1 >= 5) {\n            await this.offlineMessages.removeMessage(message.id);\n          }\n        }\n      }\n    } catch {\n      // Silently ignore sync errors\n    } finally {\n      this.isSyncing.set(false);\n    }\n  }\n\n  unsubscribe(): void {\n    if (this.realtimeChannel) {\n      this.realtimeConnection.unsubscribe(this.realtimeChannel.topic);\n      this.realtimeChannel = undefined;\n    }\n  }\n\n  /**\n   * Lista conversaciones con paginación usando MessagesRepository\n   */\n  async listConversations(\n    userId: string,\n    options?: ConversationListOptions,\n  ): Promise<PaginatedConversations> {\n    return this.messagesRepository.listConversations(userId, options);\n  }\n\n  /**\n   * Marca una conversación completa como leída\n   * Actualiza todos los mensajes no leídos de la conversación\n   */\n  async markConversationRead(\n    conversationId: string,\n    userId: string,\n    type: 'booking' | 'car',\n  ): Promise<void> {\n    const filter = type === 'booking' ? { booking_id: conversationId } : { car_id: conversationId };\n\n    const { error } = await this.supabase\n      .from('messages')\n      .update({ read_at: new Date().toISOString() })\n      .eq('recipient_id', userId)\n      .match(filter)\n      .is('read_at', null);\n\n    if (error) throw error;\n  }\n\n  /**\n   * Bloquea a un usuario en el servidor.\n   */\n  async blockUser(userIdToBlock: string): Promise<void> {\n    const {\n      data: { user },\n    } = await this.supabase.auth.getUser();\n    if (!user) throw new Error('No autenticado');\n\n    const { error } = await this.supabase.from('user_blocks').insert({\n      blocker_id: user.id,\n      blocked_id: userIdToBlock,\n    });\n\n    if (error) throw error;\n  }\n\n  /**\n   * Desbloquea a un usuario en el servidor.\n   */\n  async unblockUser(userIdToUnblock: string): Promise<void> {\n    const {\n      data: { user },\n    } = await this.supabase.auth.getUser();\n    if (!user) throw new Error('No autenticado');\n\n    const { error } = await this.supabase\n      .from('user_blocks')\n      .delete()\n      .eq('blocker_id', user.id)\n      .eq('blocked_id', userIdToUnblock);\n\n    if (error) throw error;\n  }\n\n  /**\n   * Verifica si el usuario actual ha bloqueado a otro usuario.\n   */\n  async isUserBlocked(userId: string): Promise<boolean> {\n    const {\n      data: { user },\n    } = await this.supabase.auth.getUser();\n    if (!user) return false;\n\n    const { count, error } = await this.supabase\n      .from('user_blocks')\n      .select('*', { count: 'exact', head: true })\n      .eq('blocker_id', user.id)\n      .eq('blocked_id', userId);\n\n    if (error) return false;\n    return (count ?? 0) > 0;\n  }\n\n  /**\n   * Formatea una fecha relativa para mostrar en UI\n   * Ejemplos: \"Ahora\", \"Hace 5m\", \"Hace 2h\", \"Hace 3d\", \"15 nov\"\n   */\n  formatRelativeDate(date: Date | string): string {\n    const dateObj = typeof date === 'string' ? new Date(date) : date;\n    const now = new Date();\n    const diff = now.getTime() - dateObj.getTime();\n    const minutes = Math.floor(diff / 60000);\n    const hours = Math.floor(diff / 3600000);\n    const days = Math.floor(diff / 86400000);\n\n    if (minutes < 1) return 'Ahora';\n    if (minutes < 60) return `Hace ${minutes}m`;\n    if (hours < 24) return `Hace ${hours}h`;\n    if (days < 7) return `Hace ${days}d`;\n\n    return dateObj.toLocaleDateString('es-AR', { day: 'numeric', month: 'short' });\n  }\n\n  /**\n   * Formatea hora para mostrar en mensajes\n   * Ejemplo: \"14:30\"\n   */\n  formatTime(dateStr: string): string {\n    return new Date(dateStr).toLocaleTimeString('es-AR', {\n      hour: '2-digit',\n      minute: '2-digit',\n    });\n  }\n\n  /**\n   * Formatea fecha completa para mostrar en mensajes\n   * Ejemplo: \"15 nov 2024, 14:30\"\n   */\n  formatDateTime(dateStr: string): string {\n    return new Date(dateStr).toLocaleString('es-AR', {\n      day: 'numeric',\n      month: 'short',\n      year: 'numeric',\n      hour: '2-digit',\n      minute: '2-digit',\n    });\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/core/services/bookings/unread-messages.service.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`./car-owner-notifications.service` import should occur after import of `@core/services/auth/profile.service`","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":82,"fix":{"range":[302,518],"text":"import { CarsService } from '@core/services/cars/cars.service';\nimport { ProfileService } from '@core/services/auth/profile.service';\nimport { CarOwnerNotificationsService } from './car-owner-notifications.service';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { Injectable, signal, inject, computed, effect, Injector } from '@angular/core';\nimport type { RealtimeChannel } from '@supabase/supabase-js';\nimport { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\nimport { AuthService } from '@core/services/auth/auth.service';\nimport { CarOwnerNotificationsService } from './car-owner-notifications.service';\nimport { CarsService } from '@core/services/cars/cars.service';\nimport { ProfileService } from '@core/services/auth/profile.service';\n\nexport interface UnreadConversation {\n  conversationId: string; // booking_id or car_id\n  type: 'booking' | 'car';\n  unreadCount: number;\n  lastMessage: string;\n  lastMessageAt: string;\n  otherUserId: string;\n  otherUserName?: string;\n}\n\ninterface MessageRow {\n  id: string;\n  booking_id: string | null;\n  car_id: string | null;\n  sender_id: string;\n  recipient_id: string;\n  body: string;\n  created_at: string;\n  read_at: string | null;\n}\n\ninterface AudioContextWindow extends Window {\n  webkitAudioContext?: typeof AudioContext;\n}\n\n/**\n * Service to track unread messages count across all conversations\n * Supports both booking-based and car-based conversations\n */\n@Injectable({\n  providedIn: 'root',\n})\nexport class UnreadMessagesService {\n  private readonly supabase = injectSupabase();\n  private readonly authService = inject(AuthService);\n  private readonly carOwnerNotifications = inject(CarOwnerNotificationsService);\n  private readonly carsService = inject(CarsService);\n  private readonly profileService = inject(ProfileService);\n\n  private realtimeChannel?: RealtimeChannel;\n\n  // Signals for reactivity\n  readonly unreadConversations = signal<UnreadConversation[]>([]);\n  readonly totalUnreadCount = computed(() =>\n    this.unreadConversations().reduce((sum, conv) => sum + conv.unreadCount, 0),\n  );\n  readonly isLoading = signal(false);\n\n  constructor() {\n    effect(\n      () => {\n        const session = this.authService.session$();\n        if (session?.user) {\n          this.initialize();\n        } else {\n          this.cleanup();\n        }\n      },\n      { injector: this.injector },\n    );\n  }\n\n  private readonly injector = inject(Injector);\n\n  /**\n   * Initialize the service: fetch unread counts and subscribe to real-time updates\n   */\n  async initialize(): Promise<void> {\n    const user = this.authService.session$()?.user;\n    if (!user) return;\n\n    this.isLoading.set(true);\n\n    try {\n      await this.fetchUnreadConversations(user.id);\n      this.subscribeToNewMessages(user.id);\n    } catch {\n      // Silent fail\n    } finally {\n      this.isLoading.set(false);\n    }\n  }\n\n  /**\n   * Fetch all conversations with unread messages\n   */\n  private async fetchUnreadConversations(userId: string): Promise<void> {\n    try {\n      // Fetch unread messages grouped by conversation\n      const { data, error } = await this.supabase\n        .from('messages')\n        .select('id, booking_id, car_id, sender_id, recipient_id, body, created_at')\n        .eq('recipient_id', userId)\n        .is('read_at', null)\n        .order('created_at', { ascending: false });\n\n      if (error) throw error;\n\n      if (!data || data.length === 0) {\n        this.unreadConversations.set([]);\n        return;\n      }\n\n      // Group by conversation (booking_id or car_id)\n      const conversationsMap = new Map<string, UnreadConversation>();\n\n      const messages = (data as MessageRow[]) ?? [];\n\n      for (const message of messages) {\n        const conversationId = message.booking_id ?? message.car_id;\n        if (!conversationId) continue;\n\n        const type = message.booking_id ? 'booking' : 'car';\n        const key = `${type}-${conversationId}`;\n\n        if (!conversationsMap.has(key)) {\n          conversationsMap.set(key, {\n            conversationId,\n            type: type as 'booking' | 'car',\n            unreadCount: 0,\n            lastMessage: message.body,\n            lastMessageAt: message.created_at,\n            otherUserId: message.sender_id,\n          });\n        }\n\n        const conv = conversationsMap.get(key)!;\n        conv.unreadCount++;\n\n        // Keep the most recent message\n        if (new Date(message.created_at) > new Date(conv.lastMessageAt)) {\n          conv.lastMessage = message.body;\n          conv.lastMessageAt = message.created_at;\n        }\n      }\n\n      this.unreadConversations.set(Array.from(conversationsMap.values()));\n    } catch {\n      // Silent fail\n    }\n  }\n\n  /**\n   * Subscribe to real-time new messages\n   */\n  private subscribeToNewMessages(userId: string): void {\n    // Unsubscribe from any existing channel\n    if (this.realtimeChannel) {\n      this.supabase.removeChannel(this.realtimeChannel);\n    }\n\n    // Subscribe to messages table for new messages where user is recipient\n    this.realtimeChannel = this.supabase\n      .channel('unread-messages')\n      .on(\n        'postgres_changes',\n        {\n          event: 'INSERT',\n          schema: 'public',\n          table: 'messages',\n          filter: `recipient_id=eq.${userId}`,\n        },\n        (payload) => {\n          this.handleNewMessage(payload.new as MessageRow);\n        },\n      )\n      .on(\n        'postgres_changes',\n        {\n          event: 'UPDATE',\n          schema: 'public',\n          table: 'messages',\n          filter: `recipient_id=eq.${userId}`,\n        },\n        (payload) => {\n          this.handleMessageUpdate(payload.new as MessageRow);\n        },\n      )\n      .subscribe((status) => {\n        if (status === 'SUBSCRIBED') {\n          console.debug('[UnreadMessages] Realtime subscription active');\n        }\n      });\n  }\n\n  /**\n   * Handle new message received via real-time\n   */\n  private async handleNewMessage(message: MessageRow): Promise<void> {\n    const conversationId = message.booking_id ?? message.car_id;\n    if (!conversationId) return;\n\n    const type = message.booking_id ? 'booking' : 'car';\n    const conversations = [...this.unreadConversations()];\n    const existingIndex = conversations.findIndex(\n      (c) => c.conversationId === conversationId && c.type === type,\n    );\n\n    if (existingIndex >= 0) {\n      // Update existing conversation\n      conversations[existingIndex] = {\n        ...conversations[existingIndex],\n        unreadCount: conversations[existingIndex].unreadCount + 1,\n        lastMessage: message.body,\n        lastMessageAt: message.created_at,\n      };\n    } else {\n      // Add new conversation\n      conversations.push({\n        conversationId,\n        type: type as 'booking' | 'car',\n        unreadCount: 1,\n        lastMessage: message.body,\n        lastMessageAt: message.created_at,\n        otherUserId: message.sender_id,\n      });\n    }\n\n    this.unreadConversations.set(conversations);\n\n    // Play notification sound\n    this.playNotificationSound();\n\n    // ✅ NUEVO: Mostrar notificación profesional si es un mensaje sobre un auto\n    // Solo si el usuario actual es el dueño del auto (recipient)\n    const currentUser = this.authService.session$()?.user;\n    if (currentUser && message.recipient_id === currentUser.id) {\n      const carId = message.car_id;\n      if (carId && type === 'car') {\n        // Mostrar notificación de forma asíncrona sin bloquear\n        this.showCarMessageNotification(carId, message.sender_id, message.body).catch(() => {\n          // Silently fail - notification is optional enhancement\n        });\n      }\n    }\n  }\n\n  /**\n   * Muestra notificación profesional cuando llega un mensaje sobre un auto\n   */\n  private async showCarMessageNotification(\n    carId: string,\n    senderId: string,\n    messageBody: string,\n  ): Promise<void> {\n    try {\n      // Obtener información del auto y del remitente en paralelo\n      const [car, sender] = await Promise.all([\n        this.carsService.getCarById(carId),\n        this.profileService.getProfileById(senderId),\n      ]);\n\n      if (car && sender) {\n        const carName = car.title || `${car.brand || ''} ${car.model || ''}`.trim() || 'tu auto';\n        const senderName = sender.full_name || 'Un usuario';\n        const chatUrl = `/messages?carId=${carId}&userId=${senderId}`;\n\n        this.carOwnerNotifications.notifyNewChatMessage(senderName, carName, messageBody, chatUrl);\n      }\n    } catch {\n      // Silently fail - notification is optional enhancement\n    }\n  }\n\n  /**\n   * Handle message update (e.g., marked as read)\n   */\n  private handleMessageUpdate(message: MessageRow): void {\n    if (message.read_at) {\n      // Message was marked as read, decrement count\n      const conversationId = message.booking_id ?? message.car_id;\n      if (!conversationId) return;\n\n      const type = message.booking_id ? 'booking' : 'car';\n      const conversations = [...this.unreadConversations()];\n      const existingIndex = conversations.findIndex(\n        (c) => c.conversationId === conversationId && c.type === type,\n      );\n\n      if (existingIndex >= 0) {\n        conversations[existingIndex] = {\n          ...conversations[existingIndex],\n          unreadCount: Math.max(0, conversations[existingIndex].unreadCount - 1),\n        };\n\n        // Remove conversation if no unread messages\n        if (conversations[existingIndex].unreadCount === 0) {\n          conversations.splice(existingIndex, 1);\n        }\n\n        this.unreadConversations.set(conversations);\n      }\n    }\n  }\n\n  /**\n   * Mark all messages in a conversation as read\n   */\n  async markConversationAsRead(conversationId: string, type: 'booking' | 'car'): Promise<void> {\n    const user = this.authService.session$()?.user;\n    if (!user) return;\n\n    try {\n      const filter =\n        type === 'booking' ? { booking_id: conversationId } : { car_id: conversationId };\n\n      const { error } = await this.supabase\n        .from('messages')\n        .update({ read_at: new Date().toISOString() })\n        .eq('recipient_id', user.id)\n        .match(filter)\n        .is('read_at', null);\n\n      if (error) throw error;\n\n      // Update local state\n      const conversations = this.unreadConversations().filter(\n        (c) => !(c.conversationId === conversationId && c.type === type),\n      );\n      this.unreadConversations.set(conversations);\n    } catch {\n      // Silent fail\n    }\n  }\n\n  /**\n   * Play a notification sound\n   */\n  private playNotificationSound(): void {\n    try {\n      // Create a simple notification sound using Web Audio API\n      const audioContextClass =\n        window.AudioContext || (window as AudioContextWindow).webkitAudioContext;\n      if (!audioContextClass) {\n        return;\n      }\n\n      const audioContext = new audioContextClass();\n      const oscillator = audioContext.createOscillator();\n      const gainNode = audioContext.createGain();\n\n      oscillator.connect(gainNode);\n      gainNode.connect(audioContext.destination);\n\n      oscillator.frequency.value = 800;\n      oscillator.type = 'sine';\n\n      gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);\n      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);\n\n      oscillator.start(audioContext.currentTime);\n      oscillator.stop(audioContext.currentTime + 0.2);\n    } catch {\n      // Silently fail if audio context not supported\n    }\n  }\n\n  /**\n   * Clean up subscriptions\n   */\n  private cleanup(): void {\n    if (this.realtimeChannel) {\n      this.supabase.removeChannel(this.realtimeChannel);\n      this.realtimeChannel = undefined;\n    }\n    this.unreadConversations.set([]);\n  }\n\n  /**\n   * Manual refresh\n   */\n  async refresh(): Promise<void> {\n    const user = this.authService.session$()?.user;\n    if (user) {\n      await this.fetchUnreadConversations(user.id);\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/core/services/cars/car-availability.service.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`@core/services/infrastructure/supabase-client.service` import should occur before type import of `../models`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":88,"fix":{"range":[44,170],"text":"import { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\nimport type { Car } from '../models';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { Injectable } from '@angular/core';\nimport type { Car } from '../models';\nimport { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\n\nexport interface CarBlackout {\n  starts_at: string;\n  ends_at: string;\n  reason: string | null;\n}\n\nexport interface CarHandoverPoint {\n  id: string;\n  kind: string;\n  lat: number;\n  lng: number;\n  radius_m: number | null;\n}\n\nexport interface DetailedBlockedRange {\n  from: string; // YYYY-MM-DD\n  to: string; // YYYY-MM-DD\n  type: 'booking' | 'blackout' | 'manual_block';\n  reason?: string | null;\n  notes?: string | null;\n  block_id?: string;\n}\n\nexport interface AvailabilityRange {\n  from: string;\n  to: string;\n}\n\n@Injectable({ providedIn: 'root' })\nexport class CarAvailabilityService {\n  private readonly supabase = injectSupabase();\n\n  async getBlackouts(carId: string): Promise<CarBlackout[]> {\n    // car_blackouts table no longer exists; use car_blocked_dates as source\n    const { data, error } = await this.supabase\n      .from('car_blocked_dates')\n      .select('blocked_from, blocked_to, reason')\n      .eq('car_id', carId)\n      .order('blocked_from', { ascending: true });\n\n    if (error) {\n      throw error;\n    }\n\n    return (data || []).map((row) => ({\n      starts_at: row.blocked_from,\n      ends_at: row.blocked_to,\n      reason: row.reason ?? null,\n    })) as CarBlackout[];\n  }\n\n  async getHandoverPoints(carId: string): Promise<CarHandoverPoint[]> {\n    const { data, error } = await this.supabase\n      .from('car_handover_points')\n      .select('id, kind, lat, lng, radius_m')\n      .eq('car_id', carId)\n      .order('created_at', { ascending: false });\n\n    if (error) {\n      throw error;\n    }\n\n    return (data || []) as CarHandoverPoint[];\n  }\n\n  async getBlockedRangesWithDetails(\n    carId: string,\n    fromDate: string,\n    toDate: string,\n  ): Promise<DetailedBlockedRange[]> {\n    type ManualBlockRow = {\n      id: string;\n      blocked_from: string;\n      blocked_to: string;\n      reason: string;\n      notes?: string | null;\n    };\n\n    // Normalize date boundaries\n    const fromDateOnly = this.toDateString(this.normalizeToDate(fromDate));\n    const toDateOnly = this.toDateString(this.normalizeToDate(toDate));\n\n    // Execute all queries in parallel for better performance\n    // Overlap logic: range1 overlaps range2 when start1 <= end2 AND end1 >= start2\n    // Include ALL booking statuses that block the calendar:\n    // - pending: user initiated booking, waiting for payment\n    // - pending_payment: payment in progress\n    // - confirmed: booking confirmed, waiting for start\n    // - in_progress: rental is active\n    const [bookingsResult, manualBlocksResult] = await Promise.all([\n      // SECURITY DEFINER RPC: returns confirmed/in_progress ranges for public calendars\n      this.supabase.rpc('get_car_blocked_dates', {\n        p_car_id: carId,\n        p_start_date: fromDateOnly,\n        p_end_date: toDateOnly,\n      }),\n      this.supabase\n        .from('car_blocked_dates')\n        .select('id, blocked_from, blocked_to, reason, notes')\n        .eq('car_id', carId)\n        .lte('blocked_from', toDateOnly)\n        .gte('blocked_to', fromDateOnly),\n    ]);\n\n    const bookings = bookingsResult.data as\n      | Array<{ start_date: string; end_date: string; status: string }>\n      | null;\n    const manualRows = (manualBlocksResult.data || []) as ManualBlockRow[];\n\n    const ranges: DetailedBlockedRange[] = [];\n\n    if (bookings) {\n      ranges.push(\n        ...bookings.map((b) => ({\n          from: this.toDateString(b.start_date),\n          to: this.toDateString(b.end_date),\n          type: 'booking' as const,\n          reason: 'Reserva',\n        })),\n      );\n    }\n\n    if (manualRows.length) {\n      ranges.push(\n        ...manualRows.map(\n          (b) =>\n            ({\n              from: b.blocked_from,\n              to: b.blocked_to,\n              type: 'manual_block' as const,\n              reason: b.reason,\n              notes: b.notes || null,\n              block_id: b.id,\n            }) as DetailedBlockedRange,\n        ),\n      );\n    }\n\n    return ranges;\n  }\n\n  async checkAvailability(\n    carId: string,\n    start: Date | string,\n    end: Date | string,\n  ): Promise<boolean> {\n    const fromIso = this.normalizeToDate(start).toISOString();\n    const toIso = this.normalizeToDate(end).toISOString();\n    const ranges = await this.getBlockedRangesWithDetails(carId, fromIso, toIso);\n    return ranges.length === 0;\n  }\n\n  async getBlockedDates(\n    carId: string,\n    start?: Date | string,\n    end?: Date | string,\n  ): Promise<DetailedBlockedRange[]> {\n    const startDate = this.normalizeToDate(start ?? new Date());\n    const endDate = this.normalizeToDate(end ?? this.addDays(new Date(), 90));\n    const fromIso = startDate.toISOString();\n    const toIso = endDate.toISOString();\n    const ranges = await this.getBlockedRangesWithDetails(carId, fromIso, toIso);\n\n    return ranges.map((r) => ({ ...r }));\n  }\n\n  async getNextAvailableDate(carId: string, from: Date | string): Promise<string | null> {\n    const startDate = this.normalizeToDate(from);\n    const searchHorizon = this.addDays(startDate, 90);\n    const blocked = await this.getBlockedDates(carId, startDate, searchHorizon);\n\n    // Build occupied day set\n    const occupied = new Set<string>();\n    for (const range of blocked) {\n      let cursor = new Date(range.from);\n      const to = new Date(range.to);\n      while (cursor <= to) {\n        occupied.add(this.toDateString(cursor));\n        cursor.setDate(cursor.getDate() + 1);\n      }\n    }\n\n    const cursor = new Date(startDate);\n    while (cursor <= searchHorizon) {\n      const key = this.toDateString(cursor);\n      if (!occupied.has(key)) {\n        return key;\n      }\n      cursor.setDate(cursor.getDate() + 1);\n    }\n\n    return null;\n  }\n\n  async getNextAvailableRange(\n    carId: string,\n    start: Date | string,\n    end?: Date | string,\n    maxOptions = 3,\n  ): Promise<Array<{ startDate: string; endDate: string; daysCount: number }>> {\n    const startDate = this.normalizeToDate(start);\n    const searchEnd = this.normalizeToDate(end ?? this.addDays(startDate, 60));\n    const blocked = await this.getBlockedDates(carId, startDate, searchEnd);\n\n    const ranges = blocked.sort((a, b) => (a.from < b.from ? -1 : 1));\n    let cursor = new Date(startDate);\n    const available: Array<{ startDate: string; endDate: string; daysCount: number }> = [];\n\n    for (const range of ranges) {\n      const rangeStart = new Date(range.from);\n      const rangeEnd = new Date(range.to);\n      if (cursor < rangeStart) {\n        const startIso = this.toDateString(cursor);\n        const endIso = this.toDateString(this.addDays(rangeStart, -1));\n        const daysCount = Math.max(1, this.differenceInCalendarDays(rangeStart, cursor));\n        available.push({ startDate: startIso, endDate: endIso, daysCount });\n        if (available.length >= maxOptions) return available;\n      }\n      if (cursor <= rangeEnd) {\n        cursor = this.addDays(rangeEnd, 1);\n      }\n    }\n\n    if (cursor <= searchEnd && available.length < maxOptions) {\n      const startIso = this.toDateString(cursor);\n      const endIso = this.toDateString(searchEnd);\n      const daysCount = Math.max(1, this.differenceInCalendarDays(searchEnd, cursor) + 1);\n      available.push({ startDate: startIso, endDate: endIso, daysCount });\n    }\n\n    return available;\n  }\n\n  /**\n   * Filters cars by availability using batch queries instead of N+1 queries.\n   * Executes only 3 queries total regardless of the number of cars.\n   */\n  async filterByAvailability<T extends { id: string }>(\n    cars: T[],\n    start: Date | string,\n    end: Date | string,\n    excludedCarIds: string[] = [],\n  ): Promise<T[]> {\n    if (cars.length === 0) return [];\n\n    const fromIso = this.normalizeToDate(start).toISOString();\n    const toIso = this.normalizeToDate(end).toISOString();\n    const carIds = cars.map((c) => c.id).filter((id) => !excludedCarIds.includes(id));\n\n    if (carIds.length === 0) return [];\n\n    // Batch query: get all blocked car IDs in a single set of queries\n    const blockedByConflict = await this.getBlockedCarIds(fromIso, toIso, carIds);\n\n    return cars.filter((car) => !excludedCarIds.includes(car.id) && !blockedByConflict.has(car.id));\n  }\n\n  /**\n   * Returns a Set of car IDs that have conflicts in the given date range.\n   * Uses batch queries (3 total) instead of per-car queries.\n   * @param carIds - Optional list of car IDs to filter. If not provided, checks all cars.\n   */\n  private async getBlockedCarIds(\n    fromDate: string,\n    toDate: string,\n    carIds?: string[],\n  ): Promise<Set<string>> {\n    // Build queries with optional car_id filter\n    // Include ALL booking statuses that block availability\n    const buildBookingsQuery = () => {\n      let q = this.supabase\n        .from('bookings')\n        .select('car_id')\n        .in('status', ['pending', 'pending_payment', 'confirmed', 'in_progress'])\n        .lte('start_at', toDate)\n        .gte('end_at', fromDate);\n      if (carIds?.length) q = q.in('car_id', carIds);\n      return q;\n    };\n\n    // car_blackouts table no longer exists - removed query\n    // Use car_blocked_dates for all manual blocks\n\n    const buildBlockedDatesQuery = () => {\n      let q = this.supabase\n        .from('car_blocked_dates')\n        .select('car_id')\n        .lte('blocked_from', toDate)\n        .gte('blocked_to', fromDate);\n      if (carIds?.length) q = q.in('car_id', carIds);\n      return q;\n    };\n\n    const [bookingsResult, manualBlocksResult] = await Promise.all([\n      buildBookingsQuery(),\n      buildBlockedDatesQuery(),\n    ]);\n\n    const blockedIds = new Set<string>();\n\n    for (const row of bookingsResult.data || []) {\n      blockedIds.add(row.car_id);\n    }\n    for (const row of manualBlocksResult.data || []) {\n      blockedIds.add(row.car_id);\n    }\n\n    return blockedIds;\n  }\n\n  /**\n   * Gets available cars with proper pagination.\n   * First fetches all blocked car IDs, then paginates excluding them.\n   * This ensures consistent pagination results.\n   */\n  async getAvailableCars(\n    start: Date | string,\n    end: Date | string,\n    options: { limit?: number; offset?: number; city?: string; carIds?: string[] } = {},\n  ): Promise<Car[]> {\n    const { limit = 50, offset = 0, city, carIds } = options;\n    const fromIso = this.normalizeToDate(start).toISOString();\n    const toIso = this.normalizeToDate(end).toISOString();\n\n    // First, get all car IDs that are blocked in this date range\n    const blockedCarIds = await this.getBlockedCarIds(fromIso, toIso);\n\n    // Build query excluding blocked cars\n    let query = this.supabase.from('cars').select('*').eq('status', 'active');\n    if (city) query = query.eq('location_city', city);\n    if (carIds?.length) query = query.in('id', carIds);\n\n    // Exclude blocked cars from pagination (if any)\n    if (blockedCarIds.size > 0) {\n      const blockedArray = Array.from(blockedCarIds);\n      // Use Supabase SDK's native array support for NOT IN\n      query = query.not('id', 'in', blockedArray);\n    }\n\n    const { data, error } = await query.range(offset, offset + limit - 1);\n    if (error) throw error;\n\n    return (data || []) as Car[];\n  }\n\n  async hasActiveBookings(carId: string): Promise<{\n    hasActive: boolean;\n    count: number;\n    bookings?: Array<{ id: string; status: string; start_date: string; end_date: string }>;\n  }> {\n    type BookingRow = { id: string; status: string; start_at: string; end_at: string };\n    // Include ALL blocking statuses, not just active ones\n    const { data, error, count } = await this.supabase\n      .from('bookings')\n      .select('id, status, start_at, end_at', { count: 'exact' })\n      .eq('car_id', carId)\n      .in('status', ['pending', 'pending_payment', 'confirmed', 'in_progress'])\n      .order('start_at', { ascending: true })\n      .limit(10);\n\n    if (error) {\n      console.warn('hasActiveBookings error', error);\n      return { hasActive: false, count: 0 };\n    }\n\n    const bookings = (data || []) as BookingRow[];\n    return {\n      hasActive: (count ?? 0) > 0,\n      count: count ?? 0,\n      bookings: bookings.map((b) => ({\n        id: b.id,\n        status: b.status,\n        start_date: b.start_at,\n        end_date: b.end_at,\n      })),\n    };\n  }\n\n  private normalizeToDate(value: Date | string): Date {\n    if (value instanceof Date) return new Date(value);\n    const parsed = new Date(value);\n    if (Number.isNaN(parsed.getTime())) {\n      throw new Error(`Invalid date value: ${value}`);\n    }\n    return parsed;\n  }\n\n  private addDays(date: Date, days: number): Date {\n    const d = new Date(date);\n    d.setDate(d.getDate() + days);\n    return d;\n  }\n\n  /**\n   * Safely extracts YYYY-MM-DD from a date string or Date object.\n   * Handles both ISO strings and date objects without timezone issues.\n   */\n  private toDateString(value: Date | string): string {\n    if (typeof value === 'string') {\n      // If already YYYY-MM-DD format, return as-is\n      if (/^\\d{4}-\\d{2}-\\d{2}$/.test(value)) return value;\n      // Extract date part from ISO string\n      const match = value.match(/^(\\d{4}-\\d{2}-\\d{2})/);\n      if (match) return match[1];\n    }\n    // For Date objects, use UTC to avoid timezone shifts\n    const d = value instanceof Date ? value : new Date(value);\n    return d.toISOString().slice(0, 10);\n  }\n\n  /**\n   * Calculates the difference in calendar days between two dates.\n   * Uses UTC to avoid DST issues (days with 23 or 25 hours).\n   */\n  private differenceInCalendarDays(later: Date, earlier: Date): number {\n    // Normalize both dates to UTC midnight to avoid DST issues\n    const utcLater = Date.UTC(later.getFullYear(), later.getMonth(), later.getDate());\n    const utcEarlier = Date.UTC(earlier.getFullYear(), earlier.getMonth(), earlier.getDate());\n    return Math.round((utcLater - utcEarlier) / 86400000);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/core/services/cars/car-depreciation-notifications.service.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`@core/services/bookings/bookings.service` import should occur before import of `./car-owner-notifications.service`","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":76,"fix":{"range":[148,352],"text":"import { BookingsService } from '@core/services/bookings/bookings.service';\nimport { CarOwnerNotificationsService } from './car-owner-notifications.service';\nimport { CarsService } from './cars.service';\n"}},{"ruleId":"import/order","severity":1,"message":"`@core/services/auth/auth.service` import should occur before import of `./car-owner-notifications.service`","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":64,"fix":{"range":[148,416],"text":"import { AuthService } from '@core/services/auth/auth.service';\nimport { CarOwnerNotificationsService } from './car-owner-notifications.service';\nimport { CarsService } from './cars.service';\nimport { BookingsService } from '@core/services/bookings/bookings.service';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import { Injectable, inject, signal } from '@angular/core';\nimport { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\nimport { CarOwnerNotificationsService } from './car-owner-notifications.service';\nimport { CarsService } from './cars.service';\nimport { BookingsService } from '@core/services/bookings/bookings.service';\nimport { AuthService } from '@core/services/auth/auth.service';\n\ntype CarWithEstimatedValue = {\n  estimated_value_usd?: number | null;\n};\n\n/**\n * CarDepreciationNotificationsService\n *\n * Servicio para calcular y notificar sobre depreciación mensual de autos\n * y cómo contrarrestarla con ganancias de AutoRenta.\n *\n * Funcionalidades:\n * - Calcula depreciación mensual basada en categoría y edad del auto\n * - Calcula ganancias mensuales de reservas\n * - Envía notificaciones mensuales con reporte completo\n * - Sugiere optimizaciones de precio\n */\n@Injectable({\n  providedIn: 'root',\n})\nexport class CarDepreciationNotificationsService {\n  private readonly supabase = injectSupabase();\n  private readonly carOwnerNotifications = inject(CarOwnerNotificationsService);\n  private readonly carsService = inject(CarsService);\n  private readonly bookingsService = inject(BookingsService);\n  private readonly authService = inject(AuthService);\n\n  // Track last notification date per car to avoid duplicates\n  private readonly lastNotificationDate = signal<Map<string, Date>>(new Map());\n\n  /**\n   * Calcula la depreciación mensual de un auto\n   *\n   * @param car - Auto a calcular\n   * @returns Depreciación mensual en ARS\n   */\n  async calculateMonthlyDepreciation(car: {\n    id: string;\n    year?: number | null;\n    estimated_value_usd?: number | null;\n    category_id?: string | null;\n  }): Promise<number> {\n    try {\n      if (!car.year || !car.estimated_value_usd) {\n        return 0;\n      }\n\n      // Obtener tasa de depreciación de la categoría\n      let depreciationRate = 0.05; // Default 5% anual\n\n      if (car.category_id) {\n        const { data: category } = await this.supabase\n          .from('vehicle_categories')\n          .select('depreciation_rate_annual')\n          .eq('id', car.category_id)\n          .single();\n\n        if (category?.depreciation_rate_annual) {\n          depreciationRate = category.depreciation_rate_annual;\n        }\n      }\n\n      // Calcular depreciación mensual\n      // Depreciación mensual = (valor * tasa_anual) / 12\n      const monthlyDepreciation = (car.estimated_value_usd * depreciationRate) / 12;\n\n      // Convertir a ARS (asumiendo tipo de cambio, ajustar según tu sistema)\n      // Por ahora retornamos en USD, se puede convertir después\n      return monthlyDepreciation;\n    } catch (error) {\n      console.error('Error calculating depreciation:', error);\n      return 0;\n    }\n  }\n\n  /**\n   * Calcula las ganancias mensuales de un auto\n   *\n   * @param carId - ID del auto\n   * @param month - Mes a calcular (formato YYYY-MM)\n   * @returns Ganancias mensuales en ARS\n   */\n  async calculateMonthlyEarnings(carId: string, month: string): Promise<number> {\n    try {\n      const startDate = `${month}-01`;\n      const endDate = `${month}-31`;\n\n      // Obtener todas las reservas confirmadas/completadas del mes\n      const { data: bookings, error } = await this.supabase\n        .from('bookings')\n        .select('total_amount, currency, status')\n        .eq('car_id', carId)\n        .in('status', ['confirmed', 'in_progress', 'completed'])\n        .gte('start_date', startDate)\n        .lte('start_date', endDate);\n\n      if (error) {\n        console.error('Error fetching bookings:', error);\n        return 0;\n      }\n\n      // Sumar ganancias (85% para el owner según split payment)\n      const totalEarnings = (bookings || []).reduce((sum, booking) => {\n        if (booking.status === 'completed' || booking.status === 'active') {\n          // El owner recibe 85% del total\n          return sum + booking.total_amount * 0.85;\n        }\n        return sum;\n      }, 0);\n\n      return totalEarnings;\n    } catch (error) {\n      console.error('Error calculating earnings:', error);\n      return 0;\n    }\n  }\n\n  /**\n   * Envía notificación mensual de depreciación para un auto\n   *\n   * @param carId - ID del auto\n   */\n  async sendMonthlyDepreciationNotification(carId: string): Promise<void> {\n    try {\n      const user = this.authService.session$()?.user;\n      if (!user) return;\n\n      // Verificar si ya se envió notificación este mes\n      const lastNotification = this.lastNotificationDate().get(carId);\n      const now = new Date();\n      const currentMonth = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;\n\n      if (lastNotification) {\n        const lastMonth = `${lastNotification.getFullYear()}-${String(lastNotification.getMonth() + 1).padStart(2, '0')}`;\n        if (lastMonth === currentMonth) {\n          // Ya se envió este mes\n          return;\n        }\n      }\n\n      // Obtener información del auto\n      const car = await this.carsService.getCarById(carId);\n      if (!car) return;\n\n      // Calcular depreciación y ganancias\n      const monthlyDepreciation = await this.calculateMonthlyDepreciation(car);\n      const monthlyEarnings = await this.calculateMonthlyEarnings(carId, currentMonth);\n      const netGain = monthlyEarnings - monthlyDepreciation;\n\n      const carName = car.title || `${car.brand || ''} ${car.model || ''}`.trim() || 'tu auto';\n      const carUrl = `/cars/${carId}`;\n      const estimatedValueUsd = (car as CarWithEstimatedValue).estimated_value_usd ?? 0;\n\n      // Enviar notificación\n      this.carOwnerNotifications.notifyMonthlyDepreciation(\n        carName,\n        estimatedValueUsd,\n        monthlyDepreciation,\n        monthlyEarnings,\n        netGain,\n        carUrl,\n      );\n\n      // Actualizar fecha de última notificación\n      const updatedMap = new Map(this.lastNotificationDate());\n      updatedMap.set(carId, now);\n      this.lastNotificationDate.set(updatedMap);\n\n      // Si las ganancias son bajas, enviar notificación adicional\n      if (monthlyEarnings < monthlyDepreciation * 0.5) {\n        // Calcular precio recomendado (basado en análisis simple)\n        const recommendedPrice = (car.price_per_day || 0) * 1.15; // Aumentar 15%\n\n        this.carOwnerNotifications.notifyLowEarnings(\n          carName,\n          monthlyEarnings,\n          recommendedPrice,\n          carUrl,\n        );\n      } else if (netGain > monthlyDepreciation * 0.5) {\n        // Si está ganando bien, enviar notificación positiva\n        this.carOwnerNotifications.notifyExcellentEarnings(\n          carName,\n          monthlyEarnings,\n          monthlyDepreciation,\n          netGain,\n        );\n      }\n    } catch (error) {\n      console.error('Error sending depreciation notification:', error);\n    }\n  }\n\n  /**\n   * Envía notificaciones mensuales para todos los autos del usuario\n   */\n  async sendMonthlyNotificationsForAllCars(): Promise<void> {\n    try {\n      const user = this.authService.session$()?.user;\n      if (!user) return;\n\n      // Obtener todos los autos del usuario\n      const cars = await this.carsService.listMyCars();\n\n      // Enviar notificación para cada auto activo\n      for (const car of cars) {\n        if (car.status === 'active') {\n          await this.sendMonthlyDepreciationNotification(car.id);\n          // Pequeña pausa entre notificaciones para no saturar\n          await new Promise((resolve) => setTimeout(resolve, 500));\n        }\n      }\n    } catch (error) {\n      console.error('Error sending monthly notifications:', error);\n    }\n  }\n\n  /**\n   * Envía notificación educativa sobre cómo ganar dinero\n   * Se puede llamar periódicamente o después de eventos específicos\n   */\n  async sendEarningTipsNotification(carId: string): Promise<void> {\n    try {\n      const car = await this.carsService.getCarById(carId);\n      if (!car) return;\n\n      const carName = car.title || `${car.brand || ''} ${car.model || ''}`.trim() || 'tu auto';\n\n      // Tips personalizados basados en el estado del auto\n      const tips: string[] = [];\n\n      // Agregar tips según el estado\n      if (!car.photos || car.photos.length < 5) {\n        tips.push('Agrega más fotos profesionales para aumentar las reservas');\n      }\n\n      if (car.auto_approval === false) {\n        tips.push('Activa la aprobación automática para cerrar reservas más rápido');\n      }\n\n      // Tips generales\n      tips.push(\n        'Aumenta tu precio en temporada alta para maximizar ganancias',\n        'Mantén tu auto disponible los fines de semana (mayor demanda)',\n        'Completa tu perfil y documentos para aumentar confianza',\n        'Responde rápido a los mensajes para cerrar más reservas',\n        'Usa fotos profesionales para destacar tu auto',\n        'Ofrece descuentos por estadías largas para aumentar ocupación',\n      );\n\n      this.carOwnerNotifications.notifyHowToEarnMoney(carName, tips);\n    } catch (error) {\n      console.error('Error sending earning tips:', error);\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/core/services/cars/car-locations.service.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`@core/services/infrastructure/supabase-client.service` import should occur before import of `../../../environments/environment`","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":88,"fix":{"range":[224,377],"text":"import { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\nimport { environment } from '../../../environments/environment';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { LoggerService } from '@core/services/infrastructure/logger.service';\nimport { Injectable, inject } from '@angular/core';\nimport type { RealtimeChannel, RealtimePostgresChangesPayload } from '@supabase/supabase-js';\nimport { environment } from '../../../environments/environment';\nimport { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\nimport { CarAvailabilityService } from './car-availability.service';\n\nconst DEFAULT_CACHE_TTL_MS = 5 * 60 * 1000;\nconst DEFAULT_REFRESH_MS = 60 * 1000;\n\nexport interface CarMapLocation {\n  carId: string;\n  title: string;\n  pricePerDay: number;\n  pricePerHour?: number; // Dynamic pricing\n  currency: string;\n  surgeActive?: boolean; // Surge pricing indicator\n  lat: number;\n  lng: number;\n  updatedAt: string;\n  city?: string | null;\n  state?: string | null;\n  country?: string | null;\n  locationLabel: string;\n  formattedAddress?: string | null;\n  photoUrl?: string | null;\n  photoGallery?: string[] | null;\n  description?: string | null;\n  // Availability status\n  availabilityStatus?: 'available' | 'in_use' | 'soon_available' | 'unavailable';\n  nextAvailableDate?: string | null; // ISO date string\n  currentBookingEndDate?: string | null; // ISO date string for \"soon_available\"\n  // Instant booking & availability flags\n  instantBooking?: boolean; // Auto-approval enabled (can book immediately)\n  availableToday?: boolean; // Available for pickup today\n  availableTomorrow?: boolean; // Available for pickup tomorrow\n  minRentalDays?: number; // Minimum rental period\n  maxRentalDays?: number; // Maximum rental period\n  // Dynamic pricing info\n  depositRequired?: boolean;\n  depositAmount?: number;\n  insuranceIncluded?: boolean;\n  usesDynamicPricing?: boolean; // Car opts into dynamic pricing\n}\n\ninterface CacheEntry {\n  data: CarMapLocation[];\n  expiresAt: number;\n}\n\ninterface ReviewsCacheEntry {\n  reviewsCount: number;\n  expiresAt: number;\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class CarLocationsService {\n  private readonly logger = inject(LoggerService);\n  private readonly supabase = injectSupabase();\n  private readonly availabilityService = inject(CarAvailabilityService);\n  private readonly cacheTtlMs = environment.carLocationsCacheTtlMs ?? DEFAULT_CACHE_TTL_MS;\n  private readonly refreshMs = environment.carLocationsRefreshMs ?? DEFAULT_REFRESH_MS;\n  private readonly reviewsCacheTtlMs = 10 * 60 * 1000; // 10 minutes for reviews cache\n\n  private cache: CacheEntry | null = null;\n  private reviewsCache = new Map<string, ReviewsCacheEntry>();\n  private realtimeChannel: RealtimeChannel | null = null;\n\n  async fetchActiveLocations(\n    force = false,\n    includeAvailability = false,\n    options?: {\n      center?: { lat: number; lng: number };\n      radiusKm?: number;\n      dateRange?: { from: string; to: string };\n      instantBookingOnly?: boolean;\n    },\n  ): Promise<CarMapLocation[]> {\n    const now = Date.now();\n    if (!force && this.cache && this.cache.expiresAt > now) {\n      const cached = this.cache.data;\n      if (includeAvailability) {\n        return this.enrichWithAvailability(cached, options);\n      }\n      return cached;\n    }\n\n    const edgeData = await this.tryEdgeFunction();\n    const data = edgeData ?? (await this.fetchFromDatabase(options));\n\n    // Enrich with availability if requested\n    const enriched = includeAvailability ? await this.enrichWithAvailability(data, options) : data;\n\n    this.cache = {\n      data: enriched,\n      expiresAt: now + this.cacheTtlMs,\n    };\n    return enriched;\n  }\n\n  /**\n   * Enrich car locations with availability status and instant booking flags\n   */\n  private async enrichWithAvailability(\n    locations: CarMapLocation[],\n    options?: {\n      center?: { lat: number; lng: number };\n      radiusKm?: number;\n      dateRange?: { from: string; to: string };\n      instantBookingOnly?: boolean;\n    },\n  ): Promise<CarMapLocation[]> {\n    const today = new Date();\n    today.setHours(0, 0, 0, 0);\n    const tomorrow = new Date(today);\n    tomorrow.setDate(tomorrow.getDate() + 1);\n    const in7Days = new Date(today);\n    in7Days.setDate(in7Days.getDate() + 7);\n\n    // Use provided date range or default to today-tomorrow\n    const checkFrom = options?.dateRange?.from || today.toISOString().split('T')[0];\n    const checkTo = options?.dateRange?.to || tomorrow.toISOString().split('T')[0];\n\n    // Check availability for each car in parallel (limited concurrency)\n    const enriched = await Promise.all(\n      locations.map(async (location) => {\n        try {\n          // Check if available today\n          const availableToday = await this.availabilityService.checkAvailability(\n            location['carId'],\n            today.toISOString().split('T')[0],\n            tomorrow.toISOString().split('T')[0],\n          );\n\n          // Check if available tomorrow\n          const tomorrowDate = new Date(tomorrow);\n          const dayAfterTomorrow = new Date(tomorrow);\n          dayAfterTomorrow.setDate(dayAfterTomorrow.getDate() + 1);\n          const availableTomorrow = await this.availabilityService.checkAvailability(\n            location['carId'],\n            tomorrowDate.toISOString().split('T')[0],\n            dayAfterTomorrow.toISOString().split('T')[0],\n          );\n\n          // Check if available for requested date range (stored for potential future use)\n          if (options?.dateRange) {\n            await this.availabilityService.checkAvailability(location['carId'], checkFrom, checkTo);\n          }\n\n          if (availableToday) {\n            return {\n              ...location,\n              availabilityStatus: 'available' as const,\n              availableToday: true,\n              availableTomorrow,\n            };\n          }\n\n          // Check if available in next 7 days\n          const nextAvailable = await this.availabilityService.getNextAvailableDate(\n            location['carId'],\n            today.toISOString().split('T')[0],\n          );\n\n          if (nextAvailable) {\n            const nextDate = new Date(nextAvailable);\n            const daysUntilAvailable = Math.ceil(\n              (nextDate.getTime() - today.getTime()) / (1000 * 60 * 60 * 24),\n            );\n\n            if (daysUntilAvailable <= 7) {\n              // Get current booking end date\n              const blockedDates = await this.availabilityService.getBlockedDates(location['carId']);\n              const currentBlock = blockedDates.find(\n                (block) => new Date(block.to) >= today && new Date(block.from) <= today,\n              );\n\n              return {\n                ...location,\n                availabilityStatus: 'soon_available' as const,\n                nextAvailableDate: nextAvailable,\n                currentBookingEndDate: currentBlock?.to || null,\n                availableToday: false,\n                availableTomorrow,\n              };\n            }\n          }\n\n          return {\n            ...location,\n            availabilityStatus: 'unavailable' as const,\n            availableToday: false,\n            availableTomorrow: false,\n          };\n        } catch (error) {\n          console.error(`Error checking availability for car ${location['carId']}:`, error);\n          return {\n            ...location,\n            availabilityStatus: 'unavailable' as const,\n            availableToday: false,\n            availableTomorrow: false,\n          };\n        }\n      }),\n    );\n\n    // Filter by instant booking if requested\n    if (options?.instantBookingOnly) {\n      return enriched.filter((loc) => loc.instantBooking === true);\n    }\n\n    return enriched;\n  }\n\n  // 🚀 PERF: Track subscribers to avoid duplicate channels\n  private realtimeSubscribers = new Set<() => void>();\n\n  subscribeToRealtime(onChange: () => void): () => void {\n    // Add callback to subscribers set\n    this.realtimeSubscribers.add(onChange);\n\n    // If channel already exists, just return cleanup (reuse channel)\n    if (this.realtimeChannel) {\n      this.logger.debug('♻️ [CarLocations] Reusing existing realtime channel');\n      return () => {\n        this.realtimeSubscribers.delete(onChange);\n        // Only remove channel if no more subscribers\n        if (this.realtimeSubscribers.size === 0 && this.realtimeChannel) {\n          void this.supabase.removeChannel(this.realtimeChannel);\n          this.realtimeChannel = null;\n        }\n      };\n    }\n\n    // Create shared notification function\n    const notifyAllSubscribers = () => {\n      this.realtimeSubscribers.forEach((cb) => cb());\n    };\n\n    const channel = this.supabase.channel('public:car_map_feed');\n    channel.on(\n      'postgres_changes',\n      { schema: 'public', table: 'car_locations', event: '*' },\n      (_payload: RealtimePostgresChangesPayload<Record<string, unknown>>) => notifyAllSubscribers(),\n    );\n    channel.on(\n      'postgres_changes',\n      { schema: 'public', table: 'cars', event: '*' },\n      (payload: RealtimePostgresChangesPayload<Record<string, unknown>>) => {\n        const newRecord = payload.new as Record<string, unknown> | undefined;\n        const oldRecord = payload.old as Record<string, unknown> | undefined;\n        const newStatus = newRecord?.['status'];\n        const oldStatus = oldRecord?.['status'];\n        if (newStatus === 'active' || oldStatus === 'active') {\n          notifyAllSubscribers();\n        }\n      },\n    );\n\n    void channel.subscribe((status) => {\n      if (status === 'SUBSCRIBED') {\n        console.debug('[CarLocations] Realtime subscription active');\n      }\n    });\n    this.realtimeChannel = channel;\n\n    return () => {\n      this.realtimeSubscribers.delete(onChange);\n      // Only remove channel if no more subscribers\n      if (this.realtimeSubscribers.size === 0 && this.realtimeChannel) {\n        void this.supabase.removeChannel(this.realtimeChannel);\n        this.realtimeChannel = null;\n      }\n    };\n  }\n\n  getRefreshInterval(): number {\n    return this.refreshMs;\n  }\n\n  private async tryEdgeFunction(): Promise<CarMapLocation[] | null> {\n    const functionName = environment.carLocationsEdgeFunction;\n    if (!functionName) {\n      return null;\n    }\n\n    try {\n      const { data, error } = await this.supabase.functions.invoke(functionName, {\n        body: {\n          ttl: Math.round(this.cacheTtlMs / 1000),\n          status: 'active',\n        },\n      });\n      if (error) {\n        throw error;\n      }\n      if (!Array.isArray(data)) {\n        return null;\n      }\n      const normalized = this.normalizePayloadArray(data);\n      return normalized.length > 0 ? normalized : null;\n    } catch {\n      return null;\n    }\n  }\n\n  private async fetchFromDatabase(options?: {\n    center?: { lat: number; lng: number };\n    radiusKm?: number;\n    dateRange?: { from: string; to: string };\n    instantBookingOnly?: boolean;\n  }): Promise<CarMapLocation[]> {\n    // Build query with optional filters\n    let query = this.supabase\n      .from('v_cars_with_main_photo')\n      .select(\n        'id, title, status, price_per_day, currency, location_city, location_state, location_country, location_lat, location_lng, main_photo_url, photo_gallery, description, updated_at, auto_approval, min_rental_days, max_rental_days, deposit_required, deposit_amount, insurance_included, uses_dynamic_pricing',\n      )\n      .eq('status', 'active')\n      .not('location_lat', 'is', null)\n      .not('location_lng', 'is', null);\n\n    // Filter by instant booking if requested\n    if (options?.instantBookingOnly) {\n      query = query.eq('auto_approval', true);\n    }\n\n    // Note: Radius filtering should be done client-side or via PostGIS RPC\n    // For now, we fetch all and filter client-side if center/radius provided\n\n    const { data: cars, error: carsError } = await query;\n\n    if (carsError) {\n      throw carsError;\n    }\n\n    const carsArray = Array.isArray(cars) ? cars : [];\n    if (carsArray.length === 0) {\n      return [];\n    }\n\n    // Normalize entries\n    let normalized = carsArray\n      .map((car: unknown) => this.normalizeEntry(car))\n      .filter((value): value is CarMapLocation => !!value);\n\n    // Filter by radius if center and radius provided (client-side filtering)\n    if (options?.center && options?.radiusKm) {\n      normalized = normalized.filter((loc) => {\n        const distance = this.calculateDistance(\n          options.center!.lat,\n          options.center!.lng,\n          loc.lat,\n          loc.lng,\n        );\n        return distance <= options.radiusKm!;\n      });\n    }\n\n    return normalized;\n  }\n\n  /**\n   * Calculate distance between two coordinates (Haversine formula)\n   */\n  private calculateDistance(lat1: number, lon1: number, lat2: number, lon2: number): number {\n    const R = 6371; // Earth radius in km\n    const dLat = this.toRad(lat2 - lat1);\n    const dLon = this.toRad(lon2 - lon1);\n    const a =\n      Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n      Math.cos(this.toRad(lat1)) *\n        Math.cos(this.toRad(lat2)) *\n        Math.sin(dLon / 2) *\n        Math.sin(dLon / 2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n    return R * c;\n  }\n\n  private toRad(degrees: number): number {\n    return degrees * (Math.PI / 180);\n  }\n\n  /**\n   * Get review count for a car with caching\n   * This avoids multiple queries when multiple tooltips request the same car's reviews\n   */\n  async getReviewCount(carId: string, force = false): Promise<number> {\n    const now = Date.now();\n    const cached = this.reviewsCache.get(carId);\n\n    if (!force && cached && cached.expiresAt > now) {\n      return cached.reviewsCount;\n    }\n\n    try {\n      // Use car_stats table for efficient query\n      const { data, error } = await this.supabase\n        .from('car_stats')\n        .select('reviews_count')\n        .eq('car_id', carId)\n        .maybeSingle();\n\n      if (error) {\n        console.warn(`Error fetching review count for car ${carId}:`, error);\n        return 0;\n      }\n\n      const reviewsCount = (data?.reviews_count as number | null | undefined) ?? 0;\n\n      // Update cache\n      this.reviewsCache.set(carId, {\n        reviewsCount,\n        expiresAt: now + this.reviewsCacheTtlMs,\n      });\n\n      return reviewsCount;\n    } catch (error) {\n      console.warn(`Exception fetching review count for car ${carId}:`, error);\n      return 0;\n    }\n  }\n\n  /**\n   * Clear reviews cache for a specific car or all cars\n   */\n  clearReviewsCache(carId?: string): void {\n    if (carId) {\n      this.reviewsCache.delete(carId);\n    } else {\n      this.reviewsCache.clear();\n    }\n  }\n\n  /**\n   * Batch fetch review counts for multiple cars (more efficient)\n   */\n  async getReviewCountsBatch(carIds: string[]): Promise<Map<string, number>> {\n    const now = Date.now();\n    const result = new Map<string, number>();\n    const uncachedIds: string[] = [];\n\n    // Check cache first\n    for (const carId of carIds) {\n      const cached = this.reviewsCache.get(carId);\n      if (cached && cached.expiresAt > now) {\n        result.set(carId, cached.reviewsCount);\n      } else {\n        uncachedIds.push(carId);\n      }\n    }\n\n    // Fetch uncached reviews in batch\n    if (uncachedIds.length > 0) {\n      try {\n        const { data, error } = await this.supabase\n          .from('car_stats')\n          .select('car_id, reviews_count')\n          .in('car_id', uncachedIds);\n\n        if (error) {\n          console.warn('Error batch fetching review counts:', error);\n          // Set 0 for all uncached\n          uncachedIds.forEach((id) => result.set(id, 0));\n        } else {\n          // Update cache and result\n          const stats = (data || []) as Array<{ car_id: string; reviews_count: number | null }>;\n          stats.forEach((stat) => {\n            const reviewsCount = stat.reviews_count ?? 0;\n            result.set(stat['car_id'], reviewsCount);\n            this.reviewsCache.set(stat['car_id'], {\n              reviewsCount,\n              expiresAt: now + this.reviewsCacheTtlMs,\n            });\n          });\n\n          // Set 0 for cars not found in stats\n          uncachedIds.forEach((id) => {\n            if (!result.has(id)) {\n              result.set(id, 0);\n            }\n          });\n        }\n      } catch (error) {\n        console.warn('Exception batch fetching review counts:', error);\n        uncachedIds.forEach((id) => result.set(id, 0));\n      }\n    }\n\n    return result;\n  }\n\n  private normalizePayloadArray(payload: unknown[]): CarMapLocation[] {\n    return payload\n      .map((entry) => this.normalizeEntry(entry))\n      .filter((value): value is CarMapLocation => !!value);\n  }\n\n  private normalizeEntry(entry: unknown): CarMapLocation | null {\n    if (!entry || typeof entry !== 'object') {\n      return null;\n    }\n\n    const record = entry as Record<string, unknown>;\n    const car = (record['car'] ?? record) as Record<string, unknown>;\n    const meta = (record['meta'] ?? {}) as Record<string, unknown>;\n    const carId = String(record['car_id'] ?? car['id'] ?? meta['car_id'] ?? '');\n    if (!carId) {\n      return null;\n    }\n\n    const latRaw = record['lat'] ?? record['location_lat'] ?? car['location_lat'];\n    const lngRaw = record['lng'] ?? record['location_lng'] ?? car['location_lng'];\n    const lat = typeof latRaw === 'string' ? Number.parseFloat(latRaw) : (latRaw as number);\n    const lng = typeof lngRaw === 'string' ? Number.parseFloat(lngRaw) : (lngRaw as number);\n    if (\n      typeof lat !== 'number' ||\n      Number.isNaN(lat) ||\n      typeof lng !== 'number' ||\n      Number.isNaN(lng)\n    ) {\n      return null;\n    }\n\n    const status = car['status'] ?? record['status'];\n    if (status && status !== 'active') {\n      return null;\n    }\n\n    const title = String(car['title'] ?? record['title'] ?? 'Auto disponible');\n    const pricePerDayRaw = car['price_per_day'] ?? record['price_per_day'] ?? 0;\n    const pricePerDay =\n      typeof pricePerDayRaw === 'string'\n        ? Number.parseFloat(pricePerDayRaw)\n        : Number(pricePerDayRaw ?? 0);\n    const currency = String(\n      car['currency'] ?? record['currency'] ?? environment.defaultCurrency ?? 'USD',\n    ).toUpperCase();\n\n    const cityRaw = car['location_city'] ?? record['city'] ?? record['location_city'] ?? null;\n    const city = typeof cityRaw === 'string' ? cityRaw : null;\n\n    const stateRaw = car['location_state'] ?? record['state'] ?? record['location_state'] ?? null;\n    const state = typeof stateRaw === 'string' ? stateRaw : null;\n\n    const countryRaw = car['location_country'] ?? record['country'] ?? record['location_country'] ?? null;\n    const country = typeof countryRaw === 'string' ? countryRaw : null;\n\n    const formattedAddressRaw =\n      car['location_formatted_address'] ?? record['location_formatted_address'] ?? null;\n    const formattedAddress = typeof formattedAddressRaw === 'string' ? formattedAddressRaw : null;\n\n    const updatedAt = String(record['updated_at'] ?? car['updated_at'] ?? new Date().toISOString());\n\n    // Get photo URL with fallback logic\n    // La vista v_cars_with_main_photo ahora incluye photo_gallery como JSONB array\n    const photoUrlRaw = car['main_photo_url'] ?? record['main_photo_url'] ?? record['photo_url'] ?? null;\n    let photoUrl =\n      typeof photoUrlRaw === 'string' && photoUrlRaw.trim() ? photoUrlRaw.trim() : null;\n\n    // Get photo_gallery from view (comes as JSONB, Supabase converts to array automatically)\n    const photoGalleryRaw =\n      car['photo_gallery'] ?? record['photo_gallery'] ?? record['photoGallery'] ?? null;\n    let photoGallery: string[] | null = null;\n\n    if (photoGalleryRaw) {\n      if (Array.isArray(photoGalleryRaw)) {\n        // Supabase convierte JSONB automáticamente a array\n        photoGallery = photoGalleryRaw.filter(\n          (url): url is string => typeof url === 'string' && url.trim().length > 0,\n        );\n      } else if (typeof photoGalleryRaw === 'string') {\n        // Fallback: si viene como string JSON (de edge function o payload)\n        try {\n          const parsed = JSON.parse(photoGalleryRaw);\n          if (Array.isArray(parsed)) {\n            photoGallery = parsed.filter(\n              (url): url is string => typeof url === 'string' && url.trim().length > 0,\n            );\n          }\n        } catch {\n          // Invalid JSON, ignore\n        }\n      }\n    }\n\n    // Use first photo from gallery as fallback if main_photo_url is missing\n    if (!photoUrl && photoGallery && photoGallery.length > 0) {\n      photoUrl = photoGallery[0];\n    }\n\n    // If still no photo, photoUrl remains null (will use initials fallback in UI)\n\n    const descriptionRaw =\n      car['description'] ??\n      record['description'] ??\n      (typeof meta['description'] === 'string' ? meta['description'] : '');\n    const description = this.buildSummary(typeof descriptionRaw === 'string' ? descriptionRaw : '');\n\n    // Extract instant booking and rental terms\n    const autoApprovalRaw = car['auto_approval'] ?? record['auto_approval'] ?? meta['auto_approval'] ?? null;\n    const instantBooking =\n      typeof autoApprovalRaw === 'boolean'\n        ? autoApprovalRaw\n        : autoApprovalRaw === 'true' || autoApprovalRaw === true;\n\n    const minRentalDaysRaw =\n      car['min_rental_days'] ?? record['min_rental_days'] ?? meta['min_rental_days'] ?? null;\n    const minRentalDays =\n      typeof minRentalDaysRaw === 'number'\n        ? minRentalDaysRaw\n        : typeof minRentalDaysRaw === 'string'\n          ? Number.parseInt(minRentalDaysRaw, 10)\n          : undefined;\n\n    const maxRentalDaysRaw =\n      car['max_rental_days'] ?? record['max_rental_days'] ?? meta['max_rental_days'] ?? null;\n    const maxRentalDays =\n      typeof maxRentalDaysRaw === 'number'\n        ? maxRentalDaysRaw\n        : typeof maxRentalDaysRaw === 'string'\n          ? Number.parseInt(maxRentalDaysRaw, 10)\n          : undefined;\n\n    const depositRequiredRaw =\n      car['deposit_required'] ?? record['deposit_required'] ?? meta['deposit_required'] ?? null;\n    const depositRequired =\n      typeof depositRequiredRaw === 'boolean'\n        ? depositRequiredRaw\n        : depositRequiredRaw === 'true' || depositRequiredRaw === true;\n\n    const depositAmountRaw =\n      car['deposit_amount'] ?? record['deposit_amount'] ?? meta['deposit_amount'] ?? null;\n    const depositAmount =\n      typeof depositAmountRaw === 'number'\n        ? depositAmountRaw\n        : typeof depositAmountRaw === 'string'\n          ? Number.parseFloat(depositAmountRaw)\n          : undefined;\n\n    const insuranceIncludedRaw =\n      car['insurance_included'] ?? record['insurance_included'] ?? meta['insurance_included'] ?? null;\n    const insuranceIncluded =\n      typeof insuranceIncludedRaw === 'boolean'\n        ? insuranceIncludedRaw\n        : insuranceIncludedRaw === 'true' || insuranceIncludedRaw === true;\n\n    const usesDynamicPricingRaw =\n      car['uses_dynamic_pricing'] ?? record['uses_dynamic_pricing'] ?? meta['uses_dynamic_pricing'] ?? null;\n    const usesDynamicPricing =\n      typeof usesDynamicPricingRaw === 'boolean'\n        ? usesDynamicPricingRaw\n        : usesDynamicPricingRaw === 'true' || usesDynamicPricingRaw === true;\n\n    return {\n      carId,\n      title,\n      pricePerDay: Number.isFinite(pricePerDay) ? pricePerDay : 0,\n      currency,\n      lat,\n      lng,\n      updatedAt,\n      city,\n      state,\n      country,\n      locationLabel: this.buildLocationLabel(city, state, country),\n      formattedAddress,\n      photoUrl,\n      photoGallery,\n      description,\n      instantBooking,\n      minRentalDays,\n      maxRentalDays,\n      depositRequired,\n      depositAmount,\n      insuranceIncluded,\n      usesDynamicPricing,\n    };\n  }\n\n  private buildSummary(value: string | null | undefined): string | null {\n    if (!value) {\n      return null;\n    }\n    const normalized = value.trim().replace(/\\s+/g, ' ');\n    if (normalized.length <= 140) {\n      return normalized;\n    }\n    return `${normalized.slice(0, 137)}...`;\n  }\n\n  private buildLocationLabel(\n    city: string | null | undefined,\n    state: string | null | undefined,\n    country: string | null | undefined,\n  ): string {\n    const parts = [city, state, country].filter((part) => !!part && String(part).trim().length > 0);\n    return parts.length > 0 ? parts.map((part) => String(part).trim()).join(', ') : 'Uruguay';\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/core/services/cars/cars-compare.service.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`@core/services/infrastructure/notification-manager.service` import should occur before import of `../models`","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":105,"fix":{"range":[126,340],"text":"import { NotificationManagerService } from '@core/services/infrastructure/notification-manager.service';\nimport { Car, CarComparison, ComparisonRow } from '../models';\nimport { CarsService } from './cars.service';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { isPlatformBrowser } from '@angular/common';\nimport { Injectable, signal, inject, PLATFORM_ID } from '@angular/core';\nimport { Car, CarComparison, ComparisonRow } from '../models';\nimport { CarsService } from './cars.service';\nimport { NotificationManagerService } from '@core/services/infrastructure/notification-manager.service';\n\nconst STORAGE_KEY = 'autorenta_comparison';\nconst MAX_COMPARE = 3;\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class CarsCompareService {\n  private readonly comparedCarIds = signal<string[]>([]);\n  readonly comparedCars = signal<Car[]>([]);\n  readonly count = signal<number>(0);\n  private readonly toastService = inject(NotificationManagerService);\n  private readonly platformId = inject(PLATFORM_ID);\n  private readonly isBrowser = isPlatformBrowser(this.platformId);\n\n  constructor(private readonly carsService: CarsService) {\n    if (this.isBrowser) {\n      this.loadFromStorage();\n    }\n  }\n\n  /**\n   * Agregar auto a la comparación\n   * @returns true si se agregó exitosamente, false si no se pudo agregar\n   */\n  addCar(carId: string): boolean {\n    const current = this.comparedCarIds();\n\n    // Validar si ya existe\n    if (current.includes(carId)) {\n      this.toastService.info('Auto ya agregado', 'Este vehículo ya está en tu comparación', 3000);\n      return false;\n    }\n\n    // Validar máximo\n    if (current.length >= MAX_COMPARE) {\n      this.toastService.warning(\n        'Límite alcanzado',\n        `Solo puedes comparar hasta ${MAX_COMPARE} vehículos a la vez. Elimina uno para agregar otro.`,\n        4000,\n      );\n      return false;\n    }\n\n    // Agregar\n    const updated = [...current, carId];\n    this.comparedCarIds.set(updated);\n    this.count.set(updated.length);\n    this.saveToStorage(updated);\n    void this.loadCars();\n\n    // Mostrar feedback de éxito\n    this.toastService.success(\n      'Auto agregado',\n      `Vehículo agregado a la comparación (${updated.length}/${MAX_COMPARE})`,\n      3000,\n    );\n\n    return true;\n  }\n\n  /**\n   * Remover auto de la comparación\n   */\n  removeCar(carId: string): void {\n    const updated = this.comparedCarIds().filter((id) => id !== carId);\n    this.comparedCarIds.set(updated);\n    this.count.set(updated.length);\n    this.saveToStorage(updated);\n    void this.loadCars();\n  }\n\n  /**\n   * Limpiar toda la comparación\n   */\n  clearAll(): void {\n    this.comparedCarIds.set([]);\n    this.comparedCars.set([]);\n    this.count.set(0);\n    if (this.isBrowser) {\n      sessionStorage.removeItem(STORAGE_KEY);\n    }\n  }\n\n  /**\n   * Verificar si un auto está en la comparación\n   */\n  isComparing(carId: string): boolean {\n    return this.comparedCarIds().includes(carId);\n  }\n\n  /**\n   * Cargar autos completos desde el servicio\n   */\n  private async loadCars(): Promise<void> {\n    const ids = this.comparedCarIds();\n    if (ids.length === 0) {\n      this.comparedCars.set([]);\n      return;\n    }\n\n    try {\n      // Cargar todos los autos en paralelo\n      const cars = await Promise.all(ids.map((id) => this.carsService.getCarById(id)));\n\n      // Filtrar nulls por si algún auto no existe\n      const validCars = cars.filter((car) => car !== null) as Car[];\n      this.comparedCars.set(validCars);\n    } catch {\n      this.comparedCars.set([]);\n    }\n  }\n\n  /**\n   * Generar filas de comparación estructuradas\n   */\n  generateComparisonRows(): ComparisonRow[] {\n    const cars = this.comparedCars();\n    if (cars.length === 0) return [];\n\n    const rows: ComparisonRow[] = [];\n\n    // BASIC INFO\n    rows.push({\n      label: 'Marca',\n      category: 'basic',\n      values: cars.map((c) => c.brand || c.brand_name || '-'),\n    });\n    rows.push({\n      label: 'Modelo',\n      category: 'basic',\n      values: cars.map((c) => c.model || c.model_name || '-'),\n    });\n    rows.push({\n      label: 'Año',\n      category: 'basic',\n      values: cars.map((c) => c.year),\n    });\n    rows.push({\n      label: 'Color',\n      category: 'basic',\n      values: cars.map((c) => c.color),\n    });\n\n    // SPECS\n    rows.push({\n      label: 'Transmisión',\n      category: 'specs',\n      values: cars.map((c) => (c.transmission === 'automatic' ? 'Automática' : 'Manual')),\n    });\n    rows.push({\n      label: 'Combustible',\n      category: 'specs',\n      values: cars.map((c) => {\n        const fuelType = String(c.fuel);\n        switch (fuelType) {\n          case 'gasoline':\n            return 'Nafta';\n          case 'diesel':\n            return 'Diesel';\n          case 'electric':\n            return 'Eléctrico';\n          case 'hybrid':\n            return 'Híbrido';\n          default:\n            return fuelType;\n        }\n      }),\n    });\n    rows.push({\n      label: 'Asientos',\n      category: 'specs',\n      values: cars.map((c) => c.seats),\n    });\n    rows.push({\n      label: 'Puertas',\n      category: 'specs',\n      values: cars.map((c) => c.doors),\n    });\n    rows.push({\n      label: 'Kilometraje',\n      category: 'specs',\n      values: cars.map((c) => `${c.mileage.toLocaleString()} km`),\n      highlightBest: true, // Menor kilometraje es mejor\n    });\n\n    // PRICING\n    rows.push({\n      label: 'Precio por día',\n      category: 'pricing',\n      values: cars.map((c) => `${c.currency} ${c.price_per_day.toLocaleString()}`),\n      highlightBest: true, // Menor precio es mejor\n    });\n    rows.push({\n      label: 'Rating',\n      category: 'pricing',\n      values: cars.map((c) => `⭐ ${c.rating_avg.toFixed(1)} (${c.rating_count})`),\n      highlightBest: true, // Mayor rating es mejor\n    });\n\n    // LOCATION\n    rows.push({\n      label: 'Ciudad',\n      category: 'location',\n      values: cars.map((c) => c.location_city),\n    });\n    rows.push({\n      label: 'Provincia',\n      category: 'location',\n      values: cars.map((c) => c.location_province || c.location_state || '-'),\n    });\n\n    // OWNER\n    if (cars.every((c) => c.owner)) {\n      rows.push({\n        label: 'Propietario',\n        category: 'owner',\n        values: cars.map((c) => c.owner?.full_name || '-'),\n      });\n      rows.push({\n        label: 'Rating propietario',\n        category: 'owner',\n        values: cars.map((c) => (c.owner ? `⭐ ${c.owner.rating_avg.toFixed(1)}` : '-')),\n      });\n    }\n\n    return rows;\n  }\n\n  /**\n   * Persistir en sessionStorage\n   */\n  private saveToStorage(carIds: string[]): void {\n    if (!this.isBrowser) return;\n    const comparison: CarComparison = {\n      carIds,\n      timestamp: new Date().toISOString(),\n    };\n    sessionStorage.setItem(STORAGE_KEY, JSON.stringify(comparison));\n  }\n\n  /**\n   * Cargar desde sessionStorage\n   */\n  private loadFromStorage(): void {\n    if (!this.isBrowser) return;\n    const stored = sessionStorage.getItem(STORAGE_KEY);\n    if (!stored) return;\n\n    try {\n      const comparison: CarComparison = JSON.parse(stored);\n\n      // Validar que no sea muy antigua (1 hora)\n      const timestamp = new Date(comparison.timestamp);\n      const hourAgo = new Date(Date.now() - 60 * 60 * 1000);\n\n      if (timestamp > hourAgo && comparison.carIds.length > 0) {\n        this.comparedCarIds.set(comparison.carIds);\n        this.count.set(comparison.carIds.length);\n        void this.loadCars();\n      } else {\n        sessionStorage.removeItem(STORAGE_KEY);\n      }\n    } catch {\n      sessionStorage.removeItem(STORAGE_KEY);\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/core/services/cars/cars.service.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`@core/services/infrastructure/supabase-client.service` import should occur before import of `../models`","line":7,"column":1,"nodeType":"ImportDeclaration","endLine":7,"endColumn":88,"fix":{"range":[167,433],"text":"import { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\nimport { Car, CarFilters, CarPhoto } from '../models';\nimport { optimizeImage } from '../utils/image.utils';\nimport { CarAvailabilityService } from './car-availability.service';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { LoggerService } from '@core/services/infrastructure/logger.service';\nimport { Injectable, inject } from '@angular/core';\nimport { v4 as uuidv4 } from 'uuid';\nimport { Car, CarFilters, CarPhoto } from '../models';\nimport { optimizeImage } from '../utils/image.utils';\nimport { CarAvailabilityService } from './car-availability.service';\nimport { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\n\n// Type for raw car data from Supabase with photos joined\ntype CarWithPhotosRaw = Record<string, unknown> & {\n  car_photos?: unknown[];\n  owner?: unknown | unknown[];\n};\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class CarsService {\n  private readonly logger = inject(LoggerService);\n  private readonly supabase = injectSupabase();\n  private readonly carAvailabilityService = inject(CarAvailabilityService);\n  private readonly defaultValuationConfig = {\n    averageRentalDays: 300,\n  };\n\n  async createCar(input: Partial<Car>): Promise<Car> {\n    const userId = (await this.supabase.auth.getUser()).data['user']?.['id'];\n    if (!userId) {\n      throw new Error('Usuario no autenticado');\n    }\n\n    // Validate required fields\n    // ✅ CRITICAL: brand_id/model_id son UUIDs (pueden ser null si usamos FIPE)\n    // Si no hay UUIDs, debemos tener brand_text_backup y model_text_backup\n    const hasBrandId = !!input.brand_id;\n    const hasModelId = !!input.model_id;\n    const hasBrandText = !!input.brand_text_backup;\n    const hasModelText = !!input.model_text_backup;\n\n    if (!hasBrandId && !hasBrandText) {\n      throw new Error('Marca es requerida (brand_id o brand_text_backup)');\n    }\n    if (!hasModelId && !hasModelText) {\n      throw new Error('Modelo es requerido (model_id o model_text_backup)');\n    }\n    if (!input['price_per_day'] || input['price_per_day'] <= 0) {\n      throw new Error('Precio por día debe ser mayor a 0');\n    }\n\n    // Check for coordinates (using type assertion since location_lat/location_lng come from form)\n    const carInput = input as Record<string, unknown>;\n\n    // ✅ CRITICAL: Las coordenadas son OBLIGATORIAS para que el auto aparezca en búsquedas\n    // Si no hay coordenadas, el auto será invisible en el mapa y en búsquedas espaciales\n    if (!carInput['location_lat'] || !carInput['location_lng']) {\n      throw new Error(\n        'Ubicación del vehículo requerida. Por favor selecciona una ubicación en el mapa o usa tu ubicación actual.',\n      );\n    }\n\n    const cleanInput = { ...input };\n\n    // ✅ CRITICAL: Mapear campos de ubicación legacy (city, province, country)\n    // La base de datos requiere city/province/country (NOT NULL)\n    // pero el formulario envía location_city/location_state/location_country\n    const city =\n      (input as Record<string, unknown>)['city'] ||\n      (input as Record<string, unknown>)['location_city'] ||\n      '';\n    const province =\n      (input as Record<string, unknown>)['province'] ||\n      (input as Record<string, unknown>)['location_state'] ||\n      (input as Record<string, unknown>)['location_province'] ||\n      '';\n    const country =\n      (input as Record<string, unknown>)['country'] ||\n      (input as Record<string, unknown>)['location_country'] ||\n      'AR';\n\n    // Prepare clean data for insert\n    const carData = {\n      ...cleanInput,\n      // ✅ Mapear campos legacy requeridos por la base de datos\n      city: city || 'Buenos Aires', // Default si está vacío\n      province: province || 'Buenos Aires', // Default si está vacío\n      country: country || 'AR',\n      owner_id: userId,\n      status: input['status'] || 'active', // Default to active if not specified\n      created_at: new Date().toISOString(),\n    };\n\n    this.logger.debug('🚗 Creating car with data:', {\n      ...carData,\n      // Redact sensitive fields for logging\n      owner_id: '***',\n    });\n\n    const { data, error } = await this.supabase\n      .from('cars')\n      .insert(carData)\n      .select('*, car_photos(*)')\n      .single();\n\n    if (error) {\n      console.error('❌ Error creating car:', error);\n      throw error;\n    }\n\n    this.logger.debug('✅ Car created successfully:', data['id']);\n\n    return {\n      ...data,\n      photos: data.car_photos || [],\n    } as Car;\n  }\n\n  async uploadPhoto(file: File, carId: string, position = 0): Promise<CarPhoto> {\n    const userId = (await this.supabase.auth.getUser()).data['user']?.['id'];\n    if (!userId) throw new Error('Usuario no autenticado');\n\n    const optimizedFile = await optimizeImage(file, {\n      maxWidth: 1200,\n      maxHeight: 900,\n      quality: 0.85,\n      format: 'webp',\n    });\n\n    const extension = 'webp';\n    const filePath = `${userId}/${carId}/${uuidv4()}.${extension}`;\n    const { error } = await this.supabase.storage\n      .from('car-images')\n      .upload(filePath, optimizedFile, {\n        cacheControl: '3600',\n        upsert: false,\n      });\n    if (error) throw error;\n    const { data } = this.supabase.storage.from('car-images').getPublicUrl(filePath);\n\n    const photoId = uuidv4();\n    const { data: photoData, error: photoError } = await this.supabase\n      .from('car_photos')\n      .insert({\n        id: photoId,\n        car_id: carId,\n        stored_path: filePath,\n        url: data.publicUrl,\n        position,\n        sort_order: position,\n      })\n      .select()\n      .single();\n\n    if (photoError) throw photoError;\n    return photoData as CarPhoto;\n  }\n\n  async getCarPhotos(carId: string): Promise<CarPhoto[]> {\n    const { data, error } = await this.supabase\n      .from('car_photos')\n      .select('*')\n      .eq('car_id', carId)\n      .order('sort_order', { ascending: true })\n      .order('position', { ascending: true });\n\n    if (error) throw error;\n    return (data ?? []) as CarPhoto[];\n  }\n\n  suggestVehicleValueUsd(\n    pricePerDay: number | null | undefined,\n    options?: { averageRentalDays?: number },\n  ): number {\n    if (!pricePerDay || pricePerDay <= 0) {\n      return 0;\n    }\n\n    const days = options?.averageRentalDays ?? this.defaultValuationConfig.averageRentalDays;\n    return Math.round(pricePerDay * days);\n  }\n\n  getDefaultAverageRentalDays(): number {\n    return this.defaultValuationConfig.averageRentalDays;\n  }\n\n  async listActiveCars(filters: CarFilters): Promise<Car[]> {\n    let query = this.supabase\n      .from('cars')\n      .select(\n        `\n        *,\n        car_photos(*),\n        owner:profiles!cars_owner_id_fkey(\n          id,\n          full_name,\n          avatar_url,\n          rating_avg,\n          rating_count,\n          created_at\n        )\n      `,\n      )\n      .eq('status', 'active')\n      .order('created_at', { ascending: false });\n\n    if (filters['city']) {\n      query = query.ilike('location_city', `%${filters['city']}%`);\n    }\n\n    // ✅ FIX P0.3: Filtrar por coordenadas (bounding box)\n    if (filters.bounds) {\n      query = query\n        .lte('location_lat', filters.bounds.north)\n        .gte('location_lat', filters.bounds.south)\n        .lte('location_lng', filters.bounds.east)\n        .gte('location_lng', filters.bounds.west);\n    }\n\n    const { data, error } = await query;\n    if (error) throw error;\n\n    // Data loaded successfully\n\n    // ✅ FIX P0.2: Filtrar por disponibilidad si hay fechas\n    if (filters.from && filters.to && data) {\n      const availableCars = await this.carAvailabilityService.filterByAvailability(\n        data as Car[],\n        filters.from,\n        filters.to,\n        filters.blockedCarIds || [],\n      );\n      return (availableCars as unknown[]).map((car) => {\n        const typedCar = car as CarWithPhotosRaw;\n        return {\n          ...typedCar,\n          photos: typedCar.car_photos || [],\n          owner: Array.isArray(typedCar.owner) ? typedCar.owner[0] : typedCar.owner,\n        };\n      }) as Car[];\n    }\n\n    return (data ?? []).map((car: CarWithPhotosRaw) => ({\n      ...car,\n      photos: car.car_photos || [],\n      owner: Array.isArray(car.owner) ? car.owner[0] : car.owner,\n    })) as Car[];\n  }\n\n  async getCarById(id: string): Promise<Car | null> {\n    const { data, error } = await this.supabase\n      .from('cars')\n      .select(\n        `\n        *,\n        car_photos(*),\n        owner:profiles!cars_owner_id_fkey(\n          id,\n          full_name,\n          avatar_url,\n          rating_avg,\n          rating_count,\n          created_at\n        )\n      `,\n      )\n      .eq('id', id)\n      .single();\n    if (error) {\n      if (error.code === 'PGRST116') return null;\n      throw error;\n    }\n\n    return {\n      ...data,\n      photos: data.car_photos || [],\n    } as Car;\n  }\n\n  async listMyCars(): Promise<Car[]> {\n    const userId = (await this.supabase.auth.getUser()).data['user']?.['id'];\n    if (!userId) throw new Error('Usuario no autenticado');\n\n    // 1. Get my orgs IDs (to include fleet cars)\n    const { data: orgs } = await this.supabase\n      .from('organization_members')\n      .select('organization_id')\n      .eq('user_id', userId);\n\n    const orgIds = orgs?.map((o) => o.organization_id) || [];\n\n    // 2. Build query\n    let query = this.supabase\n      .from('cars')\n      .select('*, car_photos(*)')\n      .order('created_at', { ascending: false });\n\n    if (orgIds.length > 0) {\n      // Fetch cars where:\n      // A) I am the owner (owner_id = me)\n      // B) OR the car belongs to an organization I am a member of\n      query = query.or(`owner_id.eq.${userId},organization_id.in.(${orgIds.join(',')})`);\n    } else {\n      // Fallback for individuals with no orgs\n      query = query.eq('owner_id', userId);\n    }\n\n    const { data, error } = await query;\n    if (error) throw error;\n\n    return (data ?? []).map((car: CarWithPhotosRaw) => ({\n      ...car,\n      photos: car.car_photos || [],\n    })) as Car[];\n  }\n\n  /**\n   * Alias for listMyCars for backward compatibility\n   */\n  async getMyCars(): Promise<Car[]> {\n    return this.listMyCars();\n  }\n\n  /**\n   * @deprecated Use CarAvailabilityService.getBlockedDateRanges instead\n   */\n  async getBlockedDateRanges(carId: string): Promise<Array<{ from: string; to: string }>> {\n    const ranges = await this.carAvailabilityService.getBlockedDates(carId);\n    return ranges.map((r) => ({ from: r.from, to: r.to }));\n  }\n\n  async deleteCar(carId: string): Promise<void> {\n    const userId = (await this.supabase.auth.getUser()).data['user']?.['id'];\n    if (!userId) throw new Error('Usuario no autenticado');\n    const { error } = await this.supabase\n      .from('cars')\n      .delete()\n      .eq('id', carId)\n      .eq('owner_id', userId);\n    if (error) throw error;\n  }\n\n  /**\n   * ✅ NUEVO: Actualizar solo el status del auto\n   */\n  async updateCarStatus(carId: string, status: string): Promise<void> {\n    const userId = (await this.supabase.auth.getUser()).data['user']?.['id'];\n    if (!userId) throw new Error('Usuario no autenticado');\n\n    const { error } = await this.supabase\n      .from('cars')\n      .update({ status, updated_at: new Date().toISOString() })\n      .eq('id', carId)\n      .eq('owner_id', userId);\n\n    if (error) throw error;\n  }\n\n  async updateCar(carId: string, input: Partial<Car>): Promise<Car> {\n    const userId = (await this.supabase.auth.getUser()).data['user']?.['id'];\n    if (!userId) throw new Error('Usuario no autenticado');\n\n    // ✅ CRITICAL: Mapear campos de ubicación legacy (city, province, country)\n    // La base de datos requiere city/province/country (NOT NULL)\n    // pero el formulario envía location_city/location_state/location_country\n    const inputRecord = input as Record<string, unknown>;\n    const updateData: Record<string, unknown> = { ...input };\n\n    // Mapear location_city a city si existe\n    if (inputRecord['location_city'] && !inputRecord['city']) {\n      updateData['city'] = inputRecord['location_city'];\n    }\n    // Mapear location_state/location_province a province si existe\n    if ((inputRecord['location_state'] || inputRecord['location_province']) && !inputRecord['province']) {\n      updateData['province'] = inputRecord['location_state'] || inputRecord['location_province'];\n    }\n    // Mapear location_country a country si existe\n    if (inputRecord['location_country'] && !inputRecord['country']) {\n      updateData['country'] = inputRecord['location_country'];\n    }\n\n    const { data, error } = await this.supabase\n      .from('cars')\n      .update(updateData)\n      .eq('id', carId)\n      .eq('owner_id', userId)\n      .select('*, car_photos(*)')\n      .single();\n\n    if (error) throw error;\n\n    return {\n      ...data,\n      photos: data.car_photos || [],\n    } as Car;\n  }\n\n  async listPendingCars(): Promise<Car[]> {\n    const { data, error } = await this.supabase\n      .from('cars')\n      .select('*, car_photos(*)')\n      .eq('status', 'draft')\n      .order('created_at', { ascending: false });\n    if (error) throw error;\n\n    return (data ?? []).map((car: CarWithPhotosRaw) => ({\n      ...car,\n      photos: car.car_photos || [],\n    })) as Car[];\n  }\n\n  async getCarBrands(): Promise<Array<{ id: string; name: string }>> {\n    const { data, error } = await this.supabase.from('car_brands').select('id, name').order('name');\n    if (error) throw error;\n    return data ?? [];\n  }\n\n  async getCarModels(\n    brandId: string,\n  ): Promise<Array<{ id: string; name: string; category: string; seats: number; doors: number }>> {\n    const { data, error } = await this.supabase\n      .from('car_models')\n      .select('id, name, category, seats, doors')\n      .eq('brand_id', brandId)\n      .order('name');\n    if (error) throw error;\n    return data ?? [];\n  }\n\n  async getAllCarModels(): Promise<\n    Array<{\n      id: string;\n      brand_id: string;\n      name: string;\n      category: string;\n      seats: number;\n      doors: number;\n    }>\n  > {\n    const { data, error } = await this.supabase\n      .from('car_models')\n      .select('id, brand_id, name, category, seats, doors')\n      .order('name');\n    if (error) throw error;\n    return data ?? [];\n  }\n\n  async getUserLastCar(): Promise<Car | null> {\n    const userId = (await this.supabase.auth.getUser()).data['user']?.['id'];\n    if (!userId) return null;\n\n    const { data, error } = await this.supabase\n      .from('cars')\n      .select('*')\n      .eq('owner_id', userId)\n      .order('created_at', { ascending: false })\n      .limit(1)\n      .single();\n\n    if (error) {\n      if (error.code === 'PGRST116') return null; // No rows found\n      throw error;\n    }\n\n    return data as Car;\n  }\n\n  async getCarsByOwner(ownerId: string): Promise<Car[]> {\n    const { data, error } = await this.supabase\n      .from('cars')\n      .select('*')\n      .eq('owner_id', ownerId)\n      .order('created_at', { ascending: false });\n\n    if (error) {\n      throw error;\n    }\n\n    return (data as Car[]) ?? [];\n  }\n\n  /**\n   * @deprecated Use CarAvailabilityService.getAvailableCars instead\n   */\n  async getAvailableCars(\n    startDate: string,\n    endDate: string,\n    options: {\n      limit?: number;\n      offset?: number;\n      city?: string;\n    } = {},\n  ): Promise<Car[]> {\n    const available = await this.carAvailabilityService.getAvailableCars(\n      startDate,\n      endDate,\n      options,\n    );\n    // Map to Car model if needed (Supabase returns `cars` rows already compatible with `Car`).\n    return available as Car[];\n  }\n\n  /**\n   * @deprecated Use CarAvailabilityService.isCarAvailable instead\n   */\n  async isCarAvailable(carId: string, startDate: string, endDate: string): Promise<boolean> {\n    return this.carAvailabilityService.checkAvailability(carId, startDate, endDate);\n  }\n\n  /**\n   * @deprecated Use CarAvailabilityService.hasActiveBookings instead\n   */\n  async hasActiveBookings(carId: string): Promise<{\n    hasActive: boolean;\n    count: number;\n    bookings?: Array<{ id: string; status: string; start_date: string; end_date: string }>;\n  }> {\n    return this.carAvailabilityService.hasActiveBookings(carId);\n  }\n\n  /**\n   * @deprecated Use CarAvailabilityService.getNextAvailableRange instead\n   */\n  async getNextAvailableRange(\n    carId: string,\n    startDate: string,\n    endDate: string,\n    maxOptions = 3,\n  ): Promise<\n    Array<{\n      startDate: string;\n      endDate: string;\n      daysCount: number;\n    }>\n  > {\n    return this.carAvailabilityService.getNextAvailableRange(carId, startDate, endDate, maxOptions);\n  }\n\n  /**\n   * Get available cars using server-side RPC with PostGIS distance scoring.\n   * This method uses the `get_available_cars` Postgres function which:\n   * - Filters by availability (no overlapping bookings)\n   * - Calculates distance from user location using ST_DistanceSphere\n   * - Applies smart scoring (distance, rating, price, auto_approval)\n   * - Returns cars sorted by score (distance prioritized for nearby cars)\n   */\n  async getAvailableCarsWithDistance(\n    startDate: string,\n    endDate: string,\n    options: {\n      lat?: number;\n      lng?: number;\n      limit?: number;\n      offset?: number;\n    } = {},\n  ): Promise<CarWithScore[]> {\n    const { lat, lng, limit = 12, offset = 0 } = options;\n\n    const { data, error } = await this.supabase.rpc('get_available_cars', {\n      p_start_date: startDate,\n      p_end_date: endDate,\n      p_lat: lat ?? null,\n      p_lng: lng ?? null,\n      p_limit: limit,\n      p_offset: offset,\n    });\n\n    if (error) {\n      console.error('Error calling get_available_cars RPC:', error);\n      throw error;\n    }\n\n    return (data || []) as CarWithScore[];\n  }\n\n  /**\n   * Get cars within a specific radius from user location.\n   * Uses the `get_cars_within_radius` Postgres function.\n   */\n  async getCarsWithinRadius(\n    userLat: number,\n    userLng: number,\n    radiusKm: number,\n    options: {\n      startDate?: string;\n      endDate?: string;\n      limit?: number;\n      offset?: number;\n    } = {},\n  ): Promise<CarWithDistance[]> {\n    const { startDate, endDate, limit = 50, offset = 0 } = options;\n\n    const { data, error } = await this.supabase.rpc('get_cars_within_radius', {\n      p_user_lat: userLat,\n      p_user_lng: userLng,\n      p_radius_km: radiusKm,\n      p_start_date: startDate ?? null,\n      p_end_date: endDate ?? null,\n      p_limit: limit,\n      p_offset: offset,\n    });\n\n    if (error) {\n      console.error('Error calling get_cars_within_radius RPC:', error);\n      throw error;\n    }\n\n    return (data || []) as CarWithDistance[];\n  }\n}\n\n/**\n * Car with score from get_available_cars RPC\n */\nexport interface CarWithScore {\n  id: string;\n  owner_id: string;\n  brand: string;\n  model: string;\n  year: number;\n  plate: string;\n  price_per_day: number;\n  currency: string;\n  status: string;\n  location: {\n    city?: string;\n    state?: string;\n    province?: string;\n    country?: string;\n    lat?: number;\n    lng?: number;\n  };\n  images: string[];\n  features: Record<string, unknown>;\n  created_at: string;\n  updated_at: string;\n  total_bookings: number;\n  avg_rating: number;\n  score: number;\n}\n\n/**\n * Car with distance from get_cars_within_radius RPC\n */\nexport interface CarWithDistance {\n  id: string;\n  owner_id: string;\n  title: string;\n  brand_text_backup: string;\n  model_text_backup: string;\n  year: number;\n  price_per_day: number;\n  currency: string;\n  value_usd: number;\n  location_city: string;\n  location_state: string;\n  location_lat: number;\n  location_lng: number;\n  location_formatted_address: string;\n  distance_km: number;\n  status: string;\n  photos_count: number;\n  avg_rating: number;\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/core/services/cars/reviews.service.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`@core/services/auth/profile.service` import should occur before type import of `../models`","line":12,"column":1,"nodeType":"ImportDeclaration","endLine":12,"endColumn":70,"fix":{"range":[70,390],"text":"import { ProfileService } from '@core/services/auth/profile.service';\nimport type {\n  CarStats,\n  CreateReviewParams,\n  Review,\n  ReviewSummary,\n  ReviewType,\n  UserStats,\n} from '../models';\nimport { CarOwnerNotificationsService } from './car-owner-notifications.service';\nimport { CarsService } from './cars.service';\n"}},{"ruleId":"import/order","severity":1,"message":"`@core/services/infrastructure/supabase-client.service` import should occur before type import of `../models`","line":13,"column":1,"nodeType":"ImportDeclaration","endLine":13,"endColumn":88,"fix":{"range":[70,478],"text":"import { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\nimport type {\n  CarStats,\n  CreateReviewParams,\n  Review,\n  ReviewSummary,\n  ReviewType,\n  UserStats,\n} from '../models';\nimport { CarOwnerNotificationsService } from './car-owner-notifications.service';\nimport { CarsService } from './cars.service';\nimport { ProfileService } from '@core/services/auth/profile.service';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import { computed, inject, Injectable, signal } from '@angular/core';\nimport type {\n  CarStats,\n  CreateReviewParams,\n  Review,\n  ReviewSummary,\n  ReviewType,\n  UserStats,\n} from '../models';\nimport { CarOwnerNotificationsService } from './car-owner-notifications.service';\nimport { CarsService } from './cars.service';\nimport { ProfileService } from '@core/services/auth/profile.service';\nimport { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\n\nexport interface CreateReviewResult {\n  success: boolean;\n  review_id?: string;\n  error?: string;\n  published_immediately?: boolean;\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class ReviewsService {\n  private readonly supabase = injectSupabase();\n  private readonly carOwnerNotifications = inject(CarOwnerNotificationsService);\n  private readonly carsService = inject(CarsService);\n  private readonly profileService = inject(ProfileService);\n\n  // Signals privados para estado reactivo\n  private readonly reviewsSignal = signal<Review[]>([]);\n  private readonly carStatsSignal = signal<CarStats | null>(null);\n  private readonly userStatsSignal = signal<UserStats | null>(null);\n  private readonly loadingSignal = signal<boolean>(false);\n  private readonly errorSignal = signal<string | null>(null);\n\n  // Exponer signals como readonly\n  readonly reviews = this.reviewsSignal.asReadonly();\n  readonly carStats = this.carStatsSignal.asReadonly();\n  readonly userStats = this.userStatsSignal.asReadonly();\n  readonly loading = this.loadingSignal.asReadonly();\n  readonly error = this.errorSignal.asReadonly();\n\n  // Computed values\n  readonly reviewsCount = computed(() => this.reviews().length);\n  readonly averageRating = computed(() => {\n    const reviews = this.reviews();\n    if (reviews.length === 0) return 0;\n    const total = reviews.reduce((sum, r) => {\n      const avg =\n        (r.rating_cleanliness +\n          r.rating_communication +\n          r.rating_accuracy +\n          r.rating_location +\n          r.rating_checkin +\n          r.rating_value) /\n        6;\n      return sum + avg;\n    }, 0);\n    return Number((total / reviews.length).toFixed(1));\n  });\n  readonly hasReviews = computed(() => this.reviews().length > 0);\n\n  /**\n   * Create a new review using the v2 system with category ratings\n   */\n  async createReview(params: CreateReviewParams): Promise<CreateReviewResult> {\n    try {\n      const {\n        data: { user },\n        error: authError,\n      } = await this.supabase.auth.getUser();\n\n      if (authError) throw authError;\n      if (!user?.id) throw new Error('Usuario no autenticado');\n\n      // Call the create_review_v2 function\n      const { data, error } = await this.supabase.rpc('create_review_v2', {\n        p_booking_id: params.booking_id,\n        p_reviewer_id: user.id,\n        p_reviewee_id: params.reviewee_id,\n        p_car_id: params.car_id,\n        p_review_type: params.review_type,\n        p_rating_cleanliness: params.rating_cleanliness,\n        p_rating_communication: params.rating_communication,\n        p_rating_accuracy: params.rating_accuracy,\n        p_rating_location: params.rating_location,\n        p_rating_checkin: params.rating_checkin,\n        p_rating_value: params.rating_value,\n        p_comment_public: params.comment_public ?? null,\n        p_comment_private: params.comment_private ?? null,\n      });\n\n      if (error) throw error;\n\n      const reviewId = data as string;\n\n      // ✅ NUEVO: Notificar al dueño del auto sobre la nueva reseña (si es renter_to_owner)\n      if (params.review_type === 'renter_to_owner') {\n        this.notifyOwnerOfNewReview(reviewId, params).catch((_error: unknown) => {\n          // Silently fail - notification is optional enhancement\n        });\n      }\n\n      return {\n        success: true,\n        review_id: reviewId,\n      };\n    } catch (error: unknown) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Error desconocido',\n      };\n    }\n  }\n\n  /**\n   * Get reviews for a specific user (as owner or renter)\n   */\n  async getReviewsForUser(userId: string, asOwner: boolean = true): Promise<Review[]> {\n    try {\n      // Use v_car_reviews view which has review_type computed column\n      const isCarReview = asOwner; // renter_to_owner = is_car_review\n\n      const { data, error } = await this.supabase\n        .from('v_car_reviews')\n        .select('*')\n        .eq('reviewee_id', userId)\n        .eq('is_car_review', isCarReview)\n        .order('created_at', { ascending: false });\n\n      if (error) throw error;\n\n      return (data || []) as Review[];\n    } catch {\n      return [];\n    }\n  }\n\n  /**\n   * Load reviews for a specific car (updates signals)\n   * Uses v_car_reviews view which has car_id via booking JOIN\n   */\n  async loadReviewsForCar(carId: string): Promise<void> {\n    this.loadingSignal.set(true);\n    this.errorSignal.set(null);\n\n    try {\n      const { data, error } = await this.supabase\n        .from('v_car_reviews')\n        .select('*')\n        .eq('car_id', carId)\n        .eq('is_car_review', true)\n        .order('created_at', { ascending: false });\n\n      if (error) throw error;\n\n      const reviews = (data || []).map((review) => ({\n        ...review,\n        // View already includes reviewer_name and reviewer_avatar\n      })) as Review[];\n\n      this.reviewsSignal.set(reviews);\n    } catch (err) {\n      // Gracefully handle errors (e.g. missing table, bad request)\n      console.warn('⚠️ Error loading reviews (suppressed):', err);\n      this.reviewsSignal.set([]);\n      // Do not set errorSignal to avoid breaking UI for non-critical data\n    } finally {\n      this.loadingSignal.set(false);\n    }\n  }\n\n  /**\n   * Get reviews for a specific car (backward compatibility - returns Promise)\n   * @deprecated Use loadReviewsForCar() and subscribe to reviews signal instead\n   */\n  async getReviewsForCar(carId: string): Promise<Review[]> {\n    await this.loadReviewsForCar(carId);\n    return this.reviews();\n  }\n\n  /**\n   * Load user statistics (updates signals)\n   * TODO: Enable when user_stats table/view is created\n   */\n  async loadUserStats(_userId: string): Promise<void> {\n    // Table user_stats doesn't exist yet - skip query to avoid 404 errors\n    // When the table is created, uncomment the code below\n    this.userStatsSignal.set(null);\n\n    /*\n    this.loadingSignal.set(true);\n    this.errorSignal.set(null);\n\n    try {\n      const { data, error } = await this.supabase\n        .from('user_stats')\n        .select('*')\n        .eq('user_id', userId)\n        .maybeSingle();\n\n      if (error) throw error;\n      this.userStatsSignal.set(data as UserStats | null);\n    } catch (err) {\n      console.warn('⚠️ Error loading user stats (suppressed):', err);\n      this.userStatsSignal.set(null);\n    } finally {\n      this.loadingSignal.set(false);\n    }\n    */\n  }\n\n  /**\n   * Get user statistics (backward compatibility - returns Promise)\n   * @deprecated Use loadUserStats() and subscribe to userStats signal instead\n   */\n  async getUserStats(userId: string): Promise<UserStats | null> {\n    await this.loadUserStats(userId);\n    return this.userStats();\n  }\n\n  /**\n   * Load car statistics (updates signals)\n   */\n  async loadCarStats(carId: string): Promise<void> {\n    this.loadingSignal.set(true);\n    this.errorSignal.set(null);\n\n    try {\n      const { data, error } = await this.supabase\n        .from('car_stats')\n        .select('*')\n        .eq('car_id', carId)\n        .maybeSingle();\n\n      if (error) throw error;\n      this.carStatsSignal.set(data as CarStats | null);\n    } catch (err) {\n      // Gracefully handle missing table/data\n      console.warn('⚠️ Error loading car stats (suppressed):', err);\n      this.carStatsSignal.set(null);\n    } finally {\n      this.loadingSignal.set(false);\n    }\n  }\n\n  /**\n   * Get car statistics (backward compatibility - returns Promise)\n   * @deprecated Use loadCarStats() and subscribe to carStats signal instead\n   */\n  async getCarStats(carId: string): Promise<CarStats | null> {\n    await this.loadCarStats(carId);\n    return this.carStats();\n  }\n\n  /**\n   * Check if current user can review a specific booking\n   */\n  async canReviewBooking(bookingId: string): Promise<boolean> {\n    try {\n      const {\n        data: { user },\n        error: authError,\n      } = await this.supabase.auth.getUser();\n\n      if (authError || !user?.id) return false;\n\n      const { data, error } = await this.supabase.rpc('user_can_review', {\n        _booking: bookingId,\n      });\n\n      if (error) throw error;\n      return data as boolean;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Flag a review as inappropriate\n   */\n  async flagReview(reviewId: string, reason: string): Promise<boolean> {\n    try {\n      const {\n        data: { user },\n        error: authError,\n      } = await this.supabase.auth.getUser();\n\n      if (authError) throw authError;\n      if (!user?.id) throw new Error('Usuario no autenticado');\n\n      const { data, error } = await this.supabase.rpc('flag_review', {\n        p_review_id: reviewId,\n        p_user_id: user.id,\n        p_reason: reason,\n      });\n\n      if (error) throw error;\n      return data as boolean;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Get review summary for a user (aggregated stats)\n   */\n  async getReviewSummary(userId: string, asOwner: boolean = true): Promise<ReviewSummary> {\n    try {\n      const reviewType: ReviewType = asOwner ? 'renter_to_owner' : 'owner_to_renter';\n\n      // Use the view which has the computed review_type column\n      const { data: reviews, error } = await this.supabase\n        .from('v_car_reviews')\n        .select('*')\n        .eq('reviewee_id', userId)\n        .eq('review_type', reviewType)\n        .eq('is_visible', true);\n\n      if (error) throw error;\n\n      const reviewList = reviews || [];\n      const totalCount = reviewList.length;\n\n      if (totalCount === 0) {\n        return {\n          total_count: 0,\n          average_rating: 0,\n          rating_distribution: { 5: 0, 4: 0, 3: 0, 2: 0, 1: 0 },\n          category_averages: {\n            cleanliness: 0,\n            communication: 0,\n            accuracy: 0,\n            location: 0,\n            checkin: 0,\n            value: 0,\n          },\n        };\n      }\n\n      // Calculate overall average\n      const totalRating = reviewList.reduce((sum, r) => {\n        const avg =\n          (r.rating_cleanliness +\n            r.rating_communication +\n            r.rating_accuracy +\n            r.rating_location +\n            r.rating_checkin +\n            r.rating_value) /\n          6;\n        return sum + avg;\n      }, 0);\n\n      // Calculate distribution\n      const distribution = { 5: 0, 4: 0, 3: 0, 2: 0, 1: 0 };\n      reviewList.forEach((r) => {\n        const avg = Math.round(\n          (r.rating_cleanliness +\n            r.rating_communication +\n            r.rating_accuracy +\n            r.rating_location +\n            r.rating_checkin +\n            r.rating_value) /\n          6,\n        );\n        distribution[avg as keyof typeof distribution]++;\n      });\n\n      // Calculate category averages\n      const categoryAverages = {\n        cleanliness: reviewList.reduce((sum, r) => sum + r.rating_cleanliness, 0) / totalCount,\n        communication: reviewList.reduce((sum, r) => sum + r.rating_communication, 0) / totalCount,\n        accuracy: reviewList.reduce((sum, r) => sum + r.rating_accuracy, 0) / totalCount,\n        location: reviewList.reduce((sum, r) => sum + r.rating_location, 0) / totalCount,\n        checkin: reviewList.reduce((sum, r) => sum + r.rating_checkin, 0) / totalCount,\n        value: reviewList.reduce((sum, r) => sum + r.rating_value, 0) / totalCount,\n      };\n\n      return {\n        total_count: totalCount,\n        average_rating: totalRating / totalCount,\n        rating_distribution: distribution,\n        category_averages: categoryAverages,\n      };\n    } catch {\n      return {\n        total_count: 0,\n        average_rating: 0,\n        rating_distribution: { 5: 0, 4: 0, 3: 0, 2: 0, 1: 0 },\n        category_averages: {\n          cleanliness: 0,\n          communication: 0,\n          accuracy: 0,\n          location: 0,\n          checkin: 0,\n          value: 0,\n        },\n      };\n    }\n  }\n\n  /**\n   * Get pending reviews for current user (reviews they need to write)\n   */\n  async getPendingReviews(): Promise<\n    Array<{\n      booking_id: string;\n      car_title: string;\n      reviewee_name: string;\n      checkout_date: string;\n      days_remaining: number;\n    }>\n  > {\n    try {\n      const {\n        data: { user },\n        error: authError,\n      } = await this.supabase.auth.getUser();\n\n      if (authError || !user?.id) return [];\n\n      // Get completed bookings without reviews in last 14 days\n      const fourteenDaysAgo = new Date();\n      fourteenDaysAgo.setDate(fourteenDaysAgo.getDate() - 14);\n\n      // As renter\n      const { data: renterBookings, error: renterError } = await this.supabase\n        .from('my_bookings')\n        .select('id, car_title, end_at, status')\n        .eq('status', 'completed')\n        .gte('end_at', fourteenDaysAgo.toISOString());\n\n      if (renterError) throw renterError;\n\n      // As owner\n      const { data: ownerBookings, error: ownerError } = await this.supabase\n        .from('owner_bookings')\n        .select('id, car_title, renter_name, end_at, status')\n        .eq('status', 'completed')\n        .gte('end_at', fourteenDaysAgo.toISOString());\n\n      if (ownerError) throw ownerError;\n\n      // Filter out bookings that already have reviews\n      const allBookings = [...(renterBookings || []), ...(ownerBookings || [])];\n      const pendingReviews = [];\n\n      for (const booking of allBookings) {\n        const { data: existingReview } = await this.supabase\n          .from('reviews')\n          .select('id')\n          .eq('booking_id', booking.id)\n          .eq('reviewer_id', user.id)\n          .maybeSingle();\n\n        if (!existingReview) {\n          const checkoutDate = new Date(booking.end_at);\n          const now = new Date();\n          const daysElapsed = Math.floor(\n            (now.getTime() - checkoutDate.getTime()) / (1000 * 60 * 60 * 24),\n          );\n          const daysRemaining = 14 - daysElapsed;\n\n          if (daysRemaining > 0) {\n            pendingReviews.push({\n              booking_id: booking.id,\n              car_title: booking.car_title || 'Vehículo',\n              reviewee_name: (booking as { renter_name?: string }).renter_name || 'Usuario',\n              checkout_date: booking.end_at,\n              days_remaining: daysRemaining,\n            });\n          }\n        }\n      }\n\n      return pendingReviews;\n    } catch {\n      return [];\n    }\n  }\n\n  /**\n   * Obtiene las reviews recibidas por un usuario como owner (para perfil público)\n   * Uses v_car_reviews view which includes reviewer info and computes review_type\n   */\n  async getReviewsForOwner(ownerId: string): Promise<Review[]> {\n    const { data, error } = await this.supabase\n      .from('v_car_reviews')\n      .select('*')\n      .eq('reviewee_id', ownerId)\n      .eq('is_car_review', true)\n      .order('created_at', { ascending: false });\n\n    if (error) {\n      return [];\n    }\n\n    // View already includes reviewer_name and reviewer_avatar\n    return (data || []).map((review) => ({\n      ...review,\n      reviewer_name: review.reviewer_name || 'Usuario',\n      reviewer_avatar: review.reviewer_avatar || null,\n    })) as Review[];\n  }\n\n  /**\n   * Obtiene las reviews recibidas por un usuario como renter (para perfil público)\n   * Uses v_car_reviews view which includes reviewer info\n   */\n  async getReviewsForRenter(renterId: string): Promise<Review[]> {\n    const { data, error } = await this.supabase\n      .from('v_car_reviews')\n      .select('*')\n      .eq('reviewee_id', renterId)\n      .eq('is_renter_review', true)\n      .order('created_at', { ascending: false });\n\n    if (error) {\n      return [];\n    }\n\n    // View already includes reviewer_name and reviewer_avatar\n    return (data || []).map((review) => ({\n      ...review,\n      reviewer_name: review.reviewer_name || 'Usuario',\n      reviewer_avatar: review.reviewer_avatar || null,\n    })) as Review[];\n  }\n\n  // ============================================\n  // ADMIN MODERATION METHODS\n  // ============================================\n\n  /**\n   * Get all flagged reviews for admin moderation\n   * Requires admin role\n   */\n  async getFlaggedReviews(status?: 'pending' | 'approved' | 'rejected'): Promise<Review[]> {\n    try {\n      const {\n        data: { user },\n        error: authError,\n      } = await this.supabase.auth.getUser();\n\n      if (authError || !user?.id) throw new Error('Usuario no autenticado');\n\n      const { data, error } = await this.supabase.rpc('get_flagged_reviews', {\n        p_admin_id: user.id,\n        p_status: status || null,\n      });\n\n      if (error) throw error;\n\n      return (data || []) as Review[];\n    } catch (error) {\n      console.error('Error fetching flagged reviews:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Moderate a review (approve or reject)\n   * Requires admin role\n   */\n  async moderateReview(\n    reviewId: string,\n    action: 'approved' | 'rejected',\n    notes?: string,\n  ): Promise<{ success: boolean; error?: string }> {\n    try {\n      const {\n        data: { user },\n        error: authError,\n      } = await this.supabase.auth.getUser();\n\n      if (authError || !user?.id) throw new Error('Usuario no autenticado');\n\n      const { error } = await this.supabase.rpc('moderate_review', {\n        p_review_id: reviewId,\n        p_admin_id: user.id,\n        p_action: action,\n        p_notes: notes || null,\n      });\n\n      if (error) throw error;\n\n      return { success: true };\n    } catch (error) {\n      console.error('Error moderating review:', error);\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Error al moderar la review',\n      };\n    }\n  }\n\n  /**\n   * Bulk moderate multiple reviews at once\n   * Requires admin role\n   */\n  async bulkModerateReviews(\n    reviewIds: string[],\n    action: 'approved' | 'rejected',\n    notes?: string,\n  ): Promise<{ success: boolean; updatedCount?: number; error?: string }> {\n    try {\n      const {\n        data: { user },\n        error: authError,\n      } = await this.supabase.auth.getUser();\n\n      if (authError || !user?.id) throw new Error('Usuario no autenticado');\n\n      const { data, error } = await this.supabase.rpc('bulk_moderate_reviews', {\n        p_review_ids: reviewIds,\n        p_admin_id: user.id,\n        p_action: action,\n        p_notes: notes || null,\n      });\n\n      if (error) throw error;\n\n      return {\n        success: true,\n        updatedCount: data?.updated_count || 0,\n      };\n    } catch (error) {\n      console.error('Error bulk moderating reviews:', error);\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Error al moderar las reviews',\n      };\n    }\n  }\n\n  /**\n   * Notifica al dueño del auto sobre una nueva reseña\n   */\n  private async notifyOwnerOfNewReview(\n    reviewId: string,\n    params: CreateReviewParams,\n  ): Promise<void> {\n    try {\n      if (!params.car_id || !params.reviewee_id) return;\n\n      // Obtener el ID del reseñador desde el usuario autenticado\n      const {\n        data: { user },\n      } = await this.supabase.auth.getUser();\n      if (!user?.id) return;\n\n      // Obtener información del auto y del reseñador en paralelo\n      const [car, reviewer] = await Promise.all([\n        this.carsService.getCarById(params.car_id),\n        this.profileService.getProfileById(user.id),\n      ]);\n\n      if (car && reviewer) {\n        const carName = car.title || `${car.brand || ''} ${car.model || ''}`.trim() || 'tu auto';\n        const reviewerName = reviewer.full_name || 'Un usuario';\n\n        // Calcular rating promedio de las 6 categorías\n        const ratings = [\n          params.rating_cleanliness,\n          params.rating_communication,\n          params.rating_accuracy,\n          params.rating_location,\n          params.rating_checkin,\n          params.rating_value,\n        ];\n        const avgRating = Math.round(\n          ratings.reduce((sum, rating) => sum + rating, 0) / ratings.length,\n        );\n\n        const reviewUrl = `/cars/${params.car_id}/reviews`;\n\n        this.carOwnerNotifications.notifyNewReview(reviewerName, avgRating, carName, reviewUrl);\n      }\n    } catch {\n      // Silently fail - notification is optional enhancement\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/core/services/geo/location.service.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`./geocoding.service` import should occur after import of `@core/services/infrastructure/supabase-client.service`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":73,"fix":{"range":[118,349],"text":"import { ProfileService } from '@core/services/auth/profile.service';\nimport { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\nimport { GeocodingResult, GeocodingService } from './geocoding.service';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { isPlatformBrowser } from '@angular/common';\nimport { inject, Injectable, PLATFORM_ID } from '@angular/core';\nimport { GeocodingResult, GeocodingService } from './geocoding.service';\nimport { ProfileService } from '@core/services/auth/profile.service';\nimport { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\n\n/**\n * Location coordinates\n */\nexport interface LocationCoordinates {\n  lat: number;\n  lng: number;\n  accuracy?: number;\n  timestamp?: number;\n}\n\n/**\n * Location choice type\n */\nexport type LocationChoice = 'home' | 'current' | null;\n\n/**\n * Location with metadata\n */\nexport interface LocationData extends LocationCoordinates {\n  source: 'home' | 'gps' | 'address';\n  address?: string;\n  verified?: boolean;\n}\n\n/**\n * Service for managing user location (home location and current GPS)\n */\n@Injectable({\n  providedIn: 'root',\n})\nexport class LocationService {\n  private readonly platformId = inject(PLATFORM_ID);\n  private readonly isBrowser = isPlatformBrowser(this.platformId);\n  private readonly supabase = injectSupabase();\n  private readonly profileService = inject(ProfileService);\n  private readonly geocodingService = inject(GeocodingService);\n\n  /**\n   * Get user location with priority:\n   * 1. Home location from profile (if verified)\n   * 2. Current GPS location\n   * 3. null if both fail\n   * @returns Location coordinates or null\n   */\n  async getUserLocation(): Promise<LocationData | null> {\n    // Try to get home location from profile\n    const homeLocation = await this.getHomeLocation();\n    if (homeLocation) {\n      return homeLocation;\n    }\n\n    // Fallback to current GPS location\n    const gpsLocation = await this.getCurrentPosition();\n    if (gpsLocation) {\n      return {\n        ...gpsLocation,\n        source: 'gps',\n      };\n    }\n\n    return null;\n  }\n\n  /**\n   * Get user's saved home location from profile\n   * @returns Home location or null if not set or user not authenticated\n   */\n  async getHomeLocation(): Promise<LocationData | null> {\n    try {\n      const profile = await this.profileService.getCurrentProfile();\n\n      if (\n        profile &&\n        profile.home_latitude !== null &&\n        profile.home_latitude !== undefined &&\n        profile.home_longitude !== null &&\n        profile.home_longitude !== undefined\n      ) {\n        return {\n          lat: profile.home_latitude,\n          lng: profile.home_longitude,\n          source: 'home',\n          address: profile.address_line1 ?? undefined,\n          verified: profile.location_verified_at !== null,\n        };\n      }\n\n      return null;\n    } catch (error) {\n      // Silently handle authentication errors - user is not logged in\n      if (error instanceof Error && error.message.includes('Usuario no autenticado')) {\n        return null;\n      }\n      // Log other errors but don't throw\n      console.error('Error getting home location:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Get current GPS position from browser or native platform\n   * Uses Capacitor Geolocation on native platforms for better accuracy\n   * @returns Current position or null if geolocation not available/denied\n   */\n  async getCurrentPosition(): Promise<LocationCoordinates | null> {\n    // Always use browser geolocation API (works on both web and native via WebView)\n    return new Promise((resolve) => {\n      if (!this.isBrowser || !navigator.geolocation) {\n        console.warn('Geolocation is not supported by this browser');\n        resolve(null);\n        return;\n      }\n\n      navigator.geolocation.getCurrentPosition(\n        (position) => {\n          resolve({\n            lat: position.coords.latitude,\n            lng: position.coords.longitude,\n            accuracy: position.coords.accuracy,\n            timestamp: position.timestamp,\n          });\n        },\n        (error: GeolocationPositionError) => {\n          console.warn('Error getting current position:', error.message);\n          resolve(null);\n        },\n        {\n          enableHighAccuracy: true,\n          timeout: 10000, // 10 seconds\n          maximumAge: 300000, // 5 minutes cache\n        },\n      );\n    });\n  }\n\n  /**\n   * Watch user's position for real-time updates\n   * @param callback Function to call with new location\n   * @returns Watch ID to clear later\n   */\n  watchPosition(callback: (location: LocationCoordinates) => void): number | null {\n    if (!this.isBrowser || !navigator.geolocation) {\n      console.warn('Geolocation is not supported by this browser');\n      return null;\n    }\n\n    return navigator.geolocation.watchPosition(\n      (position) => {\n        callback({\n          lat: position.coords.latitude,\n          lng: position.coords.longitude,\n          accuracy: position.coords.accuracy,\n          timestamp: position.timestamp,\n        });\n      },\n      (error) => {\n        console.warn('Error watching position:', error.message);\n      },\n      {\n        enableHighAccuracy: true,\n        timeout: 10000,\n        maximumAge: 0, // No cache for real-time\n      },\n    );\n  }\n\n  /**\n   * Clear position watch\n   * @param watchId ID returned by watchPosition\n   */\n  clearWatch(watchId: number | null): void {\n    if (this.isBrowser && navigator.geolocation && watchId !== null) {\n      navigator.geolocation.clearWatch(watchId);\n    }\n  }\n\n  /**\n   * Save home location to user profile\n   * @param lat Latitude\n   * @param lng Longitude\n   * @param address Optional address string for display\n   */\n  async saveHomeLocation(lat: number, lng: number, address?: string): Promise<void> {\n    const {\n      data: { user },\n    } = await this.supabase.auth.getUser();\n\n    if (!user) {\n      throw new Error('Usuario no autenticado');\n    }\n\n    // Update profile with home location\n    const updates: Record<string, unknown> = {\n      home_latitude: lat,\n      home_longitude: lng,\n      location_verified_at: new Date().toISOString(),\n    };\n\n    // Optionally update address if provided\n    if (address) {\n      updates['address_line1'] = address;\n    }\n\n    await this.supabase.from('profiles').update(updates).eq('id', user.id);\n  }\n\n  /**\n   * Clear home location from profile\n   */\n  async clearHomeLocation(): Promise<void> {\n    const {\n      data: { user },\n    } = await this.supabase.auth.getUser();\n\n    if (!user) {\n      throw new Error('Usuario no autenticado');\n    }\n\n    await this.supabase\n      .from('profiles')\n      .update({\n        home_latitude: null,\n        home_longitude: null,\n        location_verified_at: null,\n      })\n      .eq('id', user.id);\n  }\n\n  /**\n   * Geocode an address and save as home location\n   * @param address Address string to geocode\n   * @param countryCode Optional country code (default 'AR')\n   * @returns Geocoding result with coordinates\n   */\n  async geocodeAndSaveHomeLocation(\n    address: string,\n    countryCode: string = 'AR',\n  ): Promise<GeocodingResult> {\n    const result = await this.geocodingService.geocodeAddress(address, countryCode);\n\n    if (result) {\n      await this.saveHomeLocation(result.latitude, result.longitude, result.fullAddress);\n    }\n\n    return result;\n  }\n\n  /**\n   * Request location permission from browser\n   * @returns True if permission granted, false otherwise\n   */\n  async requestLocationPermission(): Promise<boolean> {\n    try {\n      const position = await this.getCurrentPosition();\n      return position !== null;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Check if user has saved home location\n   * @returns True if home location is set\n   */\n  async hasHomeLocation(): Promise<boolean> {\n    const homeLocation = await this.getHomeLocation();\n    return homeLocation !== null;\n  }\n\n  /**\n   * Check if browser supports geolocation\n   * @returns True if geolocation API is available\n   */\n  isGeolocationSupported(): boolean {\n    return 'geolocation' in navigator;\n  }\n\n  /**\n   * Get location by choice (home or current GPS)\n   * Used when user explicitly selects location source\n   * @param choice Location choice ('home' or 'current')\n   * @returns Location data or null\n   */\n  async getLocationByChoice(choice: LocationChoice): Promise<LocationData | null> {\n    if (choice === 'home') {\n      return await this.getHomeLocation();\n    } else if (choice === 'current') {\n      const gpsLocation = await this.getCurrentPosition();\n      if (gpsLocation) {\n        // Optionally reverse geocode to get address\n        try {\n          const result = await this.geocodingService.reverseGeocode(\n            gpsLocation.lat,\n            gpsLocation.lng,\n          );\n          return {\n            ...gpsLocation,\n            source: 'gps',\n            address: result.fullAddress,\n          };\n        } catch {\n          return {\n            ...gpsLocation,\n            source: 'gps',\n          };\n        }\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Validate coordinates are within valid ranges\n   * @param lat Latitude\n   * @param lng Longitude\n   * @returns True if coordinates are valid\n   */\n  validateCoordinates(lat: number, lng: number): boolean {\n    return lat >= -90 && lat <= 90 && lng >= -180 && lng <= 180;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/core/services/infrastructure/analytics.service.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`@core/services/auth/auth.service` import should occur before import of `../../../environments/environment`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":64,"fix":{"range":[52,181],"text":"import { AuthService } from '@core/services/auth/auth.service';\nimport { environment } from '../../../environments/environment';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { Injectable, inject } from '@angular/core';\nimport { environment } from '../../../environments/environment';\nimport { AuthService } from '@core/services/auth/auth.service';\nimport { LoggerService } from './logger.service';\nimport { injectSupabase } from './supabase-client.service';\n\n/**\n * Tipos de eventos de conversión que trackeamos\n */\nexport type ConversionEventType =\n  | 'search_performed'\n  | 'car_viewed'\n  | 'checkout_started'\n  | 'checkout_completed'\n  | 'sign_up'\n  | 'login'\n  | 'deposit_page_viewed'\n  | 'deposit_mercadopago_preference_created'\n  | 'deposit_error'\n  | 'deposit_cancelled'\n  | string; // Allow any string for flexibility\n\nexport interface ConversionEventData {\n  // Common fields\n  car_id?: string;\n  user_id?: string | null;\n\n  // Date picker specific\n  preset_type?: 'weekend' | '1week' | '2weeks' | '1month';\n  days_count?: number;\n  total_price?: number;\n  is_available?: boolean;\n  from_date?: string;\n  to_date?: string;\n  source?: string;\n\n  // CTA specific\n  has_dates?: boolean;\n  express_mode?: boolean;\n\n  // Booking specific\n  payment_method?: string;\n  total_amount?: number;\n\n  // Social proof specific\n  indicator_type?: 'viewers' | 'bookings' | 'availability' | 'badge';\n  badge_type?: 'popular' | 'high_demand' | 'superhost';\n\n  // Wallet specific\n  deposit_amount?: number;\n  deposit_type?: 'protected_credit' | 'withdrawable';\n  deposit_provider?: 'mercadopago' | 'stripe' | 'bank_transfer';\n  protected_credit_balance?: number;\n  protected_credit_progress?: number;\n  milestone_percentage?: number;\n  transaction_filter?: string;\n  cta_type?: string;\n  error_message?: string;\n  failure_reason?: string;\n\n  // Price Transparency specific\n  context?: string;\n  timestamp?: string;\n\n  // Additional metadata\n  [key: string]: unknown;\n}\n\n// Declaración global para gtag (Google Analytics)\ndeclare global {\n  interface Window {\n    gtag?: (command: string, eventName: string | Date, params?: Record<string, unknown>) => void;\n    dataLayer?: unknown[];\n  }\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class AnalyticsService {\n  private readonly logger = inject(LoggerService);\n  private readonly supabase = injectSupabase();\n  private readonly authService = inject(AuthService);\n  private readonly isEnabled = environment.enableAnalytics;\n  private readonly ga4MeasurementId = environment.googleAnalyticsMeasurementId;\n\n  /**\n   * Track de evento principal - envía a GA4 y Supabase\n   * P0-033 FIX: Only track if user has accepted cookies\n   */\n  trackEvent(eventType: ConversionEventType, data: ConversionEventData = {}): void {\n    if (!this.isEnabled) return;\n\n    // P0-033 FIX: Check for cookie consent before tracking\n    if (!this.hasConsentForTracking()) {\n      this.logger.debug('[Analytics] Tracking blocked - no cookie consent');\n      return;\n    }\n\n    // Track en GA4\n    this.trackGA4Event(eventType, data);\n\n    // Track en Supabase (async, no bloqueante)\n    void this.trackSupabaseEvent(eventType, data);\n  }\n\n  /**\n   * P0-033 FIX: Check if user has given consent for analytics tracking\n   * Reads from localStorage['cookies_consent']\n   */\n  private hasConsentForTracking(): boolean {\n    if (typeof window === 'undefined' || typeof localStorage === 'undefined') {\n      return false; // No consent in SSR or environments without localStorage\n    }\n\n    try {\n      const consent = localStorage.getItem('cookies_consent');\n      if (!consent) {\n        return false; // No consent given yet\n      }\n\n      const consentData = JSON.parse(consent);\n      // Check if analytics cookies are accepted\n      return consentData.analytics === true || consentData.all === true;\n    } catch {\n      // If parsing fails, assume no consent\n      return false;\n    }\n  }\n\n  /**\n   * Track de evento en Google Analytics 4\n   */\n  private trackGA4Event(eventType: ConversionEventType, data: ConversionEventData): void {\n    if (!this.ga4MeasurementId || typeof window === 'undefined' || !window.gtag) {\n      return;\n    }\n\n    try {\n      // Mapear nuestros eventos a eventos GA4 estándar o custom\n      const ga4EventName = this.mapToGA4EventName(eventType);\n\n      // Preparar parámetros para GA4\n      const params: Record<string, unknown> = {\n        ...data,\n        // Agregar metadata adicional\n        timestamp: new Date().toISOString(),\n        user_authenticated: this.authService.isAuthenticated(),\n      };\n\n      // Enviar a GA4\n      window.gtag!('event', ga4EventName, params);\n    } catch (error) {\n      console.error('Error tracking GA4 event:', error);\n    }\n  }\n\n  /**\n   * Track de evento en Supabase\n   */\n  private async trackSupabaseEvent(\n    eventType: ConversionEventType,\n    data: ConversionEventData,\n  ): Promise<void> {\n    try {\n      const userId = data.user_id ?? (await this.getCurrentUserId());\n\n      const { error } = await this.supabase.from('conversion_events').insert({\n        event_type: eventType,\n        car_id: data.car_id ?? null,\n        user_id: userId,\n        event_data: data,\n        created_at: new Date().toISOString(),\n      });\n\n      if (error) {\n        console.error('Error tracking Supabase event:', error);\n      }\n    } catch (error) {\n      console.error('Error in trackSupabaseEvent:', error);\n    }\n  }\n\n  /**\n   * Mapea nuestros eventos custom a eventos GA4 estándar o custom\n   */\n  private mapToGA4EventName(eventType: ConversionEventType): string {\n    const mapping: Record<ConversionEventType, string> = {\n      // Date Picker\n      date_preset_clicked: 'select_content',\n      date_range_selected: 'begin_checkout',\n      date_availability_checked: 'view_item',\n      date_unavailable_error: 'exception',\n      date_autosuggest_applied: 'select_content',\n      alternative_dates_suggested: 'select_content',\n      alternative_date_applied: 'select_content',\n\n      // Social Proof\n      social_proof_viewed: 'view_promotion',\n      urgency_indicator_viewed: 'view_promotion',\n\n      // CTA\n      cta_clicked: 'add_to_cart',\n      cta_hovered: 'select_promotion',\n\n      // Booking\n      booking_initiated: 'begin_checkout',\n      booking_completed: 'purchase',\n      booking_failed: 'exception',\n\n      // Owner\n      owner_profile_viewed: 'view_item_list',\n      owner_contact_clicked: 'generate_lead',\n\n      // Reviews\n      review_viewed: 'view_item',\n      review_section_clicked: 'select_content',\n\n      // Marketplace\n      filters_opened: 'view_search_results',\n      car_details_clicked: 'select_item',\n\n      // Wallet\n      wallet_page_viewed: 'page_view',\n      wallet_onboarding_banner_viewed: 'view_promotion',\n      wallet_onboarding_cta_clicked: 'select_promotion',\n      wallet_deposit_modal_opened: 'begin_checkout',\n      wallet_deposit_initiated: 'add_payment_info',\n      wallet_deposit_completed: 'purchase',\n      wallet_deposit_failed: 'exception',\n      wallet_protected_credit_milestone: 'level_up',\n      wallet_cta_clicked: 'select_content',\n      wallet_benefits_section_expanded: 'view_item',\n      wallet_transaction_filter_applied: 'search',\n      wallet_retry_deposit_clicked: 'refund',\n\n      // Onboarding\n      onboarding_modal_shown: 'view_promotion',\n      onboarding_goal_selected: 'select_content',\n      onboarding_step_clicked: 'select_content',\n      onboarding_step_completed: 'tutorial_complete',\n      onboarding_modal_dismissed: 'refund',\n\n      // Price Transparency\n      price_transparency_modal_viewed: 'view_promotion',\n    };\n\n    return mapping[eventType] || eventType;\n  }\n\n  /**\n   * Obtiene el ID del usuario actual\n   */\n  private async getCurrentUserId(): Promise<string | null> {\n    try {\n      const { data } = await this.supabase.auth.getUser();\n      return data.user?.id ?? null;\n    } catch {\n      return null;\n    }\n  }\n\n  /**\n   * Track de pageview (para Single Page Applications)\n   */\n  trackPageView(path: string, title?: string): void {\n    if (!this.isEnabled || !this.ga4MeasurementId || !window.gtag) return;\n\n    try {\n      window.gtag('event', 'page_view', {\n        page_path: path,\n        page_title: title,\n      });\n    } catch (error) {\n      console.error('Error tracking pageview:', error);\n    }\n  }\n\n  /**\n   * Set user properties en GA4\n   */\n  setUserProperties(properties: Record<string, unknown>): void {\n    if (!this.isEnabled || !this.ga4MeasurementId || !window.gtag) return;\n\n    try {\n      window.gtag('set', 'user_properties', properties);\n    } catch (error) {\n      console.error('Error setting user properties:', error);\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/core/services/infrastructure/logger.service.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`@core/services/admin/debug.service` import should occur before import of `../../../environments/environment`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":67,"fix":{"range":[52,184],"text":"import { DebugService } from '@core/services/admin/debug.service';\nimport { environment } from '../../../environments/environment';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { Injectable, inject } from '@angular/core';\nimport { environment } from '../../../environments/environment';\nimport { DebugService } from '@core/services/admin/debug.service';\n\n/**\n * Sentry module type definition for lazy loading\n * We only import the types, not the actual module\n */\ntype SentryModule = typeof import('@sentry/angular');\n\n/**\n * Centralized LoggerService for Angular Frontend\n *\n * Part of the centralized logging infrastructure (Issue #120).\n *\n * Features:\n * - Structured logging with LAZY-LOADED Sentry integration (saves ~238KB)\n * - Level-based filtering (debug, info, warn, error, critical)\n * - Automatic sensitive data sanitization\n * - Trace ID support for request correlation\n * - Performance and action logging\n * - [AR] prefix for ADB filtering on Android devices\n * - Integration with DebugService for in-app debug panel\n *\n * Usage:\n *   constructor(private logger: LoggerService) {}\n *\n *   // Basic logging\n *\n *   // With ChildLogger\n *   private logger = inject(LoggerService).createChildLogger('MyService');\n *   this.logger.info('Action completed'); // Auto-prefixed with [MyService]\n *\n * Log Format (Console):\n *   [AR][14:30:45.123][INFO][PaymentService] Processing payment { amount: 1000 }\n *\n * ADB Filtering:\n *   adb logcat | grep \"\\[AR\\]\"\n *\n * Production:\n * - DEBUG/INFO filtered out, only WARN/ERROR/CRITICAL sent to Sentry\n * - Sensitive data automatically redacted\n * - Trace IDs included in Sentry context\n */\n@Injectable({\n  providedIn: 'root',\n})\nexport class LoggerService {\n  private readonly logger = globalThis.console;\n  private readonly isDevelopment = !environment.production;\n  private traceId?: string;\n  private debugService?: DebugService;\n\n  /** Cached Sentry module (lazy-loaded) */\n  private sentryModule: SentryModule | null = null;\n  private sentryLoadPromise: Promise<SentryModule> | null = null;\n\n  /**\n   * Set trace ID for request correlation\n   */\n  setTraceId(traceId: string): void {\n    this.traceId = traceId;\n  }\n\n  /**\n   * Get current trace ID\n   */\n  getTraceId(): string | undefined {\n    return this.traceId;\n  }\n\n  /**\n   * Generate a trace ID for request correlation\n   * Format: req-{timestamp}-{random}\n   */\n  generateTraceId(): string {\n    const timestamp = Date.now().toString(36);\n    const random = Math.random().toString(36).substring(2, 9);\n    const traceId = `req-${timestamp}-${random}`;\n    this.setTraceId(traceId);\n    return traceId;\n  }\n\n  /**\n   * Get DebugService lazily to avoid circular dependency\n   */\n  private getDebugService(): DebugService {\n    if (!this.debugService) {\n      this.debugService = inject(DebugService);\n    }\n    return this.debugService;\n  }\n\n  /**\n   * Format timestamp for logging (HH:mm:ss.SSS)\n   */\n  private formatTimestamp(): string {\n    return new Date().toISOString().substring(11, 23);\n  }\n\n  /**\n   * Build log prefix with [AR] tag for ADB filtering\n   * Format: [AR][HH:mm:ss.SSS][LEVEL][Context]\n   */\n  private buildLogPrefix(level: string, context?: string): string {\n    const timestamp = this.formatTimestamp();\n    const parts: string[] = ['[AR]', `[${timestamp}]`, level];\n\n    if (this.traceId) {\n      parts.push(`[${this.traceId.substring(0, 8)}]`);\n    }\n\n    if (context) {\n      parts.push(`[${context}]`);\n    }\n\n    return parts.join('');\n  }\n\n  private looksLikeContext(value: string): boolean {\n    if (!/^[A-Za-z0-9]+$/.test(value)) return false;\n    return /[A-Z]/.test(value) && /[a-z]/.test(value);\n  }\n\n  private resolveLogArgs(\n    message: string,\n    args: unknown[],\n  ): { context?: string; data?: unknown; extra: unknown[] } {\n    if (args.length === 0) {\n      return { extra: [] };\n    }\n\n    const [first, ...rest] = args;\n\n    if (typeof first === 'string') {\n      if (rest.length >= 1) {\n        return { context: first, data: rest[0], extra: rest.slice(1) };\n      }\n\n      const messageLooksLikeData = message.trim().endsWith(':');\n      if (!messageLooksLikeData && this.looksLikeContext(first)) {\n        return { context: first, data: undefined, extra: [] };\n      }\n    }\n\n    return { context: undefined, data: first, extra: rest };\n  }\n\n  private mergeLogData(data: unknown, extra: unknown[]): unknown {\n    if (!extra.length) return data;\n    const merged: unknown[] = [];\n    if (data !== undefined) merged.push(data);\n    merged.push(...extra);\n    return merged.length === 1 ? merged[0] : merged;\n  }\n\n  private sanitizeLogArgs(data: unknown, extra: unknown[]): unknown[] {\n    const safeArgs: unknown[] = [];\n    if (data !== undefined) safeArgs.push(this.sanitizeData(data));\n    for (const item of extra) {\n      if (item !== undefined) safeArgs.push(this.sanitizeData(item));\n    }\n    return safeArgs;\n  }\n\n  /**\n   * Log to DebugService for in-app panel\n   */\n  private logToDebugService(\n    level: 'DEBUG' | 'INFO' | 'WARN' | 'ERROR' | 'CRITICAL',\n    context: string,\n    message: string,\n    data?: unknown\n  ): void {\n    try {\n      const debug = this.getDebugService();\n      if (debug.isEnabled()) {\n        debug.log(level, context || 'App', message, this.sanitizeData(data));\n      }\n    } catch {\n      // Ignore if DebugService not available\n    }\n  }\n\n  /**\n   * Debug level: Detailed diagnostic information\n   * Only logged in development mode\n   */\n  debug(message: string, ...args: unknown[]): void {\n    const { context, data, extra } = this.resolveLogArgs(message, args);\n    const mergedData = this.mergeLogData(data, extra);\n    // Always log to DebugService if enabled\n    this.logToDebugService('DEBUG', context || 'App', message, mergedData);\n\n    if (this.isDevelopment) {\n      // In development, log to console with safe data only\n      const safeArgs = this.sanitizeLogArgs(data, extra);\n      const prefix = this.buildLogPrefix('[DEBUG]', context);\n      this.logger.debug(`${prefix} ${message}`, ...safeArgs);\n    }\n  }\n\n  /**\n   * Info level: Informational messages\n   * Production: Filtered (not logged)\n   * Development: Logged to console\n   */\n  info(message: string, ...args: unknown[]): void {\n    const { context, data, extra } = this.resolveLogArgs(message, args);\n    const mergedData = this.mergeLogData(data, extra);\n    // Always log to DebugService if enabled\n    this.logToDebugService('INFO', context || 'App', message, mergedData);\n\n    if (this.isDevelopment) {\n      const safeArgs = this.sanitizeLogArgs(data, extra);\n      const prefix = this.buildLogPrefix('[INFO]', context);\n      this.logger.debug(`${prefix} ${message}`, ...safeArgs);\n    }\n    // Production: INFO is too noisy, don't send to Sentry\n  }\n\n  /**\n   * Warn level: Warning messages\n   * Production: Sent to Sentry\n   * Development: Logged to console\n   */\n  warn(message: string, ...args: unknown[]): void {\n    const { context, data, extra } = this.resolveLogArgs(message, args);\n    const mergedData = this.mergeLogData(data, extra);\n    // Always log to DebugService if enabled\n    this.logToDebugService('WARN', context || 'App', message, mergedData);\n\n    const prefix = this.buildLogPrefix('[WARN]', context);\n    if (this.isDevelopment) {\n      const safeArgs = this.sanitizeLogArgs(data, extra);\n      this.logger.warn(`${prefix} ${message}`, ...safeArgs);\n    } else {\n      this.sendToSentry('warning', message, mergedData);\n    }\n  }\n\n  /**\n   * Error level: Error conditions\n   * ALWAYS sent to Sentry with full stack trace\n   * Development: Also logged to console\n   */\n  error(message: string, ...args: unknown[]): void {\n    const { context, data, extra } = this.resolveLogArgs(message, args);\n    const mergedData = this.mergeLogData(data, extra);\n    // Always log to DebugService if enabled\n    this.logToDebugService('ERROR', context || 'App', message, mergedData);\n\n    const prefix = this.buildLogPrefix('[ERROR]', context);\n    if (this.isDevelopment) {\n      const safeArgs = this.sanitizeLogArgs(data, extra);\n      this.logger.error(`${prefix} ${message}`, ...safeArgs);\n    }\n\n    // Always report errors to Sentry\n    if (mergedData instanceof Error) {\n      this.sendToSentry('error', message, mergedData);\n    } else if (mergedData !== undefined) {\n      this.sendToSentry('error', message, new Error(String(mergedData)));\n    } else {\n      this.sendToSentry('error', message, new Error(message));\n    }\n  }\n\n  /**\n   * Critical level: Critical errors that may cause downtime\n   * ALWAYS sent to Sentry with highest priority\n   */\n  critical(message: string, ...args: unknown[]): void {\n    const { context, data, extra } = this.resolveLogArgs(message, args);\n    const mergedData = this.mergeLogData(data, extra);\n    // Always log to DebugService if enabled\n    this.logToDebugService('CRITICAL', context || 'App', message, mergedData);\n\n    const prefix = this.buildLogPrefix('[CRITICAL]', context);\n    if (this.isDevelopment) {\n      const safeArgs = this.sanitizeLogArgs(data, extra);\n      this.logger.error(`${prefix} ${message}`, ...safeArgs);\n    }\n    this.sendToSentry('fatal', message, mergedData);\n  }\n\n  /**\n   * Log user action for analytics\n   * Useful for tracking user behavior\n   */\n  logAction(action: string, metadata?: Record<string, unknown>): void {\n    const safeMeta = this.sanitizeData(metadata);\n    if (this.isDevelopment) {\n      this.logger.debug(`[ACTION] ${action}`, safeMeta);\n    } else {\n      this.sendToSentry('info', action, safeMeta);\n    }\n  }\n\n  /**\n   * Log performance metrics\n   * Useful for identifying slow operations\n   */\n  logPerformance(operation: string, durationMs: number, metadata?: Record<string, unknown>): void {\n    const level = durationMs > 1000 ? 'warning' : 'info';\n    const message = `${operation} took ${durationMs}ms`;\n    const safeMeta = this.sanitizeData(metadata);\n\n    if (this.isDevelopment) {\n      this.logger.debug(`[PERF] ${message}`, safeMeta);\n    } else {\n      this.sendToSentry(level, message, safeMeta);\n    }\n  }\n\n  /**\n   * Remove sensitive data from logs (tokens, passwords, etc)\n   * @private\n   */\n  private sanitizeData(data: unknown): unknown {\n    if (data === null || data === undefined) return undefined;\n\n    if (typeof data === 'string') {\n      // Don't log strings that look like tokens\n      if (data.includes('token') || data.includes('key') || data.includes('secret')) {\n        return '[REDACTED]';\n      }\n      return data;\n    }\n\n    if (Array.isArray(data)) {\n      return data.map((item) => this.sanitizeData(item));\n    }\n\n    if (typeof data === 'object' && data !== null) {\n      const obj = { ...data } as Record<string, unknown>;\n\n      // Redact sensitive fields\n      const sensitiveFields = [\n        'password',\n        'token',\n        'access_token',\n        'refresh_token',\n        'mp_access_token_encrypted',\n        'mp_refresh_token_encrypted',\n        'mercadopago_token',\n        'mercadopago_access_token',\n        'apiKey',\n        'api_key',\n        'secretKey',\n        'secret_key',\n        'authorization',\n        'creditCard',\n        'credit_card',\n        'cvv',\n        'ssn',\n        'encryptionKey',\n        'encryption_key',\n      ];\n\n      for (const field of sensitiveFields) {\n        if (field in obj) {\n          obj[field] = '[REDACTED]';\n        }\n      }\n\n      // Recursively sanitize nested objects\n      for (const [key, value] of Object.entries(obj)) {\n        if (typeof value === 'object' && value !== null) {\n          obj[key] = this.sanitizeData(value);\n        }\n      }\n\n      return obj;\n    }\n\n    return data;\n  }\n\n  /**\n   * Create a child logger with fixed context\n   * Useful for services that always log with the same context\n   *\n   * Usage:\n   *   private logger = inject(LoggerService).createChildLogger('MyService');\n   *   this.logger.info('Action completed'); // [INFO] [MyService] Action completed\n   */\n  createChildLogger(context: string): ChildLogger {\n    return new ChildLogger(this, context);\n  }\n\n  /**\n   * Lazy-load Sentry module (saves ~238KB from initial bundle)\n   * Caches the module for subsequent calls\n   * @private\n   */\n  private async getSentry(): Promise<SentryModule | null> {\n    // Return cached module if available\n    if (this.sentryModule) {\n      return this.sentryModule;\n    }\n\n    // Only load Sentry if DSN is configured\n    if (!environment.sentryDsn) {\n      return null;\n    }\n\n    // Reuse existing load promise to avoid duplicate imports\n    if (!this.sentryLoadPromise) {\n      this.sentryLoadPromise = (import('@sentry/angular')\n        .then((module) => {\n          this.sentryModule = module;\n          return module;\n        })\n        .catch((err) => {\n          console.error('Failed to load Sentry:', err);\n          this.sentryLoadPromise = null;\n          return null;\n        }) as unknown) as Promise<SentryModule>;\n    }\n\n    return this.sentryLoadPromise;\n  }\n\n  /**\n   * Send log to Sentry (production)\n   * Uses lazy loading to avoid including Sentry in the initial bundle\n   * @private\n   */\n  private sendToSentry(\n    level: 'debug' | 'info' | 'warning' | 'error' | 'fatal',\n    message: string,\n    data?: unknown,\n  ): void {\n    // Only send to Sentry if DSN is configured\n    if (!environment.sentryDsn) {\n      return;\n    }\n\n    // Use void to indicate we're intentionally not awaiting this async operation\n    void this.sendToSentryAsync(level, message, data);\n  }\n\n  /**\n   * Async implementation of sendToSentry\n   * @private\n   */\n  private async sendToSentryAsync(\n    level: 'debug' | 'info' | 'warning' | 'error' | 'fatal',\n    message: string,\n    data?: unknown,\n  ): Promise<void> {\n    try {\n      const Sentry = await this.getSentry();\n      if (!Sentry) return;\n\n      const captureContext = {\n        level: level as 'debug' | 'info' | 'warning' | 'error' | 'fatal',\n        extra: { data: this.sanitizeData(data) },\n      };\n\n      if (level === 'error' || level === 'fatal') {\n        if (data instanceof Error) {\n          Sentry.captureException(data, captureContext);\n        } else {\n          Sentry.captureException(new Error(message), captureContext);\n        }\n      } else {\n        Sentry.captureMessage(message, captureContext);\n      }\n    } catch (e: unknown) {\n      // Fallback if Sentry fails\n      console.error('Failed to send to Sentry:', e);\n    }\n  }\n}\n\n/**\n * Child logger with fixed context\n *\n * Automatically prefixes all log messages with the context name.\n * Useful for services that always log from the same context.\n *\n * Usage:\n * ```typescript\n * export class MyService {\n *   private logger = inject(LoggerService).createChildLogger('MyService');\n *\n *   doSomething() {\n *     this.logger.info('Action performed', { actionId: 123 });\n *     // Output: [INFO] [MyService] Action performed { actionId: 123 }\n *   }\n *\n *   handleError(error: Error) {\n *     this.logger.error('Operation failed', error);\n *     // Output: [ERROR] [MyService] Operation failed Error: ...\n *   }\n * }\n * ```\n */\nexport class ChildLogger {\n  constructor(\n    private parent: LoggerService,\n    private context: string,\n  ) {}\n\n  debug(message: string, ...args: unknown[]): void {\n    this.parent.debug(message, this.context, ...args);\n  }\n\n  info(message: string, ...args: unknown[]): void {\n    this.parent.info(message, this.context, ...args);\n  }\n\n  warn(message: string, ...args: unknown[]): void {\n    this.parent.warn(message, this.context, ...args);\n  }\n\n  error(message: string, ...args: unknown[]): void {\n    this.parent.error(message, this.context, ...args);\n  }\n\n  critical(message: string, ...args: unknown[]): void {\n    this.parent.critical(message, this.context, ...args);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/core/services/infrastructure/offline-manager.service.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`./logger.service` import should occur after import of `@angular/core/rxjs-interop`","line":1,"column":1,"nodeType":"ImportDeclaration","endLine":1,"endColumn":50,"fix":{"range":[0,244],"text":"import { Injectable, signal, inject, DestroyRef } from '@angular/core';\nimport { fromEvent, merge, map, startWith } from 'rxjs';\nimport { takeUntilDestroyed } from '@angular/core/rxjs-interop';\nimport { LoggerService } from './logger.service';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { LoggerService } from './logger.service';\nimport { Injectable, signal, inject, DestroyRef } from '@angular/core';\nimport { fromEvent, merge, map, startWith } from 'rxjs';\nimport { takeUntilDestroyed } from '@angular/core/rxjs-interop';\n\n/**\n * P1-024 FIX: Offline Manager Service\n *\n * Manages offline/online state and queued mutations\n *\n * Features:\n * - Detects online/offline status\n * - Shows offline banner\n * - Queues mutations for retry when online\n * - Auto-retries failed requests\n */\n\nexport interface QueuedMutation {\n  id: string;\n  type: string;\n  payload: unknown;\n  timestamp: number;\n  retryCount: number;\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class OfflineManagerService {\n  private readonly logger = inject(LoggerService);\n  private readonly isOnlineSignal = signal(true);\n  private readonly mutationQueue = signal<QueuedMutation[]>([]);\n  private readonly destroyRef = inject(DestroyRef);\n\n  readonly isOnline = this.isOnlineSignal.asReadonly();\n  readonly queuedMutations = this.mutationQueue.asReadonly();\n\n  constructor() {\n    this.initializeOnlineDetection();\n  }\n\n  /**\n   * Initialize online/offline detection\n   */\n  private initializeOnlineDetection(): void {\n    if (typeof window === 'undefined') return;\n\n    // Listen to online/offline events\n    const online$ = fromEvent(window, 'online').pipe(map(() => true));\n    const offline$ = fromEvent(window, 'offline').pipe(map(() => false));\n\n    merge(online$, offline$)\n      .pipe(\n        startWith(navigator.onLine),\n        takeUntilDestroyed(this.destroyRef)\n      )\n      .subscribe((isOnline) => {\n        this.isOnlineSignal.set(isOnline);\n\n        if (isOnline) {\n          this.processQueue();\n        }\n      });\n  }\n\n  /**\n   * Queue a mutation for later retry\n   */\n  queueMutation(type: string, payload: unknown): string {\n    const mutation: QueuedMutation = {\n      id: this.generateId(),\n      type,\n      payload,\n      timestamp: Date.now(),\n      retryCount: 0,\n    };\n\n    this.mutationQueue.set([...this.mutationQueue(), mutation]);\n\n    return mutation.id;\n  }\n\n  /**\n   * Remove mutation from queue\n   */\n  removeMutation(id: string): void {\n    this.mutationQueue.set(this.mutationQueue().filter((m) => m.id !== id));\n  }\n\n  /**\n   * Process queued mutations when online\n   */\n  private async processQueue(): Promise<void> {\n    const queue = this.mutationQueue();\n\n    if (queue.length === 0) return;\n\n    this.logger.debug(`[Offline] Processing ${queue.length} queued mutations`);\n\n    for (const mutation of queue) {\n      try {\n        await this.retryMutation(mutation);\n        this.removeMutation(mutation.id);\n      } catch (error) {\n        console.error(`[Offline] Failed to retry mutation ${mutation.id}:`, error);\n\n        // Increment retry count\n        const updated = this.mutationQueue().map((m) =>\n          m.id === mutation.id ? { ...m, retryCount: m.retryCount + 1 } : m,\n        );\n        this.mutationQueue.set(updated);\n\n        // Remove if too many retries\n        if (mutation.retryCount >= 3) {\n          console.error(`[Offline] Giving up on mutation ${mutation.id} after 3 retries`);\n          this.removeMutation(mutation.id);\n        }\n      }\n    }\n  }\n\n  /**\n   * Retry a specific mutation (override in app)\n   */\n  private async retryMutation(mutation: QueuedMutation): Promise<void> {\n    this.logger.debug(`[Offline] Retrying mutation ${mutation.type}`);\n\n    // This should be overridden by app-specific logic\n    // For now, just log\n    await new Promise((resolve) => setTimeout(resolve, 100));\n  }\n\n  /**\n   * Generate unique ID\n   */\n  private generateId(): string {\n    return `mutation-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  /**\n   * Check if offline\n   */\n  isOffline(): boolean {\n    return !this.isOnlineSignal();\n  }\n\n  /**\n   * Clear all queued mutations\n   */\n  clearQueue(): void {\n    this.mutationQueue.set([]);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/core/services/infrastructure/pdf-generator.service.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`@angular/core` import should occur before import of `./logger.service`","line":2,"column":1,"nodeType":"ImportDeclaration","endLine":2,"endColumn":50,"fix":{"range":[0,100],"text":"import {Injectable, inject} from '@angular/core';\nimport { LoggerService } from './logger.service';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { LoggerService } from './logger.service';\nimport {Injectable, inject} from '@angular/core';\n\nexport interface PdfOptions {\n  filename?: string;\n  format?: 'a4' | 'letter';\n  orientation?: 'portrait' | 'landscape';\n  scale?: number;\n  quality?: number;\n}\n\n/**\n * Servicio para generar PDFs desde elementos HTML\n *\n * Usa html2canvas para capturar el HTML como imagen y\n * jsPDF para generar el archivo PDF final.\n *\n * Las librerías se cargan bajo demanda (Lazy Loading) para no afectar\n * el tiempo de carga inicial de la aplicación.\n *\n * Uso:\n * ```typescript\n * await this.pdfGenerator.generateFromElement('#pdf-content', {\n *   filename: 'reserva-123.pdf',\n *   format: 'a4',\n *   orientation: 'portrait'\n * });\n * ```\n */\n@Injectable({\n  providedIn: 'root',\n})\nexport class PdfGeneratorService {\n  private readonly logger = inject(LoggerService);\n  /**\n   * Genera un PDF a partir de un elemento HTML\n   *\n   * @param elementOrSelector - Elemento HTML o selector CSS\n   * @param options - Opciones de configuración del PDF\n   */\n  async generateFromElement(\n    elementOrSelector: HTMLElement | string,\n    options: PdfOptions = {},\n  ): Promise<void> {\n    const {\n      filename = 'document.pdf',\n      format = 'a4',\n      orientation = 'portrait',\n      scale = 2, // Mayor escala = mejor calidad (pero más pesado)\n      quality = 0.95,\n    } = options;\n\n    try {\n      // 1. Obtener el elemento HTML\n      const element =\n        typeof elementOrSelector === 'string'\n          ? document.querySelector<HTMLElement>(elementOrSelector)\n          : elementOrSelector;\n\n      if (!element) {\n        throw new Error(\n          `Element not found: ${typeof elementOrSelector === 'string' ? elementOrSelector : 'provided element'}`,\n        );\n      }\n\n      // 2. Cargar librerías dinámicamente\n      const [html2canvasModule, jsPDFModule] = await Promise.all([\n        import('html2canvas'),\n        import('jspdf'),\n      ]);\n      const html2canvas = html2canvasModule.default;\n      const jsPDF = jsPDFModule.default;\n\n      // 3. Capturar el HTML como canvas\n      this.logger.debug('📸 Capturando HTML como imagen...');\n      const canvas = await html2canvas(element, {\n        scale,\n        useCORS: true, // Permitir imágenes de otros dominios\n        logging: false,\n        backgroundColor: '#ffffff',\n        imageTimeout: 15000,\n        allowTaint: false,\n      });\n\n      // 4. Obtener dimensiones del canvas\n      const imgWidth = canvas.width;\n      const imgHeight = canvas.height;\n\n      // 5. Dimensiones del PDF (mm)\n      const pdfWidth = format === 'a4' ? 210 : 215.9; // A4 o Letter\n      const pdfHeight = format === 'a4' ? 297 : 279.4;\n\n      // 6. Calcular ratio para mantener proporción\n      const ratio = Math.min(pdfWidth / imgWidth, pdfHeight / imgHeight);\n\n      // 7. Dimensiones finales de la imagen en el PDF\n      const imgPdfWidth = imgWidth * ratio;\n      const imgPdfHeight = imgHeight * ratio;\n\n      // 8. Crear documento PDF\n      const pdf = new jsPDF({\n        orientation,\n        unit: 'mm',\n        format,\n        compress: true,\n      });\n\n      // 9. Agregar imagen al PDF\n      const imgData = canvas.toDataURL('image/jpeg', quality);\n      pdf.addImage(imgData, 'JPEG', 0, 0, imgPdfWidth, imgPdfHeight);\n\n      // 10. Descargar PDF\n      this.logger.debug('✅ PDF generado exitosamente');\n      pdf.save(filename);\n    } catch (error) {\n      console.error('❌ Error generando PDF:', error);\n      throw new Error('No se pudo generar el PDF. Por favor, intente nuevamente.');\n    }\n  }\n\n  /**\n   * Genera un PDF multipágina si el contenido es muy largo\n   *\n   * @param elementOrSelector - Elemento HTML o selector CSS\n   * @param options - Opciones de configuración del PDF\n   */\n  async generateMultiPagePdf(\n    elementOrSelector: HTMLElement | string,\n    options: PdfOptions = {},\n  ): Promise<void> {\n    const {\n      filename = 'document.pdf',\n      format = 'a4',\n      orientation = 'portrait',\n      scale = 2,\n      quality = 0.95,\n    } = options;\n\n    try {\n      // 1. Obtener el elemento HTML\n      const element =\n        typeof elementOrSelector === 'string'\n          ? document.querySelector<HTMLElement>(elementOrSelector)\n          : elementOrSelector;\n\n      if (!element) {\n        throw new Error('Element not found');\n      }\n\n      // 2. Cargar librerías dinámicamente\n      const [html2canvasModule, jsPDFModule] = await Promise.all([\n        import('html2canvas'),\n        import('jspdf'),\n      ]);\n      const html2canvas = html2canvasModule.default;\n      const jsPDF = jsPDFModule.default;\n\n      // 3. Capturar HTML como canvas\n      this.logger.debug('📸 Capturando HTML como imagen...');\n      const canvas = await html2canvas(element, {\n        scale,\n        useCORS: true,\n        logging: false,\n        backgroundColor: '#ffffff',\n        imageTimeout: 15000,\n      });\n\n      // 4. Dimensiones del PDF (mm)\n      const pdfWidth = format === 'a4' ? 210 : 215.9;\n      const pdfHeight = format === 'a4' ? 297 : 279.4;\n\n      // 5. Crear documento PDF\n      const pdf = new jsPDF({\n        orientation,\n        unit: 'mm',\n        format,\n        compress: true,\n      });\n\n      // 6. Convertir canvas a imagen\n      const imgData = canvas.toDataURL('image/jpeg', quality);\n\n      // 7. Dimensiones de la imagen\n      const imgWidth = canvas.width;\n      const imgHeight = canvas.height;\n\n      // 8. Calcular cuántas páginas se necesitan\n      const ratio = pdfWidth / imgWidth;\n      const imgPdfHeight = imgHeight * ratio;\n      const pageHeight = pdfHeight;\n\n      let heightLeft = imgPdfHeight;\n      let position = 0;\n\n      // 9. Agregar primera página\n      pdf.addImage(imgData, 'JPEG', 0, position, pdfWidth, imgPdfHeight);\n      heightLeft -= pageHeight;\n\n      // 10. Agregar páginas adicionales si es necesario\n      while (heightLeft > 0) {\n        position -= pageHeight;\n        pdf.addPage();\n        pdf.addImage(imgData, 'JPEG', 0, position, pdfWidth, imgPdfHeight);\n        heightLeft -= pageHeight;\n      }\n\n      // 11. Descargar PDF\n      this.logger.debug(`✅ PDF multipágina generado (${pdf.getNumberOfPages()} páginas)`);\n      pdf.save(filename);\n    } catch (error) {\n      console.error('❌ Error generando PDF multipágina:', error);\n      throw new Error('No se pudo generar el PDF. Por favor, intente nuevamente.');\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/core/services/infrastructure/performance-monitoring.service.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`./logger.service` import should occur after import of `../../../environments/environment`","line":1,"column":1,"nodeType":"ImportDeclaration","endLine":1,"endColumn":50,"fix":{"range":[0,165],"text":"import {Injectable, inject} from '@angular/core';\nimport { environment } from '../../../environments/environment';\nimport { LoggerService } from './logger.service';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { LoggerService } from './logger.service';\nimport {Injectable, inject} from '@angular/core';\nimport { environment } from '../../../environments/environment';\n\n/**\n * Sentry module type for lazy loading\n */\ntype SentryModule = typeof import('@sentry/angular');\n\ntype LargestContentfulPaintEntry = PerformanceEntry & {\n  renderTime?: number;\n  loadTime?: number;\n};\n\ntype FirstInputDelayEntry = PerformanceEntry & {\n  processingStart: number;\n  startTime: number;\n};\n\ntype LayoutShiftEntry = PerformanceEntry & {\n  value: number;\n  hadRecentInput: boolean;\n};\n\ntype PerformanceWithMemory = Performance & {\n  memory?: {\n    usedJSHeapSize: number;\n    totalJSHeapSize: number;\n    jsHeapSizeLimit: number;\n  };\n};\n\n// Network Information API types (not in standard lib)\ninterface NetworkInformation extends EventTarget {\n  readonly effectiveType: 'slow-2g' | '2g' | '3g' | '4g';\n  readonly downlink: number;\n  readonly rtt: number;\n  readonly saveData: boolean;\n  onchange: ((this: NetworkInformation, ev: Event) => unknown) | null;\n}\n\ntype NavigatorWithOptionalConnection = Navigator & {\n  connection?: NetworkInformation;\n};\n\n/**\n * 📊 Performance Monitoring Service\n *\n * Monitorea métricas clave de performance en móvil:\n * - FPS (Frames per second)\n * - Memory usage\n * - Load times\n * - Core Web Vitals\n */\n@Injectable({\n  providedIn: 'root',\n})\nexport class PerformanceMonitoringService {\n  private readonly logger = inject(LoggerService);\n  private fpsFrameCount = 0;\n  private fpsSampleStart = 0;\n  private fpsBaselineSamples = 0;\n  private fpsMaxObserved = 0;\n  private fpsBaseline: number | null = null;\n  private lowFpsStreak = 0;\n\n  /** Cached Sentry module (lazy-loaded) */\n  private sentryModule: SentryModule | null = null;\n  private sentryLoadPromise: Promise<SentryModule | null> | null = null;\n\n  constructor() {\n    if (typeof window !== 'undefined') {\n      this.initMonitoring();\n    }\n  }\n\n  /**\n   * Lazy-load Sentry module (saves ~238KB from initial bundle)\n   */\n  private async getSentry(): Promise<SentryModule | null> {\n    if (this.sentryModule) {\n      return this.sentryModule;\n    }\n\n    if (!environment.sentryDsn) {\n      return null;\n    }\n\n    if (!this.sentryLoadPromise) {\n      this.sentryLoadPromise = import('@sentry/angular')\n        .then((module) => {\n          this.sentryModule = module;\n          return module;\n        })\n        .catch((err) => {\n          console.error('Failed to load Sentry:', err);\n          this.sentryLoadPromise = null;\n          return null;\n        });\n    }\n\n    return this.sentryLoadPromise;\n  }\n\n  /**\n   * Send performance metric to Sentry (lazy-loaded)\n   */\n  private async sendToSentry(contextKey: string, value: number): Promise<void> {\n    if (!environment.sentryDsn) return;\n\n    const Sentry = await this.getSentry();\n    if (!Sentry) return;\n\n    Sentry.getCurrentScope().setContext('performance', {\n      [contextKey]: value,\n    });\n  }\n\n  /**\n   * Send warning to Sentry (lazy-loaded)\n   */\n  private async sendWarningToSentry(\n    message: string,\n    tags: Record<string, string>,\n  ): Promise<void> {\n    if (!environment.sentryDsn || !environment.production) return;\n\n    const Sentry = await this.getSentry();\n    if (!Sentry) return;\n\n    Sentry.captureMessage(message, {\n      level: 'warning',\n      tags,\n    });\n  }\n\n  /**\n   * Inicializa el monitoreo de performance\n   */\n  private initMonitoring(): void {\n    // Monitorear FPS\n    this.monitorFPS();\n\n    // Monitorear Core Web Vitals\n    this.monitorWebVitals();\n\n    // Log inicial de device info\n    this.logDeviceInfo();\n  }\n\n  /**\n   * Monitorea FPS en tiempo real\n   */\n  private monitorFPS(): void {\n    const sampleWindowMs = 1000;\n    const minBaselineSamples = 3;\n    const minThresholdFps = 24; // 80% of 30fps displays\n    const warnAfterConsecutive = 2;\n\n    this.fpsFrameCount = 0;\n    this.fpsSampleStart = performance.now();\n\n    const measureFPS = (currentTime: number) => {\n      if (document.visibilityState !== 'visible') {\n        // Reset sampling while hidden to avoid skewed readings.\n        this.fpsFrameCount = 0;\n        this.fpsSampleStart = currentTime;\n        requestAnimationFrame(measureFPS);\n        return;\n      }\n\n      this.fpsFrameCount++;\n      const elapsed = currentTime - this.fpsSampleStart;\n\n      if (elapsed >= sampleWindowMs) {\n        const fps = Math.round((this.fpsFrameCount * 1000) / elapsed);\n        this.fpsFrameCount = 0;\n        this.fpsSampleStart = currentTime;\n\n        if (Number.isFinite(fps)) {\n          if (this.fpsBaseline === null) {\n            this.fpsMaxObserved = Math.max(this.fpsMaxObserved, fps);\n            this.fpsBaselineSamples++;\n            if (this.fpsBaselineSamples >= minBaselineSamples) {\n              this.fpsBaseline = this.fpsMaxObserved;\n            }\n          }\n\n          const baseline = this.fpsBaseline ?? (this.fpsMaxObserved || 60);\n          const threshold = Math.max(minThresholdFps, Math.round(baseline * 0.8));\n\n          if (fps < threshold) {\n            this.lowFpsStreak++;\n            if (this.lowFpsStreak >= warnAfterConsecutive) {\n              console.warn(`⚠️ Low FPS detected: ${fps}fps`);\n              this.lowFpsStreak = 0;\n            }\n          } else {\n            this.lowFpsStreak = 0;\n          }\n        }\n      }\n\n      requestAnimationFrame(measureFPS);\n    };\n\n    requestAnimationFrame(measureFPS);\n  }\n\n  /**\n   * Monitorea Core Web Vitals\n   */\n  private monitorWebVitals(): void {\n    // LCP (Largest Contentful Paint)\n    if ('PerformanceObserver' in window) {\n      try {\n        const lcpObserver = new PerformanceObserver((list) => {\n          const entries = list.getEntries() as LargestContentfulPaintEntry[];\n          const lastEntry = entries[entries.length - 1];\n\n          const lcp = lastEntry?.renderTime ?? lastEntry?.loadTime ?? 0;\n          this.logger.debug(`📊 LCP: ${lcp.toFixed(2)}ms`);\n\n          // Send to Sentry as measurement (lazy-loaded)\n          void this.sendToSentry('lcp', lcp);\n\n          if (lcp > 2500) {\n            console.warn(`⚠️ LCP is above target (2.5s): ${(lcp / 1000).toFixed(2)}s`);\n            void this.sendWarningToSentry(`Poor LCP: ${(lcp / 1000).toFixed(2)}s`, {\n              metric: 'lcp',\n            });\n          }\n        });\n\n        lcpObserver.observe({ entryTypes: ['largest-contentful-paint'] });\n      } catch {\n        // Browser doesn't support LCP\n      }\n\n      // FID (First Input Delay)\n      try {\n        const fidObserver = new PerformanceObserver((list) => {\n          list.getEntries().forEach((entry) => {\n            const fidEntry = entry as FirstInputDelayEntry;\n            const fid = fidEntry.processingStart - fidEntry.startTime;\n            this.logger.debug(`📊 FID: ${fid.toFixed(2)}ms`);\n\n            // Send to Sentry as measurement (lazy-loaded)\n            void this.sendToSentry('fid', fid);\n\n            if (fid > 100) {\n              console.warn(`⚠️ FID is above target (100ms): ${fid.toFixed(2)}ms`);\n              void this.sendWarningToSentry(`Poor FID: ${fid.toFixed(2)}ms`, {\n                metric: 'fid',\n              });\n            }\n          });\n        });\n\n        fidObserver.observe({ entryTypes: ['first-input'] });\n      } catch {\n        // Browser doesn't support FID\n      }\n\n      // CLS (Cumulative Layout Shift)\n      try {\n        // CLS should be calculated using session windows (web-vitals algorithm),\n        // not by summing shifts across the whole page lifetime.\n        let clsScore = 0;\n        let sessionValue = 0;\n        let sessionStartTime = 0;\n        let lastEntryTime = 0;\n\n        let warnedPoorCls = false;\n        let lastLoggedCls = 0;\n        let lastSentCls = 0;\n        let sendTimer: ReturnType<typeof setTimeout> | null = null;\n\n        const scheduleClsSend = () => {\n          if (!environment.sentryDsn) return;\n\n          if (sendTimer) clearTimeout(sendTimer);\n          sendTimer = setTimeout(() => {\n            // Send latest value occasionally (not every entry)\n            void this.sendToSentry('cls', clsScore);\n            lastSentCls = clsScore;\n          }, 2000);\n        };\n\n        const finalizeCls = () => {\n          if (sendTimer) {\n            clearTimeout(sendTimer);\n            sendTimer = null;\n          }\n\n          // Final snapshot\n          this.logger.debug(`📊 CLS: ${clsScore.toFixed(4)}`);\n          void this.sendToSentry('cls', clsScore);\n\n          if (clsScore > 0.1 && !warnedPoorCls) {\n            warnedPoorCls = true;\n            console.warn(`⚠️ CLS is above target (0.1): ${clsScore.toFixed(4)}`);\n            void this.sendWarningToSentry(`Poor CLS: ${clsScore.toFixed(4)}`, {\n              metric: 'cls',\n            });\n          }\n        };\n\n        // Flush CLS when the page is being hidden/unloaded.\n        const onVisibilityChange = () => {\n          if (document.visibilityState === 'hidden') {\n            finalizeCls();\n          }\n        };\n        document.addEventListener('visibilitychange', onVisibilityChange, { once: false });\n        window.addEventListener('pagehide', finalizeCls, { once: true });\n\n        const clsObserver = new PerformanceObserver((list) => {\n          list.getEntries().forEach((entry) => {\n            const clsEntry = entry as LayoutShiftEntry;\n            if (!clsEntry.hadRecentInput) {\n              const entryTime = clsEntry.startTime;\n\n              // New session window if:\n              // - gap since last entry >= 1s, or\n              // - session length >= 5s\n              const startsNewSession =\n                sessionValue === 0 ||\n                entryTime - lastEntryTime >= 1000 ||\n                entryTime - sessionStartTime >= 5000;\n\n              if (startsNewSession) {\n                sessionValue = clsEntry.value;\n                sessionStartTime = entryTime;\n              } else {\n                sessionValue += clsEntry.value;\n              }\n\n              lastEntryTime = entryTime;\n              clsScore = Math.max(clsScore, sessionValue);\n\n              // Throttle console noise: log only when CLS meaningfully changes.\n              if (clsScore - lastLoggedCls >= 0.01) {\n                lastLoggedCls = clsScore;\n                this.logger.debug(`📊 CLS: ${clsScore.toFixed(4)}`);\n              }\n\n              // Throttle Sentry updates.\n              if (clsScore - lastSentCls >= 0.05) {\n                scheduleClsSend();\n              }\n\n              // Warn once when crossing threshold.\n              if (clsScore > 0.1 && !warnedPoorCls) {\n                warnedPoorCls = true;\n                console.warn(`⚠️ CLS is above target (0.1): ${clsScore.toFixed(4)}`);\n                void this.sendWarningToSentry(`Poor CLS: ${clsScore.toFixed(4)}`, {\n                  metric: 'cls',\n                });\n              }\n            }\n          });\n        });\n\n        clsObserver.observe({ entryTypes: ['layout-shift'] });\n      } catch {\n        // Browser doesn't support CLS\n      }\n    }\n  }\n\n  /**\n   * Log información del dispositivo\n   */\n  private logDeviceInfo(): void {\n    const performanceMemory = (performance as PerformanceWithMemory).memory;\n    const networkConnection = (navigator as NavigatorWithOptionalConnection).connection;\n\n    const info = {\n      userAgent: navigator.userAgent,\n      platform: navigator.platform,\n      memory: performanceMemory\n        ? {\n          used: (performanceMemory.usedJSHeapSize / 1048576).toFixed(2) + ' MB',\n          total: (performanceMemory.totalJSHeapSize / 1048576).toFixed(2) + ' MB',\n          limit: (performanceMemory.jsHeapSizeLimit / 1048576).toFixed(2) + ' MB',\n        }\n        : 'Not available',\n      connection: networkConnection\n        ? {\n          effectiveType: networkConnection.effectiveType,\n          downlink: `${networkConnection.downlink} Mbps`,\n          rtt: `${networkConnection.rtt} ms`,\n        }\n        : 'Not available',\n      screen: {\n        width: window.screen.width,\n        height: window.screen.height,\n        pixelRatio: window.devicePixelRatio,\n      },\n    };\n\n    this.logger.debug('📱 Device Info:', info);\n  }\n\n  /**\n   * Mide el tiempo de una operación\n   */\n  measureOperation(name: string, operation: () => void | Promise<void>): void {\n    const start = performance.now();\n\n    const finish = () => {\n      const duration = performance.now() - start;\n      this.logger.debug(`⏱️ ${name}: ${duration.toFixed(2)}ms`);\n\n      // Send to Sentry as measurement (lazy-loaded)\n      const metricKey = name.toLowerCase().replace(/\\s+/g, '_');\n      void this.sendToSentry(metricKey, duration);\n\n      if (duration > 100) {\n        console.warn(`⚠️ Slow operation detected: ${name} took ${duration.toFixed(2)}ms`);\n        void this.sendWarningToSentry(\n          `Slow operation: ${name} took ${duration.toFixed(2)}ms`,\n          {\n            metric: 'operation_duration',\n            operation: name,\n          },\n        );\n      }\n    };\n\n    const result = operation();\n\n    if (result instanceof Promise) {\n      result.then(finish).catch(finish);\n    } else {\n      finish();\n    }\n  }\n\n  /**\n   * Obtiene el uso actual de memoria (si está disponible)\n   */\n  getMemoryUsage(): { used: string; total: string; limit: string } | null {\n    const perfWithMemory = performance as PerformanceWithMemory;\n    if (perfWithMemory.memory) {\n      return {\n        used: (perfWithMemory.memory.usedJSHeapSize / 1048576).toFixed(2) + ' MB',\n        total: (perfWithMemory.memory.totalJSHeapSize / 1048576).toFixed(2) + ' MB',\n        limit: (perfWithMemory.memory.jsHeapSizeLimit / 1048576).toFixed(2) + ' MB',\n      };\n    }\n    return null;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/core/services/infrastructure/push-notification.service.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`./logger.service` import should occur after import of `@core/services/auth/auth.service`","line":1,"column":1,"nodeType":"ImportDeclaration","endLine":1,"endColumn":50,"fix":{"range":[0,534],"text":"import { isPlatformBrowser } from '@angular/common';\nimport { Injectable, inject, PLATFORM_ID } from '@angular/core';\nimport { SwPush } from '@angular/service-worker';\nimport { Capacitor } from '@capacitor/core';\nimport { PushNotifications, Token, ActionPerformed, PushNotificationSchema } from '@capacitor/push-notifications';\nimport { Subject } from 'rxjs';\nimport { injectSupabase } from './supabase-client.service';\nimport { AuthService } from '@core/services/auth/auth.service';\nimport { LoggerService } from './logger.service';\n"}},{"ruleId":"import/order","severity":1,"message":"`./supabase-client.service` import should occur after import of `@core/services/auth/auth.service`","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":8,"endColumn":60,"fix":{"range":[410,534],"text":"import { AuthService } from '@core/services/auth/auth.service';\nimport { injectSupabase } from './supabase-client.service';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import { LoggerService } from './logger.service';\nimport { isPlatformBrowser } from '@angular/common';\nimport { Injectable, inject, PLATFORM_ID } from '@angular/core';\nimport { SwPush } from '@angular/service-worker';\nimport { Capacitor } from '@capacitor/core';\nimport { PushNotifications, Token, ActionPerformed, PushNotificationSchema } from '@capacitor/push-notifications';\nimport { Subject } from 'rxjs';\nimport { injectSupabase } from './supabase-client.service';\nimport { AuthService } from '@core/services/auth/auth.service';\n\n/**\n * Push notification message interface\n */\nexport interface PushMessage {\n  title?: string;\n  body?: string;\n  data?: Record<string, unknown>;\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class PushNotificationService {\n  private readonly logger = inject(LoggerService);\n  private readonly platformId = inject(PLATFORM_ID);\n  private readonly isBrowser = isPlatformBrowser(this.platformId);\n  private readonly isNative = this.isBrowser && Capacitor.isNativePlatform();\n  private readonly supabase = injectSupabase();\n  private readonly authService = inject(AuthService);\n  private readonly swPush = inject(SwPush);\n\n  // Native push notification subjects\n  private readonly nativeNotificationClicks$ = new Subject<ActionPerformed>();\n  private readonly nativeMessages$ = new Subject<PushNotificationSchema>();\n\n  // VAPID public key - should be stored in environment variables\n  // Generar en: https://web-push-codelab.glitch.me/\n  private readonly VAPID_PUBLIC_KEY = 'BEl62iUYgUivxIkv69yViEuiBIa-Ib37J8-gSpN1fPQ';\n\n  /**\n   * Verifica si push notifications están disponibles\n   */\n  get isEnabled(): boolean {\n    if (this.isNative) {\n      return true; // Always available on native\n    }\n    return this.swPush.isEnabled;\n  }\n\n  /**\n   * Observable de clicks en notificaciones\n   */\n  get notificationClicks$() {\n    if (this.isNative) {\n      return this.nativeNotificationClicks$.asObservable();\n    }\n    return this.swPush.notificationClicks;\n  }\n\n  /**\n   * Observable de mensajes recibidos\n   */\n  get messages$() {\n    if (this.isNative) {\n      return this.nativeMessages$.asObservable();\n    }\n    return this.swPush.messages;\n  }\n\n  /**\n   * Initializes the push notification subscription process.\n   * This should be called once when the application bootstraps.\n   */\n  public async initializePushNotifications(): Promise<void> {\n    if (!this.isBrowser) {\n      return;\n    }\n\n    // Wait for the user to be logged in\n    const user = await this.authService.getCurrentUser();\n    if (!user) {\n      return;\n    }\n\n    // Use native push on mobile platforms\n    if (this.isNative) {\n      await this.initializeNativePush();\n      return;\n    }\n\n    // Web push fallback\n    if (!('serviceWorker' in navigator) || !('PushManager' in window)) {\n      return;\n    }\n\n    try {\n      const subscription = await this.subscribeUserToPush();\n      if (subscription) {\n        await this.saveTokenToDatabase(subscription.endpoint, 'web');\n      }\n    } catch {\n      /* Silenced */\n    }\n  }\n\n  /**\n   * Initialize native push notifications using Capacitor\n   */\n  private async initializeNativePush(): Promise<void> {\n    try {\n      // Check permissions\n      let permStatus = await PushNotifications.checkPermissions();\n\n      if (permStatus.receive === 'prompt') {\n        permStatus = await PushNotifications.requestPermissions();\n      }\n\n      if (permStatus.receive !== 'granted') {\n        console.warn('Push notification permission not granted');\n        return;\n      }\n\n      // Register for push notifications\n      await PushNotifications.register();\n\n      // Listen for registration success\n      PushNotifications.addListener('registration', async (token: Token) => {\n        this.logger.debug('Push registration success, token:', token.value);\n        await this.saveTokenToDatabase(token.value, 'fcm');\n      });\n\n      // Listen for registration errors\n      PushNotifications.addListener('registrationError', (error) => {\n        console.error('Push registration error:', error.error);\n      });\n\n      // Listen for push notifications received\n      PushNotifications.addListener('pushNotificationReceived', (notification: PushNotificationSchema) => {\n        this.logger.debug('Push notification received:', notification);\n        this.nativeMessages$.next(notification);\n      });\n\n      // Listen for notification action performed (user tapped notification)\n      PushNotifications.addListener('pushNotificationActionPerformed', (action: ActionPerformed) => {\n        this.logger.debug('Push notification action performed:', action);\n        this.nativeNotificationClicks$.next(action);\n      });\n    } catch (error) {\n      console.error('Error initializing native push:', error);\n    }\n  }\n\n  /**\n   * Subscribes the user to push notifications (web only).\n   * @returns The PushSubscription object or null if permission is denied.\n   */\n  private async subscribeUserToPush(): Promise<PushSubscription | null> {\n    const permission = await Notification.requestPermission();\n    if (permission !== 'granted') {\n      return null;\n    }\n\n    const serviceWorkerRegistration = await navigator.serviceWorker.ready;\n    const existingSubscription = await serviceWorkerRegistration.pushManager.getSubscription();\n\n    if (existingSubscription) {\n      return existingSubscription;\n    }\n\n    const subscription = await serviceWorkerRegistration.pushManager.subscribe({\n      userVisibleOnly: true,\n      applicationServerKey: this.urlBase64ToUint8Array(this.VAPID_PUBLIC_KEY),\n    });\n\n    return subscription;\n  }\n\n  /**\n   * Saves the push subscription token to the database.\n   * @param token The token string (endpoint for web, FCM token for native)\n   * @param platform The platform type ('web' | 'fcm')\n   */\n  private async saveTokenToDatabase(token: string, platform: 'web' | 'fcm'): Promise<void> {\n    // Ensure we have a user\n    const user = await this.authService.getCurrentUser();\n    if (!user) return;\n\n    const { error } = await this.supabase.from('push_tokens').upsert(\n      {\n        user_id: user.id,\n        token: token,\n        platform: platform,\n        updated_at: new Date().toISOString(),\n      },\n      { onConflict: 'token' },\n    );\n\n    if (error) {\n      console.error('Error saving push token:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Remove push token from database (call on logout)\n   */\n  public async removeToken(): Promise<void> {\n    const user = await this.authService.getCurrentUser();\n    if (!user) return;\n\n    // Get current token\n    if (this.isNative) {\n      // For native, we need to get the token from storage or registration\n      // This is handled by removing all tokens for the user on logout\n      await this.supabase\n        .from('push_tokens')\n        .delete()\n        .eq('user_id', user.id);\n    }\n  }\n\n  /**\n   * Helper function to convert VAPID key.\n   */\n  private urlBase64ToUint8Array(base64String: string): Uint8Array<ArrayBuffer> {\n    const padding = '='.repeat((4 - (base64String.length % 4)) % 4);\n    const base64 = (base64String + padding).replace(/-/g, '+').replace(/_/g, '/');\n    const rawData = window.atob(base64);\n    const outputArray = new Uint8Array(rawData.length);\n    for (let i = 0; i < rawData.length; ++i) {\n      outputArray[i] = rawData.charCodeAt(i);\n    }\n    return outputArray as Uint8Array<ArrayBuffer>;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/core/services/infrastructure/pwa-install.service.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`./logger.service` import should occur after import of `@angular/core`","line":1,"column":1,"nodeType":"ImportDeclaration","endLine":1,"endColumn":50,"fix":{"range":[0,176],"text":"import { isPlatformBrowser } from '@angular/common';\nimport { inject, Injectable, PLATFORM_ID, signal } from '@angular/core';\nimport { LoggerService } from './logger.service';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { LoggerService } from './logger.service';\nimport { isPlatformBrowser } from '@angular/common';\nimport { inject, Injectable, PLATFORM_ID, signal } from '@angular/core';\n\ninterface BeforeInstallPromptEvent extends Event {\n  readonly platforms: string[];\n  prompt: () => Promise<void>;\n  userChoice: Promise<{ outcome: 'accepted' | 'dismissed'; platform: string }>;\n}\n\ntype NavigatorWithStandalone = Navigator & { standalone?: boolean };\ntype WindowWithMSStream = Window & { MSStream?: unknown };\n\n/**\n * 📲 PWA Install Service\n *\n * Maneja la instalación de PWA con prompt personalizado\n */\n@Injectable({\n  providedIn: 'root',\n})\nexport class PwaInstallService {\n  private readonly logger = inject(LoggerService);\n  private readonly platformId = inject(PLATFORM_ID);\n  private readonly isBrowser = isPlatformBrowser(this.platformId);\n  private deferredPrompt: BeforeInstallPromptEvent | null = null;\n\n  // Señales reactivas\n  readonly canInstall = signal(false);\n  readonly isInstalled = signal(false);\n  readonly showInstallPrompt = signal(false);\n\n  constructor() {\n    if (this.isBrowser) {\n      this.initializeInstallPrompt();\n      this.checkIfInstalled();\n    }\n  }\n\n  /**\n   * Inicializa el evento de instalación\n   */\n  private initializeInstallPrompt(): void {\n    window.addEventListener('beforeinstallprompt', (event: Event) => {\n      const beforeInstallPrompt = event as BeforeInstallPromptEvent;\n      // Prevenir el prompt automático de Chrome\n      beforeInstallPrompt.preventDefault();\n\n      // Guardar el evento para usarlo después\n      this.deferredPrompt = beforeInstallPrompt;\n      this.canInstall.set(true);\n\n      this.logger.debug('✅ PWA instalable detectada');\n\n      // Mostrar prompt personalizado después de 30 segundos\n      setTimeout(() => {\n        if (!this.isInstalled() && this.canInstall() && !this.wasRecentlyDismissed()) {\n          this.showInstallPrompt.set(true);\n        }\n      }, 30000);\n    });\n\n    // Detectar cuando se instala\n    window.addEventListener('appinstalled', () => {\n      this.logger.debug('✅ PWA instalada exitosamente');\n      this.isInstalled.set(true);\n      this.canInstall.set(false);\n      this.showInstallPrompt.set(false);\n      this.deferredPrompt = null;\n\n      // Vibración de éxito\n      if ('vibrate' in navigator) {\n        navigator.vibrate([200, 100, 200]);\n      }\n    });\n  }\n\n  /**\n   * Verifica si la app ya está instalada\n   */\n  private checkIfInstalled(): void {\n    // Detecta si se abrió desde PWA instalada\n    if (window.matchMedia('(display-mode: standalone)').matches) {\n      this.isInstalled.set(true);\n      this.logger.debug('✅ App ya instalada (standalone mode)');\n    }\n\n    // Detecta si es iOS instalado\n    const navigatorWithStandalone = window.navigator as NavigatorWithStandalone;\n    if (navigatorWithStandalone.standalone === true) {\n      this.isInstalled.set(true);\n      this.logger.debug('✅ App ya instalada (iOS standalone)');\n    }\n  }\n\n  /**\n   * Muestra el prompt de instalación\n   */\n  async promptInstall(): Promise<boolean> {\n    if (!this.deferredPrompt) {\n      console.warn('No hay prompt de instalación disponible');\n      return false;\n    }\n\n    // Mostrar el prompt nativo\n    this.deferredPrompt.prompt();\n\n    // Esperar la respuesta del usuario\n    const { outcome } = await this.deferredPrompt.userChoice;\n\n    this.logger.debug(`Usuario ${outcome === 'accepted' ? 'aceptó' : 'rechazó'} la instalación`);\n\n    // Limpiar el prompt usado\n    this.deferredPrompt = null;\n    this.canInstall.set(false);\n    this.showInstallPrompt.set(false);\n\n    return outcome === 'accepted';\n  }\n\n  /**\n   * Oculta el prompt personalizado\n   */\n  dismissPrompt(): void {\n    this.showInstallPrompt.set(false);\n\n    if (!this.isBrowser) return;\n\n    // No mostrar de nuevo en 7 días\n    const dismissedUntil = new Date();\n    dismissedUntil.setDate(dismissedUntil.getDate() + 7);\n    localStorage.setItem('pwa-install-dismissed', dismissedUntil.toISOString());\n  }\n\n  /**\n   * Verifica si el prompt fue rechazado recientemente\n   */\n  private wasRecentlyDismissed(): boolean {\n    if (!this.isBrowser) return false;\n    const dismissedUntil = localStorage.getItem('pwa-install-dismissed');\n    if (!dismissedUntil) return false;\n\n    const dismissDate = new Date(dismissedUntil);\n    return dismissDate > new Date();\n  }\n\n  /**\n   * Obtiene instrucciones de instalación según el navegador\n   */\n  getInstallInstructions(): {\n    browser: string;\n    instructions: string[];\n    icon: string;\n  } | null {\n    const ua = navigator.userAgent;\n\n    // iOS Safari\n    const windowWithMsStream = window as WindowWithMSStream;\n    if (/iPad|iPhone|iPod/.test(ua) && !windowWithMsStream.MSStream) {\n      return {\n        browser: 'Safari iOS',\n        instructions: [\n          'Toca el botón de compartir ⎙',\n          'Desplázate y selecciona \"Añadir a la pantalla de inicio\"',\n          'Toca \"Añadir\" en la esquina superior derecha',\n        ],\n        icon: '📱',\n      };\n    }\n\n    // Chrome Android\n    if (/Chrome/.test(ua) && /Android/.test(ua)) {\n      return {\n        browser: 'Chrome Android',\n        instructions: [\n          'Toca el menú ⋮ (tres puntos)',\n          'Selecciona \"Instalar app\" o \"Añadir a pantalla de inicio\"',\n          'Toca \"Instalar\"',\n        ],\n        icon: '🤖',\n      };\n    }\n\n    // Edge\n    if (/Edg/.test(ua)) {\n      return {\n        browser: 'Microsoft Edge',\n        instructions: [\n          'Haz clic en el ícono de instalación en la barra de direcciones',\n          'O ve a Menú > Aplicaciones > Instalar este sitio como una aplicación',\n        ],\n        icon: '🌐',\n      };\n    }\n\n    // Chrome Desktop\n    if (/Chrome/.test(ua)) {\n      return {\n        browser: 'Chrome',\n        instructions: [\n          'Haz clic en el ícono de instalación en la barra de direcciones',\n          'O ve a Menú > Instalar Autorentar',\n        ],\n        icon: '💻',\n      };\n    }\n\n    return null;\n  }\n\n  /**\n   * Verifica las capacidades de la plataforma\n   */\n  getPlatformCapabilities(): {\n    notifications: boolean;\n    offline: boolean;\n    backgroundSync: boolean;\n    fileHandling: boolean;\n  } {\n    return {\n      notifications: 'Notification' in window && 'PushManager' in window,\n      offline: 'serviceWorker' in navigator,\n      backgroundSync: 'serviceWorker' in navigator && 'SyncManager' in window,\n      fileHandling: 'launchQueue' in window,\n    };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/core/services/infrastructure/sentry.service.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`./logger.service` import should occur after import of `../../../environments/environment`","line":1,"column":1,"nodeType":"ImportDeclaration","endLine":1,"endColumn":50,"fix":{"range":[0,179],"text":"import {ErrorHandler, Injectable, inject} from '@angular/core';\nimport { environment } from '../../../environments/environment';\nimport { LoggerService } from './logger.service';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { LoggerService } from './logger.service';\nimport {ErrorHandler, Injectable, inject} from '@angular/core';\nimport { environment } from '../../../environments/environment';\n\n/**\n * Sentry module type for lazy loading\n */\ntype SentryModule = typeof import('@sentry/angular');\n\n/** Cached Sentry module */\nlet sentryModule: SentryModule | null = null;\nlet sentryLoadPromise: Promise<SentryModule | null> | null = null;\n\n/**\n * Lazy-load Sentry module (saves ~238KB from initial bundle)\n * Caches the module for subsequent calls\n */\nasync function getSentry(): Promise<SentryModule | null> {\n  if (sentryModule) {\n    return sentryModule;\n  }\n\n  if (!environment.sentryDsn) {\n    return null;\n  }\n\n  if (!sentryLoadPromise) {\n    sentryLoadPromise = import('@sentry/angular')\n      .then((module) => {\n        sentryModule = module;\n        return module;\n      })\n      .catch((err) => {\n        console.error('Failed to load Sentry:', err);\n        sentryLoadPromise = null;\n        return null;\n      });\n  }\n\n  return sentryLoadPromise;\n}\n\n/**\n * Sentry Error Handler\n *\n * Global error handler that captures all unhandled errors and sends them to Sentry.\n * Only active in production mode when Sentry DSN is configured.\n *\n * Usage:\n *   Configured automatically in app.config.ts\n *   No manual action needed - all errors are automatically captured\n */\n@Injectable()\nexport class SentryErrorHandler implements ErrorHandler {\n  private readonly logger = inject(LoggerService);\n  handleError(error: Error | unknown): void {\n    // Log to console in development\n    if (!environment.production) {\n      console.error('❌ Unhandled error:', error);\n    }\n\n    // Send to Sentry if configured (lazy-loaded)\n    if (environment.sentryDsn) {\n      void this.sendToSentry(error);\n    }\n\n    // Rethrow in development for visibility\n    if (!environment.production) {\n      throw error;\n    }\n  }\n\n  private async sendToSentry(error: Error | unknown): Promise<void> {\n    const Sentry = await getSentry();\n    if (!Sentry) return;\n\n    if (error instanceof Error) {\n      Sentry.captureException(error);\n    } else {\n      Sentry.captureException(new Error(String(error)));\n    }\n  }\n}\n\n/**\n * Initialize Sentry (lazy-loaded)\n *\n * Call this function early in the application bootstrap process.\n * Configures Sentry with Angular-specific integrations.\n */\nexport async function initSentry(): Promise<void> {\n  if (!environment.sentryDsn) {\n    if (environment.production) {\n      console.warn('⚠️ Sentry DSN not configured - error tracking disabled');\n    }\n    return;\n  }\n\n  const Sentry = await getSentry();\n  if (!Sentry) return;\n  const logger = inject(LoggerService);\n\n  const options = {\n    dsn: environment.sentryDsn,\n    environment: environment.sentryEnvironment,\n\n    // Performance Monitoring\n    tracesSampleRate: environment.sentryTracesSampleRate,\n    tracePropagationTargets: ['localhost', environment.appUrl, environment.supabaseUrl],\n\n    // Integrations\n    integrations: [\n      // Browser tracing for performance monitoring\n      Sentry.browserTracingIntegration(),\n\n      // Replay sessions for debugging\n      Sentry.replayIntegration({\n        maskAllText: true,\n        blockAllMedia: true,\n      }),\n    ],\n\n    // Session Replay (sample rate)\n    replaysSessionSampleRate: environment.production ? 0.1 : 1.0,\n    replaysOnErrorSampleRate: 1.0, // Always capture on errors\n\n    // Release tracking\n    release: `autorenta-web@${environment.production ? 'production' : 'development'}`,\n\n    // Filter sensitive data\n    // beforeSend(event: any, _hint: any) { // Cambiado a any\n    //   // Remove sensitive query parameters\n    //   if (event.request?.url) {\n    //     try {\n    //       const url = new URL(event.request.url);\n    //       const sensitiveParams = ['token', 'key', 'password', 'secret', 'apikey'];\n\n    //       sensitiveParams.forEach((param) => {\n    //         if (url.searchParams.has(param)) {\n    //           url.searchParams.set(param, '[REDACTED]');\n    //         }\n    //       });\n\n    //       event.request.url = url.toString();\n    //     } catch {\n    //       // Invalid URL, ignore\n    //     }\n    //   }\n\n    //   // Remove sensitive headers\n    //   if (event.request?.headers) {\n    //     const sensitiveHeaders = ['authorization', 'cookie', 'x-api-key'];\n    //     sensitiveHeaders.forEach((header) => {\n    //       if (event.request?.headers?.[header]) {\n    //         event.request.headers[header] = '[REDACTED]';\n    //       }\n    //     });\n    //   }\n\n    //   return event;\n    // },\n\n    // Ignore specific errors\n    ignoreErrors: [\n      // Browser extensions\n      'ResizeObserver loop limit exceeded',\n      'Non-Error promise rejection captured',\n\n      // Network errors (handled separately)\n      'NetworkError',\n      'Failed to fetch',\n\n      // Third-party errors\n      'ChunkLoadError',\n    ],\n  };\n\n  // Por ahora, solo inicializamos la parte web debido a conflictos de tipos con Sentry Capacitor\n  Sentry.init(options);\n  logger.debug('✅ Sentry initialized (Web only)', 'Sentry');\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/core/services/infrastructure/supabase-client.service.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Expression expected.","line":309,"column":11}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { isPlatformBrowser } from '@angular/common';\nimport {\n  EnvironmentProviders,\n  inject,\n  isDevMode,\n  Injectable,\n  makeEnvironmentProviders,\n  PLATFORM_ID,\n} from '@angular/core';\nimport { createClient, SupabaseClient } from '@supabase/supabase-js';\nimport { environment } from '../../../environments/environment';\nimport { LoggerService } from '@core/services/infrastructure/logger.service';\n\ntype SupabaseLock = <T>(name: string, acquireTimeout: number, fn: () => Promise<T>) => Promise<T>;\n\n// Type-safe interfaces for Navigator Locks API\ninterface NavigatorLockOptions {\n  mode: 'exclusive' | 'shared';\n  signal?: AbortSignal;\n}\n\ninterface NavigatorLocks {\n  request<T>(name: string, options: NavigatorLockOptions, callback: () => Promise<T>): Promise<T>;\n}\n\ninterface GlobalWithNavigator {\n  navigator?: {\n    locks?: NavigatorLocks;\n  };\n}\n\nconst createResilientLock = (): SupabaseLock => {\n  const navigatorLocks = (globalThis as unknown as GlobalWithNavigator)?.navigator?.locks;\n  if (!navigatorLocks?.request) {\n    return async (_name, _acquireTimeout, fn) => fn();\n  }\n\n  return async (name, acquireTimeout, fn) => {\n    const controller =\n      typeof acquireTimeout === 'number' && acquireTimeout > 0 ? new AbortController() : null;\n    let timeoutId: ReturnType<typeof setTimeout> | undefined;\n\n    try {\n      if (controller) {\n        timeoutId = setTimeout(() => controller.abort(), acquireTimeout);\n      }\n\n      const options: NavigatorLockOptions = { mode: 'exclusive' };\n      if (controller) {\n        options.signal = controller.signal;\n      }\n\n      return await navigatorLocks.request(name, options, async () => fn());\n    } catch (error: unknown) {\n      const errorObj = error as { name?: string; message?: string };\n      if (\n        errorObj?.name === 'AbortError' ||\n        errorObj?.name === 'NavigatorLockAcquireTimeoutError' ||\n        errorObj?.message?.includes('Navigator LockManager')\n      ) {\n        // Lock timeout - continue without locking\n        return fn();\n      }\n      throw error;\n    } finally {\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n      }\n    }\n  };\n};\n\n/**\n * Creates a stub Supabase client for SSR that returns empty results\n * This prevents errors during prerendering while maintaining type safety\n */\nfunction createSSRStubClient(): SupabaseClient {\n  // Create a proxy that returns safe stubs for any property access\n  const createChainableStub = (): unknown => {\n    const stub = new Proxy(() => createChainableStub(), {\n      get: (_target, prop) => {\n        // Handle common async methods\n        if (prop === 'then' || prop === 'catch' || prop === 'finally') {\n          return undefined; // Not a promise\n        }\n        // Return empty data for terminal methods\n        if (prop === 'single' || prop === 'maybeSingle') {\n          return () => Promise.resolve({ data: null, error: null });\n        }\n        // Auth state methods\n        if (prop === 'getSession' || prop === 'getUser') {\n          return () => Promise.resolve({ data: { session: null, user: null }, error: null });\n        }\n        if (prop === 'onAuthStateChange') {\n          return () => ({ data: { subscription: { unsubscribe: () => { } } } });\n        }\n        // RPC calls\n        if (typeof prop === 'string' && prop.startsWith('rpc')) {\n          return () => Promise.resolve({ data: null, error: null });\n        }\n        // Realtime channel\n        if (prop === 'subscribe') {\n          return () => ({ unsubscribe: () => { } });\n        }\n        if (prop === 'unsubscribe') {\n          return () => { };\n        }\n        // Default: return chainable stub\n        return createChainableStub();\n      },\n      apply: () => {\n        // When called as function, return promise with empty result\n        return Promise.resolve({ data: [], error: null, count: 0 });\n      },\n    });\n    return stub;\n  };\n\n  return createChainableStub() as unknown as SupabaseClient;\n}\n\nfunction createUnconfiguredBrowserStubClient(message: string): SupabaseClient {\n  const createChainableThrower = (): unknown => {\n    const thrower = () => {\n      throw new Error(message);\n    };\n\n    const stub = new Proxy(thrower, {\n      get: (_target, prop) => {\n        if (prop === 'then' || prop === 'catch' || prop === 'finally') {\n          return undefined;\n        }\n\n        return createChainableThrower();\n      },\n      apply: () => {\n        throw new Error(message);\n      },\n    });\n\n    return stub;\n  };\n\n  return createChainableThrower() as unknown as SupabaseClient;\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class SupabaseClientService {\n  private readonly logger = inject(LoggerService);\n  private client: SupabaseClient | null = null;\n  private readonly platformId = inject(PLATFORM_ID);\n  private readonly isBrowser = isPlatformBrowser(this.platformId);\n\n  constructor() {\n    // SSR-safe: Don't initialize Supabase during server-side rendering\n    // The client will be created lazily on first getClient() call in browser\n    if (!this.isBrowser) {\n      this.logger.debug('[SupabaseClientService] SSR mode - skipping initialization');\n      return;\n    }\n  }\n\n  /**\n   * Initialize the Supabase client (only in browser)\n   */\n  private initializeClient(): void {\n    if (this.client) return; // Already initialized\n\n    this.logger.debug('[SupabaseClientService] Initializing...');\n    const supabaseUrl = environment.supabaseUrl;\n    const supabaseAnonKey = environment.supabaseAnonKey;\n\n    if (!supabaseUrl || !supabaseAnonKey) {\n      const message =\n        'Supabase no está configurado. Define NG_APP_SUPABASE_URL y NG_APP_SUPABASE_ANON_KEY en tus variables de entorno (por ejemplo, .env.development.local).';\n      throw new Error(message);\n    }\n\n    this.client = createClient(supabaseUrl, supabaseAnonKey, {\n      auth: {\n        persistSession: true,\n        autoRefreshToken: true,\n        lock: createResilientLock(),\n        detectSessionInUrl: true,\n      },\n      db: {\n        schema: 'public',\n      },\n      realtime: {\n        params: {\n          eventsPerSecond: 10,\n        },\n      },\n    });\n  }\n\n  static forRoot(): EnvironmentProviders {\n    return makeEnvironmentProviders([\n      {\n        provide: SupabaseClientService,\n        useFactory: () => new SupabaseClientService(),\n      },\n    ]);\n  }\n\n  /**\n   * Get the Supabase client instance\n   * Returns a stub client during SSR that safely returns empty results\n   */\n  getClient(): SupabaseClient {\n    if (!this.client) {\n      if (!this.isBrowser) {\n        // Return stub client during SSR instead of throwing\n        return createSSRStubClient();\n      }\n      // Lazy init if not done yet\n      this.initializeClient();\n    }\n    return this.client!;\n  }\n\n  /**\n   * Check if Supabase is available (only true in browser)\n   */\n  isAvailable(): boolean {\n    return this.isBrowser && this.client !== null;\n  }\n\n  /**\n   * Get client or null (SSR-safe alternative to getClient())\n   */\n  getClientOrNull(): SupabaseClient | null {\n    if (!this.isBrowser) return null;\n\n    if (this.client) return this.client;\n\n    const supabaseUrl = environment.supabaseUrl;\n    const supabaseAnonKey = environment.supabaseAnonKey;\n    if (!supabaseUrl || !supabaseAnonKey) return null;\n\n    try {\n      this.initializeClient();\n      return this.client;\n    } catch {\n      return null;\n    }\n  }\n\n  async healthCheck(): Promise<boolean> {\n    const client = this.getClientOrNull();\n    if (!client) return false;\n    try {\n      const { error } = await client.from('profiles').select('id').limit(1);\n      return !error;\n    } catch {\n      return false;\n    }\n  }\n\n  getConnectionInfo(): { url: string; pooling: string } {\n    return {\n      url: environment.supabaseUrl || 'hardcoded',\n      pooling: 'transaction',\n    };\n  }\n}\n\n/**\n * Inject Supabase client - SSR-safe\n * Returns a stub client during SSR that returns empty results\n * Returns the real client in browser\n */\nexport const injectSupabase = (): SupabaseClient => {\n  const service = inject(SupabaseClientService) as unknown as {\n    getClient?: () => SupabaseClient;\n    getClientOrNull?: () => SupabaseClient | null;\n    client?: SupabaseClient | null;\n  };\n  const platformId = inject(PLATFORM_ID);\n\n  // During SSR, return a stub client that doesn't throw\n  if (!isPlatformBrowser(platformId)) {\n    return createSSRStubClient();\n  }\n\n  // Browser: prefer a non-throwing lookup first.\n  if (typeof service.getClientOrNull === 'function') {\n    const client = service.getClientOrNull();\n    if (client) return client;\n  }\n\n  // Tolerate test doubles that only expose `client`.\n  if (service.client) return service.client;\n\n  // Fall back to `getClient()` (may throw if env isn't configured).\n  if (typeof service.getClient === 'function') {\n    try {\n      return service.getClient();\n    } catch {\n      // In dev/test we prefer a lazy throwing proxy so services can be constructed\n      // without requiring env vars or a fully mocked Supabase client.\n      if (isDevMode()) {\n        return createUnconfiguredBrowserStubClient(\n          'Supabase no está configurado (o no fue mockeado en tests). Define NG_APP_SUPABASE_URL y NG_APP_SUPABASE_ANON_KEY, o provee un mock de SupabaseClientService en el spec.',\n        );\n      }\n      throw;\n    }\n  }\n\n  if (isDevMode()) {\n    return createUnconfiguredBrowserStubClient(\n      'Supabase client is not available (missing provider or mock in tests).',\n    );\n  }\n\n  throw new Error('Supabase client is not available');\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/core/services/infrastructure/tiktok-events.service.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`./logger.service` import should occur after import of `@core/services/auth/auth.service`","line":1,"column":1,"nodeType":"ImportDeclaration","endLine":1,"endColumn":50,"fix":{"range":[0,321],"text":"import { Injectable, inject } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\nimport { firstValueFrom } from 'rxjs';\nimport { environment } from '../../../environments/environment';\nimport { AuthService } from '@core/services/auth/auth.service';\nimport { LoggerService } from './logger.service';\n"}},{"ruleId":"import/order","severity":1,"message":"`../../../environments/environment` import should occur after import of `@core/services/auth/auth.service`","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":65,"fix":{"range":[192,321],"text":"import { AuthService } from '@core/services/auth/auth.service';\nimport { environment } from '../../../environments/environment';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import { LoggerService } from './logger.service';\nimport { Injectable, inject } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\nimport { firstValueFrom } from 'rxjs';\nimport { environment } from '../../../environments/environment';\nimport { AuthService } from '@core/services/auth/auth.service';\n\n/**\n * TikTok Events Service\n *\n * Servicio para enviar eventos de tracking a TikTok Pixel vía Edge Function.\n * Todos los eventos se envían desde el servidor para mayor seguridad.\n *\n * @example\n * ```typescript\n * // Track cuando un usuario ve un auto\n * tiktokEvents.trackViewContent({\n *   contentId: car.id,\n *   contentName: car.title,\n *   value: car.pricePerDay,\n *   currency: 'ARS'\n * });\n *\n * // Track cuando un usuario completa el registro\n * tiktokEvents.trackCompleteRegistration({\n *   value: 0,\n *   currency: 'ARS'\n * });\n * ```\n */\n@Injectable({\n  providedIn: 'root',\n})\nexport class TikTokEventsService {\n  private readonly logger = inject(LoggerService);\n  private readonly http = inject(HttpClient);\n  private readonly authService = inject(AuthService);\n\n  private readonly edgeFunctionUrl = `${environment.supabaseUrl}/functions/v1/tiktok-events`;\n  private readonly isEnabled = environment.production; // ✅ ENABLED in production\n\n  /**\n   * Track ViewContent event\n   * Cuando un usuario ve una página importante (detalle de auto, comparación, etc.)\n   */\n  async trackViewContent(params: {\n    contentId: string;\n    contentName: string;\n    contentType?: string;\n    value?: number;\n    currency?: string;\n    url?: string;\n  }): Promise<void> {\n    await this.sendEvent('ViewContent', {\n      content_id: params.contentId,\n      content_name: params.contentName,\n      content_type: params.contentType || 'product',\n      value: params.value,\n      currency: params.currency || 'ARS',\n      url: params.url || window.location.href,\n    });\n  }\n\n  /**\n   * Track AddToWishlist event\n   * Cuando un usuario agrega un auto a favoritos\n   */\n  async trackAddToWishlist(params: {\n    contentId: string;\n    contentName: string;\n    value?: number;\n    currency?: string;\n  }): Promise<void> {\n    await this.sendEvent('AddToWishlist', {\n      content_id: params.contentId,\n      content_name: params.contentName,\n      content_type: 'product',\n      value: params.value,\n      currency: params.currency || 'ARS',\n      url: window.location.href,\n    });\n  }\n\n  /**\n   * Track Search event\n   * Cuando un usuario realiza una búsqueda\n   */\n  async trackSearch(params: {\n    searchString: string;\n    value?: number;\n    currency?: string;\n  }): Promise<void> {\n    await this.sendEvent('Search', {\n      search_string: params.searchString,\n      value: params.value,\n      currency: params.currency || 'ARS',\n      url: window.location.href,\n    });\n  }\n\n  /**\n   * Track AddPaymentInfo event\n   * Cuando un usuario agrega su información de pago\n   */\n  async trackAddPaymentInfo(params: {\n    value: number;\n    currency?: string;\n    contentId?: string;\n  }): Promise<void> {\n    await this.sendEvent('AddPaymentInfo', {\n      value: params.value,\n      currency: params.currency || 'ARS',\n      content_id: params.contentId,\n      url: window.location.href,\n    });\n  }\n\n  /**\n   * Track AddToCart event\n   * Cuando un usuario inicia el proceso de booking (equivalente a agregar al carrito)\n   */\n  async trackAddToCart(params: {\n    contentId: string;\n    contentName: string;\n    value: number;\n    currency?: string;\n    quantity?: number;\n  }): Promise<void> {\n    await this.sendEvent('AddToCart', {\n      content_id: params.contentId,\n      content_name: params.contentName,\n      content_type: 'product',\n      value: params.value,\n      currency: params.currency || 'ARS',\n      contents: [\n        {\n          content_id: params.contentId,\n          content_name: params.contentName,\n          quantity: params.quantity || 1,\n          price: params.value,\n        },\n      ],\n      url: window.location.href,\n    });\n  }\n\n  /**\n   * Track InitiateCheckout event\n   * Cuando un usuario confirma la reserva y procede al pago\n   */\n  async trackInitiateCheckout(params: {\n    contentId: string;\n    contentName: string;\n    value: number;\n    currency?: string;\n    contents?: Array<{\n      content_id: string;\n      content_name: string;\n      quantity: number;\n      price: number;\n    }>;\n  }): Promise<void> {\n    await this.sendEvent('InitiateCheckout', {\n      content_id: params.contentId,\n      content_name: params.contentName,\n      content_type: 'product',\n      value: params.value,\n      currency: params.currency || 'ARS',\n      contents: params.contents || [\n        {\n          content_id: params.contentId,\n          content_name: params.contentName,\n          quantity: 1,\n          price: params.value,\n        },\n      ],\n      url: window.location.href,\n    });\n  }\n\n  /**\n   * Track PlaceAnOrder event\n   * Cuando un usuario formaliza el pedido (crea la reserva)\n   */\n  async trackPlaceAnOrder(params: {\n    contentId: string;\n    contentName: string;\n    value: number;\n    currency?: string;\n  }): Promise<void> {\n    await this.sendEvent('PlaceAnOrder', {\n      content_id: params.contentId,\n      content_name: params.contentName,\n      content_type: 'product',\n      value: params.value,\n      currency: params.currency || 'ARS',\n      url: window.location.href,\n    });\n  }\n\n  /**\n   * Track CompleteRegistration event\n   * Cuando un usuario completa el registro\n   */\n  async trackCompleteRegistration(params?: { value?: number; currency?: string }): Promise<void> {\n    await this.sendEvent('CompleteRegistration', {\n      value: params?.value || 0,\n      currency: params?.currency || 'ARS',\n      url: window.location.href,\n    });\n  }\n\n  /**\n   * Track Purchase event\n   * Cuando un usuario completa el pago de la reserva\n   */\n  async trackPurchase(params: {\n    contentId: string;\n    contentName: string;\n    value: number;\n    currency?: string;\n    contents?: Array<{\n      content_id: string;\n      content_name: string;\n      quantity: number;\n      price: number;\n    }>;\n  }): Promise<void> {\n    await this.sendEvent('Purchase', {\n      content_id: params.contentId,\n      content_name: params.contentName,\n      content_type: 'product',\n      value: params.value,\n      currency: params.currency || 'ARS',\n      contents: params.contents || [\n        {\n          content_id: params.contentId,\n          content_name: params.contentName,\n          quantity: 1,\n          price: params.value,\n        },\n      ],\n      url: window.location.href,\n    });\n  }\n\n  /**\n   * Send event to Edge Function\n   */\n  private async sendEvent(event: string, properties: Record<string, unknown>): Promise<void> {\n    if (!this.isEnabled) {\n      this.logger.debug('[TikTok Events] Disabled in development');\n      return;\n    }\n\n    try {\n      const user = await this.authService.getCurrentUser();\n\n      // Get ttclid from URL parameters (TikTok click ID)\n      const urlParams = new URLSearchParams(window.location.search);\n      const ttclid = urlParams.get('ttclid');\n\n      const payload = {\n        event,\n        event_time: Date.now(),\n        user: {\n          external_id: user?.id,\n          email: user?.email,\n          ttclid: ttclid || undefined,\n        },\n        properties,\n      };\n\n      await firstValueFrom(\n        this.http.post(this.edgeFunctionUrl, payload, {\n          headers: {\n            'Content-Type': 'application/json',\n          },\n        }),\n      );\n\n      this.logger.debug(`[TikTok Events] ${event} sent successfully`);\n    } catch (error) {\n      // Fail silently to not break user experience\n      console.error(`[TikTok Events] Error sending ${event}:`, error);\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/core/services/infrastructure/user-notifications.service.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`./logger.service` import should occur after import of `@core/services/auth/auth.service`","line":1,"column":1,"nodeType":"ImportDeclaration","endLine":1,"endColumn":50,"fix":{"range":[0,346],"text":"import { Injectable, signal, inject, OnDestroy, effect } from '@angular/core';\nimport type { RealtimeChannel, RealtimePostgresInsertPayload } from '@supabase/supabase-js';\nimport { injectSupabase } from './supabase-client.service';\nimport { AuthService } from '@core/services/auth/auth.service';\nimport { LoggerService } from './logger.service';\n"}},{"ruleId":"import/order","severity":1,"message":"`./supabase-client.service` import should occur after import of `@core/services/auth/auth.service`","line":4,"column":1,"nodeType":"ImportDeclaration","endLine":4,"endColumn":60,"fix":{"range":[222,346],"text":"import { AuthService } from '@core/services/auth/auth.service';\nimport { injectSupabase } from './supabase-client.service';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import { LoggerService } from './logger.service';\nimport { Injectable, signal, inject, OnDestroy, effect } from '@angular/core';\nimport type { RealtimeChannel, RealtimePostgresInsertPayload } from '@supabase/supabase-js';\nimport { injectSupabase } from './supabase-client.service';\nimport { AuthService } from '@core/services/auth/auth.service';\n\nexport interface NotificationItem {\n  id: string;\n  title: string;\n  message: string;\n  type: 'info' | 'success' | 'warning' | 'error';\n  read: boolean;\n  createdAt: Date;\n  actionUrl?: string;\n  actionText?: string;\n  metadata?: Record<string, unknown>;\n}\n\ninterface NotificationRow {\n  id: string;\n  title: string;\n  body: string;\n  type: string;\n  is_read: boolean;\n  created_at: string;\n  cta_link?: string | null;\n  metadata?: Record<string, unknown> | null;\n}\n\ntype NotificationListItem = NotificationItem & { dbType: string };\n\nexport type NotificationPreferences = {\n  browserPushEnabled: boolean;\n  browserPushPermission: NotificationPermission;\n  bookingUpdates: boolean;\n  paymentNotifications: boolean;\n  messageNotifications: boolean;\n  promotionsAndOffers: boolean;\n  systemUpdates: boolean;\n  inAppNotifications: boolean;\n  emailNotifications: boolean;\n  soundEnabled: boolean;\n};\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class NotificationsService implements OnDestroy {\n  private readonly logger = inject(LoggerService);\n  private readonly supabase = injectSupabase();\n  private readonly authService = inject(AuthService);\n\n  // Estado reactivo\n  readonly notifications = signal<NotificationItem[]>([]);\n  readonly unreadCount = signal(0);\n  readonly connectionStatus = signal<'disconnected' | 'connecting' | 'connected' | 'error'>(\n    'disconnected',\n  );\n\n  // Referencia al channel de Realtime para poder hacer cleanup\n  private realtimeChannel: RealtimeChannel | null = null;\n  private isSubscribed = false;\n  private reconnectTimeoutId: ReturnType<typeof setTimeout> | null = null;\n\n  constructor() {\n    // Efecto reactivo: suscribirse cuando el usuario se autentica\n    effect(() => {\n      const isAuthenticated = this.authService.isAuthenticated();\n\n      if (isAuthenticated) {\n        // Usuario autenticado: cargar notificaciones y suscribirse\n        void this.initializeNotifications();\n      } else {\n        // Usuario no autenticado: limpiar suscripción\n        this.unsubscribe();\n        this.notifications.set([]);\n        this.unreadCount.set(0);\n      }\n    });\n  }\n\n  ngOnDestroy(): void {\n    if (this.reconnectTimeoutId !== null) {\n      clearTimeout(this.reconnectTimeoutId);\n      this.reconnectTimeoutId = null;\n    }\n    this.unsubscribe();\n  }\n\n  /**\n   * Inicializa notificaciones cuando el usuario está autenticado\n   */\n  private async initializeNotifications(): Promise<void> {\n    // Cargar notificaciones existentes\n    await this.loadNotificationsInternal();\n\n    // Suscribirse a cambios en tiempo real\n    await this.subscribeToRealtime();\n  }\n\n  /**\n   * Método público para refrescar notificaciones manualmente\n   */\n  async refresh(): Promise<void> {\n    await this.loadNotifications();\n  }\n\n  /**\n   * Método público para cargar notificaciones\n   */\n  async loadNotifications(): Promise<void> {\n    await this.loadNotificationsInternal();\n  }\n\n  async getSettings(): Promise<NotificationPreferences | null> {\n    try {\n      const {\n        data: { user },\n      } = await this.supabase.auth.getUser();\n      if (!user) return null;\n\n      const { data, error } = await this.supabase\n        .from('notification_settings')\n        .select('preferences')\n        .eq('user_id', user.id)\n        .maybeSingle();\n\n      if (error) throw error;\n      return (data?.preferences as NotificationPreferences) || null;\n    } catch (error) {\n      this.logger.warn('Failed to load notification settings', 'NotificationsService', error);\n      return null;\n    }\n  }\n\n  async saveSettings(preferences: NotificationPreferences): Promise<void> {\n    const {\n      data: { user },\n    } = await this.supabase.auth.getUser();\n    if (!user) return;\n\n    const { error } = await this.supabase\n      .from('notification_settings')\n      .upsert({\n        user_id: user.id,\n        preferences,\n        updated_at: new Date().toISOString(),\n      });\n\n    if (error) {\n      this.logger.error('Failed to save notification settings', 'NotificationsService', error);\n      throw error;\n    }\n  }\n\n  private async loadNotificationsInternal() {\n    try {\n      const {\n        data: { user },\n      } = await this.supabase.auth.getUser();\n      if (!user) return;\n\n      const { data, error } = await this.supabase\n        .from('notifications')\n        .select('*')\n        .eq('user_id', user.id)\n        .order('created_at', { ascending: false })\n        .limit(50)\n        .returns<NotificationRow[]>();\n\n      if (error) throw error as Error;\n\n      const notifications: NotificationItem[] = (data || []).map((notification) =>\n        this.mapNotification(notification),\n      );\n\n      this.notifications.set(notifications);\n      this.updateUnreadCount();\n    } catch (_error) {\n      console.error('Error loading notifications:', _error);\n    }\n  }\n\n  /**\n   * Suscribirse a cambios en tiempo real de notificaciones\n   * Maneja reconexión automática y estado de conexión\n   */\n  private async subscribeToRealtime(): Promise<void> {\n    try {\n      const {\n        data: { user },\n      } = await this.supabase.auth.getUser();\n\n      if (!user) {\n        console.warn('[NotificationsService] No user found, skipping Realtime subscription');\n        this.connectionStatus.set('disconnected');\n        return;\n      }\n\n      // Limpiar suscripción anterior si existe\n      if (this.realtimeChannel) {\n        this.unsubscribe();\n      }\n\n      this.connectionStatus.set('connecting');\n      this.logger.debug(\n        '[NotificationsService] Subscribing to Realtime notifications for user:',\n        user.id,\n      );\n\n      // Crear nuevo channel\n      this.realtimeChannel = this.supabase\n        .channel(`notifications:${user.id}`)\n        .on(\n          'postgres_changes',\n          {\n            event: 'INSERT',\n            schema: 'public',\n            table: 'notifications',\n            filter: `user_id=eq.${user.id}`,\n          },\n          (payload: RealtimePostgresInsertPayload<NotificationRow>) => {\n            this.logger.debug('[NotificationsService] New notification received via Realtime:', payload);\n            this.addNotification(payload.new);\n          },\n        )\n        .subscribe((status) => {\n          this.logger.debug('[NotificationsService] Realtime subscription status:', status);\n\n          if (status === 'SUBSCRIBED') {\n            this.connectionStatus.set('connected');\n            this.isSubscribed = true;\n            this.logger.debug(\n              '[NotificationsService] ✅ Successfully subscribed to Realtime notifications',\n            );\n          } else if (status === 'CHANNEL_ERROR') {\n            this.connectionStatus.set('error');\n            this.isSubscribed = false;\n            console.error('[NotificationsService] ❌ Realtime channel error');\n\n            // Intentar reconectar después de 5 segundos\n            if (this.reconnectTimeoutId !== null) {\n              clearTimeout(this.reconnectTimeoutId);\n            }\n            this.reconnectTimeoutId = setTimeout(() => {\n              this.logger.debug('[NotificationsService] Attempting to reconnect...');\n              void this.subscribeToRealtime();\n            }, 5000);\n          } else if (status === 'TIMED_OUT') {\n            this.connectionStatus.set('error');\n            this.isSubscribed = false;\n            console.warn('[NotificationsService] ⚠️ Realtime subscription timed out');\n\n            // Intentar reconectar después de 5 segundos\n            if (this.reconnectTimeoutId !== null) {\n              clearTimeout(this.reconnectTimeoutId);\n            }\n            this.reconnectTimeoutId = setTimeout(() => {\n              this.logger.debug('[NotificationsService] Attempting to reconnect after timeout...');\n              void this.subscribeToRealtime();\n            }, 5000);\n          } else if (status === 'CLOSED') {\n            this.connectionStatus.set('disconnected');\n            this.isSubscribed = false;\n            this.logger.debug('[NotificationsService] Realtime channel closed');\n          }\n        });\n    } catch (error) {\n      console.error('[NotificationsService] Error subscribing to Realtime:', error);\n      this.connectionStatus.set('error');\n      this.isSubscribed = false;\n\n      // Intentar reconectar después de 5 segundos\n      if (this.reconnectTimeoutId !== null) {\n        clearTimeout(this.reconnectTimeoutId);\n      }\n      this.reconnectTimeoutId = setTimeout(() => {\n        this.logger.debug('[NotificationsService] Attempting to reconnect after error...');\n        void this.subscribeToRealtime();\n      }, 5000);\n    }\n  }\n\n  /**\n   * Desuscribirse del channel de Realtime\n   */\n  private unsubscribe(): void {\n    if (this.realtimeChannel) {\n      this.logger.debug('[NotificationsService] Unsubscribing from Realtime notifications');\n      this.supabase.removeChannel(this.realtimeChannel);\n      this.realtimeChannel = null;\n      this.isSubscribed = false;\n      this.connectionStatus.set('disconnected');\n    }\n  }\n\n  /**\n   * Reconectar manualmente a Realtime\n   */\n  async reconnect(): Promise<void> {\n    this.logger.debug('[NotificationsService] Manual reconnect requested');\n    this.unsubscribe();\n    await this.subscribeToRealtime();\n  }\n\n  private addNotification(notificationData: NotificationRow) {\n    const notification = this.mapNotification(notificationData, false);\n\n    const current = this.notifications();\n    this.notifications.set([notification, ...current]);\n    this.updateUnreadCount();\n\n    // Mostrar notificación push si está disponible\n    this.showBrowserNotification(notification);\n  }\n\n  private mapNotification(\n    notification: NotificationRow,\n    preserveReadState: boolean = true,\n  ): NotificationItem {\n    const dbType = notification.type;\n    const metadata = notification.metadata ?? undefined;\n    let actionUrl = notification.cta_link ?? undefined;\n\n    if (dbType === 'new_booking_for_owner') {\n      const bookingId =\n        (metadata && (metadata['booking_id'] as string)) ||\n        (metadata && (metadata['bookingId'] as string));\n      actionUrl = bookingId\n        ? `/bookings/pending-approval?bookingId=${bookingId}`\n        : '/bookings/pending-approval';\n    } else if (dbType === 'pending_requests_reminder') {\n      actionUrl = '/bookings/pending-approval';\n    } else if (dbType === 'booking_cancelled_for_owner') {\n      actionUrl = '/bookings/owner';\n    }\n\n    return {\n      id: notification.id,\n      title: notification.title,\n      message: notification.body,\n      type: this.mapNotificationType(notification.type),\n      read: preserveReadState ? (notification.is_read ?? false) : false,\n      createdAt: new Date(notification.created_at),\n      actionUrl,\n      actionText: 'Ver detalles',\n      metadata,\n    };\n  }\n\n  private mapNotificationWithDbType(notification: NotificationRow): NotificationListItem {\n    return {\n      ...this.mapNotification(notification),\n      dbType: notification.type,\n    };\n  }\n\n  // Map database notification types to UI types\n  private mapNotificationType(dbType: string): 'info' | 'success' | 'warning' | 'error' {\n    switch (dbType) {\n      // Success types\n      case 'new_booking_for_owner':\n      case 'payment_successful':\n      case 'payout_successful':\n      case 'booking_ended_review':\n      case 'welcome':\n      case 'verification_approved':\n      case 'car_views_milestone':\n        return 'success';\n\n      // Warning types\n      case 'booking_cancelled_for_owner':\n      case 'booking_cancelled_for_renter':\n      case 'inspection_reminder':\n      case 'document_expiry_license':\n      case 'owner_inactive_reminder':\n      case 'verification_rejected':\n      case 'pending_requests_reminder':\n        return 'warning';\n\n      // Info types\n      case 'new_chat_message':\n      case 'generic_announcement':\n      case 'booking_reminder_24h':\n      case 'booking_reminder_2h':\n      case 'optimization_tip':\n      case 'monthly_report':\n      case 'mp_onboarding_required':\n      case 'nearby_cars':\n      case 'car_recommendation':\n      case 'renter_tip':\n      case 'price_drop_alert':\n      case 'favorite_car_available':\n      default:\n        return 'info';\n    }\n  }\n\n  private updateUnreadCount() {\n    const unread = this.notifications().filter((n) => !n.read).length;\n    this.unreadCount.set(unread);\n  }\n\n  async markAsRead(notificationId: string) {\n    try {\n      const { error } = await this.supabase\n        .from('notifications')\n        .update({ is_read: true })\n        .eq('id', notificationId);\n\n      if (error) throw error as Error;\n\n      // Actualizar estado local\n      const current = this.notifications();\n      const updated = current.map((n) => (n.id === notificationId ? { ...n, read: true } : n));\n      this.notifications.set(updated);\n      this.updateUnreadCount();\n    } catch (_error) {\n      console.error('Error marking notification as read:', _error);\n    }\n  }\n\n  async markAllAsRead() {\n    try {\n      const {\n        data: { user },\n      } = await this.supabase.auth.getUser();\n      if (!user) return;\n\n      const { error } = await this.supabase\n        .from('notifications')\n        .update({ is_read: true })\n        .eq('user_id', user.id)\n        .eq('is_read', false);\n\n      if (error) throw error as Error;\n\n      // Actualizar estado local\n      const current = this.notifications();\n      const updated = current.map((n) => ({ ...n, read: true }));\n      this.notifications.set(updated);\n      this.unreadCount.set(0);\n    } catch (_error) {\n      console.error('Error marking all notifications as read:', _error);\n    }\n  }\n\n  // Notificaciones push del navegador\n  private async showBrowserNotification(notification: NotificationItem) {\n    if ('Notification' in window && Notification.permission === 'granted') {\n      const browserNotification = new Notification(notification.title, {\n        body: notification.message,\n        icon: '/assets/icons/icon-192x192.png',\n        badge: '/assets/icons/icon-192x192.png',\n        tag: notification.id,\n      });\n\n      browserNotification.onclick = () => {\n        if (notification.actionUrl) {\n          window.location.href = notification.actionUrl;\n        }\n        browserNotification.close();\n      };\n\n      // Auto-close después de 5 segundos\n      setTimeout(() => browserNotification.close(), 5000);\n    }\n  }\n\n  async requestNotificationPermission(): Promise<boolean> {\n    if (!('Notification' in window)) {\n      return false;\n    }\n\n    if (Notification.permission === 'granted') {\n      return true;\n    }\n\n    if (Notification.permission === 'denied') {\n      return false;\n    }\n\n    const permission = await Notification.requestPermission();\n    return permission === 'granted';\n  }\n\n  // Métodos para crear notificaciones (desde backend)\n  async createNotification(\n    userId: string,\n    notification: Omit<NotificationItem, 'id' | 'read' | 'createdAt'>,\n    dbType: string,\n  ) {\n    try {\n      const { data, error } = await this.supabase\n        .from('notifications')\n        .insert({\n          user_id: userId,\n          title: notification.title,\n          body: notification.message,\n          type: dbType,\n          is_read: false,\n          cta_link: notification.actionUrl || null,\n          metadata: notification.metadata || {},\n        })\n        .select('*')\n        .single();\n\n      if (error) throw error as Error;\n      if (data) {\n        this.addNotification(data as NotificationRow);\n      }\n      return data as NotificationRow;\n    } catch (_error) {\n      console.error('Error creating notification:', _error);\n      throw _error as Error;\n    }\n  }\n\n  // Notificaciones predefinidas\n  async notifyNewBookingForOwner(bookingId: string, carTitle: string, renterName: string) {\n    const {\n      data: { user },\n    } = await this.supabase.auth.getUser();\n    if (!user) return;\n\n    return this.createNotification(\n      user.id,\n      {\n        title: 'Nueva reserva recibida',\n        message: `${renterName} solicitó reservar tu ${carTitle}`,\n        type: 'success',\n        actionUrl: `/bookings/pending-approval?bookingId=${bookingId}`,\n        metadata: { bookingId, renterName, carTitle },\n      },\n      'new_booking_for_owner',\n    );\n  }\n\n  async notifyBookingCreated(bookingId: string, carTitle: string) {\n    const {\n      data: { user },\n    } = await this.supabase.auth.getUser();\n    if (!user) return;\n\n    return this.createNotification(\n      user.id,\n      {\n        title: 'Reserva creada',\n        message: `Tu solicitud de reserva para ${carTitle} ha sido enviada`,\n        type: 'success',\n        actionUrl: `/bookings/${bookingId}`,\n        metadata: { bookingId, carTitle },\n      },\n      'booking_created',\n    );\n  }\n\n  async notifyBookingCancelledForOwner(bookingId: string, carTitle: string, renterName: string) {\n    const {\n      data: { user },\n    } = await this.supabase.auth.getUser();\n    if (!user) return;\n\n    return this.createNotification(\n      user.id,\n      {\n        title: 'Reserva cancelada',\n        message: `${renterName} canceló la reserva de tu ${carTitle}`,\n        type: 'warning',\n        actionUrl: `/bookings/${bookingId}`,\n        metadata: { bookingId, renterName, carTitle },\n      },\n      'booking_cancelled_for_owner',\n    );\n  }\n\n  async notifyBookingCancelledForRenter(bookingId: string, carTitle: string, ownerName: string) {\n    const {\n      data: { user },\n    } = await this.supabase.auth.getUser();\n    if (!user) return;\n\n    return this.createNotification(\n      user.id,\n      {\n        title: 'Reserva cancelada',\n        message: `El anfitrión ${ownerName} canceló tu reserva para ${carTitle}`,\n        type: 'warning',\n        actionUrl: `/bookings/${bookingId}`,\n        metadata: { bookingId, ownerName, carTitle },\n      },\n      'booking_cancelled_for_renter',\n    );\n  }\n\n  async notifyPaymentSuccessful(amount: number, currency: string = 'ARS', bookingId?: string) {\n    const {\n      data: { user },\n    } = await this.supabase.auth.getUser();\n    if (!user) return;\n\n    return this.createNotification(\n      user.id,\n      {\n        title: 'Pago exitoso',\n        message: `Tu pago de ${amount.toLocaleString()} ${currency} fue procesado correctamente`,\n        type: 'success',\n        actionUrl: bookingId ? `/bookings/${bookingId}` : '/wallet',\n        metadata: { amount, currency, bookingId },\n      },\n      'payment_successful',\n    );\n  }\n\n  async notifyPayoutSuccessful(amount: number, currency: string = 'ARS') {\n    const {\n      data: { user },\n    } = await this.supabase.auth.getUser();\n    if (!user) return;\n\n    return this.createNotification(\n      user.id,\n      {\n        title: 'Pago recibido',\n        message: `Se acreditaron ${amount.toLocaleString()} ${currency} en tu wallet`,\n        type: 'success',\n        actionUrl: '/wallet',\n        metadata: { amount, currency },\n      },\n      'payout_successful',\n    );\n  }\n\n  async notifyInspectionReminder(\n    bookingId: string,\n    carTitle: string,\n    inspectionType: 'pickup' | 'return',\n  ) {\n    const {\n      data: { user },\n    } = await this.supabase.auth.getUser();\n    if (!user) return;\n\n    const message =\n      inspectionType === 'pickup'\n        ? `Recuerda realizar la inspección de recogida para ${carTitle}`\n        : `Recuerda realizar la inspección de devolución para ${carTitle}`;\n\n    return this.createNotification(\n      user.id,\n      {\n        title: 'Recordatorio de inspección',\n        message,\n        type: 'warning',\n        actionUrl: `/bookings/${bookingId}`,\n        metadata: { bookingId, carTitle, inspectionType },\n      },\n      'inspection_reminder',\n    );\n  }\n\n  async notifyGenericAnnouncement(title: string, message: string, actionUrl?: string) {\n    const {\n      data: { user },\n    } = await this.supabase.auth.getUser();\n    if (!user) return;\n\n    return this.createNotification(\n      user.id,\n      {\n        title,\n        message,\n        type: 'info',\n        actionUrl,\n        metadata: {},\n      },\n      'generic_announcement',\n    );\n  }\n\n  // Additional methods for notifications page\n  async loadAllNotifications(limit?: number, offset?: number) {\n    try {\n      const {\n        data: { user },\n      } = await this.supabase.auth.getUser();\n      if (!user) return [];\n\n      let query = this.supabase\n        .from('notifications')\n        .select('*')\n        .eq('user_id', user.id)\n        .order('created_at', { ascending: false });\n\n      if (limit) query = query.limit(limit);\n      if (offset) query = query.range(offset, offset + (limit || 50) - 1);\n\n      const { data, error } = await query.returns<NotificationRow[]>();\n\n      if (error) throw error as Error;\n\n      return (data || []).map((notification) => this.mapNotificationWithDbType(notification));\n    } catch (_error) {\n      console.error('Error loading all notifications:', _error);\n      return [];\n    }\n  }\n\n  async filterNotificationsByType(dbType?: string) {\n    try {\n      const {\n        data: { user },\n      } = await this.supabase.auth.getUser();\n      if (!user) return [];\n\n      let query = this.supabase\n        .from('notifications')\n        .select('*')\n        .eq('user_id', user.id)\n        .order('created_at', { ascending: false });\n\n      if (dbType && dbType !== 'all') {\n        query = query.eq('type', dbType);\n      }\n\n      const { data, error } = await query.returns<NotificationRow[]>();\n\n      if (error) throw error as Error;\n\n      return (data || []).map((notification) => this.mapNotificationWithDbType(notification));\n    } catch (_error) {\n      console.error('Error filtering notifications:', _error);\n      return [];\n    }\n  }\n\n  async deleteNotification(notificationId: string) {\n    try {\n      const { error } = await this.supabase.from('notifications').delete().eq('id', notificationId);\n\n      if (error) throw error as Error;\n\n      // Update local state\n      const current = this.notifications();\n      const updated = current.filter((n) => n.id !== notificationId);\n      this.notifications.set(updated);\n      this.updateUnreadCount();\n    } catch (_error) {\n      console.error('Error deleting notification:', _error);\n      throw _error as Error;\n    }\n  }\n\n  async deleteAllRead() {\n    try {\n      const {\n        data: { user },\n      } = await this.supabase.auth.getUser();\n      if (!user) return;\n\n      const { error } = await this.supabase\n        .from('notifications')\n        .delete()\n        .eq('user_id', user.id)\n        .eq('is_read', true);\n\n      if (error) throw error as Error;\n\n      // Update local state\n      const current = this.notifications();\n      const updated = current.filter((n) => !n.read);\n      this.notifications.set(updated);\n    } catch (_error) {\n      console.error('Error deleting read notifications:', _error);\n      throw _error as Error;\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/core/services/payments/bonus-malus.service.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`@core/services/infrastructure/supabase-client.service` import should occur before type import of `../models`","line":9,"column":1,"nodeType":"ImportDeclaration","endLine":9,"endColumn":88,"fix":{"range":[44,265],"text":"import { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\nimport type {\n  UserBonusMalus,\n  BonusMalusCalculation,\n  BonusMalusDisplay,\n  BonusMalusType,\n  AutorentaTier,\n} from '../models';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { Injectable } from '@angular/core';\nimport type {\n  UserBonusMalus,\n  BonusMalusCalculation,\n  BonusMalusDisplay,\n  BonusMalusType,\n  AutorentaTier,\n} from '../models';\nimport { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\n\nexport interface TierDisplay {\n  label: string;\n  color: string;\n  icon: string;\n  badgeClass: string;\n  description: string;\n  benefits: string[];\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class BonusMalusService {\n  private readonly supabase = injectSupabase();\n\n  /**\n   * Obtiene el factor bonus-malus del usuario autenticado\n   * Recalcula automáticamente si es necesario\n   */\n  async getUserBonusMalus(userId?: string): Promise<UserBonusMalus | null> {\n    try {\n      // Si no se proporciona userId, usar el usuario autenticado\n      let targetUserId = userId;\n      if (!targetUserId) {\n        const {\n          data: { user },\n          error: authError,\n        } = await this.supabase.auth.getUser();\n        if (authError) throw authError;\n        if (!user?.id) throw new Error('Usuario no autenticado');\n        targetUserId = user.id;\n      }\n\n      // Obtener factor (usa get_user_bonus_malus que recalcula si es necesario)\n      const { data, error } = await this.supabase\n        .from('user_bonus_malus')\n        .select('*')\n        .eq('user_id', targetUserId)\n        .maybeSingle();\n\n      if (error) throw error;\n\n      // Si no existe, calcular por primera vez\n      if (!data) {\n        await this.calculateBonusMalus(targetUserId);\n        return await this.getUserBonusMalus(targetUserId);\n      }\n\n      // Fallback: Calcular tier si no viene de la BD (para compatibilidad inmediata)\n      const bonusMalus = data as UserBonusMalus;\n      if (!bonusMalus.tier) {\n        bonusMalus.tier = this.calculateTierFallback(bonusMalus);\n      }\n\n      return bonusMalus;\n    } catch {\n      return null;\n    }\n  }\n\n  /**\n   * Fallback para determinar el nivel si la DB no lo tiene\n   */\n  private calculateTierFallback(data: UserBonusMalus): AutorentaTier {\n    const isVerified = data.metrics?.is_verified ?? false;\n    \n    // Elite: Factor excelente Y verificado\n    if (isVerified && data.total_factor <= -0.05) return 'elite';\n    \n    // Trusted: Factor bueno/neutral Y verificado\n    if (isVerified && data.total_factor <= 0.0) return 'trusted';\n    \n    // Standard: Todo lo demas\n    return 'standard';\n  }\n\n  /**\n   * Obtiene el nivel actual del usuario\n   */\n  async getUserTier(userId?: string): Promise<AutorentaTier> {\n    const data = await this.getUserBonusMalus(userId);\n    return data?.tier || 'standard';\n  }\n\n  /**\n   * Verifica si el usuario está exento de pagar depósito (Elite Tier)\n   */\n  async shouldWaiveDeposit(userId?: string): Promise<boolean> {\n    const tier = await this.getUserTier(userId);\n    return tier === 'elite';\n  }\n\n  /**\n   * Obtiene el porcentaje de descuento para el depósito (0.0 a 1.0)\n   */\n  async getDepositDiscount(userId?: string): Promise<number> {\n    const tier = await this.getUserTier(userId);\n    switch (tier) {\n      case 'elite': return 1.0;   // 100% OFF (Sin depósito)\n      case 'trusted': return 0.5; // 50% OFF\n      default: return 0.0;        // 0% OFF (Full depósito)\n    }\n  }\n\n  /**\n   * Obtiene la configuración visual para un nivel\n   */\n  getTierDisplay(tier: AutorentaTier): TierDisplay {\n    switch (tier) {\n      case 'elite':\n        return {\n          label: 'Elite',\n          color: '#10B981', // emerald-500\n          icon: 'trophy',\n          badgeClass: 'bg-emerald-100 text-emerald-800 border-emerald-200',\n          description: 'Nivel máximo de confianza',\n          benefits: ['Sin depósito de garantía', 'Descuento máximo en tarifas', 'Soporte prioritario']\n        };\n      case 'trusted':\n        return {\n          label: 'Trusted',\n          color: '#8B5CF6', // violet-500\n          icon: 'shield-checkmark',\n          badgeClass: 'bg-violet-100 text-violet-800 border-violet-200',\n          description: 'Usuario verificado y confiable',\n          benefits: ['50% descuento en depósito', 'Acceso a mejores autos']\n        };\n      default:\n        return {\n          label: 'Standard',\n          color: '#6B7280', // gray-500\n          icon: 'person',\n          badgeClass: 'bg-gray-100 text-gray-800 border-gray-200',\n          description: 'Nivel inicial',\n          benefits: ['Acceso básico a la plataforma']\n        };\n    }\n  }\n\n  /**\n   * Calcula el factor bonus-malus para un usuario específico\n   */\n  async calculateBonusMalus(userId?: string): Promise<BonusMalusCalculation | null> {\n    try {\n      // Si no se proporciona userId, usar el usuario autenticado\n      let targetUserId = userId;\n      if (!targetUserId) {\n        const {\n          data: { user },\n          error: authError,\n        } = await this.supabase.auth.getUser();\n        if (authError) throw authError;\n        if (!user?.id) throw new Error('Usuario no autenticado');\n        targetUserId = user.id;\n      }\n\n      const { data, error } = await this.supabase.rpc('calculate_user_bonus_malus', {\n        p_user_id: targetUserId,\n      });\n\n      if (error) throw error;\n      return data as BonusMalusCalculation;\n    } catch {\n      return null;\n    }\n  }\n\n  /**\n   * Obtiene el factor bonus-malus simple (sin recalcular)\n   */\n  async getBonusMalusFactor(userId?: string): Promise<number> {\n    try {\n      const bonusMalus = await this.getUserBonusMalus(userId);\n      return bonusMalus?.total_factor ?? 0;\n    } catch {\n      return 0;\n    }\n  }\n\n  /**\n   * Convierte el factor bonus-malus en un objeto para mostrar en UI\n   */\n  getBonusMalusDisplay(factor: number): BonusMalusDisplay {\n    const percentage = Math.abs(factor * 100);\n    let type: BonusMalusType;\n    let message: string;\n    let icon: string;\n    let color: string;\n    const tips: string[] = [];\n\n    if (factor < -0.05) {\n      // BONUS significativo\n      type = 'BONUS';\n      message = `¡Tienes un ${percentage.toFixed(0)}% de descuento!`;\n      icon = '🎉';\n      color = 'text-success-strong';\n      tips.push('Mantén tu excelente reputación para seguir obteniendo descuentos.');\n    } else if (factor < 0) {\n      // BONUS pequeño\n      type = 'BONUS';\n      message = `Tienes un ${percentage.toFixed(0)}% de descuento`;\n      icon = '✨';\n      color = 'text-success-strong';\n      tips.push('Completa más reservas y mantén un buen rating para aumentar tu descuento.');\n    } else if (factor === 0) {\n      // NEUTRAL\n      type = 'NEUTRAL';\n      message = 'Precio estándar sin ajustes';\n      icon = '➖';\n      color = 'text-text-secondary dark:text-text-secondary';\n      tips.push('Completa reservas y obtén buenas calificaciones para recibir descuentos.');\n      tips.push('Evita cancelaciones para no recibir recargos.');\n    } else if (factor <= 0.05) {\n      // MALUS pequeño\n      type = 'MALUS';\n      message = `Tienes un ${percentage.toFixed(0)}% de recargo`;\n      icon = '⚠️';\n      color = 'text-warning-strong';\n      tips.push('Mejora tu rating completando reservas exitosas.');\n      tips.push('Evita cancelaciones para reducir el recargo.');\n    } else {\n      // MALUS significativo\n      type = 'MALUS';\n      message = `Tienes un ${percentage.toFixed(0)}% de recargo`;\n      icon = '⛔';\n      color = 'text-error-text';\n      tips.push('Tu historial necesita mejorar para reducir el recargo.');\n      tips.push('Completa reservas sin incidentes y obtén mejores calificaciones.');\n      tips.push('Verifica tu identidad para reducir el recargo.');\n    }\n\n    return {\n      type,\n      percentage,\n      message,\n      icon,\n      color,\n      tips,\n    };\n  }\n\n  /**\n   * Verifica si un usuario necesita recalcular su factor\n   */\n  async needsRecalculation(userId?: string): Promise<boolean> {\n    try {\n      const bonusMalus = await this.getUserBonusMalus(userId);\n      if (!bonusMalus) return true;\n\n      const nextRecalc = new Date(bonusMalus.next_recalculation_at);\n      return nextRecalc < new Date();\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Obtiene recomendaciones personalizadas para mejorar el factor\n   */\n  async getImprovementTips(userId?: string): Promise<string[]> {\n    try {\n      const bonusMalus = await this.getUserBonusMalus(userId);\n      if (!bonusMalus) return [];\n\n      const tips: string[] = [];\n      const metrics = bonusMalus.metrics;\n\n      // Analizar rating\n      if (metrics.average_rating < 4.0 && metrics.average_rating > 0) {\n        tips.push(\n          '📊 Mejora tu rating: Actualmente tienes ' +\n            metrics.average_rating.toFixed(1) +\n            '/5.0. Enfócate en la comunicación y puntualidad.',\n        );\n      }\n\n      // Analizar cancelaciones\n      if (metrics.cancellation_rate > 0.1) {\n        tips.push(\n          '🚫 Reduce cancelaciones: Tu tasa actual es ' +\n            (metrics.cancellation_rate * 100).toFixed(0) +\n            '%. Evita cancelar reservas confirmadas.',\n        );\n      }\n\n      // Analizar experiencia\n      if (metrics.completed_rentals < 10) {\n        tips.push(\n          '🚗 Gana experiencia: Completa ' +\n            (10 - metrics.completed_rentals) +\n            ' reservas más para obtener mejores descuentos.',\n        );\n      }\n\n      // Analizar verificación\n      if (!metrics.is_verified) {\n        tips.push(\n          '✅ Verifica tu identidad: Los usuarios verificados reciben hasta 3% de descuento adicional.',\n        );\n      }\n\n      // Si el usuario ya está excelente\n      if (\n        metrics.average_rating >= 4.8 &&\n        metrics.cancellation_rate < 0.05 &&\n        metrics.is_verified &&\n        metrics.completed_rentals >= 20\n      ) {\n        tips.push(\n          '🏆 ¡Excelente! Tienes el máximo descuento posible. Mantén este nivel de servicio.',\n        );\n      }\n\n      return tips;\n    } catch {\n      return [];\n    }\n  }\n\n  /**\n   * Calcula el impacto monetario del factor bonus-malus en una reserva\n   */\n  calculateMonetaryImpact(\n    basePrice: number,\n    factor: number,\n  ): {\n    adjustedPrice: number;\n    difference: number;\n    percentageChange: number;\n  } {\n    const adjustedPrice = basePrice * (1 + factor);\n    const difference = adjustedPrice - basePrice;\n    const percentageChange = factor * 100;\n\n    return {\n      adjustedPrice: Math.round(adjustedPrice * 100) / 100,\n      difference: Math.round(difference * 100) / 100,\n      percentageChange: Math.round(percentageChange * 10) / 10,\n    };\n  }\n\n  /**\n   * Obtiene estadísticas agregadas del sistema bonus-malus (para admin)\n   */\n  async getBonusMalusStats(): Promise<{\n    totalUsers: number;\n    usersWithBonus: number;\n    usersWithMalus: number;\n    usersNeutral: number;\n    averageFactor: number;\n  } | null> {\n    try {\n      const { data, error } = await this.supabase.from('user_bonus_malus').select('total_factor');\n\n      if (error) throw error;\n\n      const totalUsers = data.length;\n      const usersWithBonus = data.filter((u) => u.total_factor < 0).length;\n      const usersWithMalus = data.filter((u) => u.total_factor > 0).length;\n      const usersNeutral = data.filter((u) => u.total_factor === 0).length;\n      const averageFactor = data.reduce((sum, u) => sum + u.total_factor, 0) / totalUsers;\n\n      return {\n        totalUsers,\n        usersWithBonus,\n        usersWithMalus,\n        usersNeutral,\n        averageFactor,\n      };\n    } catch {\n      return null;\n    }\n  }\n\n  /**\n   * Fuerza el recálculo de todos los usuarios que lo necesiten (admin)\n   */\n  async recalculateAllBonusMalus(): Promise<{ count: number; success: boolean }> {\n    try {\n      const { data, error } = await this.supabase.rpc('recalculate_all_bonus_malus');\n\n      if (error) throw error;\n\n      return {\n        count: data as number,\n        success: true,\n      };\n    } catch {\n      return {\n        count: 0,\n        success: false,\n      };\n    }\n  }\n\n  // ============================================================================\n  // RPC INTEGRATIONS - Backend Functions\n  // ============================================================================\n\n  /**\n   * Aplica el factor bonus-malus al depósito de seguridad\n   * Retorna el depósito ajustado según el historial del usuario\n   */\n  async applyBonusMalusToDeposit(\n    baseDepositCents: number,\n    userId?: string,\n  ): Promise<{\n    adjustedDepositCents: number;\n    factor: number;\n    savings: number;\n  }> {\n    try {\n      // Nueva lógica basada en Tiers\n      const tier = await this.getUserTier(userId);\n      let discount = 0;\n      \n      if (tier === 'elite') discount = 1.0;\n      else if (tier === 'trusted') discount = 0.5;\n      \n      const savings = Math.round(baseDepositCents * discount);\n      const adjustedDepositCents = baseDepositCents - savings;\n      \n      return {\n        adjustedDepositCents,\n        factor: -discount, // Factor negativo para indicar descuento\n        savings\n      };\n    } catch {\n      // Fallback\n      return {\n        adjustedDepositCents: baseDepositCents,\n        factor: 0,\n        savings: 0,\n      };\n    }\n  }\n\n  /**\n   * Obtiene el score de riesgo completo del usuario\n   * Incluye desglose de bonificaciones y penalizaciones\n   */\n  async getUserRiskScore(userId?: string): Promise<{\n    totalScore: number;\n    riskLevel: 'low' | 'medium' | 'high';\n    bonuses: Array<{ type: string; value: number; description: string }>;\n    maluses: Array<{ type: string; value: number; description: string }>;\n    lastCalculated: string | null;\n  } | null> {\n    try {\n      let targetUserId = userId;\n      if (!targetUserId) {\n        const { data: { user } } = await this.supabase.auth.getUser();\n        targetUserId = user?.id;\n      }\n\n      const { data, error } = await this.supabase.rpc('get_user_risk_score', {\n        p_user_id: targetUserId,\n      });\n\n      if (error) throw error;\n\n      // Determine risk level based on score\n      const score = data?.total_score ?? 0;\n      let riskLevel: 'low' | 'medium' | 'high' = 'medium';\n      if (score <= -0.1) riskLevel = 'low';\n      else if (score >= 0.1) riskLevel = 'high';\n\n      return {\n        totalScore: score,\n        riskLevel,\n        bonuses: data?.bonuses ?? [],\n        maluses: data?.maluses ?? [],\n        lastCalculated: data?.last_calculated ?? null,\n      };\n    } catch {\n      return null;\n    }\n  }\n\n  /**\n   * Obtiene el nivel de renter del usuario\n   * Niveles: basic, verified, premium\n   */\n  async getRenterLevel(userId?: string): Promise<{\n    level: 'basic' | 'verified' | 'premium';\n    requirements: {\n      emailVerified: boolean;\n      phoneVerified: boolean;\n      dniVerified: boolean;\n      licenseVerified: boolean;\n      selfieVerified: boolean;\n      minRentals: number;\n      currentRentals: number;\n      minRating: number;\n      currentRating: number;\n      noLostDisputes: boolean;\n    };\n    nextLevel: 'verified' | 'premium' | null;\n    missingRequirements: string[];\n  } | null> {\n    try {\n      let targetUserId = userId;\n      if (!targetUserId) {\n        const { data: { user } } = await this.supabase.auth.getUser();\n        targetUserId = user?.id;\n      }\n\n      const { data, error } = await this.supabase.rpc('get_renter_level', {\n        p_user_id: targetUserId,\n      });\n\n      if (error) throw error;\n\n      return {\n        level: data?.level ?? 'basic',\n        requirements: data?.requirements ?? {\n          emailVerified: false,\n          phoneVerified: false,\n          dniVerified: false,\n          licenseVerified: false,\n          selfieVerified: false,\n          minRentals: 5,\n          currentRentals: 0,\n          minRating: 4.5,\n          currentRating: 0,\n          noLostDisputes: true,\n        },\n        nextLevel: data?.next_level ?? null,\n        missingRequirements: data?.missing_requirements ?? [],\n      };\n    } catch {\n      return null;\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/core/services/payments/dynamic-pricing.service.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`@core/services/infrastructure/supabase-client.service` import should occur before type import of `../models/dynamic-pricing.model`","line":9,"column":1,"nodeType":"ImportDeclaration","endLine":9,"endColumn":88,"fix":{"range":[52,368],"text":"import { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\nimport type {\n  PriceLock,\n  LockPriceResult,\n  LockPriceRpcResponse,\n  LockPriceRpcParams,\n} from '../models/dynamic-pricing.model';\nimport { PriceLockErrorCode, rpcResponseToPriceLock } from '../models/dynamic-pricing.model';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { Injectable, signal } from '@angular/core';\nimport type {\n  PriceLock,\n  LockPriceResult,\n  LockPriceRpcResponse,\n  LockPriceRpcParams,\n} from '../models/dynamic-pricing.model';\nimport { PriceLockErrorCode, rpcResponseToPriceLock } from '../models/dynamic-pricing.model';\nimport { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\n\nexport interface PricingRequest {\n  region_id: string;\n  rental_start: string; // ISO 8601 timestamp\n  rental_hours: number;\n  car_id?: string;\n}\n\nexport interface PricingBreakdown {\n  base_price: number;\n  day_factor: number;\n  hour_factor: number;\n  user_factor: number;\n  demand_factor: number;\n  event_factor: number;\n  total_multiplier: number;\n}\n\nexport interface PricingDetails {\n  user_rentals: number;\n  day_of_week: number; // 0=Sunday, 6=Saturday\n  hour_of_day: number;\n}\n\nexport interface DynamicPricingResponse {\n  region_id?: string; // Included in batch responses\n  price_per_hour: number;\n  total_price: number;\n  currency: string;\n  price_in_usd?: number; // USD equivalent using live exchange rate\n  breakdown: PricingBreakdown;\n  details: PricingDetails;\n  surge_active: boolean;\n  surge_message?: string;\n}\n\nexport interface PricingRegion {\n  id: string;\n  name: string;\n  country_code: string;\n  currency: string;\n  base_price_per_hour: number;\n  fuel_cost_multiplier: number;\n  inflation_rate: number;\n  active: boolean;\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class DynamicPricingService {\n  private readonly supabase = injectSupabase();\n\n  // Cached regions\n  private readonly regionsCache = signal<PricingRegion[]>([]);\n  private regionsCacheTimestamp = 0;\n  private readonly CACHE_TTL = 5 * 60 * 1000; // 5 minutes\n\n  /**\n   * Get all active pricing regions\n   */\n  async getRegions(): Promise<PricingRegion[]> {\n    const now = Date.now();\n\n    // Return cached data if still valid\n    if (this.regionsCache().length > 0 && now - this.regionsCacheTimestamp < this.CACHE_TTL) {\n      return this.regionsCache();\n    }\n\n    const { data, error } = await this.supabase\n      .from('pricing_regions')\n      .select('*')\n      .eq('active', true)\n      .order('name');\n\n    if (error) {\n      throw new Error(`Failed to fetch pricing regions: ${error.message}`);\n    }\n\n    this.regionsCache.set(data as PricingRegion[]);\n    this.regionsCacheTimestamp = now;\n\n    return data as PricingRegion[];\n  }\n\n  /**\n   * Get region by ID\n   */\n  async getRegionById(regionId: string): Promise<PricingRegion | null> {\n    const regions = await this.getRegions();\n    return regions.find((r) => r.id === regionId) ?? null;\n  }\n\n  /**\n   * Calculate dynamic price for a rental\n   */\n  async calculatePrice(request: PricingRequest): Promise<DynamicPricingResponse> {\n    const { data, error } = await this.supabase.functions.invoke('calculate-dynamic-price', {\n      body: request,\n    });\n\n    if (error) {\n      throw new Error(`Failed to calculate dynamic price: ${error.message}`);\n    }\n\n    return data as DynamicPricingResponse;\n  }\n\n  /**\n   * Calculate price using RPC function (fallback if Edge Function unavailable)\n   * NEW: Optionally accepts carId for vehicle-aware pricing\n   */\n  async calculatePriceRPC(\n    regionId: string,\n    userId: string,\n    rentalStart: string,\n    rentalHours: number,\n    carId?: string,\n  ): Promise<DynamicPricingResponse> {\n    const params: Record<string, unknown> = {\n      p_region_id: regionId,\n      p_user_id: userId,\n      p_rental_start: rentalStart,\n      p_rental_hours: rentalHours,\n    };\n\n    // NEW: Pass car_id for vehicle-aware pricing if provided\n    if (carId) {\n      params['p_car_id'] = carId;\n    }\n\n    const { data, error } = await this.supabase.rpc('calculate_dynamic_price', params);\n\n    if (error) {\n      throw new Error(`Failed to calculate price via RPC: ${error.message}`);\n    }\n\n    return data as DynamicPricingResponse;\n  }\n\n  /**\n   * Calculate prices for multiple regions in a single RPC call (batch optimization)\n   * Returns a map of region_id -> pricing data for efficient lookup\n   */\n  async calculateBatchPricesRPC(\n    regionIds: string[],\n    userId: string,\n    rentalStart: string,\n    rentalHours: number,\n  ): Promise<Map<string, DynamicPricingResponse>> {\n    if (regionIds.length === 0) {\n      return new Map();\n    }\n\n    const { data, error } = await this.supabase.rpc('calculate_batch_dynamic_prices', {\n      p_region_ids: regionIds,\n      p_user_id: userId,\n      p_rental_start: rentalStart,\n      p_rental_hours: rentalHours,\n    });\n\n    if (error) {\n      throw new Error(`Failed to calculate batch prices via RPC: ${error.message}`);\n    }\n\n    // Convert array response to Map for O(1) lookups\n    const pricesMap = new Map<string, DynamicPricingResponse>();\n    const results = data as DynamicPricingResponse[];\n\n    for (const result of results) {\n      if (result.region_id) {\n        pricesMap.set(result.region_id, result);\n      }\n    }\n\n    return pricesMap;\n  }\n\n  /**\n   * Get latest demand snapshot for a region\n   */\n  async getLatestDemand(regionId: string): Promise<{\n    available_cars: number;\n    active_bookings: number;\n    pending_requests: number;\n    demand_ratio: number;\n    surge_factor: number;\n    timestamp: string;\n  } | null> {\n    const { data, error } = await this.supabase\n      .from('pricing_demand_snapshots')\n      .select('*')\n      .eq('region_id', regionId)\n      .order('timestamp', { ascending: false })\n      .limit(1)\n      .single();\n\n    if (error) {\n      return null;\n    }\n\n    return data;\n  }\n\n  /**\n   * Get active special events for a region\n   */\n  async getActiveEvents(\n    regionId: string,\n    startDate: Date,\n    endDate: Date,\n  ): Promise<\n    Array<{\n      id: string;\n      name: string;\n      start_date: string;\n      end_date: string;\n      factor: number;\n    }>\n  > {\n    const { data, error } = await this.supabase\n      .from('pricing_special_events')\n      .select('id, name, start_date, end_date, factor')\n      .eq('region_id', regionId)\n      .eq('active', true)\n      .lte('start_date', endDate.toISOString())\n      .gte('end_date', startDate.toISOString());\n\n    if (error) {\n      return [];\n    }\n\n    return data;\n  }\n\n  /**\n   * Get user's pricing calculation history\n   */\n  async getUserPricingHistory(\n    userId: string,\n    limit = 10,\n  ): Promise<\n    Array<{\n      id: string;\n      created_at: string;\n      base_price: number;\n      final_price: number;\n      calculation_details: DynamicPricingResponse;\n    }>\n  > {\n    const { data, error } = await this.supabase\n      .from('pricing_calculations')\n      .select('id, created_at, base_price, final_price, calculation_details')\n      .eq('user_id', userId)\n      .order('created_at', { ascending: false })\n      .limit(limit);\n\n    if (error) {\n      return [];\n    }\n\n    return data;\n  }\n\n  /**\n   * Format price with currency\n   */\n  formatPrice(amount: number, currency: string): string {\n    const formatter = new Intl.NumberFormat('es-UY', {\n      style: 'currency',\n      currency: currency,\n      minimumFractionDigits: 2,\n      maximumFractionDigits: 2,\n    });\n\n    return formatter.format(amount);\n  }\n\n  /**\n   * Get surge badge info\n   */\n  getSurgeBadge(response: DynamicPricingResponse): {\n    show: boolean;\n    text: string;\n    color: string;\n    icon: string;\n  } {\n    const multiplier = response.breakdown.total_multiplier;\n\n    if (multiplier > 1.15) {\n      return {\n        show: true,\n        text: response.surge_message || 'Tarifa ajustada',\n        color: 'bg-warning-bg0 text-text-inverse',\n        icon: '⚡',\n      };\n    } else if (multiplier < 0.95) {\n      return {\n        show: true,\n        text: response.surge_message || 'Descuento disponible',\n        color: 'bg-success-bg0 text-text-inverse',\n        icon: '💰',\n      };\n    }\n\n    return {\n      show: false,\n      text: '',\n      color: '',\n      icon: '',\n    };\n  }\n\n  /**\n   * Get human-readable breakdown labels\n   */\n  getBreakdownLabels(): {\n    day_factor: string;\n    hour_factor: string;\n    user_factor: string;\n    demand_factor: string;\n    event_factor: string;\n  } {\n    return {\n      day_factor: 'Día de la semana',\n      hour_factor: 'Hora del día',\n      user_factor: 'Tipo de usuario',\n      demand_factor: 'Demanda',\n      event_factor: 'Eventos especiales',\n    };\n  }\n\n  /**\n   * Format factor as percentage\n   */\n  formatFactor(factor: number): string {\n    const percent = (factor * 100).toFixed(0);\n    return factor >= 0 ? `+${percent}%` : `${percent}%`;\n  }\n\n  /**\n   * Get day name from day_of_week number\n   */\n  getDayName(dayOfWeek: number): string {\n    const days = ['Domingo', 'Lunes', 'Martes', 'Miércoles', 'Jueves', 'Viernes', 'Sábado'];\n    return days[dayOfWeek] || 'Desconocido';\n  }\n\n  /**\n   * Get hour range description\n   */\n  getHourDescription(hour: number): string {\n    if (hour >= 0 && hour < 6) return 'Madrugada (descuento)';\n    if (hour >= 6 && hour < 10) return 'Mañana (pico)';\n    if (hour >= 10 && hour < 17) return 'Tarde (normal)';\n    if (hour >= 17 && hour < 22) return 'Noche (pico)';\n    return 'Noche tardía';\n  }\n\n  /**\n   * Get quick price for a car (for map markers and search results)\n   * Uses current time and 24h rental by default\n   */\n  async getQuickPrice(\n    carId: string,\n    regionId: string,\n  ): Promise<{\n    price_per_hour: number;\n    price_per_day: number;\n    currency: string;\n    price_usd_hour?: number;\n    price_usd_day?: number;\n    surge_active: boolean;\n    surge_icon?: string;\n  } | null> {\n    try {\n      // Get current user ID (if logged in)\n      const {\n        data: { user },\n      } = await this.supabase.auth.getUser();\n      const userId = user?.id || '00000000-0000-0000-0000-000000000000'; // Anonymous user\n\n      const now = new Date();\n      const response = await this.calculatePriceRPC(\n        regionId,\n        userId,\n        now.toISOString(),\n        24, // Default 24 hours for \"per day\" pricing\n      );\n\n      const result = {\n        price_per_hour: response.price_per_hour,\n        price_per_day: response.total_price,\n        currency: response.currency,\n        price_usd_hour: response.price_in_usd,\n        price_usd_day: response.price_in_usd ? response.price_in_usd * 24 : undefined,\n        surge_active: response.surge_active,\n        surge_icon: this.getSurgeBadge(response).icon,\n      };\n\n      return result;\n    } catch {\n      return null;\n    }\n  }\n\n  /**\n   * Get batch prices for multiple cars (optimized for map view)\n   * Returns a map of car_id -> pricing data\n   */\n  async getBatchPrices(cars: Array<{ id: string; region_id: string }>): Promise<\n    Map<\n      string,\n      {\n        price_per_hour: number;\n        price_per_day: number;\n        currency: string;\n        price_usd_hour?: number;\n        surge_active: boolean;\n      }\n    >\n  > {\n    const pricesMap = new Map();\n\n    // Group cars by region for efficient processing\n    const carsByRegion = cars.reduce((acc, car) => {\n      if (!acc.has(car.region_id)) {\n        acc.set(car.region_id, []);\n      }\n      acc.get(car.region_id)!.push(car);\n      return acc;\n    }, new Map<string, typeof cars>());\n\n    // Process each region\n    for (const [regionId, regionCars] of carsByRegion) {\n      for (const car of regionCars) {\n        const price = await this.getQuickPrice(car.id, regionId);\n        if (price) {\n          pricesMap.set(car.id, price);\n        }\n      }\n    }\n\n    return pricesMap;\n  }\n\n  /**\n   * Format quick price for display (e.g., \"$3.20/h\")\n   */\n  formatQuickPrice(pricePerHour: number, currency: string, showUSD = false): string {\n    if (showUSD && currency !== 'USD') {\n      // Try to convert to USD if exchange rate available\n      // For now, just show local currency\n      return `${this.formatPrice(pricePerHour, currency)}/h`;\n    }\n    return `${this.formatPrice(pricePerHour, currency)}/h`;\n  }\n\n  /**\n   * Get price trend indicator (↑ ↓ →)\n   */\n  getPriceTrend(currentMultiplier: number): string {\n    if (currentMultiplier > 1.1) return '↑';\n    if (currentMultiplier < 0.9) return '↓';\n    return '→';\n  }\n\n  // ============================================================================\n  // PRICE LOCK METHODS (NEW - for dynamic pricing integration)\n  // ============================================================================\n\n  /**\n   * Lock a price for 15 minutes before booking\n   * Calls lock_price_for_booking RPC and returns PriceLock\n   */\n  async lockPrice(\n    carId: string,\n    userId: string,\n    rentalStart: Date,\n    rentalHours: number,\n  ): Promise<LockPriceResult> {\n    try {\n      const params: LockPriceRpcParams = {\n        p_car_id: carId,\n        p_user_id: userId,\n        p_rental_start: rentalStart.toISOString(),\n        p_rental_hours: rentalHours,\n      };\n\n      const { data, error } = await this.supabase.rpc('lock_price_for_booking', params);\n\n      if (error) {\n        console.error('[DynamicPricingService] Lock price RPC error:', error);\n        return {\n          ok: false,\n          error: error.message,\n          errorCode: PriceLockErrorCode.NETWORK_ERROR,\n        };\n      }\n\n      const response = data as LockPriceRpcResponse;\n\n      // Check if car uses fixed pricing (not an error, just different flow)\n      if (!response.uses_dynamic_pricing) {\n        return {\n          ok: true,\n          priceLock: undefined, // No lock needed for fixed pricing\n          error: response.message,\n        };\n      }\n\n      // Check for fallback error\n      if (response.fallback && response.error) {\n        return {\n          ok: false,\n          error: response.error,\n          errorCode: PriceLockErrorCode.CALCULATION_FAILED,\n        };\n      }\n\n      // Convert RPC response to PriceLock model\n      const priceLock = rpcResponseToPriceLock(response);\n\n      if (!priceLock) {\n        return {\n          ok: false,\n          error: 'Failed to parse price lock response',\n          errorCode: PriceLockErrorCode.CALCULATION_FAILED,\n        };\n      }\n\n      return {\n        ok: true,\n        priceLock,\n      };\n    } catch (err) {\n      console.error('[DynamicPricingService] Lock price error:', err);\n      return {\n        ok: false,\n        error: err instanceof Error ? err.message : 'Unknown error',\n        errorCode: PriceLockErrorCode.NETWORK_ERROR,\n      };\n    }\n  }\n\n  /**\n   * Check if a price lock is still valid\n   */\n  async isPriceLockValid(priceLock: PriceLock | null): Promise<boolean> {\n    if (!priceLock) {\n      return false;\n    }\n\n    const { isPriceLockExpired } = await import('../models/dynamic-pricing.model');\n    return !isPriceLockExpired(priceLock);\n  }\n\n  /**\n   * Get seconds remaining until price lock expires\n   * Returns 0 if already expired or null\n   */\n  async getLockExpiresIn(priceLock: PriceLock | null): Promise<number> {\n    if (!priceLock) {\n      return 0;\n    }\n\n    const { calculateLockExpiresIn } = await import('../models/dynamic-pricing.model');\n    return calculateLockExpiresIn(priceLock);\n  }\n\n  /**\n   * Refresh/renew a price lock by locking again\n   * Useful when user is about to complete checkout and lock is expiring\n   */\n  async refreshPriceLock(priceLock: PriceLock): Promise<LockPriceResult> {\n    return this.lockPrice(\n      priceLock.carId,\n      priceLock.userId,\n      priceLock.rentalStart,\n      priceLock.rentalHours,\n    );\n  }\n\n  /**\n   * Validate price lock for booking creation\n   * Returns null if valid, error message if invalid\n   */\n  async validatePriceLockForBooking(priceLock: PriceLock | null): Promise<string | null> {\n    const { validatePriceLock } = await import('../models/dynamic-pricing.model');\n    return validatePriceLock(priceLock);\n  }\n\n  /**\n   * Get formatted countdown string (MM:SS) for price lock\n   */\n  async formatLockCountdown(priceLock: PriceLock | null): Promise<string> {\n    if (!priceLock) {\n      return '00:00';\n    }\n\n    const { calculateLockExpiresIn, formatLockCountdown } =\n      await import('../models/dynamic-pricing.model');\n    const seconds = calculateLockExpiresIn(priceLock);\n    return formatLockCountdown(seconds);\n  }\n\n  /**\n   * Check if price lock is expiring soon (< 2 minutes)\n   * Used to show warning to user\n   */\n  async isPriceLockExpiringSoon(priceLock: PriceLock | null): Promise<boolean> {\n    const seconds = await this.getLockExpiresIn(priceLock);\n    return seconds > 0 && seconds < 120; // Less than 2 minutes\n  }\n\n  /**\n   * Get price comparison between fixed and dynamic pricing\n   * Used to show savings/surcharge to user\n   */\n  async getPriceComparison(\n    fixedPrice: number,\n    priceLock: PriceLock | null,\n  ): Promise<{\n    fixedPrice: number;\n    dynamicPrice: number;\n    difference: number;\n    percentageDiff: number;\n    isCheaper: boolean;\n    message: string;\n  } | null> {\n    if (!priceLock) {\n      return null;\n    }\n\n    const { calculatePriceComparison, generatePriceComparisonMessage } =\n      await import('../models/dynamic-pricing.model');\n\n    const comparison = calculatePriceComparison(fixedPrice, priceLock.totalPrice);\n    const message = generatePriceComparisonMessage(comparison);\n\n    return {\n      ...comparison,\n      message,\n    };\n  }\n\n  /**\n   * Get surge pricing info for display\n   */\n  async getSurgePricingInfo(priceLock: PriceLock | null): Promise<{\n    isActive: boolean;\n    tier: string;\n    factor: number;\n    message: string;\n    icon: string;\n    badgeColor: string;\n  } | null> {\n    if (!priceLock) {\n      return null;\n    }\n\n    const { generateSurgeInfo } = await import('../models/dynamic-pricing.model');\n    return generateSurgeInfo(priceLock.priceSnapshot);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/core/services/payments/fx.service.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`@core/services/infrastructure/supabase-client.service` import should occur before import of `../models/booking-detail-payment.model`","line":11,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":88,"fix":{"range":[192,471],"text":"import { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\nimport {\n  CurrencyCode,\n  FxSnapshot,\n  isFxExpired,\n  isFxVariationExceeded,\n} from '../models/booking-detail-payment.model';\nimport { ExchangeRateService } from './exchange-rate.service';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { LoggerService } from '@core/services/infrastructure/logger.service';\nimport { Injectable, inject } from '@angular/core';\nimport { Observable, catchError, from, map, of } from 'rxjs';\nimport {\n  CurrencyCode,\n  FxSnapshot,\n  isFxExpired,\n  isFxVariationExceeded,\n} from '../models/booking-detail-payment.model';\nimport { ExchangeRateService } from './exchange-rate.service';\nimport { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\n\n/**\n * Servicio para gestionar tipos de cambio (FX)\n * Maneja snapshots, validación de expiración y revalidación\n *\n * IMPORTANTE: Ahora obtiene precio EN TIEMPO REAL de Binance API.\n * El ExchangeRateService aplica margen del 10% automáticamente.\n *\n * Flujo:\n * - Frontend → ExchangeRateService → Binance API (tiempo real)\n * - Cache en memoria: 30 segundos\n * - Margen del 10% aplicado automáticamente\n */\n@Injectable({\n  providedIn: 'root',\n})\nexport class FxService {\n  private readonly logger = inject(LoggerService);\n  private supabaseClient = injectSupabase();\n  private exchangeRateService = inject(ExchangeRateService);\n\n  /**\n   * Obtiene el snapshot actual de FX para USD_ARS desde la base de datos\n   * Usa exchange_rates table con el campo 'rate' (ya incluye margen aplicado)\n   *\n   * NOTA: data.rate YA incluye el margen, no multiplicar nuevamente\n   */\n  getFxSnapshot(\n    _fromCurrency: CurrencyCode = 'USD',\n    toCurrency: CurrencyCode = 'ARS',\n  ): Observable<FxSnapshot | null> {\n    const pair = `${_fromCurrency}${toCurrency}`;\n\n    return from(\n      this.supabaseClient\n        .from('exchange_rates')\n        .select('*')\n        .eq('pair', pair)\n        .eq('is_active', true)\n        .order('last_updated', { ascending: false })\n        .limit(1)\n        .single(),\n    ).pipe(\n      map((response) => {\n        if (response['error'] || !response.data) {\n          return null;\n        }\n\n        const data = response.data;\n        const timestamp = new Date(data.last_updated);\n        const expiresAt = new Date(timestamp);\n        expiresAt.setDate(expiresAt.getDate() + 7);\n\n        const snapshot: FxSnapshot = {\n          rate: data.rate, // ✅ Usar 'rate' directamente (ya incluye margen)\n          timestamp,\n          fromCurrency: 'USD',\n          toCurrency: toCurrency as CurrencyCode,\n          expiresAt,\n          isExpired: new Date() > expiresAt,\n          variationThreshold: 0.1,\n        };\n\n        this.logger.debug(\n          `💱 FX Snapshot - Tasa: ${snapshot.rate} ARS/USD (fuente: ${data.source}, actualizada: ${data.last_updated})`,\n        );\n\n        return snapshot;\n      }),\n      catchError((error: unknown) => {\n        console.error('Error obteniendo FX snapshot:', error);\n        return of(null);\n      }),\n    );\n  }\n\n  /**\n   * Valida si un FX snapshot necesita revalidación\n   */\n  needsRevalidation(fxSnapshot: FxSnapshot): { needs: boolean; reason?: string } {\n    if (isFxExpired(fxSnapshot)) {\n      return {\n        needs: true,\n        reason: 'El tipo de cambio ha expirado (más de 7 días)',\n      };\n    }\n\n    return { needs: false };\n  }\n\n  /**\n   * Revalida un FX snapshot obteniendo la tasa actual\n   * y comparando con el snapshot anterior\n   */\n  revalidateFxSnapshot(oldSnapshot: FxSnapshot): Observable<{\n    needsUpdate: boolean;\n    newSnapshot?: FxSnapshot;\n    reason?: string;\n  }> {\n    return this.getFxSnapshot(oldSnapshot.fromCurrency, oldSnapshot.toCurrency).pipe(\n      map((newSnapshot) => {\n        if (!newSnapshot) {\n          return {\n            needsUpdate: false,\n            reason: 'No se pudo obtener nueva tasa',\n          };\n        }\n\n        const variationExceeded = isFxVariationExceeded(\n          oldSnapshot.rate,\n          newSnapshot.rate,\n          oldSnapshot.variationThreshold,\n        );\n\n        if (variationExceeded) {\n          return {\n            needsUpdate: true,\n            newSnapshot,\n            reason: `La tasa ha variado más del ${oldSnapshot.variationThreshold * 100}%`,\n          };\n        }\n\n        if (isFxExpired(oldSnapshot)) {\n          return {\n            needsUpdate: true,\n            newSnapshot,\n            reason: 'El snapshot ha expirado',\n          };\n        }\n\n        return {\n          needsUpdate: false,\n          newSnapshot,\n        };\n      }),\n    );\n  }\n\n  /**\n   * Convierte monto de una moneda a otra usando el snapshot\n   */\n  convert(amount: number, fxSnapshot: FxSnapshot): number {\n    return amount * fxSnapshot.rate;\n  }\n\n  /**\n   * Convierte monto inverso (de moneda destino a origen)\n   */\n  convertReverse(amount: number, fxSnapshot: FxSnapshot): number {\n    return amount / fxSnapshot.rate;\n  }\n\n  /**\n   * Mapea FxSnapshotDb (de DB) a FxSnapshot (para componentes)\n   */\n  private mapFxSnapshotFromDb(db: Record<string, unknown>): FxSnapshot {\n    const timestamp = new Date(String(db['timestamp'] || db['created_at']));\n    const expiresAt = new Date(timestamp);\n    expiresAt.setDate(expiresAt.getDate() + 7);\n\n    return {\n      rate: Number(db['rate']),\n      timestamp,\n      fromCurrency: db['from_currency'] as CurrencyCode,\n      toCurrency: db['to_currency'] as CurrencyCode,\n      expiresAt,\n      isExpired: new Date() > expiresAt,\n      variationThreshold: 0.1,\n    };\n  }\n\n  /**\n   * Obtiene la tasa actual de forma asíncrona\n   * NOTA: Retorna platform_rate (CON margen 10%) para garantías\n   * Para precios, usar exchangeRateService.getBinanceRate() directamente\n   */\n  async getCurrentRateAsync(\n    _fromCurrency: CurrencyCode = 'USD',\n    _toCurrency: CurrencyCode = 'ARS',\n  ): Promise<number> {\n    try {\n      const rate = await this.exchangeRateService.getPlatformRate('USDARS');\n      return rate;\n    } catch (error) {\n      console.error('Error obteniendo tasa desde exchange_rates:', error);\n      throw new Error('No se pudo obtener tasa de cambio de ninguna fuente');\n    }\n  }\n\n  /**\n   * Obtiene la tasa Binance SIN margen para conversiones de precio\n   */\n  async getBinanceRateAsync(): Promise<number> {\n    try {\n      return await this.exchangeRateService.getBinanceRate('USDARS');\n    } catch (error) {\n      console.error('Error obteniendo tasa Binance:', error);\n      throw new Error('No se pudo obtener tasa de Binance');\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/core/services/payments/mercadopago-booking-gateway.service.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`@core/services/infrastructure/supabase-client.service` import should occur before import of `../interfaces/payment-gateway.interface`","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":95,"fix":{"range":[150,346],"text":"import { SupabaseClientService } from '@core/services/infrastructure/supabase-client.service';\nimport { PaymentPreferenceResponse, PaymentGateway } from '../interfaces/payment-gateway.interface';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { Injectable, inject } from '@angular/core';\nimport { Observable, from, throwError } from 'rxjs';\nimport { catchError } from 'rxjs/operators';\nimport { PaymentPreferenceResponse, PaymentGateway } from '../interfaces/payment-gateway.interface';\nimport { SupabaseClientService } from '@core/services/infrastructure/supabase-client.service';\n\n/**\n * Respuesta de creación de preferencia de MercadoPago\n */\nexport interface MercadoPagoPreferenceResponse extends PaymentPreferenceResponse {\n  amount_ars: number;\n  amount_usd: number;\n  exchange_rate: number;\n}\n\n/**\n * Gateway de MercadoPago para Bookings (Argentina)\n *\n * Abstrae la integración con la Edge Function `mercadopago-create-booking-preference`.\n * Elimina la necesidad de que los componentes hagan `fetch` directo y conozcan\n * las URLs de Supabase.\n *\n * Ventajas:\n * - Separación de capas (UI no conoce infraestructura)\n * - Facilita testing (mockear el gateway)\n * - Manejo centralizado de errores\n * - Type-safety con interfaces TypeScript\n */\n@Injectable({\n  providedIn: 'root',\n})\nexport class MercadoPagoBookingGatewayService implements PaymentGateway {\n  readonly provider = 'mercadopago' as const;\n  private readonly supabaseService = inject(SupabaseClientService);\n\n  /**\n   * Crea una preferencia de pago en MercadoPago para un booking\n   *\n   * @param bookingId - ID del booking\n   * @param useSplitPayment - Whether to use marketplace split payments (optional)\n   * @returns Observable con la respuesta de MercadoPago\n   */\n  createBookingPreference(\n    bookingId: string,\n    useSplitPayment?: boolean,\n  ): Observable<MercadoPagoPreferenceResponse> {\n    return from(this._createPreference(bookingId, useSplitPayment)).pipe(\n      catchError((err) => {\n        return throwError(() => new Error(this.formatError(err)));\n      }),\n    );\n  }\n\n  /**\n   * Implementación interna usando async/await\n   */\n  private async _createPreference(\n    bookingId: string,\n    _useSplitPayment?: boolean,\n  ): Promise<MercadoPagoPreferenceResponse> {\n    const supabase = this.supabaseService.getClient();\n\n    // Obtener token de autenticación\n    const {\n      data: { session },\n    } = await supabase.auth.getSession();\n\n    if (!session) {\n      throw new Error('Usuario no autenticado');\n    }\n\n    // Obtener URL base de Supabase desde configuración\n    const supabaseUrl = this.getSupabaseUrl();\n    const edgeFunctionUrl = `${supabaseUrl}/functions/v1/mercadopago-create-booking-preference`;\n\n    // Llamar a Edge Function\n    const response = await fetch(edgeFunctionUrl, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        Authorization: `Bearer ${session.access_token}`,\n      },\n      body: JSON.stringify({ booking_id: bookingId }),\n    });\n\n    if (!response.ok) {\n      const errorData = await response.json().catch(() => ({\n        error: `HTTP ${response.status}: ${response.statusText}`,\n      }));\n      throw new Error(errorData.error || 'Error al crear preferencia de pago');\n    }\n\n    const data: MercadoPagoPreferenceResponse = await response.json();\n\n    if (!data.success) {\n      throw new Error(data.error || 'Error desconocido al crear preferencia');\n    }\n\n    return data;\n  }\n\n  /**\n   * Obtiene la URL base de Supabase desde variables de entorno\n   */\n  private getSupabaseUrl(): string {\n    // En Angular, las variables de entorno se acceden vía import\n    // o se definen en environment.ts\n    // Por ahora, obtenemos del cliente Supabase\n    const supabase = this.supabaseService.getClient();\n    // @ts-expect-error - Acceso interno al URL\n    return supabase.supabaseUrl || '';\n  }\n\n  /**\n   * Formatea errores para mostrar al usuario\n   */\n  private formatError(error: unknown): string {\n    if (error && typeof error === 'object' && 'message' in error) {\n      return String(error.message);\n    }\n\n    if (typeof error === 'string') {\n      return error;\n    }\n\n    return 'Error al procesar el pago. Por favor intente nuevamente.';\n  }\n\n  /**\n   * Verifica si una preferencia de MercadoPago sigue válida\n   *\n   * @param preferenceId - ID de la preferencia\n   * @returns true si la preferencia existe y no ha expirado\n   */\n  async isPreferenceValid(preferenceId: string): Promise<boolean> {\n    try {\n      const supabase = this.supabaseService.getClient();\n      const {\n        data: { session },\n      } = await supabase.auth.getSession();\n\n      if (!session) return false;\n\n      // Verificar en la tabla bookings si la preferencia sigue activa\n      const { data: booking } = await supabase\n        .from('bookings')\n        .select('mercadopago_preference_id, status')\n        .eq('mercadopago_preference_id', preferenceId)\n        .single();\n\n      if (!booking) return false;\n\n      // La preferencia es válida si el booking no ha sido pagado aún\n      return booking.status === 'pending';\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Redirige al usuario al checkout de MercadoPago\n   *\n   * @param initPoint - URL de checkout de MercadoPago\n   * @param openInNewTab - Si true, abre en nueva pestaña (default: false)\n   */\n  redirectToCheckout(initPoint: string, openInNewTab = false): void {\n    if (openInNewTab) {\n      window.open(initPoint, '_blank');\n    } else {\n      window.location.href = initPoint;\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/core/services/payments/mercadopago-wallet-gateway.service.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`@core/services/infrastructure/supabase-client.service` import should occur before import of `../interfaces/payment-gateway.interface`","line":9,"column":1,"nodeType":"ImportDeclaration","endLine":9,"endColumn":95,"fix":{"range":[150,372],"text":"import { SupabaseClientService } from '@core/services/infrastructure/supabase-client.service';\nimport {\n  WalletPaymentGateway,\n  WalletDepositResponse,\n  PaymentProvider,\n} from '../interfaces/payment-gateway.interface';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { Injectable, inject } from '@angular/core';\nimport { Observable, from, throwError } from 'rxjs';\nimport { catchError } from 'rxjs/operators';\nimport {\n  WalletPaymentGateway,\n  WalletDepositResponse,\n  PaymentProvider,\n} from '../interfaces/payment-gateway.interface';\nimport { SupabaseClientService } from '@core/services/infrastructure/supabase-client.service';\n\n/**\n * MercadoPago Wallet Gateway Service\n *\n * Maneja depósitos al wallet usando MercadoPago como proveedor de pago.\n * Integra con la Edge Function mercadopago-create-preference (depósitos).\n *\n * Flujo de depósito:\n * 1. Usuario solicita depósito en USD\n * 2. Se convierte a ARS usando tasa de cambio actual\n * 3. Se crea una preferencia en MercadoPago (mercadopago-create-preference)\n * 4. Usuario es redirigido a MercadoPago para aprobar\n * 5. MercadoPago envía webhook después de pago completado\n * 6. Webhook actualiza wallet balance automáticamente\n *\n * Diferencias vs PayPal:\n * - MercadoPago opera en ARS (PayPal en USD)\n * - Requiere conversión de moneda USD -> ARS\n * - Procesamiento típicamente 1-3 segundos\n * - Soporta transferencias bancarias y tarjetas\n */\n@Injectable({\n  providedIn: 'root',\n})\nexport class MercadoPagoWalletGatewayService implements WalletPaymentGateway {\n  readonly provider: PaymentProvider = 'mercadopago';\n  private readonly supabaseService = inject(SupabaseClientService);\n\n  /**\n   * Crea una orden de MercadoPago para depósito al wallet\n   *\n   * @param amountUSD - Monto a depositar en USD\n   * @param transactionId - ID de la transacción de wallet\n   * @returns Observable con la respuesta de MercadoPago\n   */\n  createDepositOrder(amountUSD: number, transactionId: string): Observable<WalletDepositResponse> {\n    return from(this._createDepositOrder(amountUSD, transactionId)).pipe(\n      catchError((err) => {\n        return throwError(() => new Error(this.formatError(err)));\n      }),\n    );\n  }\n\n  /**\n   * Implementación interna usando async/await\n   */\n  private async _createDepositOrder(\n    amountUSD: number,\n    transactionId: string,\n  ): Promise<WalletDepositResponse> {\n    // Validaciones\n    if (amountUSD <= 0) {\n      throw new Error('El monto debe ser mayor a 0');\n    }\n\n    if (!transactionId) {\n      throw new Error('Transaction ID es requerido');\n    }\n\n    const supabase = this.supabaseService.getClient();\n\n    // Obtener token de autenticación\n    const {\n      data: { session },\n    } = await supabase.auth.getSession();\n\n    if (!session) {\n      throw new Error('Usuario no autenticado');\n    }\n\n    // Obtener URL base de Supabase\n    const supabaseUrl = this.getSupabaseUrl();\n    // Usamos la función existente para depósitos a wallet\n    const edgeFunctionUrl = `${supabaseUrl}/functions/v1/mercadopago-create-preference`;\n\n    // Llamar a Edge Function\n    const response = await fetch(edgeFunctionUrl, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        Authorization: `Bearer ${session.access_token}`,\n      },\n      body: JSON.stringify({\n        amount: amountUSD,\n        transaction_id: transactionId,\n        description: 'Depósito a Wallet - MercadoPago',\n      }),\n    });\n\n    if (!response.ok) {\n      const errorData = await response.json().catch(() => ({\n        error: `HTTP ${response.status}: ${response.statusText}`,\n      }));\n      throw new Error(errorData.error || 'Error al crear orden de depósito en MercadoPago');\n    }\n\n    const data = await response.json();\n\n    if (!data.success) {\n      throw new Error(data.error || 'Error desconocido al crear orden de MercadoPago');\n    }\n\n    // Retornar en formato estándar WalletDepositResponse\n    return {\n      success: true,\n      order_id: data.preference_id ?? data.order_id,\n      approval_url: data.init_point || data.approval_url,\n      amount_usd: parseFloat(data.amount_usd ?? amountUSD.toString()),\n      currency: data.currency || 'ARS',\n      transaction_id: transactionId,\n      provider: 'mercadopago',\n    };\n  }\n\n  /**\n   * Verifica si un depósito fue completado exitosamente\n   *\n   * Consulta la tabla wallet_transactions para verificar el estado.\n   *\n   * @param transactionId - ID de la transacción de wallet\n   * @returns true si el depósito fue confirmado\n   */\n  async verifyDeposit(transactionId: string): Promise<boolean> {\n    try {\n      const supabase = this.supabaseService.getClient();\n      const {\n        data: { session },\n      } = await supabase.auth.getSession();\n\n      if (!session) return false;\n\n      // Consultar estado de la transacción\n      const { data: transaction, error } = await supabase\n        .from('wallet_transactions')\n        .select('status, provider')\n        .eq('id', transactionId)\n        .eq('user_id', session.user.id)\n        .eq('provider', 'mercadopago')\n        .single();\n\n      if (error || !transaction) {\n        console.error('Error verifying MercadoPago deposit:', error);\n        return false;\n      }\n\n      // La transacción es válida si está completada o confirmada\n      return transaction.status === 'completed' || transaction.status === 'confirmed';\n    } catch (err) {\n      console.error('Error in verifyDeposit:', err);\n      return false;\n    }\n  }\n\n  /**\n   * Obtiene el estado detallado de una transacción de depósito\n   *\n   * @param transactionId - ID de la transacción\n   * @returns Objeto con estado y detalles de la transacción\n   */\n  async getDepositStatus(transactionId: string): Promise<{\n    status: string;\n    provider_transaction_id: string | null;\n    amount: number;\n    currency: string;\n  } | null> {\n    try {\n      const supabase = this.supabaseService.getClient();\n      const {\n        data: { session },\n      } = await supabase.auth.getSession();\n\n      if (!session) return null;\n\n      const { data: transaction, error } = await supabase\n        .from('wallet_transactions')\n        .select('status, provider_transaction_id, amount, currency')\n        .eq('id', transactionId)\n        .eq('user_id', session.user.id)\n        .single();\n\n      if (error || !transaction) {\n        return null;\n      }\n\n      return transaction;\n    } catch (err) {\n      console.error('Error getting deposit status:', err);\n      return null;\n    }\n  }\n\n  /**\n   * Obtiene la URL base de Supabase\n   */\n  private getSupabaseUrl(): string {\n    const supabase = this.supabaseService.getClient();\n    // @ts-expect-error - Acceso interno al URL\n    return supabase.supabaseUrl || '';\n  }\n\n  /**\n   * Formatea errores para mostrar al usuario\n   */\n  private formatError(error: unknown): string {\n    if (error && typeof error === 'object' && 'message' in error) {\n      return String(error.message);\n    }\n\n    if (typeof error === 'string') {\n      return error;\n    }\n\n    return 'Error al procesar el depósito con MercadoPago. Por favor intente nuevamente.';\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/core/services/payments/payment-authorization.service.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`../models/booking-detail-payment.model` import should occur after import of `@core/services/infrastructure/supabase-client.service`","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":10,"endColumn":49,"fix":{"range":[274,550],"text":"import { AuthService } from '@core/services/auth/auth.service';\nimport { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\nimport {\n  PaymentAuthorization,\n  AuthorizePaymentResult,\n  CurrencyCode,\n} from '../models/booking-detail-payment.model';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { Injectable, inject } from '@angular/core';\nimport { Observable, from, of } from 'rxjs';\nimport { switchMap, catchError, map } from 'rxjs/operators';\nimport { SupabaseClient } from '@supabase/supabase-js';\nimport { FunctionsResponse } from '@supabase/functions-js';\nimport {\n  PaymentAuthorization,\n  AuthorizePaymentResult,\n  CurrencyCode,\n} from '../models/booking-detail-payment.model';\nimport { AuthService } from '@core/services/auth/auth.service';\nimport { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\n\ninterface MercadoPagoPreauthResponse {\n  success: boolean;\n  status: 'approved' | 'authorized' | 'in_process' | 'rejected' | 'pending';\n  status_detail?: string;\n  error?: string;\n  expires_at?: string;\n}\n\ninterface MercadoPagoFunctionResponse {\n  success: boolean;\n  error?: string;\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class PaymentAuthorizationService {\n  private readonly supabase: SupabaseClient = injectSupabase();\n  private readonly authService = inject(AuthService);\n\n  private readonly MP_ERROR_MESSAGES: Record<string, string> = {\n    cc_rejected_high_risk: 'Tu pago fue rechazado por políticas de seguridad.',\n    cc_rejected_insufficient_amount: 'Tu tarjeta no tiene fondos suficientes.',\n    cc_rejected_bad_filled_card_number: 'Revisa el número de tu tarjeta.',\n    cc_rejected_bad_filled_security_code: 'El código de seguridad (CVV) es incorrecto.',\n    cc_rejected_bad_filled_date: 'La fecha de vencimiento es incorrecta.',\n    cc_rejected_call_for_authorize: 'Debes autorizar este pago con tu banco.',\n  };\n\n  private getErrorMessage(statusDetail?: string): string {\n    return (\n      (statusDetail && this.MP_ERROR_MESSAGES[statusDetail]) ||\n      'No pudimos procesar tu pago. Por favor, intenta nuevamente.'\n    );\n  }\n\n  authorizePayment(params: {\n    userId: string;\n    amountUsd: number;\n    amountArs: number;\n    fxRate: number;\n    cardToken: string;\n    payerEmail: string;\n    payerIdentification?: { type: string; number: string };\n    description?: string;\n    bookingId?: string;\n  }): Observable<AuthorizePaymentResult> {\n    return from(\n      this.supabase.rpc('create_payment_authorization', {\n        p_user_id: params.userId,\n        p_booking_id: params.bookingId || null,\n        p_amount_usd: params.amountUsd,\n        p_amount_ars: params.amountArs,\n        p_fx_rate: params.fxRate,\n        p_description: params.description || 'Preautorización de garantía',\n        p_external_reference: `preauth_${params.bookingId || Date.now()}`,\n      }),\n    ).pipe(\n      switchMap(({ data, error }) => {\n        if (error || !data?.success) {\n          throw new Error(data?.error || 'Error creating payment intent');\n        }\n        return from(this.authService.ensureSession()).pipe(\n          switchMap((session) => {\n            if (!session?.access_token) throw new Error('No session token');\n            // Convert camelCase to snake_case for Edge Function\n            return from(\n              this.supabase.functions.invoke<MercadoPagoPreauthResponse>('mp-create-preauth', {\n                body: {\n                  intent_id: data.intent_id,\n                  user_id: params.userId,\n                  booking_id: params.bookingId || null,\n                  amount_ars: params.amountArs,\n                  amount_usd: params.amountUsd,\n                  card_token: params.cardToken,\n                  payer_email: params.payerEmail,\n                  payer_identification_type: params.payerIdentification?.type || null,\n                  payer_identification_number: params.payerIdentification?.number || null,\n                  description: params.description,\n                  external_reference: `preauth_${params.bookingId || Date.now()}`,\n                },\n                headers: {\n                  Authorization: `Bearer ${session.access_token}`,\n                },\n              }),\n            );\n          }),\n          map((mpResponse: FunctionsResponse<MercadoPagoPreauthResponse>) => {\n            const responseData = mpResponse.data;\n            if (!responseData) {\n              throw new Error('Authorization failed');\n            }\n            if (responseData.status === 'rejected') {\n              throw new Error(this.getErrorMessage(responseData.status_detail));\n            }\n            if (!responseData.success) {\n              throw new Error(responseData.error || 'Authorization failed');\n            }\n            return {\n              ok: true,\n              authorizedPaymentId: data.intent_id,\n              expiresAt: responseData.expires_at ? new Date(responseData.expires_at) : undefined,\n            };\n          }),\n        );\n      }),\n      catchError((error) => of({ ok: false, error: error.message || 'Error desconocido' })),\n    );\n  }\n\n  getAuthorizationStatus(authorizedPaymentId: string): Observable<PaymentAuthorization | null> {\n    return from(\n      this.supabase.from('payment_intents').select('*').eq('id', authorizedPaymentId).single(),\n    ).pipe(\n      map(({ data, error }) => {\n        if (error || !data) return null;\n        return {\n          authorizedPaymentId: data.id,\n          amountArs: data.amount_ars,\n          amountUsd: data.amount_usd,\n          currency: 'ARS' as CurrencyCode,\n          expiresAt: data.preauth_expires_at ? new Date(data.preauth_expires_at) : new Date(),\n          status: this.mapStatus(data.status),\n          paymentMethodId: data.payment_method_id,\n          cardLast4: data.card_last4,\n          createdAt: new Date(data.created_at),\n        };\n      }),\n      catchError(() => of(null)),\n    );\n  }\n\n  captureAuthorization(\n    authorizedPaymentId: string,\n    amountArs?: number,\n  ): Observable<{ ok: boolean; error?: string }> {\n    return this.invokeFunction('mp-capture-preauth', {\n      intent_id: authorizedPaymentId,\n      amount_ars: amountArs,\n    });\n  }\n\n  cancelAuthorization(authorizedPaymentId: string): Observable<{ ok: boolean; error?: string }> {\n    return this.invokeFunction('mp-cancel-preauth', { intent_id: authorizedPaymentId });\n  }\n\n  private invokeFunction<TBody extends Record<string, unknown>>(\n    functionName: string,\n    body: TBody,\n  ): Observable<{ ok: boolean; error?: string }> {\n    return from(this.authService.ensureSession()).pipe(\n      switchMap((session) => {\n        if (!session?.access_token) throw new Error('No session token');\n        return from(\n          this.supabase.functions.invoke<MercadoPagoFunctionResponse>(functionName, {\n            body,\n            headers: { Authorization: `Bearer ${session.access_token}` },\n          }),\n        );\n      }),\n      map((response: FunctionsResponse<MercadoPagoFunctionResponse>) => {\n        if (!response.data?.success) {\n          throw new Error(response.data?.error || 'Function call failed');\n        }\n        return { ok: true };\n      }),\n      catchError((error) => of({ ok: false, error: error.message || 'Error desconocido' })),\n    );\n  }\n\n  private mapStatus(dbStatus: string): 'pending' | 'authorized' | 'expired' | 'failed' {\n    switch (dbStatus) {\n      case 'authorized':\n      case 'approved': // DB stores 'approved' for preauthorized payments\n        return 'authorized';\n      case 'expired':\n        return 'expired';\n      case 'failed':\n      case 'rejected':\n      case 'cancelled':\n      case 'captured':\n        return 'failed';\n      default:\n        return 'pending';\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/core/services/payments/payments.service.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`@core/services/infrastructure/supabase-client.service` import should occur before import of `../../../environments/environment`","line":4,"column":1,"nodeType":"ImportDeclaration","endLine":4,"endColumn":88,"fix":{"range":[52,248],"text":"import { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\nimport { environment } from '../../../environments/environment';\nimport { PaymentIntent } from '../models';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { Injectable, inject } from '@angular/core';\nimport { environment } from '../../../environments/environment';\nimport { PaymentIntent } from '../models';\nimport { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\nimport { FxService } from './fx.service';\n\n/**\n * PaymentsService\n * ... (Comments preserved) ...\n */\n@Injectable({\n  providedIn: 'root',\n})\nexport class PaymentsService {\n  private readonly supabase = injectSupabase();\n  private readonly fxService = inject(FxService);\n\n  async createIntent(bookingId: string): Promise<PaymentIntent> {\n    // Obtener datos del booking para el payment intent\n    const { data: booking, error: bookingError } = await this.supabase\n      .from('bookings')\n      .select('id, total_amount, currency, renter_id')\n      .eq('id', bookingId)\n      .single();\n\n    if (bookingError || !booking) {\n      throw new Error(`Booking no encontrado: ${bookingId}`);\n    }\n\n    return this.createPaymentIntent({\n      bookingId: bookingId,\n      userId: booking.renter_id,\n      amount: Number(booking.total_amount ?? 0),\n      currency: booking.currency ?? 'ARS',\n      intentType: 'booking',\n      description: `Pago de reserva ${bookingId.substring(0, 8)}`,\n    });\n  }\n\n  async createPaymentIntent(\n    params:\n      | {\n          bookingId?: string;\n          userId?: string;\n          amount: number;\n          currency: string;\n          intentType: 'booking' | 'security_deposit' | 'fine';\n          isPreAuth?: boolean;\n          description?: string;\n        }\n      | string,\n    _provider?: string,\n  ): Promise<PaymentIntent> {\n    // Overload handler: if string, it's the old signature (bookingId, provider)\n    if (typeof params === 'string') {\n      return this.createIntent(params);\n    }\n\n    // Normal generic implementation\n    const totalAmount = Number(params.amount ?? 0);\n    const currency = (params.currency ?? 'USD').toUpperCase();\n\n    if (!Number.isFinite(totalAmount) || totalAmount <= 0) {\n      throw new Error(`Monto inválido para el intent`);\n    }\n\n    const fxRate = await this.fxService.getCurrentRateAsync('USD', 'ARS');\n    if (!Number.isFinite(fxRate) || fxRate <= 0) {\n      throw new Error('No se pudo obtener la tasa de cambio vigente');\n    }\n\n    const amountUsdRaw = currency === 'USD' ? totalAmount : totalAmount / fxRate;\n    const amountArsRaw = currency === 'ARS' ? totalAmount : totalAmount * fxRate;\n\n    const amountUsd = Number(amountUsdRaw.toFixed(2));\n    const amountArs = Number(amountArsRaw.toFixed(2));\n\n    const { data, error } = await this.supabase\n      .from('payment_intents')\n      .insert({\n        booking_id: params.bookingId,\n        user_id: params.userId,\n        intent_type: params.intentType,\n        amount_usd: amountUsd,\n        amount_ars: amountArs,\n        fx_rate: fxRate,\n        status: 'pending',\n        description: params.description || `Intent ${params.intentType}`,\n        is_preauth: params.isPreAuth || false,\n      })\n      .select()\n      .single();\n\n    if (error) {\n      throw new Error(\n        `Error al crear payment intent: ${error instanceof Error ? error.message : 'Error desconocido'}`,\n      );\n    }\n    return data as PaymentIntent;\n  }\n\n  // ... (Other methods: createMpPreAuthOrder, markAsPaid, getStatus, triggerMockPayment, capture, release, cancel) ...\n\n  async createMpPreAuthOrder(\n    intentId: string,\n    amountCents: number,\n    description: string,\n    bookingId?: string,\n  ): Promise<PaymentIntent> {\n    // (Implementation preserved from previous read)\n    const { data, error } = await this.supabase.rpc('create_mp_preauth_order', {\n      p_intent_id: intentId,\n      p_amount_cents: amountCents,\n      p_description: description,\n      p_booking_id: bookingId,\n    });\n    if (error) throw new Error(error.message);\n    return data as unknown as PaymentIntent;\n  }\n\n  async markAsPaid(intentId: string): Promise<void> {\n    if (environment.production) throw new Error('Not allowed in prod');\n    const workerUrl = environment.paymentsWebhookUrl;\n    await fetch(workerUrl, {\n      method: 'POST',\n      body: JSON.stringify({ provider: 'mock', intent_id: intentId, status: 'approved' }),\n    });\n  }\n\n  async getStatus(intentId: string): Promise<PaymentIntent | null> {\n    const { data } = await this.supabase\n      .from('payment_intents')\n      .select('*')\n      .eq('id', intentId)\n      .single();\n    return data as PaymentIntent;\n  }\n\n  async triggerMockPayment(bookingId: string, status: 'approved' | 'rejected'): Promise<void> {\n    if (environment.production) throw new Error('Not allowed in prod');\n    const workerUrl = environment.paymentsWebhookUrl;\n    await fetch(workerUrl, {\n      method: 'POST',\n      body: JSON.stringify({ provider: 'mock', booking_id: bookingId, status }),\n    });\n  }\n\n  async createPaymentIntentWithDetails(details: {\n    booking_id: string;\n    payment_method: string;\n    amount_cents: number;\n    status: string;\n  }): Promise<PaymentIntent> {\n    const { data, error } = await this.supabase\n      .from('payment_intents')\n      .insert({\n        booking_id: details.booking_id,\n        provider: details.payment_method === 'wallet' ? 'wallet' : 'mercadopago',\n        status: details.status,\n      })\n      .select()\n      .single();\n    if (error) throw error;\n    return data as PaymentIntent;\n  }\n\n  async simulateWebhook(\n    __provider: string,\n    intentId: string,\n    _status: 'approved' | 'rejected',\n  ): Promise<void> {\n    return this.markAsPaid(intentId);\n  }\n\n  async captureMpPreAuth(\n    mpOrderId: string,\n    amountCents: number,\n    description: string,\n  ): Promise<PaymentIntent> {\n    const { data, error } = await this.supabase.rpc('capture_mp_preauth_order', {\n      p_mp_order_id: mpOrderId,\n      p_amount_cents: amountCents,\n      p_description: description,\n    });\n    if (error) throw new Error(error.message);\n    return data as unknown as PaymentIntent;\n  }\n\n  async releaseMpPreAuth(mpOrderId: string, description: string): Promise<PaymentIntent> {\n    const { data, error } = await this.supabase.rpc('release_mp_preauth_order', {\n      p_mp_order_id: mpOrderId,\n      p_description: description,\n    });\n    if (error) throw new Error(error.message);\n    return data as unknown as PaymentIntent;\n  }\n\n  async cancelMpPreAuth(mpOrderId: string, description: string): Promise<PaymentIntent> {\n    return this.releaseMpPreAuth(mpOrderId, description);\n  }\n\n  async processPayment(\n    bookingId: string,\n    retryCount = 0,\n  ): Promise<{\n    success: boolean;\n    paymentIntentId?: string;\n    error?: string;\n  }> {\n    const MAX_RETRIES = 3;\n\n    try {\n      const intent = await this.createIntent(bookingId);\n\n      if (!intent || !intent.id) {\n        throw new Error('No se pudo crear el payment intent');\n      }\n\n      if (!environment.production) {\n        await this.markAsPaid(intent.id);\n      }\n\n      const status = await this.getStatus(intent.id);\n\n      if (status?.status === 'completed' || status?.status === 'approved') {\n        return {\n          success: true,\n          paymentIntentId: intent.id,\n        };\n      }\n\n      throw new Error('El pago no se completó correctamente');\n    } catch (error: unknown) {\n      if (retryCount < MAX_RETRIES) {\n        await new Promise((resolve) => setTimeout(resolve, 1000 * (retryCount + 1)));\n        return this.processPayment(bookingId, retryCount + 1);\n      }\n\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Error inesperado',\n      };\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/core/services/payments/paypal-booking-gateway.service.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`@core/services/infrastructure/supabase-client.service` import should occur before import of `../interfaces/payment-gateway.interface`","line":9,"column":1,"nodeType":"ImportDeclaration","endLine":9,"endColumn":95,"fix":{"range":[150,370],"text":"import { SupabaseClientService } from '@core/services/infrastructure/supabase-client.service';\nimport {\n  PaymentGateway,\n  PaymentPreferenceResponse,\n  PaymentProvider,\n} from '../interfaces/payment-gateway.interface';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { Injectable, inject } from '@angular/core';\nimport { Observable, from, throwError } from 'rxjs';\nimport { catchError } from 'rxjs/operators';\nimport {\n  PaymentGateway,\n  PaymentPreferenceResponse,\n  PaymentProvider,\n} from '../interfaces/payment-gateway.interface';\nimport { SupabaseClientService } from '@core/services/infrastructure/supabase-client.service';\n\n/**\n * PayPal Create Order Response\n * Response from paypal-create-order Edge Function\n */\ninterface PayPalCreateOrderResponse {\n  success: boolean;\n  order_id: string;\n  approval_url: string;\n  status: string;\n  amount_usd: string;\n  currency: string;\n  split_enabled: boolean;\n  error?: string;\n}\n\n/**\n * PayPal Capture Response\n * Response from paypal-capture-order Edge Function\n */\ninterface PayPalCaptureResponse {\n  success: boolean;\n  capture_id: string;\n  order_id: string;\n  status: string;\n  amount: string;\n  currency: string;\n  booking_id: string;\n  error?: string;\n}\n\n/**\n * Gateway de PayPal para Bookings (Internacional)\n *\n * Abstrae la integración con las Edge Functions de PayPal:\n * - paypal-create-order: Crea orden de pago con split payments (85/15)\n * - paypal-capture-order: Captura orden después de aprobación del usuario\n *\n * Implementa la interfaz PaymentGateway para compatibilidad multi-provider.\n *\n * Características:\n * - Split payments: 85% dueño, 15% plataforma (INSTANT disbursement)\n * - Multi-moneda: Convierte ARS → USD automáticamente\n * - PayPal Orders API v2\n * - Webhook integration para confirmación automática\n *\n * Ventajas:\n * - Separación de capas (UI no conoce infraestructura)\n * - Facilita testing (mockear el gateway)\n * - Manejo centralizado de errores\n * - Type-safety con interfaces TypeScript\n */\n@Injectable({\n  providedIn: 'root',\n})\nexport class PayPalBookingGatewayService implements PaymentGateway {\n  readonly provider: PaymentProvider = 'paypal';\n  private readonly supabaseService = inject(SupabaseClientService);\n\n  /**\n   * Crea una orden de pago en PayPal para un booking\n   *\n   * @param bookingId - ID del booking\n   * @param useSplitPayment - Si se debe usar split payment (85/15) - opcional\n   * @returns Observable con la respuesta de PayPal\n   */\n  createBookingPreference(\n    bookingId: string,\n    useSplitPayment = false,\n  ): Observable<PaymentPreferenceResponse> {\n    return from(this._createOrder(bookingId, useSplitPayment)).pipe(\n      catchError((err) => {\n        return throwError(() => new Error(this.formatError(err)));\n      }),\n    );\n  }\n\n  /**\n   * Implementación interna usando async/await\n   */\n  private async _createOrder(\n    bookingId: string,\n    useSplitPayment: boolean,\n  ): Promise<PaymentPreferenceResponse> {\n    const supabase = this.supabaseService.getClient();\n\n    // Obtener token de autenticación\n    const {\n      data: { session },\n    } = await supabase.auth.getSession();\n\n    if (!session) {\n      throw new Error('Usuario no autenticado');\n    }\n\n    // Obtener URL base de Supabase\n    const supabaseUrl = this.getSupabaseUrl();\n    const edgeFunctionUrl = `${supabaseUrl}/functions/v1/paypal-create-order`;\n\n    // Llamar a Edge Function\n    const response = await fetch(edgeFunctionUrl, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        Authorization: `Bearer ${session.access_token}`,\n      },\n      body: JSON.stringify({\n        booking_id: bookingId,\n        use_split_payment: useSplitPayment,\n      }),\n    });\n\n    if (!response.ok) {\n      const errorData = await response.json().catch(() => ({\n        error: `HTTP ${response.status}: ${response.statusText}`,\n      }));\n      throw new Error(errorData.error || 'Error al crear orden de pago en PayPal');\n    }\n\n    const data: PayPalCreateOrderResponse = await response.json();\n\n    if (!data.success) {\n      throw new Error(data.error || 'Error desconocido al crear orden de PayPal');\n    }\n\n    // Convertir a formato genérico PaymentPreferenceResponse\n    return {\n      success: true,\n      preference_id: data.order_id,\n      init_point: data.approval_url,\n      amount_usd: parseFloat(data.amount_usd),\n      currency: data.currency,\n      provider: 'paypal',\n    };\n  }\n\n  /**\n   * Captura una orden de PayPal después de la aprobación del usuario\n   *\n   * Este método debe llamarse después de que el usuario apruebe el pago en PayPal\n   * y sea redirigido de vuelta a la aplicación.\n   *\n   * @param orderId - ID de la orden de PayPal\n   * @returns Observable con la respuesta de captura\n   */\n  captureOrder(orderId: string): Observable<PayPalCaptureResponse> {\n    return from(this._captureOrder(orderId)).pipe(\n      catchError((err) => {\n        return throwError(() => new Error(this.formatError(err)));\n      }),\n    );\n  }\n\n  /**\n   * Implementación interna de captura\n   */\n  private async _captureOrder(orderId: string): Promise<PayPalCaptureResponse> {\n    const supabase = this.supabaseService.getClient();\n\n    const {\n      data: { session },\n    } = await supabase.auth.getSession();\n\n    if (!session) {\n      throw new Error('Usuario no autenticado');\n    }\n\n    const supabaseUrl = this.getSupabaseUrl();\n    const edgeFunctionUrl = `${supabaseUrl}/functions/v1/paypal-capture-order`;\n\n    const response = await fetch(edgeFunctionUrl, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        Authorization: `Bearer ${session.access_token}`,\n      },\n      body: JSON.stringify({ order_id: orderId }),\n    });\n\n    if (!response.ok) {\n      const errorData = await response.json().catch(() => ({\n        error: `HTTP ${response.status}: ${response.statusText}`,\n      }));\n      throw new Error(errorData.error || 'Error al capturar pago de PayPal');\n    }\n\n    const data: PayPalCaptureResponse = await response.json();\n\n    if (!data.success) {\n      throw new Error(data.error || 'Error desconocido al capturar orden de PayPal');\n    }\n\n    return data;\n  }\n\n  /**\n   * Verifica si una orden de PayPal sigue válida\n   *\n   * @param orderId - ID de la orden de PayPal\n   * @returns true si la orden existe y no ha sido capturada\n   */\n  async isPreferenceValid(orderId: string): Promise<boolean> {\n    try {\n      const supabase = this.supabaseService.getClient();\n      const {\n        data: { session },\n      } = await supabase.auth.getSession();\n\n      if (!session) return false;\n\n      // Verificar en la tabla bookings si la orden sigue activa\n      const { data: booking } = await supabase\n        .from('bookings')\n        .select('payment_preference_id, payment_provider, status')\n        .eq('payment_preference_id', orderId)\n        .eq('payment_provider', 'paypal')\n        .single();\n\n      if (!booking) return false;\n\n      // La orden es válida si el booking no ha sido confirmado aún\n      return booking.status === 'pending';\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Redirige al usuario al checkout de PayPal\n   *\n   * @param approvalUrl - URL de aprobación de PayPal\n   * @param openInNewTab - Si true, abre en nueva pestaña (default: false)\n   */\n  redirectToCheckout(approvalUrl: string, openInNewTab = false): void {\n    if (openInNewTab) {\n      window.open(approvalUrl, '_blank');\n    } else {\n      window.location.href = approvalUrl;\n    }\n  }\n\n  /**\n   * Obtiene la URL base de Supabase desde variables de entorno\n   */\n  private getSupabaseUrl(): string {\n    const supabase = this.supabaseService.getClient();\n    // @ts-expect-error - Acceso interno al URL\n    return supabase.supabaseUrl || '';\n  }\n\n  /**\n   * Formatea errores para mostrar al usuario\n   */\n  private formatError(error: unknown): string {\n    if (error && typeof error === 'object' && 'message' in error) {\n      return String(error.message);\n    }\n\n    if (typeof error === 'string') {\n      return error;\n    }\n\n    return 'Error al procesar el pago con PayPal. Por favor intente nuevamente.';\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/core/services/payments/paypal-wallet-gateway.service.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`@core/services/infrastructure/supabase-client.service` import should occur before import of `../interfaces/payment-gateway.interface`","line":9,"column":1,"nodeType":"ImportDeclaration","endLine":9,"endColumn":95,"fix":{"range":[150,372],"text":"import { SupabaseClientService } from '@core/services/infrastructure/supabase-client.service';\nimport {\n  WalletPaymentGateway,\n  WalletDepositResponse,\n  PaymentProvider,\n} from '../interfaces/payment-gateway.interface';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { Injectable, inject } from '@angular/core';\nimport { Observable, from, throwError } from 'rxjs';\nimport { catchError } from 'rxjs/operators';\nimport {\n  WalletPaymentGateway,\n  WalletDepositResponse,\n  PaymentProvider,\n} from '../interfaces/payment-gateway.interface';\nimport { SupabaseClientService } from '@core/services/infrastructure/supabase-client.service';\n\n/**\n * PayPal Wallet Gateway Service\n *\n * Maneja depósitos al wallet usando PayPal como proveedor de pago.\n * Integra con la Edge Function paypal-create-deposit-order.\n *\n * Flujo de depósito:\n * 1. Usuario solicita depósito en USD\n * 2. Se crea una orden de PayPal (paypal-create-deposit-order)\n * 3. Usuario es redirigido a PayPal para aprobar\n * 4. PayPal envía webhook después de pago completado\n * 5. Webhook actualiza wallet balance automáticamente\n *\n * Diferencias vs MercadoPago:\n * - PayPal opera en USD (MercadoPago en ARS)\n * - No requiere conversión de moneda\n * - Procesamiento más rápido (típicamente < 5 segundos)\n */\n@Injectable({\n  providedIn: 'root',\n})\nexport class PayPalWalletGatewayService implements WalletPaymentGateway {\n  readonly provider: PaymentProvider = 'paypal';\n  private readonly supabaseService = inject(SupabaseClientService);\n\n  /**\n   * Crea una orden de PayPal para depósito al wallet\n   *\n   * @param amountUSD - Monto a depositar en USD\n   * @param transactionId - ID de la transacción de wallet\n   * @returns Observable con la respuesta de PayPal\n   */\n  createDepositOrder(amountUSD: number, transactionId: string): Observable<WalletDepositResponse> {\n    return from(this._createDepositOrder(amountUSD, transactionId)).pipe(\n      catchError((err) => {\n        return throwError(() => new Error(this.formatError(err)));\n      }),\n    );\n  }\n\n  /**\n   * Implementación interna usando async/await\n   */\n  private async _createDepositOrder(\n    amountUSD: number,\n    transactionId: string,\n  ): Promise<WalletDepositResponse> {\n    // Validaciones\n    if (amountUSD <= 0) {\n      throw new Error('El monto debe ser mayor a 0');\n    }\n\n    if (!transactionId) {\n      throw new Error('Transaction ID es requerido');\n    }\n\n    const supabase = this.supabaseService.getClient();\n\n    // Obtener token de autenticación\n    const {\n      data: { session },\n    } = await supabase.auth.getSession();\n\n    if (!session) {\n      throw new Error('Usuario no autenticado');\n    }\n\n    // Obtener URL base de Supabase\n    const supabaseUrl = this.getSupabaseUrl();\n    const edgeFunctionUrl = `${supabaseUrl}/functions/v1/paypal-create-deposit-order`;\n\n    // Llamar a Edge Function\n    const response = await fetch(edgeFunctionUrl, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        Authorization: `Bearer ${session.access_token}`,\n      },\n      body: JSON.stringify({\n        amount_usd: amountUSD,\n        transaction_id: transactionId,\n      }),\n    });\n\n    if (!response.ok) {\n      const errorData = await response.json().catch(() => ({\n        error: `HTTP ${response.status}: ${response.statusText}`,\n      }));\n      throw new Error(errorData.error || 'Error al crear orden de depósito en PayPal');\n    }\n\n    const data = await response.json();\n\n    if (!data.success) {\n      throw new Error(data.error || 'Error desconocido al crear orden de PayPal');\n    }\n\n    // Retornar en formato estándar WalletDepositResponse\n    return {\n      success: true,\n      order_id: data.order_id,\n      approval_url: data.approval_url,\n      amount_usd: parseFloat(data.amount_usd),\n      currency: data.currency || 'USD',\n      transaction_id: transactionId,\n      provider: 'paypal',\n    };\n  }\n\n  /**\n   * Verifica si un depósito fue completado exitosamente\n   *\n   * Consulta la tabla wallet_transactions para verificar el estado.\n   *\n   * @param transactionId - ID de la transacción de wallet\n   * @returns true si el depósito fue confirmado\n   */\n  async verifyDeposit(transactionId: string): Promise<boolean> {\n    try {\n      const supabase = this.supabaseService.getClient();\n      const {\n        data: { session },\n      } = await supabase.auth.getSession();\n\n      if (!session) return false;\n\n      // Consultar estado de la transacción\n      const { data: transaction, error } = await supabase\n        .from('wallet_transactions')\n        .select('status, provider')\n        .eq('id', transactionId)\n        .eq('user_id', session.user.id)\n        .eq('provider', 'paypal')\n        .single();\n\n      if (error || !transaction) {\n        console.error('Error verifying PayPal deposit:', error);\n        return false;\n      }\n\n      // La transacción es válida si está confirmada\n      return transaction.status === 'completed' || transaction.status === 'confirmed';\n    } catch (err) {\n      console.error('Error in verifyDeposit:', err);\n      return false;\n    }\n  }\n\n  /**\n   * Obtiene el estado detallado de una transacción de depósito\n   *\n   * @param transactionId - ID de la transacción\n   * @returns Objeto con estado y detalles de la transacción\n   */\n  async getDepositStatus(transactionId: string): Promise<{\n    status: string;\n    provider_transaction_id: string | null;\n    amount: number;\n    currency: string;\n  } | null> {\n    try {\n      const supabase = this.supabaseService.getClient();\n      const {\n        data: { session },\n      } = await supabase.auth.getSession();\n\n      if (!session) return null;\n\n      const { data: transaction, error } = await supabase\n        .from('wallet_transactions')\n        .select('status, provider_transaction_id, amount, currency')\n        .eq('id', transactionId)\n        .eq('user_id', session.user.id)\n        .single();\n\n      if (error || !transaction) {\n        return null;\n      }\n\n      return transaction;\n    } catch (err) {\n      console.error('Error getting deposit status:', err);\n      return null;\n    }\n  }\n\n  /**\n   * Obtiene la URL base de Supabase\n   */\n  private getSupabaseUrl(): string {\n    const supabase = this.supabaseService.getClient();\n    // @ts-expect-error - Acceso interno al URL\n    return supabase.supabaseUrl || '';\n  }\n\n  /**\n   * Formatea errores para mostrar al usuario\n   */\n  private formatError(error: unknown): string {\n    if (error && typeof error === 'object' && 'message' in error) {\n      return String(error.message);\n    }\n\n    if (typeof error === 'string') {\n      return error;\n    }\n\n    return 'Error al procesar el depósito con PayPal. Por favor intente nuevamente.';\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/core/services/payments/pricing.service.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`@core/services/infrastructure/supabase-client.service` import should occur before import of `../../../environments/environment`","line":4,"column":1,"nodeType":"ImportDeclaration","endLine":4,"endColumn":88,"fix":{"range":[52,255],"text":"import { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\nimport { environment } from '../../../environments/environment';\nimport type { VehicleCategory } from '../models';\n"}},{"ruleId":"import/order","severity":1,"message":"`@core/services/geo/distance-calculator.service` import should occur before import of `../../../environments/environment`","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":92,"fix":{"range":[52,347],"text":"import { DistanceCalculatorService } from '@core/services/geo/distance-calculator.service';\nimport { environment } from '../../../environments/environment';\nimport type { VehicleCategory } from '../models';\nimport { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import { Injectable, inject } from '@angular/core';\nimport { environment } from '../../../environments/environment';\nimport type { VehicleCategory } from '../models';\nimport { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\nimport { DistanceCalculatorService } from '@core/services/geo/distance-calculator.service';\n\nexport interface QuoteBreakdown {\n  price_subtotal: number;\n  discount: number;\n  service_fee: number;\n  total: number;\n  // Distance-based pricing fields\n  delivery_fee?: number;\n  delivery_distance_km?: number;\n  distance_risk_tier?: 'local' | 'regional' | 'long_distance';\n  // ✅ NEW: Dynamic pricing flags (Sprint 2)\n  pricing_strategy?: 'dynamic' | 'custom';\n  dynamic_pricing_applied?: boolean;\n}\n\nexport interface LocationCoords {\n  lat: number;\n  lng: number;\n}\n\n// ✅ VehicleCategory imported from ../models (uses base_daily_rate_pct)\n\nexport interface VehicleValueEstimation {\n  estimated_value_usd: number;\n  confidence: 'high' | 'medium' | 'low' | 'none';\n  source: 'pricing_model' | 'category_fallback';\n  category_id?: string;\n  category_name?: string;\n  suggested_daily_rate_usd?: number;\n}\n\nexport interface FipeValueResult {\n  success: boolean;\n  data?: {\n    value_brl: number;\n    value_usd: number;\n    value_ars: number;\n    fipe_code: string;\n    source: string;\n    confidence: string;\n    reference_month: string;\n    brand_found: string;\n    model_found: string;\n  };\n  error?: string;\n  errorCode?: string; // ✅ NEW: Machine-readable error code\n  suggestions?: string[]; // ✅ NEW: Actionable suggestions\n  availableOptions?: {\n    brands?: string[];\n    models?: string[];\n    years?: number[];\n  };\n  timestamp?: string;\n}\n\nexport interface FipeBrand {\n  code: string;\n  name: string;\n}\n\nexport interface FipeModel {\n  code: string;\n  name: string;\n}\n\nexport interface FipeBaseModel {\n  baseName: string;\n  variants: FipeModel[];\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class PricingService {\n  private readonly supabase = injectSupabase();\n  private readonly distanceCalculator = inject(DistanceCalculatorService);\n\n  async quoteBooking(params: {\n    carId: string;\n    start: string;\n    end: string;\n    promoCode?: string;\n    userLocation?: LocationCoords;\n  }): Promise<QuoteBreakdown> {\n    // Get base quote from RPC\n    const { data, error } = await this.supabase.rpc('quote_booking', {\n      p_car_id: params.carId,\n      p_start: params.start,\n      p_end: params.end,\n      p_promo: params.promoCode ?? null,\n    });\n    if (error) throw error;\n    if (!data || data.length === 0) {\n      throw new Error('No se pudo calcular la cotización');\n    }\n\n    const baseQuote = data[0] as QuoteBreakdown;\n\n    // If user location provided, calculate delivery fee\n    if (params.userLocation) {\n      const distanceData = await this.calculateDeliveryFee(params.carId, params.userLocation);\n\n      if (distanceData) {\n        baseQuote.delivery_fee = distanceData.deliveryFeeCents / 100; // Convert to ARS\n        baseQuote.delivery_distance_km = distanceData.distanceKm;\n        baseQuote.distance_risk_tier = distanceData.tier;\n        baseQuote.total += baseQuote.delivery_fee;\n      }\n    }\n\n    return baseQuote;\n  }\n\n  /**\n   * Calculate delivery fee based on distance between user and car\n   * @param carId Car ID\n   * @param userLocation User location coordinates\n   * @returns Delivery fee data or null if car location not available\n   */\n  async calculateDeliveryFee(\n    carId: string,\n    userLocation: LocationCoords,\n  ): Promise<{\n    distanceKm: number;\n    deliveryFeeCents: number;\n    tier: 'local' | 'regional' | 'long_distance';\n  } | null> {\n    // Get car location\n    const { data: car, error } = await this.supabase\n      .from('cars')\n      .select('location_lat, location_lng')\n      .eq('id', carId)\n      .single();\n\n    if (error || !car || !car.location_lat || !car.location_lng) {\n      return null;\n    }\n\n    // Calculate distance\n    const distanceKm = this.distanceCalculator.calculateDistance(\n      userLocation.lat,\n      userLocation.lng,\n      car.location_lat,\n      car.location_lng,\n    );\n\n    // Calculate delivery fee\n    const deliveryFeeCents = this.distanceCalculator.calculateDeliveryFee(distanceKm);\n\n    // Get tier\n    const tier = this.distanceCalculator.getDistanceTier(distanceKm);\n\n    return {\n      distanceKm,\n      deliveryFeeCents,\n      tier,\n    };\n  }\n\n  async cancelWithFee(bookingId: string): Promise<number> {\n    const { data, error } = await this.supabase.rpc('cancel_with_fee', {\n      p_booking_id: bookingId,\n    });\n    if (error) throw error;\n    if (!data || data.length === 0) {\n      throw new Error('No se pudo cancelar la reserva');\n    }\n    return Number(data[0].cancel_fee ?? 0);\n  }\n\n  /**\n   * Get all vehicle categories from database\n   */\n  async getVehicleCategories(): Promise<VehicleCategory[]> {\n    const { data, error } = await this.supabase\n      .from('vehicle_categories')\n      .select(\n        'id, code, name, name_es, base_daily_rate_pct, depreciation_rate_annual, surge_sensitivity, description, display_order, active',\n      )\n      .eq('active', true)\n      .order('display_order');\n\n    if (error) {\n      console.error('[PricingService] Error fetching vehicle categories:', error);\n      return [];\n    }\n    return data || [];\n  }\n\n  /**\n   * Estimate vehicle value using SQL function\n   * Calls estimate_vehicle_value_usd(brand, model, year, country)\n   */\n  async estimateVehicleValue(params: {\n    brand: string;\n    model: string;\n    year: number;\n    country?: string;\n  }): Promise<VehicleValueEstimation | null> {\n    // Call estimate function (note: p_country not used by SQL function)\n    const { data, error } = await this.supabase.rpc('estimate_vehicle_value_usd', {\n      p_brand: params.brand,\n      p_model: params.model,\n      p_year: params.year,\n    });\n\n    if (error) {\n      return null;\n    }\n\n    if (!data || data.length === 0) {\n      return null;\n    }\n\n    const result = data[0];\n\n    // Map SQL column names to frontend interface\n    // SQL returns: estimated_value, confidence_level, data_source, category_id\n    const estimatedValue = result.estimated_value || 0;\n\n    // Calculate suggested daily rate (0.3% of vehicle value per day)\n    const suggestedRate = estimatedValue > 0 ? estimatedValue * 0.003 : undefined;\n\n    // Fetch category name if category_id exists\n    let categoryName: string | undefined;\n    if (result.category_id) {\n      const { data: category } = await this.supabase\n        .from('vehicle_categories')\n        .select('name_es')\n        .eq('id', result.category_id)\n        .single();\n      categoryName = category?.name_es;\n    }\n\n    return {\n      estimated_value_usd: estimatedValue,\n      confidence: result.confidence_level,\n      source: result.data_source,\n      category_id: result.category_id,\n      category_name: categoryName,\n      suggested_daily_rate_usd: suggestedRate,\n    };\n  }\n\n  /**\n   * Get vehicle value in realtime via Edge Function\n   * Calls get-fipe-value Edge Function for fresh market data\n   *\n   * Note: This method requires exact brand/model names from vehicle database\n   * Use brand_text_backup and model_text_backup from database which store exact names\n   */\n  async getFipeValueRealtime(params: {\n    brand: string;\n    model: string;\n    year: number;\n    country?: string;\n  }): Promise<FipeValueResult | null> {\n    try {\n      const url = `${environment.supabaseUrl}/functions/v1/get-fipe-value`;\n\n      const response = await fetch(url, {\n        method: 'POST',\n        headers: {\n          Authorization: `Bearer ${environment.supabaseAnonKey}`,\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          brand: params.brand,\n          model: params.model,\n          year: params.year,\n          country: params.country || 'AR',\n        }),\n      });\n\n      if (!response.ok) {\n        return null;\n      }\n\n      const result: FipeValueResult = await response.json();\n      return result;\n    } catch {\n      return null;\n    }\n  }\n\n  /**\n   * Calculate suggested daily rate for a category\n   * Uses base_rate_multiplier from category\n   */\n  async calculateSuggestedRate(params: {\n    categoryId: string;\n    estimatedValueUsd?: number;\n  }): Promise<number | null> {\n    const { data } = await this.supabase\n      .from('vehicle_categories')\n      .select('base_daily_rate_pct, code')\n      .eq('id', params.categoryId)\n      .single();\n\n    if (!data) {\n      return null;\n    }\n\n    // If we have estimated value, use it with the category's rate percentage\n    if (params.estimatedValueUsd) {\n      // Use the category's base_daily_rate_pct (e.g., 0.0030 = 0.30%)\n      const ratePct = data.base_daily_rate_pct || 0.003; // Fallback to 0.3% if null\n      return params.estimatedValueUsd * ratePct;\n    }\n\n    // Otherwise use category default with average values\n    // Assume average vehicle value by category:\n    // Economy: $8k, Standard: $15k, Premium: $35k, Luxury: $80k\n    const averageValues: Record<string, number> = {\n      economy: 8000,\n      standard: 15000,\n      premium: 35000,\n      luxury: 80000,\n    };\n\n    const categoryCode = data.code?.toLowerCase() || '';\n    const categoryName = Object.keys(averageValues).find((name) => categoryCode.includes(name));\n    const avgValue = categoryName ? averageValues[categoryName] : 15000;\n\n    // Use the category's base_daily_rate_pct\n    const ratePct = data.base_daily_rate_pct || 0.003; // Fallback to 0.3% if null\n    return avgValue * ratePct;\n  }\n\n  /**\n   * Get all vehicle brands from FIPE API\n   * Calls public FIPE API directly (no auth required)\n   */\n  async getFipeBrands(): Promise<FipeBrand[]> {\n    try {\n      const response = await fetch('https://parallelum.com.br/fipe/api/v2/cars/brands');\n\n      if (!response.ok) {\n        return [];\n      }\n\n      const brands: FipeBrand[] = await response.json();\n      return brands;\n    } catch {\n      return [];\n    }\n  }\n\n  /**\n   * Get all vehicle models for a specific brand from FIPE API\n   * @param brandCode FIPE brand code (e.g., \"59\" for VW)\n   */\n  async getFipeModels(brandCode: string): Promise<FipeModel[]> {\n    try {\n      const response = await fetch(\n        `https://parallelum.com.br/fipe/api/v2/cars/brands/${brandCode}/models`,\n      );\n\n      if (!response.ok) {\n        return [];\n      }\n\n      const models: FipeModel[] = await response.json();\n      return models;\n    } catch {\n      return [];\n    }\n  }\n\n  /**\n   * Extract base model name from full model name\n   * e.g., \"Gol 1.0 Flex 12V 5p\" -> \"Gol\"\n   * e.g., \"Corolla XEi 2.0\" -> \"Corolla\"\n   */\n  extractBaseModelName(fullModelName: string): string {\n    // Remove engine specs (numbers with dots)\n    let baseName = fullModelName.replace(/\\s+\\d+\\.\\d+.*$/i, '');\n\n    // Remove version info in parentheses\n    baseName = baseName.replace(/\\s*\\(.*?\\)\\s*/g, ' ');\n\n    // Remove common version suffixes\n    baseName = baseName.replace(/\\s+(Flex|Turbo|TDI|TSI|GTI|Sport|Plus|Life|Comfort).*$/i, '');\n\n    // Clean up extra spaces\n    baseName = baseName.trim().replace(/\\s+/g, ' ');\n\n    return baseName;\n  }\n\n  /**\n   * Group models by base name\n   * Returns grouped models with first variant as representative\n   */\n  groupModelsByBaseName(models: FipeModel[]): FipeBaseModel[] {\n    const grouped = new Map<string, FipeModel[]>();\n\n    for (const model of models) {\n      const baseName = this.extractBaseModelName(model.name);\n\n      if (!grouped.has(baseName)) {\n        grouped.set(baseName, []);\n      }\n\n      grouped.get(baseName)!.push(model);\n    }\n\n    // Convert to array and return\n    return Array.from(grouped.entries()).map(([baseName, variants]) => ({\n      baseName,\n      variants,\n    }));\n  }\n\n  /**\n   * Get FIPE models grouped by base name\n   * Returns simplified list with one entry per model type\n   */\n  async getFipeBaseModels(brandCode: string): Promise<FipeBaseModel[]> {\n    const allModels = await this.getFipeModels(brandCode);\n    return this.groupModelsByBaseName(allModels);\n  }\n\n  /**\n   * Search FIPE value using base model name + year\n   * Automatically finds best matching variant for the year\n   */\n  async getFipeValueByBaseModel(params: {\n    brand: string;\n    baseModel: string;\n    year: number;\n    brandCode: string;\n    country?: string;\n  }): Promise<FipeValueResult | null> {\n    try {\n      // Get all variants for this base model\n      const allModels = await this.getFipeModels(params.brandCode);\n      const baseName = params.baseModel;\n\n      // Find variants matching base name\n      const matchingVariants = allModels.filter((model) => {\n        const modelBaseName = this.extractBaseModelName(model.name);\n        return modelBaseName.toLowerCase() === baseName.toLowerCase();\n      });\n\n      if (matchingVariants.length === 0) {\n        return {\n          success: false,\n          error: `No se encontraron variantes para el modelo ${baseName}`,\n        };\n      }\n\n      // Try each variant until we find one with data for this year\n      for (const variant of matchingVariants) {\n        const result = await this.getFipeValueRealtime({\n          brand: params.brand,\n          model: variant.name,\n          year: params.year,\n          country: params.country || 'AR',\n        });\n\n        if (result && result.success) {\n          return result;\n        }\n      }\n\n      // No variant had data for this year\n      return {\n        success: false,\n        error: `No se encontró información de precio para ${baseName} ${params.year}`,\n      };\n    } catch {\n      return null;\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/core/services/payments/settlement.service.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`../models/fgo-v1-1.model` import should occur after import of `@core/services/infrastructure/logger.service`","line":4,"column":1,"nodeType":"ImportDeclaration","endLine":15,"endColumn":35,"fix":{"range":[155,977],"text":"import { SupabaseClientService } from '@core/services/infrastructure/supabase-client.service';\nimport { FgoV1_1Service } from '@core/services/verification/fgo-v1-1.service';\nimport { RiskMatrixService } from '@core/services/verification/risk-matrix.service';\nimport { FgoService } from '@core/services/verification/fgo.service';\nimport { DamageDetectionService } from '@core/services/verification/damage-detection.service';\nimport { PaymentAuthorizationService } from './payment-authorization.service';\nimport { LoggerService } from '@core/services/infrastructure/logger.service';\nimport {\n  EligibilityResult,\n  WaterfallResult,\n  WaterfallBreakdown,\n  InspectionStage,\n  BookingInspection,\n  CurrencyCode,\n  centsToUsd,\n  usdToCents,\n  calculateWaterfallTotal,\n  isInspectionComplete,\n} from '../models/fgo-v1-1.model';\n"}},{"ruleId":"import/order","severity":1,"message":"`./payment-authorization.service` import should occur after import of `@core/services/infrastructure/logger.service`","line":21,"column":1,"nodeType":"ImportDeclaration","endLine":21,"endColumn":79,"fix":{"range":[820,977],"text":"import { LoggerService } from '@core/services/infrastructure/logger.service';\nimport { PaymentAuthorizationService } from './payment-authorization.service';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import { Injectable, signal, inject } from '@angular/core';\nimport { firstValueFrom } from 'rxjs';\nimport { SupabaseClient } from '@supabase/supabase-js';\nimport {\n  EligibilityResult,\n  WaterfallResult,\n  WaterfallBreakdown,\n  InspectionStage,\n  BookingInspection,\n  CurrencyCode,\n  centsToUsd,\n  usdToCents,\n  calculateWaterfallTotal,\n  isInspectionComplete,\n} from '../models/fgo-v1-1.model';\nimport { SupabaseClientService } from '@core/services/infrastructure/supabase-client.service';\nimport { FgoV1_1Service } from '@core/services/verification/fgo-v1-1.service';\nimport { RiskMatrixService } from '@core/services/verification/risk-matrix.service';\nimport { FgoService } from '@core/services/verification/fgo.service';\nimport { DamageDetectionService } from '@core/services/verification/damage-detection.service';\nimport { PaymentAuthorizationService } from './payment-authorization.service';\nimport { LoggerService } from '@core/services/infrastructure/logger.service';\n\n/**\n * Tipo de daño reportado\n */\nexport type DamageType =\n  | 'scratch' // Rayón\n  | 'dent' // Abolladura\n  | 'broken_glass' // Vidrio roto\n  | 'tire_damage' // Daño en neumático\n  | 'mechanical' // Falla mecánica\n  | 'interior' // Daño interior\n  | 'missing_item' // Artículo faltante\n  | 'other'; // Otro\n\n/**\n * Daño individual reportado\n */\nexport interface DamageItem {\n  type: DamageType;\n  description: string;\n  estimatedCostUsd: number;\n  photos: string[]; // URLs de evidencia\n  severity: 'minor' | 'moderate' | 'severe';\n}\n\n/**\n * Claim (reclamo) de siniestro\n */\nexport interface Claim {\n  id: string;\n  bookingId: string;\n  reportedBy: string; // locador_id\n  damages: DamageItem[];\n  totalEstimatedCostUsd: number;\n  status: 'draft' | 'submitted' | 'under_review' | 'approved' | 'rejected' | 'paid' | 'processing';\n  notes?: string;\n  createdAt: Date;\n  updatedAt: Date;\n  // P0-SECURITY: Lock fields for optimistic locking\n  lockedAt?: Date;\n  lockedBy?: string;\n  processedAt?: Date;\n}\n\n/**\n * Resultado de procesamiento de claim\n */\nexport interface ClaimProcessingResult {\n  ok: boolean;\n  claim: Claim;\n  eligibility?: EligibilityResult | null;\n  waterfall?: WaterfallResult;\n  error?: string;\n}\n\n/**\n * Servicio de Settlement (Liquidación de Siniestros)\n *\n * Orquesta el flujo completo:\n * 1. Validar evidencias (inspecciones check-in/out)\n * 2. Crear claim con daños reportados\n * 3. Evaluar elegibilidad FGO\n * 4. Ejecutar waterfall de cobros\n * 5. Actualizar estado del booking\n */\n@Injectable({\n  providedIn: 'root',\n})\nexport class SettlementService {\n  private readonly supabaseClient: SupabaseClient;\n\n  // Estado reactivo\n  readonly processing = signal(false);\n  readonly currentClaim = signal<Claim | null>(null);\n  readonly error = signal<string | null>(null);\n\n  private readonly damageDetectionService = inject(DamageDetectionService);\n  private readonly paymentAuthorizationService = inject(PaymentAuthorizationService);\n  private readonly logger = inject(LoggerService).createChildLogger('Settlement');\n\n  constructor(\n    private readonly supabaseService: SupabaseClientService,\n    private readonly fgoV1_1Service: FgoV1_1Service,\n    private readonly riskMatrixService: RiskMatrixService,\n    private readonly fgoService: FgoService,\n  ) {\n    this.supabaseClient = this.supabaseService.getClient();\n  }\n\n  // ============================================================================\n  // VALIDACIÓN DE EVIDENCIAS\n  // ============================================================================\n\n  /**\n   * Valida que un booking tenga inspecciones completas (check-in y check-out)\n   */\n  async validateInspections(\n    bookingId: string,\n  ): Promise<{ valid: boolean; missing: InspectionStage[] }> {\n    try {\n      const inspections = await firstValueFrom(this.fgoV1_1Service.getInspections(bookingId));\n\n      const hasCheckIn = inspections.some((i) => i.stage === 'check_in' && isInspectionComplete(i));\n      const hasCheckOut = inspections.some(\n        (i) => i.stage === 'check_out' && isInspectionComplete(i),\n      );\n\n      const missing: InspectionStage[] = [];\n      if (!hasCheckIn) missing.push('check_in');\n      if (!hasCheckOut) missing.push('check_out');\n\n      return {\n        valid: missing.length === 0,\n        missing,\n      };\n    } catch {\n      return { valid: false, missing: ['check_in', 'check_out'] };\n    }\n  }\n\n  /**\n   * Compara check-in vs check-out para detectar daños nuevos automáticamente\n   *\n   * Utiliza análisis de imágenes para detectar cambios entre inspecciones.\n   * Retorna array de daños detectados automáticamente.\n   */\n  async compareDamages(bookingId: string): Promise<DamageItem[]> {\n    try {\n      const inspections = await firstValueFrom(this.fgoV1_1Service.getInspections(bookingId));\n\n      const checkIn = inspections.find((i) => i.stage === 'check_in');\n      const checkOut = inspections.find((i) => i.stage === 'check_out');\n\n      if (!checkIn || !checkOut) {\n        console.warn(`compareDamages: Missing inspections for booking ${bookingId}`);\n        return [];\n      }\n\n      // Extraer URLs de fotos\n      const checkInImages = this.extractImageUrls(checkIn);\n      const checkOutImages = this.extractImageUrls(checkOut);\n\n      if (checkInImages.length === 0 || checkOutImages.length === 0) {\n        console.warn(`compareDamages: No images to analyze for booking ${bookingId}`);\n        return [];\n      }\n\n      // Analizar imágenes con detección automática\n      const analysisResult = await this.damageDetectionService.analyzeImages(\n        checkInImages,\n        checkOutImages,\n      );\n\n      if (!analysisResult.success) {\n        console.error(\n          `compareDamages: Analysis failed for booking ${bookingId}:`,\n          analysisResult.error,\n        );\n        return [];\n      }\n\n      // Convertir resultados a DamageItem[]\n      return this.damageDetectionService.convertToDamageItems(analysisResult.damages);\n    } catch (error) {\n      console.error(`compareDamages: Error analyzing damages for booking ${bookingId}:`, error);\n      return [];\n    }\n  }\n\n  /**\n   * Extrae URLs de imágenes de una inspección\n   * @private\n   */\n  private extractImageUrls(inspection: BookingInspection | undefined): string[] {\n    if (!inspection) return [];\n\n    const images: string[] = [];\n    const insp = inspection as unknown as {\n      photos?: string[];\n      images?: string[];\n      photo_urls?: string[];\n    };\n\n    // Suportar diferentes estructuras de almacenamiento de fotos\n    if (Array.isArray(insp.photos)) {\n      images.push(...insp.photos);\n    }\n\n    if (Array.isArray(insp.images)) {\n      images.push(...insp.images);\n    }\n\n    if (insp.photo_urls) {\n      const urls = insp.photo_urls;\n      if (Array.isArray(urls)) {\n        images.push(...urls);\n      }\n    }\n\n    // Filtrar URLs vacías y duplicadas\n    return Array.from(new Set(images.filter((url) => url && typeof url === 'string')));\n  }\n\n  // ============================================================================\n  // GESTIÓN DE CLAIMS\n  // ============================================================================\n\n  /**\n   * Crea un claim de siniestro\n   * P0-SECURITY: Includes anti-fraud validation before creating claim\n   */\n  async createClaim(\n    bookingId: string,\n    damages: DamageItem[],\n    notes?: string,\n  ): Promise<Claim | null> {\n    try {\n      this.processing.set(true);\n      this.error.set(null);\n\n      // Validar evidencias\n      const validation = await this.validateInspections(bookingId);\n      if (!validation.valid) {\n        this.error.set(`Faltan inspecciones: ${validation.missing.join(', ')}`);\n        return null;\n      }\n\n      // Calcular total\n      const totalEstimatedCostUsd = damages.reduce((sum, d) => sum + d.estimatedCostUsd, 0);\n\n      // Obtener usuario actual\n      const {\n        data: { user },\n      } = await this.supabaseClient.auth.getUser();\n      if (!user) {\n        this.error.set('Usuario no autenticado');\n        return null;\n      }\n\n      // P0-SECURITY: Anti-fraud validation\n      const fraudCheck = await this.validateClaimAntiFraud(\n        bookingId,\n        user.id,\n        totalEstimatedCostUsd,\n      );\n      if (fraudCheck.blocked) {\n        this.error.set(fraudCheck.blockReason || 'Claim bloqueado por validación anti-fraude');\n        return null;\n      }\n\n      // Log warnings for manual review (don't block)\n      if (fraudCheck.warnings && fraudCheck.warnings.length > 0) {\n        console.warn('[SettlementService] Claim fraud warnings:', {\n          bookingId,\n          userId: user.id,\n          totalEstimatedCostUsd,\n          warnings: fraudCheck.warnings,\n        });\n      }\n\n      // P0-SECURITY: Generate claim ID server-side (not client-side)\n      const { data: claimData, error: insertError } = await this.supabaseClient\n        .from('claims')\n        .insert({\n          booking_id: bookingId,\n          reported_by: user.id,\n          damages: damages,\n          total_estimated_cost_usd: totalEstimatedCostUsd,\n          status: 'draft',\n          notes,\n          fraud_warnings: fraudCheck.warnings || [],\n          owner_claims_30d: fraudCheck.ownerClaims30d || 0,\n        })\n        .select('id')\n        .single();\n\n      // Fallback to in-memory claim if DB insert fails (for backwards compatibility)\n      const claimId = claimData?.id || crypto.randomUUID();\n      if (insertError) {\n        console.warn(\n          '[SettlementService] Could not persist claim to DB, using in-memory:',\n          insertError,\n        );\n      }\n\n      const claim: Claim = {\n        id: claimId,\n        bookingId,\n        reportedBy: user.id,\n        damages,\n        totalEstimatedCostUsd,\n        status: 'draft',\n        notes,\n        createdAt: new Date(),\n        updatedAt: new Date(),\n      };\n\n      this.currentClaim.set(claim);\n      return claim;\n    } catch (err) {\n      console.error('[SettlementService] Error creating claim:', err);\n      this.error.set('Error al crear el claim');\n      return null;\n    } finally {\n      this.processing.set(false);\n    }\n  }\n\n  /**\n   * P0-SECURITY: Anti-fraud validation for claims\n   * Calls the database function that checks for:\n   * - Short booking duration (<24h)\n   * - High claim frequency (3+ in 30 days)\n   * - Unusually high amounts\n   * - Suspicious round numbers\n   */\n  private async validateClaimAntiFraud(\n    bookingId: string,\n    ownerId: string,\n    totalEstimatedUsd: number,\n  ): Promise<{\n    ok: boolean;\n    blocked: boolean;\n    blockReason?: string;\n    warnings?: Array<{ type: string; message: string; value?: number }>;\n    ownerClaims30d?: number;\n  }> {\n    try {\n      const { data, error } = await this.supabaseClient.rpc('validate_claim_anti_fraud', {\n        p_booking_id: bookingId,\n        p_owner_id: ownerId,\n        p_total_estimated_usd: totalEstimatedUsd,\n      });\n\n      if (error) {\n        console.warn('[SettlementService] Anti-fraud check failed, allowing claim:', error);\n        // Don't block if validation fails - fail open for UX\n        return { ok: true, blocked: false };\n      }\n\n      const result = data as {\n        ok: boolean;\n        blocked: boolean;\n        block_reason?: string;\n        warnings?: Array<{ type: string; message: string; value?: number }>;\n        owner_claims_30d?: number;\n      };\n\n      return {\n        ok: result.ok,\n        blocked: result.blocked,\n        blockReason: result.block_reason,\n        warnings: result.warnings,\n        ownerClaims30d: result.owner_claims_30d,\n      };\n    } catch (err) {\n      console.warn('[SettlementService] Anti-fraud validation exception:', err);\n      // Fail open - don't block on errors\n      return { ok: true, blocked: false };\n    }\n  }\n\n  /**\n   * Evalúa elegibilidad de un claim sin ejecutar cobros\n   */\n  async evaluateClaim(claim: Claim): Promise<EligibilityResult | null> {\n    try {\n      this.processing.set(true);\n      this.error.set(null);\n\n      // Obtener snapshot de riesgo\n      const snapshot = await firstValueFrom(this.fgoV1_1Service.getRiskSnapshot(claim.bookingId));\n      if (!snapshot) {\n        this.error.set('No se encontró snapshot de riesgo para el booking');\n        return null;\n      }\n\n      // Convertir total a centavos (moneda local)\n      const claimAmountCents = usdToCents(claim.totalEstimatedCostUsd * snapshot.fxSnapshot);\n\n      // Evaluar elegibilidad\n      const eligibility = await firstValueFrom(\n        this.fgoV1_1Service.assessEligibility({\n          bookingId: claim.bookingId,\n          claimAmountCents,\n        }),\n      );\n\n      return eligibility;\n    } catch {\n      this.error.set('Error al evaluar elegibilidad');\n      return null;\n    } finally {\n      this.processing.set(false);\n    }\n  }\n\n  /**\n   * Procesa un claim completo: evalúa y ejecuta waterfall\n   * IMPORTANTE: Solo ejecutable por admins o sistema\n   * P0-SECURITY: Implementa lock optimista para prevenir double-spend\n   */\n  async processClaim(claim: Claim): Promise<ClaimProcessingResult> {\n    try {\n      this.processing.set(true);\n      this.error.set(null);\n\n      // P0-SECURITY: Acquire optimistic lock BEFORE processing\n      const lockResult = await this.acquireClaimLock(claim.id);\n      if (!lockResult.ok) {\n        return {\n          ok: false,\n          claim,\n          error: lockResult.error || 'Claim is already being processed by another user',\n        };\n      }\n\n      // 1. Get risk policy and snapshot\n      const snapshot = await firstValueFrom(this.fgoV1_1Service.getRiskSnapshot(claim.bookingId));\n      if (!snapshot) {\n        return {\n          ok: false,\n          claim,\n          error: 'No se encontró snapshot de riesgo',\n        };\n      }\n\n      const { data: booking } = await this.supabaseClient\n        .from('bookings')\n        .select('car_id')\n        .eq('id', claim.bookingId)\n        .single();\n      if (!booking) {\n        return {\n          ok: false,\n          claim,\n          error: 'No se encontró la reserva',\n        };\n      }\n\n      const { data: car } = await this.supabaseClient\n        .from('cars')\n        .select('price_per_day')\n        .eq('id', booking.car_id)\n        .single();\n      if (!car) {\n        return {\n          ok: false,\n          claim,\n          error: 'No se encontró el auto',\n        };\n      }\n\n      const policy = await this.riskMatrixService.getRiskPolicy(car.price_per_day);\n      if (!policy) {\n        return {\n          ok: false,\n          claim,\n          error: 'No se encontró política de riesgo',\n        };\n      }\n\n      // 2. Evaluate eligibility\n      const eligibility = await this.evaluateClaim(claim);\n      if (!eligibility || !eligibility.eligible) {\n        return {\n          ok: false,\n          claim: { ...claim, status: 'rejected', updatedAt: new Date() },\n          eligibility,\n          error: `Claim no elegible: ${eligibility?.reasons.join(', ')}`,\n        };\n      }\n\n      // 3. Execute waterfall\n      const claimAmountCents = usdToCents(claim.totalEstimatedCostUsd * snapshot.fxSnapshot);\n      let remainingCents = claimAmountCents;\n      const breakdown: WaterfallBreakdown = {\n        holdCaptured: 0,\n        walletDebited: 0,\n        extraCharged: 0,\n        fgoPaid: 0,\n        remainingUncovered: 0,\n      };\n\n      if (snapshot.hasCard) {\n        // With credit card\n        const holdAmount = snapshot.estimatedHoldAmount ?? 0;\n        const captureAmount = Math.min(remainingCents, holdAmount);\n\n        // Implement partial capture logic with payment provider\n        if (captureAmount > 0 && snapshot.authorizedPaymentId) {\n          try {\n            // Convert cents to ARS for payment provider (MercadoPago uses ARS)\n            // Note: captureAmount is in USD cents, need to convert to ARS\n            const captureAmountArs = Math.round((captureAmount * snapshot.fxSnapshot) / 100);\n\n            // Capture the partial amount from the credit card hold\n            const captureResult = await firstValueFrom(\n              this.paymentAuthorizationService.captureAuthorization(\n                snapshot.authorizedPaymentId,\n                captureAmountArs,\n              ),\n            );\n\n            if (captureResult.ok) {\n              breakdown.holdCaptured = captureAmount;\n              this.logger.info(\n                `Partial capture: ${centsToUsd(captureAmount)} USD ` +\n                  `(${captureAmountArs} ARS) from auth ${snapshot.authorizedPaymentId}`,\n              );\n            } else {\n              // If capture fails, log the error but continue with waterfall\n              this.logger.error(\n                `Partial capture failed for auth ${snapshot.authorizedPaymentId}`,\n                String(captureResult.error),\n              );\n              // Don't mark as captured if it failed\n              breakdown.holdCaptured = 0;\n            }\n          } catch (error) {\n            this.logger.error('Partial capture exception', String(error));\n            // Don't mark as captured if there was an exception\n            breakdown.holdCaptured = 0;\n          }\n        } else {\n          // If no authorization ID or amount is 0, just record what we would have captured\n          breakdown.holdCaptured = captureAmount;\n          if (!snapshot.authorizedPaymentId && captureAmount > 0) {\n            this.logger.warn('No authorization ID available for capture');\n          }\n        }\n\n        remainingCents -= breakdown.holdCaptured;\n      } else {\n        // Without credit card - debit from wallet security deposit\n        const securityCredit = snapshot.estimatedDeposit ?? 0;\n        const maxDebitCents = Math.min(remainingCents, securityCredit);\n\n        if (maxDebitCents > 0) {\n          // Call wallet debit RPC to actually debit from renter's wallet\n          const debitResult = await this.debitWalletForDamage(\n            claim.bookingId,\n            claim.id,\n            centsToUsd(maxDebitCents), // Convert cents to USD for RPC\n          );\n\n          if (debitResult.success) {\n            // Convert debited USD back to cents for breakdown\n            breakdown.walletDebited = usdToCents(debitResult.debitedAmountUsd);\n            remainingCents -= breakdown.walletDebited;\n            this.logger.info(\n              `Wallet debit: ${debitResult.debitedAmountUsd} USD for booking ${claim.bookingId}`,\n            );\n          } else {\n            // Wallet debit failed or insufficient funds\n            // FGO will cover everything (per user decision)\n            this.logger.warn(\n              `Wallet debit failed: ${debitResult.error}. FGO will cover full amount.`,\n            );\n            breakdown.walletDebited = 0;\n          }\n        }\n        // Note: No top-up logic needed - FGO covers any remaining amount\n      }\n\n      // FGO Coverage - FGO covers ALL remaining (per business decision)\n      // This ensures renters are never left with uncovered damages\n      if (remainingCents > 0) {\n        // FGO covers the full remaining amount (not limited by maxCoverCents)\n        // Business decision: FGO absorbs all risk when renter wallet insufficient\n        const fgoCoverage = remainingCents;\n\n        // Log if exceeding normal coverage limits (for monitoring)\n        if (fgoCoverage > eligibility.maxCoverCents) {\n          this.logger.warn(\n            `FGO covering ${centsToUsd(fgoCoverage)} USD exceeds limit ` +\n              `${centsToUsd(eligibility.maxCoverCents)} USD for claim ${claim.id}`,\n          );\n        }\n\n        try {\n          // Convert from cents to USD for FGO service\n          const fgoAmountUsd = centsToUsd(fgoCoverage);\n\n          // Record the FGO payout in the ledger\n          // This creates an audit trail and updates the FGO reserve balance\n          await this.fgoService.addPayout(\n            fgoAmountUsd,\n            claim.bookingId,\n            snapshot.fxSnapshot, // Exchange rate at time of booking\n          );\n\n          // Track successful FGO payout in breakdown\n          breakdown.fgoPaid = fgoCoverage;\n          remainingCents = 0; // FGO covers everything\n\n          // Log for audit trail\n          this.logger.info(`FGO payout: ${fgoAmountUsd} USD for booking ${claim.bookingId}`);\n        } catch (fgoError) {\n          // If FGO payout fails, log error but continue with settlement\n          // The claim still needs to be processed even if FGO recording fails\n          this.logger.error('FGO payout recording failed', String(fgoError));\n\n          // Still mark as paid in breakdown (payment intent exists)\n          // Manual reconciliation may be needed\n          breakdown.fgoPaid = fgoCoverage;\n          remainingCents = 0; // Mark as covered for claim processing\n        }\n      }\n\n      breakdown.remainingUncovered = remainingCents;\n\n      const waterfallResult: WaterfallResult = {\n        ok: true,\n        bookingId: claim.bookingId,\n        totalClaimCents: claimAmountCents,\n        breakdown,\n        executedAt: new Date(),\n        eligibility: eligibility,\n      };\n\n      // 4. Update claim as paid in DB (releases lock)\n      await this.markClaimAsPaid(claim.id);\n\n      const updatedClaim: Claim = {\n        ...claim,\n        status: 'paid',\n        updatedAt: new Date(),\n        processedAt: new Date(),\n      };\n\n      this.currentClaim.set(updatedClaim);\n\n      return {\n        ok: true,\n        claim: updatedClaim,\n        eligibility,\n        waterfall: waterfallResult,\n      };\n    } catch (_error) {\n      // P0-SECURITY: Release lock on failure so claim can be retried\n      await this.releaseClaimLock(claim.id, 'approved');\n\n      this.error.set('Error al procesar claim');\n      return {\n        ok: false,\n        claim,\n        error: String(_error),\n      };\n    } finally {\n      this.processing.set(false);\n    }\n  }\n\n  // ============================================================================\n  // SIMULADORES Y HELPERS\n  // ============================================================================\n\n  /**\n   * Simula el resultado de un waterfall sin ejecutarlo (dry-run)\n   */\n  async simulateWaterfall(\n    bookingId: string,\n    claimAmountUsd: number,\n  ): Promise<{\n    eligibility: EligibilityResult | null;\n    estimatedBreakdown: Partial<WaterfallBreakdown> | null;\n  }> {\n    try {\n      // Obtener snapshot\n      const snapshot = await firstValueFrom(this.fgoV1_1Service.getRiskSnapshot(bookingId));\n      if (!snapshot) {\n        return { eligibility: null, estimatedBreakdown: null };\n      }\n\n      // Evaluar elegibilidad\n      const claimAmountCents = usdToCents(claimAmountUsd * snapshot.fxSnapshot);\n      const eligibility = await firstValueFrom(\n        this.fgoV1_1Service.assessEligibility({\n          bookingId,\n          claimAmountCents,\n        }),\n      );\n\n      if (!eligibility) {\n        return { eligibility: null, estimatedBreakdown: null };\n      }\n\n      // Simular breakdown\n      let remaining = claimAmountCents;\n      const breakdown: WaterfallBreakdown = {\n        holdCaptured: 0,\n        walletDebited: 0,\n        extraCharged: 0,\n        fgoPaid: 0,\n        remainingUncovered: 0,\n      };\n\n      // STEP 1: Hold\n      if (snapshot.hasCard && snapshot.estimatedHoldAmount) {\n        breakdown.holdCaptured = Math.min(remaining, snapshot.estimatedHoldAmount);\n        remaining -= breakdown.holdCaptured;\n      }\n\n      // STEP 2: Wallet\n      if (snapshot.hasWalletSecurity && snapshot.estimatedDeposit && remaining > 0) {\n        breakdown.walletDebited = Math.min(remaining, snapshot.estimatedDeposit);\n        remaining -= breakdown.walletDebited;\n      }\n\n      // STEP 3: Extra (hasta franquicia)\n      if (remaining > 0) {\n        const franchiseCents = snapshot.franchiseUsd * 100 * snapshot.fxSnapshot;\n        const alreadyCharged = breakdown.holdCaptured + breakdown.walletDebited;\n        const maxExtra = Math.max(0, franchiseCents - alreadyCharged);\n\n        breakdown.extraCharged = Math.min(remaining, maxExtra);\n        remaining -= breakdown.extraCharged;\n      }\n\n      // STEP 4: FGO\n      if (remaining > 0) {\n        breakdown.fgoPaid = Math.min(remaining, eligibility.maxCoverCents);\n        remaining -= breakdown.fgoPaid;\n      }\n\n      breakdown.remainingUncovered = remaining;\n\n      return { eligibility, estimatedBreakdown: breakdown };\n    } catch {\n      return { eligibility: null, estimatedBreakdown: null };\n    }\n  }\n\n  /**\n   * Calcula el costo estimado de daños según severidad y tipo\n   */\n  estimateDamageCost(type: DamageType, severity: 'minor' | 'moderate' | 'severe'): number {\n    // Costos base en USD\n    const baseCosts: Record<DamageType, number> = {\n      scratch: 50,\n      dent: 150,\n      broken_glass: 300,\n      tire_damage: 200,\n      mechanical: 500,\n      interior: 100,\n      missing_item: 80,\n      other: 100,\n    };\n\n    const multipliers = {\n      minor: 1.0,\n      moderate: 2.0,\n      severe: 4.0,\n    };\n\n    return baseCosts[type] * multipliers[severity];\n  }\n\n  /**\n   * Formatea un breakdown de waterfall para mostrar al usuario\n   */\n  formatBreakdown(breakdown: WaterfallBreakdown, currency: CurrencyCode = 'USD'): string {\n    const parts: string[] = [];\n    const symbol = currency === 'USD' ? '$' : currency;\n\n    if (breakdown.holdCaptured > 0) {\n      parts.push(`Hold: ${symbol}${centsToUsd(breakdown.holdCaptured)}`);\n    }\n    if (breakdown.walletDebited > 0) {\n      parts.push(`Wallet: ${symbol}${centsToUsd(breakdown.walletDebited)}`);\n    }\n    if (breakdown.extraCharged > 0) {\n      parts.push(`Adicional: ${symbol}${centsToUsd(breakdown.extraCharged)}`);\n    }\n    if (breakdown.fgoPaid > 0) {\n      parts.push(`FGO: ${symbol}${centsToUsd(breakdown.fgoPaid)}`);\n    }\n\n    const total = calculateWaterfallTotal(breakdown);\n    parts.push(`Total: ${symbol}${centsToUsd(total)}`);\n\n    if (breakdown.remainingUncovered > 0) {\n      parts.push(`Sin cubrir: ${symbol}${centsToUsd(breakdown.remainingUncovered)}`);\n    }\n\n    return parts.join(' | ');\n  }\n\n  // ============================================================================\n  // ESTADO Y UTILIDADES\n  // ============================================================================\n\n  /**\n   * Limpia el estado del servicio\n   */\n  clearState(): void {\n    this.processing.set(false);\n    this.currentClaim.set(null);\n    this.error.set(null);\n  }\n\n  /**\n   * Obtiene el estado actual\n   */\n  getState(): { processing: boolean; currentClaim: Claim | null; error: string | null } {\n    return {\n      processing: this.processing(),\n      currentClaim: this.currentClaim(),\n      error: this.error(),\n    };\n  }\n\n  // ============================================================================\n  // P0-SECURITY: CLAIM LOCKING (previene double-spend)\n  // ============================================================================\n\n  /**\n   * Acquire optimistic lock on a claim before processing\n   * Uses atomic UPDATE with WHERE clause to prevent race conditions\n   */\n  private async acquireClaimLock(claimId: string): Promise<{ ok: boolean; error?: string }> {\n    try {\n      const {\n        data: { user },\n      } = await this.supabaseClient.auth.getUser();\n      if (!user) {\n        return { ok: false, error: 'Usuario no autenticado' };\n      }\n\n      // Atomic lock acquisition: only succeeds if claim is in 'approved' status\n      // and not already locked (locked_at is null or expired > 5 minutes)\n      const lockExpiry = new Date(Date.now() - 5 * 60 * 1000).toISOString(); // 5 min expiry\n\n      const { data, error } = await this.supabaseClient\n        .from('claims')\n        .update({\n          status: 'processing',\n          locked_at: new Date().toISOString(),\n          locked_by: user.id,\n        })\n        .eq('id', claimId)\n        .eq('status', 'approved') // Only lock if still in approved state\n        .or(`locked_at.is.null,locked_at.lt.${lockExpiry}`) // Not locked or lock expired\n        .select()\n        .single();\n\n      if (error) {\n        // Check if it's a \"no rows returned\" error (claim already locked/processed)\n        if (error.code === 'PGRST116') {\n          return {\n            ok: false,\n            error: 'Claim ya está siendo procesado o no está en estado aprobado',\n          };\n        }\n        return { ok: false, error: error.message };\n      }\n\n      if (!data) {\n        return {\n          ok: false,\n          error: 'No se pudo adquirir lock - claim puede estar siendo procesado por otro usuario',\n        };\n      }\n\n      return { ok: true };\n    } catch (err) {\n      return {\n        ok: false,\n        error: err instanceof Error ? err.message : 'Error al adquirir lock',\n      };\n    }\n  }\n\n  /**\n   * Release lock on a claim (called on error/failure)\n   */\n  private async releaseClaimLock(\n    claimId: string,\n    revertToStatus: 'approved' | 'rejected' = 'approved',\n  ): Promise<void> {\n    try {\n      await this.supabaseClient\n        .from('claims')\n        .update({\n          status: revertToStatus,\n          locked_at: null,\n          locked_by: null,\n        })\n        .eq('id', claimId)\n        .eq('status', 'processing'); // Only release if still in processing\n    } catch (err) {\n      this.logger.error('Failed to release claim lock', String(err));\n    }\n  }\n\n  /**\n   * Mark claim as successfully paid (final state)\n   */\n  private async markClaimAsPaid(claimId: string): Promise<void> {\n    try {\n      await this.supabaseClient\n        .from('claims')\n        .update({\n          status: 'paid',\n          processed_at: new Date().toISOString(),\n          locked_at: null,\n          locked_by: null,\n        })\n        .eq('id', claimId);\n    } catch (err) {\n      this.logger.error('Failed to mark claim as paid', String(err));\n    }\n  }\n\n  // ============================================================================\n  // WALLET DEBIT FOR DAMAGES\n  // ============================================================================\n\n  /**\n   * Debit from renter's wallet for damage claim\n   * Uses the wallet_debit_for_damage RPC which handles:\n   * - Balance verification\n   * - Partial debit if insufficient funds\n   * - Transaction recording\n   *\n   * @param bookingId - Booking ID for audit trail\n   * @param claimId - Claim ID for audit trail\n   * @param amountUsd - Amount to debit in USD\n   * @returns Result with success status and amount actually debited\n   */\n  private async debitWalletForDamage(\n    bookingId: string,\n    claimId: string,\n    amountUsd: number,\n  ): Promise<{ success: boolean; debitedAmountUsd: number; error?: string }> {\n    try {\n      const { data, error } = await this.supabaseClient.rpc('wallet_debit_for_damage', {\n        p_booking_id: bookingId,\n        p_claim_id: claimId,\n        p_amount_usd: amountUsd,\n      });\n\n      if (error) {\n        this.logger.error('Wallet debit RPC error', error.message);\n        return { success: false, debitedAmountUsd: 0, error: error.message };\n      }\n\n      // RPC returns array with single row\n      const result = Array.isArray(data) ? data[0] : data;\n\n      return {\n        success: result?.success ?? false,\n        debitedAmountUsd: result?.debited_amount_usd ?? 0,\n        error: result?.error,\n      };\n    } catch (err) {\n      this.logger.error('Wallet debit exception', String(err));\n      return {\n        success: false,\n        debitedAmountUsd: 0,\n        error: err instanceof Error ? err.message : 'Unknown error',\n      };\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/core/services/payments/wallet.service.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`../models/wallet.model` type import should occur after import of `@core/services/infrastructure/supabase-client.service`","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":15,"endColumn":33,"fix":{"range":[303,774],"text":"import { LoggerService } from '@core/services/infrastructure/logger.service';\nimport { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\nimport type {\n  ExpiringCredit,\n  InitiateDepositParams,\n  WalletBalance,\n  WalletInitiateDepositResponse,\n  WalletLockFundsResponse,\n  WalletLockRentalAndDepositResponse,\n  WalletHistoryEntry as WalletTransaction,\n  WalletTransactionFilters,\n  WalletUnlockFundsResponse,\n} from '../models/wallet.model';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { computed, inject, Injectable, signal } from '@angular/core';\nimport { PostgrestSingleResponse, RealtimeChannel, SupabaseClient } from '@supabase/supabase-js';\nimport { firstValueFrom, from, Observable, throwError } from 'rxjs';\nimport { catchError, map, switchMap, tap } from 'rxjs/operators';\nimport type {\n  ExpiringCredit,\n  InitiateDepositParams,\n  WalletBalance,\n  WalletInitiateDepositResponse,\n  WalletLockFundsResponse,\n  WalletLockRentalAndDepositResponse,\n  WalletHistoryEntry as WalletTransaction,\n  WalletTransactionFilters,\n  WalletUnlockFundsResponse,\n} from '../models/wallet.model';\nimport { LoggerService } from '@core/services/infrastructure/logger.service';\nimport { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class WalletService {\n  private readonly supabase: SupabaseClient = injectSupabase();\n  private readonly logger = inject(LoggerService);\n\n  // ✅ SIGNALS: Single source of truth for wallet state\n  readonly balance = signal<WalletBalance | null>(null);\n  readonly transactions = signal<WalletTransaction[]>([]);\n  readonly loading = signal(false);\n  readonly error = signal<{ message: string } | null>(null);\n\n  // Computed signals for derived state\n  readonly availableBalance = computed(() => this.balance()?.available_balance ?? 0);\n  readonly lockedBalance = computed(() => this.balance()?.locked_balance ?? 0);\n  readonly totalBalance = computed(() => this.balance()?.total_balance ?? 0);\n  readonly withdrawableBalance = computed(() => this.balance()?.withdrawable_balance ?? 0);\n  readonly transferableBalance = computed(() => this.balance()?.transferable_balance ?? 0);\n\n  // Nuevo sistema de créditos separados\n  readonly autorentarCreditBalance = computed(() => this.balance()?.autorentar_credit_balance ?? 0);\n  readonly cashDepositBalance = computed(() => this.balance()?.cash_deposit_balance ?? 0);\n\n  // DEPRECATED: Backward compatibility\n  readonly protectedCreditBalance = computed(() => this.balance()?.protected_credit_balance ?? 0);\n  readonly nonWithdrawableBalance = computed(() => this.balance()?.protected_credit_balance ?? 0);\n\n  readonly pendingDepositsCount = signal(0);\n\n  // 🚀 PERF: Request deduplication to prevent multiple parallel fetches\n  // Before: 8 components calling fetchBalance() = 8 API requests\n  // After: 8 components calling fetchBalance() = 1 API request (shared promise)\n  private pendingFetchBalance: Promise<WalletBalance> | null = null;\n  private lastFetchTimestamp = 0;\n  private readonly STALE_TIME_MS = 5000; // 5 seconds cache\n\n  constructor() {\n    this.supabase.auth.getSession().then(({ data: { session } }) => {\n      if (session?.['user']) {\n        this.fetchBalance().catch((err) => {\n          this.logger.warn('Failed to fetch wallet balance on init', err);\n        });\n        this.fetchTransactions().catch((err) => {\n          this.logger.warn('Failed to fetch wallet transactions on init', err);\n        });\n      }\n    }).catch((err) => {\n      this.logger.warn('Failed to get session on wallet service init', err);\n    });\n  }\n\n  // ============================================================================\n  // ASYNC METHODS - Primary API (Signal-based)\n  // ============================================================================\n\n  /**\n   * 🚀 PERF: Fetch balance with request deduplication and SWR-like caching\n   *\n   * - If a request is already in-flight, returns the same promise (deduplication)\n   * - If data is fresh (< 5s old), returns cached data immediately\n   * - Multiple consumers calling this simultaneously get the same result\n   *\n   * @param forceRefresh - Skip cache and force a new API call\n   */\n  async fetchBalance(forceRefresh = false): Promise<WalletBalance> {\n    // 🚀 PERF: Return cached data if still fresh (SWR pattern)\n    const now = Date.now();\n    const cachedBalance = this.balance();\n    if (!forceRefresh && cachedBalance && (now - this.lastFetchTimestamp) < this.STALE_TIME_MS) {\n      return cachedBalance;\n    }\n\n    // 🚀 PERF: Return pending request if one is already in-flight (deduplication)\n    if (this.pendingFetchBalance) {\n      return this.pendingFetchBalance;\n    }\n\n    // Start new fetch\n    this.pendingFetchBalance = this.doFetchBalance();\n\n    try {\n      const result = await this.pendingFetchBalance;\n      this.lastFetchTimestamp = Date.now();\n      return result;\n    } finally {\n      this.pendingFetchBalance = null;\n    }\n  }\n\n  /**\n   * Internal method that performs the actual API call\n   */\n  private async doFetchBalance(): Promise<WalletBalance> {\n    this.loading.set(true);\n    this['error'].set(null);\n\n    try {\n      const {\n        data: { session },\n      } = await this.supabase.auth.getSession();\n      if (!session?.['user']) throw new Error('Usuario no autenticado');\n\n      const { data, error } = await this.supabase.rpc('wallet_get_balance');\n      if (error) throw error;\n      if (!data) throw new Error('No se pudo obtener el balance');\n\n      const balance = data[0] as WalletBalance;\n      this.balance.set(balance);\n      return balance;\n    } catch (err) {\n      this.handleError(err, 'Error al obtener balance');\n      throw err;\n    } finally {\n      this.loading.set(false);\n    }\n  }\n\n  async fetchTransactions(_filters?: WalletTransactionFilters): Promise<WalletTransaction[]> {\n    this.loading.set(true);\n    this['error'].set(null);\n\n    try {\n      const {\n        data: { session },\n      } = await this.supabase.auth.getSession();\n      if (!session?.['user']) throw new Error('Usuario no autenticado');\n\n      const { data, error } = await this.supabase\n        .from('v_wallet_history')\n        .select('*')\n        .order('transaction_date', { ascending: false });\n\n      if (error) throw error;\n\n      const transactions = (data ?? []) as WalletTransaction[];\n      this.transactions.set(transactions);\n      return transactions;\n    } catch (err) {\n      this.handleError(err, 'Error al obtener transacciones');\n      throw err;\n    } finally {\n      this.loading.set(false);\n    }\n  }\n\n  async refreshBalanceAsync(): Promise<WalletBalance> {\n    return this.fetchBalance();\n  }\n\n  // ============================================================================\n  // LEGACY COMPATIBILITY METHODS (Wrappers)\n  // ============================================================================\n\n  /** @deprecated Use fetchBalance() */\n  getBalance(): Observable<WalletBalance> {\n    return from(this.fetchBalance());\n  }\n\n  /** @deprecated Use fetchTransactions() */\n  getTransactions(filters?: WalletTransactionFilters): Observable<WalletTransaction[]> {\n    return from(this.fetchTransactions(filters));\n  }\n\n  /** @deprecated Use fetchBalance() */\n  refreshBalance(): Observable<WalletBalance> {\n    return from(this.fetchBalance());\n  }\n\n  // ============================================================================\n  // DEPOSIT METHODS\n  // ============================================================================\n\n  initiateDeposit(params: InitiateDepositParams): Observable<WalletInitiateDepositResponse> {\n    this.loading.set(true);\n    this['error'].set(null);\n    return from(\n      this.supabase.rpc('wallet_initiate_deposit', {\n        p_amount: params['amount'],\n        p_provider: params.provider ?? 'mercadopago',\n        p_description: params['description'] ?? 'Depósito a wallet',\n        p_allow_withdrawal: params.allowWithdrawal ?? false,\n      }),\n    ).pipe(\n      switchMap(async (response: PostgrestSingleResponse<WalletInitiateDepositResponse[]>) => {\n        if (response['error']) throw response['error'];\n        if (!response.data) throw new Error('No se pudo iniciar el depósito');\n        const result = response.data[0];\n        if (!result.success) throw new Error(result['message']);\n\n        if (params.provider === 'mercadopago') {\n          const preference = await this.createMercadoPagoPreference(\n            result.transaction_id,\n            params['amount'],\n            params['description'] ?? 'Depósito a wallet',\n          );\n          if (preference?.init_point) {\n            result.payment_url = preference.init_point;\n            result.payment_mobile_deep_link =\n              preference.sandbox_init_point ?? preference.init_point;\n          }\n        }\n        return result;\n      }),\n      catchError((err) => {\n        this.handleError(err, 'Error al iniciar depósito');\n        return throwError(() => err);\n      }),\n      tap(() => this.loading.set(false)),\n    );\n  }\n\n  /**\n   * Alias for initiateDeposit for backward compatibility with deposit.page.ts\n   */\n  async createDepositPreference(\n    params: InitiateDepositParams,\n  ): Promise<WalletInitiateDepositResponse> {\n    return firstValueFrom(this.initiateDeposit(params));\n  }\n\n  async depositFunds(\n    userId: string,\n    amountCents: number,\n    description: string,\n    referenceId?: string,\n  ): Promise<{ success: boolean; transactionId?: string; error?: string }> {\n    try {\n      const { data, error } = await this.supabase.rpc('wallet_deposit_funds_admin', {\n        p_user_id: userId,\n        p_amount_cents: amountCents,\n        p_description: description,\n        p_reference_id: referenceId || null,\n      });\n\n      if (error) throw error;\n      const result = (data && Array.isArray(data) ? data[0] : data) as {\n        success: boolean;\n        transaction_id?: string;\n        error_message?: string;\n      };\n\n      if (!result.success) throw new Error(result.error_message || 'Fallo al depositar fondos');\n\n      this.fetchBalance().catch(() => { });\n      this.fetchTransactions().catch(() => { });\n\n      return { success: true, transactionId: result.transaction_id };\n    } catch (err) {\n      this.handleError(err, 'Error al depositar fondos');\n      return { success: false, error: err instanceof Error ? err['message'] : 'Error desconocido' };\n    }\n  }\n\n  private async createMercadoPagoPreference(\n    transactionId: string,\n    amount: number,\n    description: string,\n  ): Promise<{ init_point?: string; sandbox_init_point?: string }> {\n    const { data } = await this.supabase.auth.getSession();\n    if (!data.session) throw new Error('No autenticado');\n\n    const response = await this.supabase.functions.invoke('mercadopago-create-preference', {\n      body: {\n        transaction_id: transactionId,\n        amount,\n        description: description || 'Depósito a Wallet - AutoRenta',\n      },\n    });\n\n    if (response['error'])\n      throw new Error(response['error']['message'] ?? 'No se pudo crear la preferencia de pago');\n\n    return {\n      init_point: response.data?.init_point,\n      sandbox_init_point: response.data?.sandbox_init_point,\n    };\n  }\n\n  // ============================================================================\n  // LOCK/UNLOCK FUNDS METHODS\n  // ============================================================================\n\n  lockFunds(\n    bookingId: string,\n    amount: number,\n    description?: string,\n  ): Observable<WalletLockFundsResponse> {\n    return from(\n      this.supabase.rpc('wallet_lock_funds', {\n        p_booking_id: bookingId,\n        p_amount: amount,\n        p_description: description ?? 'Bloqueo de fondos',\n      }),\n    ).pipe(\n      tap((response) => {\n        if (response['error']) throw response['error'];\n        this.fetchBalance().catch(() => { });\n      }),\n      map((response) => response.data![0] as WalletLockFundsResponse),\n    );\n  }\n\n  unlockFunds(bookingId: string, description?: string): Observable<WalletUnlockFundsResponse> {\n    return from(\n      this.supabase.rpc('wallet_unlock_funds', {\n        p_booking_id: bookingId,\n        p_description: description ?? 'Desbloqueo de fondos',\n      }),\n    ).pipe(\n      tap((response) => {\n        if (response['error']) throw response['error'];\n        this.fetchBalance().catch(() => { });\n      }),\n      map((response) => response.data![0] as WalletUnlockFundsResponse),\n    );\n  }\n\n  lockRentalAndDeposit(\n    bookingId: string,\n    rentalAmount: number,\n    depositAmount: number = 250,\n  ): Observable<WalletLockRentalAndDepositResponse> {\n    return from(\n      this.supabase.rpc('wallet_lock_rental_and_deposit', {\n        p_booking_id: bookingId,\n        p_rental_amount: rentalAmount,\n        p_deposit_amount: depositAmount,\n      }),\n    ).pipe(\n      tap((response) => {\n        if (response['error']) throw response['error'];\n        this.fetchBalance().catch(() => { });\n      }),\n      map((response) => response.data![0] as WalletLockRentalAndDepositResponse),\n    );\n  }\n\n  // ============================================================================\n  // REALTIME SUBSCRIPTIONS\n  // ============================================================================\n\n  async subscribeToWalletChanges(\n    onTransaction: (transaction: WalletTransaction) => void,\n    onBalanceChange: (balance: WalletBalance) => void,\n  ): Promise<RealtimeChannel> {\n    const { data } = await this.supabase.auth.getSession();\n    const user = data.session?.['user'];\n    if (!user) throw new Error('No autenticado');\n\n    return this.supabase\n      .channel(`wallet:${user['id']}`)\n      .on(\n        'postgres_changes',\n        {\n          event: 'INSERT',\n          schema: 'public',\n          table: 'wallet_ledger',\n          filter: `user_id=eq.${user['id']}`,\n        },\n        async (payload) => {\n          onTransaction(payload.new as WalletTransaction);\n          try {\n            const balance = await this.fetchBalance();\n            onBalanceChange(balance);\n          } catch (error) {\n            this.logger.warn('Failed to refresh wallet balance after transaction', error instanceof Error ? error.message : String(error));\n          }\n        },\n      )\n      .subscribe((status) => {\n        if (status === 'SUBSCRIBED') {\n          console.debug('[Wallet] Realtime subscription active');\n        }\n      });\n  }\n\n  async unsubscribeFromWalletChanges(): Promise<void> {\n    const { data } = await this.supabase.auth.getSession();\n    if (!data.session?.['user']) return;\n    await this.supabase.removeChannel(this.supabase.channel(`wallet:${data.session['user']['id']}`));\n  }\n\n  // ============================================================================\n  // UTILITY METHODS\n  // ============================================================================\n\n  async forcePollPendingPayments(): Promise<{\n    success: boolean;\n    confirmed: number;\n    message: string;\n  }> {\n    this.loading.set(true);\n    try {\n      const { data, error } = await this.supabase.rpc('wallet_poll_pending_payments');\n      if (error) throw error;\n      this.fetchBalance().catch(() => { });\n      this.fetchTransactions().catch(() => { });\n      return (data ?? { success: false, confirmed: 0, message: 'No data returned' }) as {\n        success: boolean;\n        confirmed: number;\n        message: string;\n      };\n    } catch (err) {\n      this.handleError(err, 'Error al consultar pagos pendientes');\n      throw err;\n    } finally {\n      this.loading.set(false);\n    }\n  }\n\n  async refreshPendingDepositsCount(): Promise<void> {\n    try {\n      const { data, error } = await this.supabase\n        .from('wallet_transactions')\n        .select('id', { count: 'exact', head: true })\n        .eq('status', 'pending')\n        .eq('type', 'deposit');\n\n      if (error) throw error;\n      this.pendingDepositsCount.set(data?.length ?? 0);\n    } catch (err: unknown) {\n      this.logger['error']('Error al obtener depósitos pendientes', String(err));\n    }\n  }\n\n  // ============================================================================\n  // PROTECTION CREDIT METHODS\n  // ============================================================================\n\n  async issueProtectionCredit(\n    userId: string,\n    amountCents: number = 30000,\n    validityDays: number = 365,\n  ): Promise<string> {\n    try {\n      const { data, error } = await this.supabase.rpc('issue_protection_credit', {\n        p_user_id: userId,\n        p_amount_cents: amountCents,\n        p_validity_days: validityDays,\n      });\n\n      if (error) throw error;\n      this.fetchBalance().catch(() => { });\n      return data;\n    } catch (err) {\n      this.handleError(err, 'Error al emitir Crédito de Protección');\n      throw err;\n    }\n  }\n\n  async checkProtectionCreditRenewal(): Promise<{\n    eligible: boolean;\n    completedBookings: number;\n    totalClaims: number;\n    bookingsNeeded: number;\n  }> {\n    try {\n      const {\n        data: { user },\n      } = await this.supabase.auth.getUser();\n      if (!user) throw new Error('Usuario no autenticado');\n\n      const { count: completedBookings } = await this.supabase\n        .from('bookings')\n        .select('*', { count: 'exact', head: true })\n        .eq('renter_id', user['id'])\n        .eq('status', 'completed');\n\n      const { count: totalClaims } = await this.supabase\n        .from('booking_claims')\n        .select('*', { count: 'exact', head: true })\n        .eq('user_id', user['id'])\n        .in('status', ['approved', 'resolved']);\n\n      const eligible = (completedBookings ?? 0) >= 10 && (totalClaims ?? 0) === 0;\n      const bookingsNeeded = Math.max(0, 10 - (completedBookings ?? 0));\n\n      return {\n        eligible,\n        completedBookings: completedBookings ?? 0,\n        totalClaims: totalClaims ?? 0,\n        bookingsNeeded,\n      };\n    } catch (err) {\n      this.handleError(err, 'Error al verificar elegibilidad de renovación');\n      throw err;\n    }\n  }\n\n  getProtectionCreditFormatted(): string {\n    const balance = this.protectedCreditBalance();\n    return `$${balance.toFixed(2)} USD`;\n  }\n\n  getTotalCoverageBalance(): number {\n    return this.availableBalance() + this.protectedCreditBalance();\n  }\n\n  // ============================================================================\n  // EXPIRING CREDITS\n  // ============================================================================\n\n  /**\n   * Signal para créditos que expiran pronto (30 días o menos)\n   */\n  readonly expiringCredits = signal<ExpiringCredit[]>([]);\n\n  /**\n   * Computed: tiene créditos por vencer en 7 días o menos (urgente)\n   */\n  readonly hasUrgentExpiringCredits = computed(() =>\n    this.expiringCredits().some(c => c.days_until_expiry <= 7)\n  );\n\n  /**\n   * Computed: total de créditos por vencer\n   */\n  readonly totalExpiringAmount = computed(() =>\n    this.expiringCredits().reduce((sum, c) => sum + c.amount_cents, 0)\n  );\n\n  /**\n   * Obtiene créditos que expiran en los próximos N días\n   */\n  async fetchExpiringCredits(daysAhead: number = 30): Promise<ExpiringCredit[]> {\n    try {\n      const { data, error } = await this.supabase.rpc('get_expiring_credits', {\n        p_days_ahead: daysAhead\n      });\n\n      if (error) throw error;\n\n      const credits = (data ?? []) as ExpiringCredit[];\n      this.expiringCredits.set(credits);\n      return credits;\n    } catch (err) {\n      this.logger['error']('Error al obtener créditos por vencer', String(err));\n      return [];\n    }\n  }\n\n  private handleError(err: unknown, defaultMessage: string): void {\n    const errorMessage = err instanceof Error ? err['message'] : defaultMessage;\n    this['error'].set({ message: errorMessage });\n    this.logger['error'](defaultMessage, String(err));\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/core/services/payments/withdrawal.service.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`@core/services/infrastructure/supabase-client.service` import should occur before type import of `../models/wallet.model`","line":16,"column":1,"nodeType":"ImportDeclaration","endLine":16,"endColumn":95,"fix":{"range":[70,503],"text":"import { SupabaseClientService } from '@core/services/infrastructure/supabase-client.service';\nimport type {\n  BankAccount,\n  WithdrawalRequest,\n  RequestWithdrawalParams,\n  WalletRequestWithdrawalResponse,\n  WalletApproveWithdrawalResponse,\n  ApproveWithdrawalParams,\n  RejectWithdrawalParams,\n  AddBankAccountParams,\n  WithdrawalFilters,\n  WithdrawalLoadingState,\n  WalletError,\n  BankAccountType,\n} from '../models/wallet.model';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { Injectable, signal, computed, inject } from '@angular/core';\nimport type {\n  BankAccount,\n  WithdrawalRequest,\n  RequestWithdrawalParams,\n  WalletRequestWithdrawalResponse,\n  WalletApproveWithdrawalResponse,\n  ApproveWithdrawalParams,\n  RejectWithdrawalParams,\n  AddBankAccountParams,\n  WithdrawalFilters,\n  WithdrawalLoadingState,\n  WalletError,\n  BankAccountType,\n} from '../models/wallet.model';\nimport { SupabaseClientService } from '@core/services/infrastructure/supabase-client.service';\n\n/**\n * WithdrawalService\n *\n * Servicio para gestionar el sistema de retiros:\n * - Gestionar cuentas bancarias del usuario\n * - Solicitar retiros de fondos\n * - Ver historial de retiros\n * - Aprobar/rechazar retiros (admin)\n *\n * Usa signals de Angular 17+ para state management reactivo.\n */\n@Injectable({\n  providedIn: 'root',\n})\nexport class WithdrawalService {\n  private readonly supabase = inject(SupabaseClientService);\n\n  // ==================== SIGNALS ====================\n\n  /**\n   * Cuentas bancarias del usuario\n   */\n  readonly bankAccounts = signal<BankAccount[]>([]);\n\n  /**\n   * Solicitudes de retiro del usuario\n   */\n  readonly withdrawalRequests = signal<WithdrawalRequest[]>([]);\n\n  /**\n   * Estados de carga para operaciones asíncronas\n   */\n  readonly loading = signal<WithdrawalLoadingState>({\n    requesting: false,\n    approving: false,\n    rejecting: false,\n    fetchingRequests: false,\n    addingBankAccount: false,\n    fetchingBankAccounts: false,\n  });\n\n  /**\n   * Error actual (si existe)\n   */\n  readonly error = signal<WalletError | null>(null);\n\n  // ==================== COMPUTED SIGNALS ====================\n\n  /**\n   * Cuenta bancaria por defecto del usuario\n   */\n  readonly defaultBankAccount = computed(() => this.bankAccounts().find((acc) => acc.is_default));\n\n  /**\n   * Cuentas bancarias activas\n   */\n  readonly activeBankAccounts = computed(() => this.bankAccounts().filter((acc) => acc.is_active));\n\n  /**\n   * Retiros pendientes\n   */\n  readonly pendingWithdrawals = computed(() =>\n    this.withdrawalRequests().filter((req) => req.status === 'pending'),\n  );\n\n  /**\n   * Retiros completados\n   */\n  readonly completedWithdrawals = computed(() =>\n    this.withdrawalRequests().filter((req) => req.status === 'completed'),\n  );\n\n  /**\n   * Indica si hay alguna operación en progreso\n   */\n  readonly isLoading = computed(() => {\n    const loadingState = this.loading();\n    return Object.values(loadingState).some((v) => v);\n  });\n\n  // ==================== BANK ACCOUNTS METHODS ====================\n\n  /**\n   * Obtiene las cuentas bancarias del usuario\n   */\n  async getBankAccounts(): Promise<BankAccount[]> {\n    this.setLoadingState('fetchingBankAccounts', true);\n    this.clearError();\n\n    try {\n      const { data, error } = await this.supabase\n        .getClient()\n        .from('bank_accounts')\n        .select('*')\n        .order('is_default', { ascending: false })\n        .order('created_at', { ascending: false });\n\n      if (error) {\n        throw this.createError('BANK_ACCOUNTS_FETCH_ERROR', error.message, error);\n      }\n\n      const accounts = (data ?? []) as BankAccount[];\n      this.bankAccounts.set(accounts);\n\n      return accounts;\n    } catch (err) {\n      const walletError = this.handleError(err, 'Error al obtener cuentas bancarias');\n      throw walletError;\n    } finally {\n      this.setLoadingState('fetchingBankAccounts', false);\n    }\n  }\n\n  /**\n   * Agrega una nueva cuenta bancaria\n   */\n  async addBankAccount(params: AddBankAccountParams): Promise<BankAccount> {\n    this.setLoadingState('addingBankAccount', true);\n    this.clearError();\n\n    try {\n      // Validar formato según tipo de cuenta\n      this.validateAccountNumber(params.account_type, params.account_number);\n\n      // Validar DNI/CUIT\n      if (!params.account_holder_document || params.account_holder_document.length < 7) {\n        throw this.createError('INVALID_DOCUMENT', 'DNI/CUIT inválido');\n      }\n\n      // Crear cuenta bancaria\n      const { data, error } = await this.supabase\n        .getClient()\n        .from('bank_accounts')\n        .insert({\n          account_type: params.account_type,\n          account_number: params.account_number,\n          account_holder_name: params.account_holder_name,\n          account_holder_document: params.account_holder_document,\n          bank_name: params.bank_name,\n          is_active: true,\n          // Marcar como default si es la primera cuenta\n          is_default: this.bankAccounts().length === 0,\n        })\n        .select()\n        .single();\n\n      if (error) {\n        throw this.createError('ADD_BANK_ACCOUNT_ERROR', error.message, error);\n      }\n\n      const account = data as BankAccount;\n\n      // Actualizar lista de cuentas\n      this.bankAccounts.update((accounts) => [account, ...accounts]);\n\n      return account;\n    } catch (err) {\n      const walletError = this.handleError(err, 'Error al agregar cuenta bancaria');\n      throw walletError;\n    } finally {\n      this.setLoadingState('addingBankAccount', false);\n    }\n  }\n\n  /**\n   * Establece una cuenta como predeterminada\n   */\n  async setDefaultBankAccount(accountId: string): Promise<void> {\n    this.clearError();\n\n    try {\n      const { error } = await this.supabase.getClient().rpc('set_default_bank_account', {\n        p_bank_account_id: accountId,\n      });\n\n      if (error) {\n        throw this.createError('SET_DEFAULT_ERROR', error.message, error);\n      }\n\n      // Actualizar estado local\n      this.bankAccounts.update((accounts) =>\n        accounts.map((acc) => ({\n          ...acc,\n          is_default: acc.id === accountId,\n        })),\n      );\n    } catch (err) {\n      const walletError = this.handleError(err, 'Error al establecer cuenta predeterminada');\n      throw walletError;\n    }\n  }\n\n  /**\n   * Elimina una cuenta bancaria\n   */\n  async deleteBankAccount(accountId: string): Promise<void> {\n    this.clearError();\n\n    try {\n      const { error } = await this.supabase\n        .getClient()\n        .from('bank_accounts')\n        .delete()\n        .eq('id', accountId);\n\n      if (error) {\n        throw this.createError('DELETE_BANK_ACCOUNT_ERROR', error.message, error);\n      }\n\n      // Actualizar estado local\n      this.bankAccounts.update((accounts) => accounts.filter((acc) => acc.id !== accountId));\n    } catch (err) {\n      const walletError = this.handleError(err, 'Error al eliminar cuenta bancaria');\n      throw walletError;\n    }\n  }\n\n  // ==================== WITHDRAWAL METHODS ====================\n\n  /**\n   * Solicita un retiro de fondos\n   */\n  async requestWithdrawal(\n    params: RequestWithdrawalParams,\n  ): Promise<WalletRequestWithdrawalResponse> {\n    this.setLoadingState('requesting', true);\n    this.clearError();\n\n    try {\n      // Validar parámetros\n      if (params.amount <= 0) {\n        throw this.createError('INVALID_AMOUNT', 'El monto debe ser mayor a 0');\n      }\n\n      if (params.amount < 100) {\n        throw this.createError('AMOUNT_TOO_LOW', 'El monto mínimo de retiro es $100 ARS');\n      }\n\n      const { data, error } = await this.supabase.getClient().rpc('wallet_request_withdrawal', {\n        p_bank_account_id: params.bank_account_id,\n        p_amount: params.amount,\n        p_user_notes: params.user_notes ?? null,\n      });\n\n      if (error) {\n        throw this.createError('REQUEST_WITHDRAWAL_ERROR', error.message, error);\n      }\n\n      if (!data || data.length === 0) {\n        throw this.createError('REQUEST_WITHDRAWAL_EMPTY', 'No se pudo procesar la solicitud');\n      }\n\n      const result = data[0] as WalletRequestWithdrawalResponse;\n\n      if (!result.success) {\n        throw this.createError('REQUEST_WITHDRAWAL_FAILED', result.message);\n      }\n\n      // Refrescar lista de solicitudes\n      await this.getWithdrawalRequests().catch(() => {\n        /* Ignorar errores de refresh */\n      });\n\n      return result;\n    } catch (err) {\n      const walletError = this.handleError(err, 'Error al solicitar retiro');\n      throw walletError;\n    } finally {\n      this.setLoadingState('requesting', false);\n    }\n  }\n\n  /**\n   * Obtiene el historial de solicitudes de retiro\n   */\n  async getWithdrawalRequests(filters?: WithdrawalFilters): Promise<WithdrawalRequest[]> {\n    this.setLoadingState('fetchingRequests', true);\n    this.clearError();\n\n    try {\n      let query = this.supabase\n        .getClient()\n        .from('withdrawal_requests')\n        .select('*')\n        .order('created_at', { ascending: false });\n\n      // Aplicar filtros\n      if (filters?.status) {\n        if (Array.isArray(filters.status)) {\n          query = query.in('status', filters.status);\n        } else {\n          query = query.eq('status', filters.status);\n        }\n      }\n\n      if (filters?.from_date) {\n        query = query.gte('created_at', filters.from_date.toISOString());\n      }\n\n      if (filters?.to_date) {\n        query = query.lte('created_at', filters.to_date.toISOString());\n      }\n\n      const { data, error } = await query;\n\n      if (error) {\n        throw this.createError('WITHDRAWAL_REQUESTS_FETCH_ERROR', error.message, error);\n      }\n\n      const requests = (data ?? []) as WithdrawalRequest[];\n      this.withdrawalRequests.set(requests);\n\n      return requests;\n    } catch (err) {\n      const walletError = this.handleError(err, 'Error al obtener solicitudes de retiro');\n      throw walletError;\n    } finally {\n      this.setLoadingState('fetchingRequests', false);\n    }\n  }\n\n  /**\n   * Obtiene TODAS las solicitudes de retiro (Admin only)\n   * Este método es semánticamente para uso administrativo.\n   * Confía en que las políticas RLS del backend permitirán al admin ver todo.\n   */\n  async getAllWithdrawals(filters?: WithdrawalFilters): Promise<WithdrawalRequest[]> {\n    return this.getWithdrawalRequests(filters);\n  }\n\n  /**\n   * Cancela una solicitud de retiro pendiente\n   */\n  async cancelWithdrawalRequest(requestId: string): Promise<void> {\n    this.clearError();\n\n    try {\n      const { error } = await this.supabase\n        .getClient()\n        .from('withdrawal_requests')\n        .update({ status: 'cancelled', updated_at: new Date().toISOString() })\n        .eq('id', requestId)\n        .eq('status', 'pending'); // Solo permitir cancelar pendientes\n\n      if (error) {\n        throw this.createError('CANCEL_WITHDRAWAL_ERROR', error.message, error);\n      }\n\n      // Actualizar estado local\n      this.withdrawalRequests.update((requests) =>\n        requests.map((req) =>\n          req.id === requestId ? { ...req, status: 'cancelled' as const } : req,\n        ),\n      );\n    } catch (err) {\n      const walletError = this.handleError(err, 'Error al cancelar solicitud de retiro');\n      throw walletError;\n    }\n  }\n\n  // ==================== ADMIN METHODS ====================\n\n  /**\n   * Aprueba una solicitud de retiro (admin only)\n   */\n  async approveWithdrawal(\n    params: ApproveWithdrawalParams,\n  ): Promise<WalletApproveWithdrawalResponse> {\n    this.setLoadingState('approving', true);\n    this.clearError();\n\n    try {\n      const { data, error } = await this.supabase.getClient().rpc('wallet_approve_withdrawal', {\n        p_request_id: params.request_id,\n        p_admin_notes: params.admin_notes ?? null,\n      });\n\n      if (error) {\n        throw this.createError('APPROVE_WITHDRAWAL_ERROR', error.message, error);\n      }\n\n      if (!data || data.length === 0) {\n        throw this.createError('APPROVE_WITHDRAWAL_EMPTY', 'No se pudo procesar la aprobación');\n      }\n\n      const result = data[0] as WalletApproveWithdrawalResponse;\n\n      if (!result.success) {\n        throw this.createError('APPROVE_WITHDRAWAL_FAILED', result.message);\n      }\n\n      // Refrescar lista de solicitudes\n      await this.getWithdrawalRequests().catch(() => {\n        /* Ignorar errores de refresh */\n      });\n\n      return result;\n    } catch (err) {\n      const walletError = this.handleError(err, 'Error al aprobar retiro');\n      throw walletError;\n    } finally {\n      this.setLoadingState('approving', false);\n    }\n  }\n\n  /**\n   * Rechaza una solicitud de retiro (admin only)\n   */\n  async rejectWithdrawal(params: RejectWithdrawalParams): Promise<void> {\n    this.setLoadingState('rejecting', true);\n    this.clearError();\n\n    try {\n      const { error } = await this.supabase\n        .getClient()\n        .from('withdrawal_requests')\n        .update({\n          status: 'rejected',\n          rejection_reason: params.rejection_reason,\n          updated_at: new Date().toISOString(),\n        })\n        .eq('id', params.request_id)\n        .eq('status', 'pending');\n\n      if (error) {\n        throw this.createError('REJECT_WITHDRAWAL_ERROR', error.message, error);\n      }\n\n      // Actualizar estado local\n      this.withdrawalRequests.update((requests) =>\n        requests.map((req) =>\n          req.id === params.request_id\n            ? {\n                ...req,\n                status: 'rejected' as const,\n                rejection_reason: params.rejection_reason,\n              }\n            : req,\n        ),\n      );\n    } catch (err) {\n      const walletError = this.handleError(err, 'Error al rechazar retiro');\n      throw walletError;\n    } finally {\n      this.setLoadingState('rejecting', false);\n    }\n  }\n\n  /**\n   * Refresca tanto las cuentas como las solicitudes\n   */\n  async refresh(): Promise<void> {\n    await Promise.all([\n      this.getBankAccounts().catch(() => {\n        /* Ignorar errores de refresh */\n      }),\n      this.getWithdrawalRequests().catch(() => {\n        /* Ignorar errores de refresh */\n      }),\n    ]);\n  }\n\n  /**\n   * Limpia el estado del servicio\n   */\n  clear(): void {\n    this.bankAccounts.set([]);\n    this.withdrawalRequests.set([]);\n    this.clearError();\n  }\n\n  // ==================== PRIVATE METHODS ====================\n\n  /**\n   * Valida el formato de número de cuenta según el tipo\n   */\n  private validateAccountNumber(type: BankAccountType, number: string): void {\n    switch (type) {\n      case 'cbu':\n        if (!/^\\d{22}$/.test(number)) {\n          throw this.createError('INVALID_CBU', 'El CBU debe tener 22 dígitos');\n        }\n        break;\n      case 'cvu':\n        if (!/^\\d{22}$/.test(number)) {\n          throw this.createError('INVALID_CVU', 'El CVU debe tener 22 dígitos');\n        }\n        break;\n      case 'alias':\n        if (!/^[a-zA-Z0-9.]+$/.test(number) || number.length < 6 || number.length > 20) {\n          throw this.createError(\n            'INVALID_ALIAS',\n            'El alias debe tener entre 6 y 20 caracteres alfanuméricos',\n          );\n        }\n        break;\n    }\n  }\n\n  /**\n   * Actualiza un estado de carga específico\n   */\n  private setLoadingState(key: keyof WithdrawalLoadingState, value: boolean): void {\n    this.loading.update((state) => ({ ...state, [key]: value }));\n  }\n\n  /**\n   * Crea un objeto de error estandarizado\n   */\n  private createError(code: string, message: string, details?: unknown): WalletError {\n    const error: WalletError = { code, message, details };\n    this.error.set(error);\n    return error;\n  }\n\n  /**\n   * Maneja errores genéricos y los convierte a WalletError\n   */\n  private handleError(err: unknown, defaultMessage: string): WalletError {\n    if (this.isWalletError(err)) {\n      return err;\n    }\n\n    if (err instanceof Error) {\n      return this.createError('UNKNOWN_ERROR', err.message || defaultMessage, err);\n    }\n\n    return this.createError('UNKNOWN_ERROR', defaultMessage, err);\n  }\n\n  /**\n   * Type guard para WalletError\n   */\n  private isWalletError(err: unknown): err is WalletError {\n    return (\n      typeof err === 'object' &&\n      err !== null &&\n      'code' in err &&\n      'message' in err &&\n      typeof (err as WalletError).code === 'string' &&\n      typeof (err as WalletError).message === 'string'\n    );\n  }\n\n  /**\n   * Limpia el error actual\n   */\n  private clearError(): void {\n    this.error.set(null);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/core/services/supabase-client.service.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Expression expected.","line":309,"column":11}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { isPlatformBrowser } from '@angular/common';\nimport {\n  EnvironmentProviders,\n  inject,\n  isDevMode,\n  Injectable,\n  makeEnvironmentProviders,\n  PLATFORM_ID,\n} from '@angular/core';\nimport { createClient, SupabaseClient } from '@supabase/supabase-js';\nimport { environment } from '../../../environments/environment';\nimport { LoggerService } from '@core/services/infrastructure/logger.service';\n\ntype SupabaseLock = <T>(name: string, acquireTimeout: number, fn: () => Promise<T>) => Promise<T>;\n\n// Type-safe interfaces for Navigator Locks API\ninterface NavigatorLockOptions {\n  mode: 'exclusive' | 'shared';\n  signal?: AbortSignal;\n}\n\ninterface NavigatorLocks {\n  request<T>(name: string, options: NavigatorLockOptions, callback: () => Promise<T>): Promise<T>;\n}\n\ninterface GlobalWithNavigator {\n  navigator?: {\n    locks?: NavigatorLocks;\n  };\n}\n\nconst createResilientLock = (): SupabaseLock => {\n  const navigatorLocks = (globalThis as unknown as GlobalWithNavigator)?.navigator?.locks;\n  if (!navigatorLocks?.request) {\n    return async (_name, _acquireTimeout, fn) => fn();\n  }\n\n  return async (name, acquireTimeout, fn) => {\n    const controller =\n      typeof acquireTimeout === 'number' && acquireTimeout > 0 ? new AbortController() : null;\n    let timeoutId: ReturnType<typeof setTimeout> | undefined;\n\n    try {\n      if (controller) {\n        timeoutId = setTimeout(() => controller.abort(), acquireTimeout);\n      }\n\n      const options: NavigatorLockOptions = { mode: 'exclusive' };\n      if (controller) {\n        options.signal = controller.signal;\n      }\n\n      return await navigatorLocks.request(name, options, async () => fn());\n    } catch (error: unknown) {\n      const errorObj = error as { name?: string; message?: string };\n      if (\n        errorObj?.name === 'AbortError' ||\n        errorObj?.name === 'NavigatorLockAcquireTimeoutError' ||\n        errorObj?.message?.includes('Navigator LockManager')\n      ) {\n        // Lock timeout - continue without locking\n        return fn();\n      }\n      throw error;\n    } finally {\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n      }\n    }\n  };\n};\n\n/**\n * Creates a stub Supabase client for SSR that returns empty results\n * This prevents errors during prerendering while maintaining type safety\n */\nfunction createSSRStubClient(): SupabaseClient {\n  // Create a proxy that returns safe stubs for any property access\n  const createChainableStub = (): unknown => {\n    const stub = new Proxy(() => createChainableStub(), {\n      get: (_target, prop) => {\n        // Handle common async methods\n        if (prop === 'then' || prop === 'catch' || prop === 'finally') {\n          return undefined; // Not a promise\n        }\n        // Return empty data for terminal methods\n        if (prop === 'single' || prop === 'maybeSingle') {\n          return () => Promise.resolve({ data: null, error: null });\n        }\n        // Auth state methods\n        if (prop === 'getSession' || prop === 'getUser') {\n          return () => Promise.resolve({ data: { session: null, user: null }, error: null });\n        }\n        if (prop === 'onAuthStateChange') {\n          return () => ({ data: { subscription: { unsubscribe: () => { } } } });\n        }\n        // RPC calls\n        if (typeof prop === 'string' && prop.startsWith('rpc')) {\n          return () => Promise.resolve({ data: null, error: null });\n        }\n        // Realtime channel\n        if (prop === 'subscribe') {\n          return () => ({ unsubscribe: () => { } });\n        }\n        if (prop === 'unsubscribe') {\n          return () => { };\n        }\n        // Default: return chainable stub\n        return createChainableStub();\n      },\n      apply: () => {\n        // When called as function, return promise with empty result\n        return Promise.resolve({ data: [], error: null, count: 0 });\n      },\n    });\n    return stub;\n  };\n\n  return createChainableStub() as unknown as SupabaseClient;\n}\n\nfunction createUnconfiguredBrowserStubClient(message: string): SupabaseClient {\n  const createChainableThrower = (): unknown => {\n    const thrower = () => {\n      throw new Error(message);\n    };\n\n    const stub = new Proxy(thrower, {\n      get: (_target, prop) => {\n        if (prop === 'then' || prop === 'catch' || prop === 'finally') {\n          return undefined;\n        }\n\n        return createChainableThrower();\n      },\n      apply: () => {\n        throw new Error(message);\n      },\n    });\n\n    return stub;\n  };\n\n  return createChainableThrower() as unknown as SupabaseClient;\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class SupabaseClientService {\n  private readonly logger = inject(LoggerService);\n  private client: SupabaseClient | null = null;\n  private readonly platformId = inject(PLATFORM_ID);\n  private readonly isBrowser = isPlatformBrowser(this.platformId);\n\n  constructor() {\n    // SSR-safe: Don't initialize Supabase during server-side rendering\n    // The client will be created lazily on first getClient() call in browser\n    if (!this.isBrowser) {\n      this.logger.debug('[SupabaseClientService] SSR mode - skipping initialization');\n      return;\n    }\n  }\n\n  /**\n   * Initialize the Supabase client (only in browser)\n   */\n  private initializeClient(): void {\n    if (this.client) return; // Already initialized\n\n    this.logger.debug('[SupabaseClientService] Initializing...');\n    const supabaseUrl = environment.supabaseUrl;\n    const supabaseAnonKey = environment.supabaseAnonKey;\n\n    if (!supabaseUrl || !supabaseAnonKey) {\n      const message =\n        'Supabase no está configurado. Define NG_APP_SUPABASE_URL y NG_APP_SUPABASE_ANON_KEY en tus variables de entorno (por ejemplo, .env.development.local).';\n      throw new Error(message);\n    }\n\n    this.client = createClient(supabaseUrl, supabaseAnonKey, {\n      auth: {\n        persistSession: true,\n        autoRefreshToken: true,\n        lock: createResilientLock(),\n        detectSessionInUrl: true,\n      },\n      db: {\n        schema: 'public',\n      },\n      realtime: {\n        params: {\n          eventsPerSecond: 10,\n        },\n      },\n    });\n  }\n\n  static forRoot(): EnvironmentProviders {\n    return makeEnvironmentProviders([\n      {\n        provide: SupabaseClientService,\n        useFactory: () => new SupabaseClientService(),\n      },\n    ]);\n  }\n\n  /**\n   * Get the Supabase client instance\n   * Returns a stub client during SSR that safely returns empty results\n   */\n  getClient(): SupabaseClient {\n    if (!this.client) {\n      if (!this.isBrowser) {\n        // Return stub client during SSR instead of throwing\n        return createSSRStubClient();\n      }\n      // Lazy init if not done yet\n      this.initializeClient();\n    }\n    return this.client!;\n  }\n\n  /**\n   * Check if Supabase is available (only true in browser)\n   */\n  isAvailable(): boolean {\n    return this.isBrowser && this.client !== null;\n  }\n\n  /**\n   * Get client or null (SSR-safe alternative to getClient())\n   */\n  getClientOrNull(): SupabaseClient | null {\n    if (!this.isBrowser) return null;\n\n    if (this.client) return this.client;\n\n    const supabaseUrl = environment.supabaseUrl;\n    const supabaseAnonKey = environment.supabaseAnonKey;\n    if (!supabaseUrl || !supabaseAnonKey) return null;\n\n    try {\n      this.initializeClient();\n      return this.client;\n    } catch {\n      return null;\n    }\n  }\n\n  async healthCheck(): Promise<boolean> {\n    const client = this.getClientOrNull();\n    if (!client) return false;\n    try {\n      const { error } = await client.from('profiles').select('id').limit(1);\n      return !error;\n    } catch {\n      return false;\n    }\n  }\n\n  getConnectionInfo(): { url: string; pooling: string } {\n    return {\n      url: environment.supabaseUrl || 'hardcoded',\n      pooling: 'transaction',\n    };\n  }\n}\n\n/**\n * Inject Supabase client - SSR-safe\n * Returns a stub client during SSR that returns empty results\n * Returns the real client in browser\n */\nexport const injectSupabase = (): SupabaseClient => {\n  const service = inject(SupabaseClientService) as unknown as {\n    getClient?: () => SupabaseClient;\n    getClientOrNull?: () => SupabaseClient | null;\n    client?: SupabaseClient | null;\n  };\n  const platformId = inject(PLATFORM_ID);\n\n  // During SSR, return a stub client that doesn't throw\n  if (!isPlatformBrowser(platformId)) {\n    return createSSRStubClient();\n  }\n\n  // Browser: prefer a non-throwing lookup first.\n  if (typeof service.getClientOrNull === 'function') {\n    const client = service.getClientOrNull();\n    if (client) return client;\n  }\n\n  // Tolerate test doubles that only expose `client`.\n  if (service.client) return service.client;\n\n  // Fall back to `getClient()` (may throw if env isn't configured).\n  if (typeof service.getClient === 'function') {\n    try {\n      return service.getClient();\n    } catch {\n      // In dev/test we prefer a lazy throwing proxy so services can be constructed\n      // without requiring env vars or a fully mocked Supabase client.\n      if (isDevMode()) {\n        return createUnconfiguredBrowserStubClient(\n          'Supabase no está configurado (o no fue mockeado en tests). Define NG_APP_SUPABASE_URL y NG_APP_SUPABASE_ANON_KEY, o provee un mock de SupabaseClientService en el spec.',\n        );\n      }\n      throw;\n    }\n  }\n\n  if (isDevMode()) {\n    return createUnconfiguredBrowserStubClient(\n      'Supabase client is not available (missing provider or mock in tests).',\n    );\n  }\n\n  throw new Error('Supabase client is not available');\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/core/services/ui/breakpoint.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'LoggerService' is defined but never used.","line":1,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":23}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { LoggerService } from '@core/services/infrastructure/logger.service';\nimport { isPlatformBrowser } from '@angular/common';\nimport { Injectable, Signal, computed, effect, inject, PLATFORM_ID } from '@angular/core';\nimport { toSignal } from '@angular/core/rxjs-interop';\nimport { fromEvent, map, startWith, throttleTime, of } from 'rxjs';\n\n/**\n * Breakpoints centralizados - Alineados con Tailwind CSS\n * @see apps/web/tailwind.config.js\n */\nexport const BREAKPOINTS = {\n  sm: 640,\n  md: 768,\n  lg: 1024,\n  xl: 1280,\n  '2xl': 1536,\n} as const;\n\nexport type Breakpoint = keyof typeof BREAKPOINTS;\n\n/**\n * Servicio centralizado para manejo de breakpoints responsivos\n *\n * @example\n * ```ts\n * export class MyComponent {\n  private readonly logger = inject(LoggerService);\n *   private breakpoint = inject(BreakpointService);\n *\n *   // Señales reactivas\n *   isMobile = this.breakpoint.isMobile;\n *   isDesktop = this.breakpoint.isDesktop;\n *\n *   // Métodos helper\n *   showMobileNav = computed(() => this.isMobile() && this.hasUser());\n * }\n * ```\n *\n * @example\n * ```html\n * @if (breakpoint.isMobile()) {\n *   <app-mobile-nav />\n * } @else {\n *   <app-desktop-nav />\n * }\n * ```\n */\n@Injectable({\n  providedIn: 'root',\n})\nexport class BreakpointService {\n  /** Ancho actual de la ventana */\n  readonly width: Signal<number>;\n\n  /** < 768px - Mobile phones */\n  readonly isMobile: Signal<boolean>;\n\n  /** >= 768px && < 1024px - Tablets */\n  readonly isTablet: Signal<boolean>;\n\n  /** >= 1024px - Desktop */\n  readonly isDesktop: Signal<boolean>;\n\n  /** < 640px - Small mobile (SE, Mini) */\n  readonly isSmallMobile: Signal<boolean>;\n\n  /** >= 1280px - Large desktop */\n  readonly isLargeDesktop: Signal<boolean>;\n\n  /** Orientación actual */\n  readonly isPortrait: Signal<boolean>;\n  readonly isLandscape: Signal<boolean>;\n\n  /** Breakpoint actual como string */\n  readonly current: Signal<Breakpoint>;\n\n  constructor() {\n    const platformId = inject(PLATFORM_ID);\n    const isBrowser = isPlatformBrowser(platformId);\n\n    // Default width for SSR (desktop first approach or mobile first, here using desktop)\n    const defaultWidth = isBrowser ? window.innerWidth : 1024;\n\n    // Observable del resize con throttle para performance\n    const resize$ = isBrowser\n      ? fromEvent(window, 'resize').pipe(\n          throttleTime(150, undefined, { leading: true, trailing: true }),\n          map(() => window.innerWidth),\n          startWith(window.innerWidth),\n        )\n      : of(defaultWidth); // Static value for SSR\n\n    // Convertir a signal\n    this.width = toSignal(resize$, { initialValue: defaultWidth });\n\n    // Signals computados para cada breakpoint\n    this.isMobile = computed(() => this.width() < BREAKPOINTS.md);\n    this.isTablet = computed(() => this.width() >= BREAKPOINTS.md && this.width() < BREAKPOINTS.lg);\n    this.isDesktop = computed(() => this.width() >= BREAKPOINTS.lg);\n    this.isSmallMobile = computed(() => this.width() < BREAKPOINTS.sm);\n    this.isLargeDesktop = computed(() => this.width() >= BREAKPOINTS.xl);\n\n    // Orientación\n    this.isPortrait = computed(() => (isBrowser ? window.innerHeight > window.innerWidth : false));\n    this.isLandscape = computed(() => (isBrowser ? window.innerHeight <= window.innerWidth : true));\n\n    // Breakpoint actual\n    this.current = computed(() => {\n      const w = this.width();\n      if (w < BREAKPOINTS.sm) return 'sm';\n      if (w < BREAKPOINTS.md) return 'md';\n      if (w < BREAKPOINTS.lg) return 'lg';\n      if (w < BREAKPOINTS.xl) return 'xl';\n      return '2xl';\n    });\n  }\n\n  /**\n   * Verifica si el ancho actual es mayor o igual al breakpoint\n   * @param breakpoint Breakpoint a verificar\n   */\n  isAtLeast(breakpoint: Breakpoint): boolean {\n    return this.width() >= BREAKPOINTS[breakpoint];\n  }\n\n  /**\n   * Verifica si el ancho actual es menor al breakpoint\n   * @param breakpoint Breakpoint a verificar\n   */\n  isBelow(breakpoint: Breakpoint): boolean {\n    return this.width() < BREAKPOINTS[breakpoint];\n  }\n\n  /**\n   * Verifica si el ancho está entre dos breakpoints\n   * @param min Breakpoint mínimo (inclusive)\n   * @param max Breakpoint máximo (exclusive)\n   */\n  isBetween(min: Breakpoint, max: Breakpoint): boolean {\n    const w = this.width();\n    return w >= BREAKPOINTS[min] && w < BREAKPOINTS[max];\n  }\n\n  /**\n   * Observa cambios en un breakpoint específico\n   * @param breakpoint Breakpoint a observar\n   * @param callback Función a ejecutar cuando cambie\n   * @returns Función para cancelar la observación\n   *\n   * @example\n   * ```ts\n   * ngOnInit() {\n   *   this.cleanup = this.breakpoint.observe('md', (matches) => {\n   *     this.logger.debug('Mobile:', matches);\n   *   });\n   * }\n   *\n   * ngOnDestroy() {\n   *   this.cleanup?.();\n   * }\n   * ```\n   */\n  observe(breakpoint: Breakpoint, callback: (matches: boolean) => void): () => void {\n    const isMatch = computed(() => this.width() >= BREAKPOINTS[breakpoint]);\n    const effectRef = effect(() => callback(isMatch()));\n    return () => effectRef.destroy();\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/core/services/verification/face-verification.service.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`@core/services/infrastructure/supabase-client.service` import should occur before import of `../../../environments/environment`","line":4,"column":1,"nodeType":"ImportDeclaration","endLine":4,"endColumn":88,"fix":{"range":[113,266],"text":"import { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\nimport { environment } from '../../../environments/environment';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { Injectable, signal } from '@angular/core';\nimport type { SupabaseClient } from '@supabase/supabase-js';\nimport { environment } from '../../../environments/environment';\nimport { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\n\n/**\n * Face Verification Result from Cloudflare Worker\n */\nexport interface FaceVerificationResult {\n  success: boolean;\n  face_detected: boolean;\n  face_match_score: number;\n  liveness_score?: number;\n  frames_analyzed?: number;\n  metadata?: {\n    video_duration_seconds?: number;\n    face_count?: number;\n    liveness_checks?: string[];\n  };\n  error?: string;\n}\n\n/**\n * Face Verification Status\n */\nexport interface FaceVerificationStatus {\n  isVerified: boolean;\n  selfieUrl: string | null;\n  verifiedAt: string | null;\n  faceMatchScore: number | null;\n  livenessScore: number | null;\n  requiresLevel2: boolean;\n}\n\n/**\n * Video Upload Progress\n */\nexport interface VideoUploadProgress {\n  loaded: number;\n  total: number;\n  percentage: number;\n}\n\n/**\n * Service for managing face verification via selfie video\n *\n * Handles:\n * - Uploading selfie videos to storage\n * - Processing videos with Cloudflare Worker AI\n * - Face matching against ID document photos\n * - Basic liveness detection (no advanced anti-spoofing)\n * - Verification status tracking\n */\n@Injectable({\n  providedIn: 'root',\n})\nexport class FaceVerificationService {\n  private readonly supabase: SupabaseClient = injectSupabase();\n  private readonly DOC_VERIFIER_URL =\n    environment.docVerifierUrl || 'https://doc-verifier.autorentar.workers.dev';\n\n  // Reactive state\n  readonly status = signal<FaceVerificationStatus>({\n    isVerified: false,\n    selfieUrl: null,\n    verifiedAt: null,\n    faceMatchScore: null,\n    livenessScore: null,\n    requiresLevel2: true,\n  });\n  readonly uploadProgress = signal<VideoUploadProgress | null>(null);\n  readonly processing = signal(false);\n  readonly loading = signal(false);\n  readonly error = signal<string | null>(null);\n\n  /**\n   * Check current face verification status\n   */\n  async checkFaceVerificationStatus(): Promise<FaceVerificationStatus> {\n    this.loading.set(true);\n    this['error'].set(null);\n\n    try {\n      const {\n        data: { user },\n      } = await this.supabase.auth.getUser();\n\n      if (!user) {\n        throw new Error('Usuario no autenticado');\n      }\n\n      // Get identity level data\n      const { data, error } = await this.supabase\n        .from('user_identity_levels')\n        .select('*')\n        .eq('user_id', user['id'])\n        .single();\n\n      if (error && error.code !== 'PGRST116') {\n        throw error;\n      }\n\n      const statusData: FaceVerificationStatus = {\n        isVerified: data?.selfie_verified_at !== null && (data?.face_match_score ?? 0) >= 70,\n        selfieUrl: data?.selfie_url ?? null,\n        verifiedAt: data?.selfie_verified_at ?? null,\n        faceMatchScore: data?.face_match_score ?? null,\n        livenessScore: data?.liveness_score ?? null,\n        requiresLevel2: (data?.current_level ?? 1) < 2,\n      };\n\n      this['status'].set(statusData);\n      return statusData;\n    } catch (err) {\n      const message =\n        err instanceof Error ? err['message'] : 'No pudimos verificar el estado de la selfie';\n      this['error'].set(message);\n      throw err;\n    } finally {\n      this.loading.set(false);\n    }\n  }\n\n  /**\n   * Upload selfie video to storage\n   * @param videoFile Video file (MP4/WebM, max 10MB, 3-10 seconds)\n   * @returns Storage URL of uploaded video\n   */\n  async uploadSelfieVideo(videoFile: File): Promise<string> {\n    this.loading.set(true);\n    this['error'].set(null);\n\n    try {\n      // Validate video file\n      this.validateVideoFile(videoFile);\n\n      const {\n        data: { user },\n      } = await this.supabase.auth.getUser();\n\n      if (!user) {\n        throw new Error('Usuario no autenticado');\n      }\n\n      // Check if user has Level 2 complete\n      const { data: levelData } = await this.supabase\n        .from('user_identity_levels')\n        .select('current_level')\n        .eq('user_id', user['id'])\n        .single();\n\n      if (!levelData || levelData.current_level < 2) {\n        throw new Error(\n          'Debes completar la verificación de documentos (Level 2) antes de verificar tu identidad con selfie',\n        );\n      }\n\n      // Generate unique filename\n      const timestamp = Date.now();\n      const extension = videoFile.name.split('.').pop() || 'mp4';\n      const fileName = `selfie_video_${timestamp}.${extension}`;\n      const filePath = `${user['id']}/${fileName}`;\n\n      // Upload to identity-documents bucket (or documents bucket if identity-documents doesn't exist)\n      const bucketName = 'identity-documents'; // Fallback to 'documents' if needed\n\n      const { error } = await this.supabase.storage.from(bucketName).upload(filePath, videoFile, {\n        cacheControl: '3600',\n        upsert: false,\n      });\n\n      if (error) {\n        // Fallback to documents bucket\n        if (error['message'].includes('not found')) {\n          const { error: fallbackError } = await this.supabase.storage\n            .from('documents')\n            .upload(filePath, videoFile, {\n              cacheControl: '3600',\n              upsert: false,\n            });\n\n          if (fallbackError) {\n            throw fallbackError;\n          }\n\n          // Get public URL\n          const {\n            data: { publicUrl },\n          } = this.supabase.storage.from('documents').getPublicUrl(filePath);\n\n          return publicUrl;\n        }\n\n        throw error;\n      }\n\n      // Get public URL\n      const {\n        data: { publicUrl },\n      } = this.supabase.storage.from(bucketName).getPublicUrl(filePath);\n\n      return publicUrl;\n    } catch (err) {\n      const message = err instanceof Error ? err['message'] : 'No pudimos subir el video';\n      this['error'].set(message);\n      throw err;\n    } finally {\n      this.loading.set(false);\n    }\n  }\n\n  /**\n   * Verify face by comparing selfie video with ID document photo\n   * @param videoUrl URL of uploaded selfie video\n   * @param documentUrl URL of ID document photo (from Level 2)\n   * @returns Verification result with face match score\n   */\n  async verifyFace(videoUrl: string, documentUrl: string): Promise<FaceVerificationResult> {\n    this.processing.set(true);\n    this['error'].set(null);\n\n    try {\n      const {\n        data: { user },\n      } = await this.supabase.auth.getUser();\n\n      if (!user) {\n        throw new Error('Usuario no autenticado');\n      }\n\n      // Call Cloudflare Worker for face verification\n      const response = await fetch(`${this.DOC_VERIFIER_URL}/verify-face`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          video_url: videoUrl,\n          document_url: documentUrl,\n          user_id: user['id'],\n        }),\n      });\n\n      if (!response.ok) {\n        const errorData = await response.json().catch(() => ({}));\n        throw new Error(errorData['error'] || 'Error al verificar la identidad facial');\n      }\n\n      const result: FaceVerificationResult = await response.json();\n\n      if (!result.success) {\n        throw new Error(result['error'] || 'Verificación facial fallida');\n      }\n\n      // Update user_identity_levels with results\n      await this.updateIdentityLevelWithResults(user['id'], videoUrl, result);\n\n      // Refresh status\n      await this.checkFaceVerificationStatus();\n\n      return result;\n    } catch (err) {\n      const message =\n        err instanceof Error ? err['message'] : 'No pudimos verificar tu identidad facial';\n      this['error'].set(message);\n      throw err;\n    } finally {\n      this.processing.set(false);\n    }\n  }\n\n  /**\n   * Get face match score for current user\n   */\n  async getFaceMatchScore(): Promise<number | null> {\n    try {\n      const status = await this.checkFaceVerificationStatus();\n      return status.faceMatchScore;\n    } catch {\n      return null;\n    }\n  }\n\n  /**\n   * Get liveness score for current user\n   */\n  async getLivenessScore(): Promise<number | null> {\n    try {\n      const status = await this.checkFaceVerificationStatus();\n      return status.livenessScore;\n    } catch {\n      return null;\n    }\n  }\n\n  /**\n   * Validate video file before upload\n   */\n  private validateVideoFile(file: File): void {\n    // Check file type\n    const validTypes = ['video/mp4', 'video/webm', 'video/quicktime'];\n    if (!validTypes.includes(file.type)) {\n      throw new Error(\n        'Formato de video no válido. Por favor usa MP4, WebM o MOV (máx 10MB, 3-10 segundos)',\n      );\n    }\n\n    // Check file size (max 10MB)\n    const maxSize = 10 * 1024 * 1024; // 10MB\n    if (file.size > maxSize) {\n      throw new Error('El video es demasiado grande. Tamaño máximo: 10MB');\n    }\n\n    // Check minimum size (at least 100KB to ensure it's not empty)\n    const minSize = 100 * 1024; // 100KB\n    if (file.size < minSize) {\n      throw new Error('El video es demasiado pequeño. Debe tener al menos 3 segundos');\n    }\n  }\n\n  /**\n   * Update user_identity_levels with face verification results\n   */\n  private async updateIdentityLevelWithResults(\n    userId: string,\n    videoUrl: string,\n    result: FaceVerificationResult,\n  ): Promise<void> {\n    const updates: Record<string, unknown> = {\n      selfie_url: videoUrl,\n      face_match_score: result.face_match_score,\n      liveness_score: result.liveness_score ?? null,\n      updated_at: new Date().toISOString(),\n    };\n\n    // Mark as verified if score is good (>= 70%)\n    if (result.face_match_score >= 70) {\n      updates['selfie_verified_at'] = new Date().toISOString();\n    }\n\n    const { error } = await this.supabase\n      .from('user_identity_levels')\n      .update(updates)\n      .eq('user_id', userId);\n\n    if (error) {\n      console['error']('Failed to update identity level with face results:', error);\n      throw new Error('No pudimos guardar los resultados de verificación facial');\n    }\n  }\n\n  /**\n   * Delete selfie video (retry verification)\n   */\n  async deleteSelfieVideo(): Promise<void> {\n    this.loading.set(true);\n    this['error'].set(null);\n\n    try {\n      const {\n        data: { user },\n      } = await this.supabase.auth.getUser();\n\n      if (!user) {\n        throw new Error('Usuario no autenticado');\n      }\n\n      // Get current selfie URL\n      const { data: levelData } = await this.supabase\n        .from('user_identity_levels')\n        .select('selfie_url')\n        .eq('user_id', user['id'])\n        .single();\n\n      if (!levelData?.selfie_url) {\n        return; // Nothing to delete\n      }\n\n      // Extract storage path from URL\n      const url = new URL(levelData.selfie_url);\n      const pathParts = url.pathname.split('/identity-documents/');\n      const storagePath = pathParts.length > 1 ? pathParts[1] : null;\n\n      if (storagePath) {\n        // Try identity-documents bucket first\n        await this.supabase.storage.from('identity-documents').remove([storagePath]);\n\n        // Fallback to documents bucket\n        const pathPartsDocuments = url.pathname.split('/documents/');\n        if (pathPartsDocuments.length > 1) {\n          await this.supabase.storage.from('documents').remove([pathPartsDocuments[1]]);\n        }\n      }\n\n      // Clear verification data\n      await this.supabase\n        .from('user_identity_levels')\n        .update({\n          selfie_url: null,\n          selfie_verified_at: null,\n          face_match_score: null,\n          liveness_score: null,\n          updated_at: new Date().toISOString(),\n        })\n        .eq('user_id', user['id']);\n\n      // Refresh status\n      await this.checkFaceVerificationStatus();\n    } catch (err) {\n      const message = err instanceof Error ? err['message'] : 'No pudimos eliminar el video';\n      this['error'].set(message);\n      throw err;\n    } finally {\n      this.loading.set(false);\n    }\n  }\n\n  /**\n   * Clear error state\n   */\n  clearError(): void {\n    this['error'].set(null);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/core/services/verification/fgo-v1-1.service.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`@core/services/infrastructure/supabase-client.service` import should occur before import of `../models/fgo-v1-1.model`","line":32,"column":1,"nodeType":"ImportDeclaration","endLine":32,"endColumn":95,"fix":{"range":[178,855],"text":"import { SupabaseClientService } from '@core/services/infrastructure/supabase-client.service';\nimport {\n  FgoParameters,\n  FgoParametersDb,\n  BookingRiskSnapshot,\n  BookingRiskSnapshotDb,\n  BookingInspection,\n  BookingInspectionDb,\n  FgoStatusV1_1,\n  PemCalculation,\n  RcCalculationV1_1,\n  AlphaAdjustment,\n  EligibilityResult,\n  WaterfallResult,\n  CreateRiskSnapshotParams,\n  CreateInspectionParams,\n  AssessEligibilityParams,\n  ExecuteWaterfallParams,\n  UpdateParametersParams,\n  mapFgoParameters,\n  mapBookingRiskSnapshot,\n  mapBookingInspection,\n  centsToUsd,\n} from '../models/fgo-v1-1.model';\n\n// Models v1.0 (base)\nimport { FgoMovementView } from '../models/fgo.model';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { Injectable } from '@angular/core';\nimport { Observable, from, map, catchError, of } from 'rxjs';\nimport { SupabaseClient } from '@supabase/supabase-js';\n\n// Models v1.1\nimport {\n  FgoParameters,\n  FgoParametersDb,\n  BookingRiskSnapshot,\n  BookingRiskSnapshotDb,\n  BookingInspection,\n  BookingInspectionDb,\n  FgoStatusV1_1,\n  PemCalculation,\n  RcCalculationV1_1,\n  AlphaAdjustment,\n  EligibilityResult,\n  WaterfallResult,\n  CreateRiskSnapshotParams,\n  CreateInspectionParams,\n  AssessEligibilityParams,\n  ExecuteWaterfallParams,\n  UpdateParametersParams,\n  mapFgoParameters,\n  mapBookingRiskSnapshot,\n  mapBookingInspection,\n  centsToUsd,\n} from '../models/fgo-v1-1.model';\n\n// Models v1.0 (base)\nimport { FgoMovementView } from '../models/fgo.model';\nimport { SupabaseClientService } from '@core/services/infrastructure/supabase-client.service';\n\n/**\n * Servicio para gestionar FGO v1.1 (Extensión de FgoService)\n *\n * NUEVAS FUNCIONALIDADES v1.1:\n * - Gestión de parámetros por país/bucket\n * - Snapshots de riesgo por booking\n * - Inspecciones de vehículo\n * - Evaluación de elegibilidad\n * - Ejecución de waterfall\n * - Métricas extendidas (PEM, RC dinámico)\n */\n@Injectable({\n  providedIn: 'root',\n})\nexport class FgoV1_1Service {\n  private readonly supabaseClient: SupabaseClient;\n  private readonly riskSnapshotTable = 'booking_risk_snapshots';\n\n  constructor(private readonly supabaseService: SupabaseClientService) {\n    this.supabaseClient = this.supabaseService.getClient();\n  }\n\n  // ============================================================================\n  // PARÁMETROS FGO\n  // ============================================================================\n\n  /**\n   * Obtiene los parámetros FGO para un país/bucket específico\n   */\n  getParameters(countryCode: string, bucket: string): Observable<FgoParameters | null> {\n    return from(\n      this.supabaseClient\n        .from('fgo_parameters')\n        .select('*')\n        .eq('country_code', countryCode)\n        .eq('bucket', bucket)\n        .single(),\n    ).pipe(\n      map((response) => {\n        if (response['error']) {\n          return null;\n        }\n        return response.data ? mapFgoParameters(response.data as FgoParametersDb) : null;\n      }),\n      catchError((_error) => {\n        return of(null);\n      }),\n    );\n  }\n\n  /**\n   * Obtiene todos los parámetros FGO (todos los países/buckets)\n   */\n  getAllParameters(): Observable<FgoParameters[]> {\n    return from(\n      this.supabaseClient.from('fgo_parameters').select('*').order('country_code').order('bucket'),\n    ).pipe(\n      map((response) => {\n        if (response['error']) {\n          return [];\n        }\n        return (response.data || []).map((p) => mapFgoParameters(p as FgoParametersDb));\n      }),\n      catchError((_error) => {\n        return of([]);\n      }),\n    );\n  }\n\n  /**\n   * Actualiza parámetros FGO (solo admins)\n   */\n  updateParameters(params: UpdateParametersParams): Observable<boolean> {\n    const updates: Partial<FgoParametersDb> = {};\n\n    if (params.alpha !== undefined) updates.alpha = params.alpha;\n    if (params.rcFloor !== undefined) updates.rc_floor = params.rcFloor;\n    if (params.eventCapUsd !== undefined) updates.event_cap_usd = params.eventCapUsd;\n    if (params.perUserLimit !== undefined) updates.per_user_limit = params.perUserLimit;\n\n    return from(\n      this.supabaseClient\n        .from('fgo_parameters')\n        .update(updates)\n        .eq('country_code', params.countryCode)\n        .eq('bucket', params.bucket),\n    ).pipe(\n      map((response) => {\n        if (response['error']) {\n          return false;\n        }\n        return true;\n      }),\n      catchError((_error) => {\n        return of(false);\n      }),\n    );\n  }\n\n  // ============================================================================\n  // SNAPSHOTS DE RIESGO\n  // ============================================================================\n\n  /**\n   * Crea un snapshot de riesgo para un booking\n   */\n  createRiskSnapshot(params: CreateRiskSnapshotParams): Observable<BookingRiskSnapshot | null> {\n    const snapshotData: Omit<BookingRiskSnapshotDb, 'created_at'> = {\n      booking_id: params['bookingId'],\n      country_code: params.countryCode,\n      bucket: params.bucket,\n      fx_snapshot: params.fxSnapshot,\n      currency: params['currency'],\n      estimated_hold_amount: params.estimatedHoldAmount,\n      estimated_deposit: params.estimatedDeposit,\n      franchise_usd: params.franchiseUsd,\n      has_card: params.hasCard,\n      has_wallet_security: params.hasWalletSecurity,\n      meta: {},\n    };\n\n    return from(\n      this.supabaseClient.from(this.riskSnapshotTable).insert(snapshotData).select().single(),\n    ).pipe(\n      map((response) => {\n        if (response['error']) {\n          return null;\n        }\n        return response.data\n          ? mapBookingRiskSnapshot(response.data as BookingRiskSnapshotDb)\n          : null;\n      }),\n      catchError((_error) => {\n        return of(null);\n      }),\n    );\n  }\n\n  /**\n   * Obtiene el snapshot de riesgo de un booking\n   */\n  getRiskSnapshot(bookingId: string): Observable<BookingRiskSnapshot | null> {\n    return from(\n      this.supabaseClient\n        .from(this.riskSnapshotTable)\n        .select('*')\n        .eq('booking_id', bookingId)\n        .maybeSingle(),\n    ).pipe(\n      map((response) => {\n        if (response['error']) {\n          return null;\n        }\n        return response.data\n          ? mapBookingRiskSnapshot(response.data as BookingRiskSnapshotDb)\n          : null;\n      }),\n      catchError((_error) => {\n        return of(null);\n      }),\n    );\n  }\n\n  // ============================================================================\n  // INSPECCIONES DE VEHÍCULO\n  // ============================================================================\n\n  /**\n   * Crea una inspección de vehículo\n   */\n  createInspection(params: CreateInspectionParams): Observable<BookingInspection | null> {\n    const inspectionData: Omit<BookingInspectionDb, 'id' | 'created_at' | 'signed_at'> = {\n      booking_id: params['bookingId'],\n      stage: params.stage,\n      inspector_id: params.inspectorId,\n      photos: params.photos,\n      odometer: params.odometer,\n      fuel_level: params.fuelLevel,\n      latitude: params.latitude,\n      longitude: params.longitude,\n    };\n\n    return from(\n      this.supabaseClient.from('booking_inspections').insert(inspectionData).select().single(),\n    ).pipe(\n      map((response) => {\n        if (response['error']) {\n          return null;\n        }\n        return response.data ? mapBookingInspection(response.data as BookingInspectionDb) : null;\n      }),\n      catchError((_error) => {\n        return of(null);\n      }),\n    );\n  }\n\n  /**\n   * Firma una inspección (marca como completada)\n   */\n  signInspection(inspectionId: string): Observable<boolean> {\n    return from(\n      this.supabaseClient\n        .from('booking_inspections')\n        .update({ signed_at: new Date().toISOString() })\n        .eq('id', inspectionId),\n    ).pipe(\n      map((response) => {\n        if (response['error']) {\n          return false;\n        }\n        return true;\n      }),\n      catchError((_error) => {\n        return of(false);\n      }),\n    );\n  }\n\n  /**\n   * Obtiene las inspecciones de un booking\n   */\n  getInspections(bookingId: string): Observable<BookingInspection[]> {\n    return from(\n      this.supabaseClient\n        .from('booking_inspections')\n        .select('*')\n        .eq('booking_id', bookingId)\n        .order('created_at', { ascending: true }),\n    ).pipe(\n      map((response) => {\n        if (response['error']) {\n          return [];\n        }\n        return (response.data || []).map((i) => mapBookingInspection(i as BookingInspectionDb));\n      }),\n      catchError((_error) => {\n        return of([]);\n      }),\n    );\n  }\n\n  /**\n   * Obtiene una inspección específica (por booking y stage)\n   */\n  getInspectionByStage(\n    bookingId: string,\n    stage: 'check_in' | 'check_out' | 'renter_check_in',\n  ): Observable<BookingInspection | null> {\n    return from(\n      this.supabaseClient\n        .from('booking_inspections')\n        .select('*')\n        .eq('booking_id', bookingId)\n        .eq('stage', stage)\n        .maybeSingle(),\n    ).pipe(\n      map((response) => {\n        if (response['error']) {\n          return null;\n        }\n        return response.data ? mapBookingInspection(response.data as BookingInspectionDb) : null;\n      }),\n      catchError((_error) => {\n        return of(null);\n      }),\n    );\n  }\n\n  // ============================================================================\n  // MÉTRICAS EXTENDIDAS v1.1\n  // ============================================================================\n\n  /**\n   * Obtiene el estado extendido del FGO con métricas v1.1\n   */\n  getStatusV1_1(): Observable<FgoStatusV1_1 | null> {\n    return from(this.supabaseClient.from('v_fgo_status_v1_1').select('*').single()).pipe(\n      map((response) => {\n        if (response['error']) {\n          return null;\n        }\n\n        const data = response.data;\n        if (!data) return null;\n\n        return {\n          // v1.0 fields\n          liquidityBalance: centsToUsd(data.liquidity_balance_cents),\n          capitalizationBalance: centsToUsd(data.capitalization_balance_cents),\n          profitabilityBalance: centsToUsd(data.profitability_balance_cents),\n          totalBalance: centsToUsd(data.total_fgo_balance_cents),\n          alphaPercentage: data.alpha_percentage,\n          targetMonthsCoverage: data.target_months_coverage,\n          totalContributions: centsToUsd(data.total_contributions_cents),\n          totalSiniestrosPaid: centsToUsd(data.total_siniestros_paid_cents),\n          totalSiniestrosCount: data.total_siniestros_count,\n          coverageRatio: data.coverage_ratio,\n          lossRatio: data.loss_ratio,\n          targetBalance: data.target_balance_cents ? centsToUsd(data.target_balance_cents) : null,\n          status: data['status'],\n\n          // 🆕 v1.1 fields\n          pemCents: data.pem_cents,\n          pem: data.pem_cents ? centsToUsd(data.pem_cents) : null,\n          lr90d: data.lr_90d,\n          lr365d: data.lr_365d,\n          totalEvents90d: data.total_events_90d || 0,\n          avgRecoveryRate: data.avg_recovery_rate,\n\n          lastCalculatedAt: new Date(data.last_calculated_at),\n          updatedAt: new Date(data['updated_at']),\n        } as FgoStatusV1_1;\n      }),\n      catchError((_error) => {\n        return of(null);\n      }),\n    );\n  }\n\n  /**\n   * Calcula PEM (Pérdida Esperada Mensual) para un país/bucket\n   */\n  calculatePem(\n    countryCode?: string,\n    bucket?: string,\n    windowDays = 90,\n  ): Observable<PemCalculation | null> {\n    return from(\n      this.supabaseClient.rpc('calculate_pem', {\n        p_country_code: countryCode || null,\n        p_bucket: bucket || null,\n        p_window_days: windowDays,\n      }),\n    ).pipe(\n      map((response) => {\n        if (response['error']) {\n          return null;\n        }\n\n        const results = response.data as Record<string, unknown>[] | null;\n        const data = results?.[0];\n        if (!data) return null;\n\n        return {\n          countryCode: data['country_code'] as string,\n          bucket: data['bucket'] as string,\n          pemCents: data['pem_cents'] as number,\n          pem: centsToUsd(data['pem_cents'] as number),\n          eventCount: data['event_count'] as number,\n          avgEventCents: data['avg_event_cents'] as number,\n          avgEvent: centsToUsd(data['avg_event_cents'] as number),\n          totalPaid: centsToUsd(data['total_paid_cents'] as number),\n          totalRecovered: centsToUsd(data['total_recovered_cents'] as number),\n        } as PemCalculation;\n      }),\n      catchError((_error) => {\n        return of(null);\n      }),\n    );\n  }\n\n  /**\n   * Calcula RC dinámico v1.1 (basado en PEM)\n   */\n  calculateRcV1_1(countryCode?: string, bucket?: string): Observable<RcCalculationV1_1 | null> {\n    return from(\n      this.supabaseClient.rpc('calculate_rc_v1_1', {\n        p_country_code: countryCode || null,\n        p_bucket: bucket || null,\n      }),\n    ).pipe(\n      map((response) => {\n        if (response['error']) {\n          return null;\n        }\n\n        const data = response.data;\n        if (!data) return null;\n\n        return {\n          pemCents: data.pem_cents,\n          pem: centsToUsd(data.pem_cents),\n          currentBalanceCents: data.current_balance_cents,\n          currentBalance: centsToUsd(data.current_balance_cents),\n          targetBalanceCents: data.target_balance_cents,\n          targetBalance: centsToUsd(data.target_balance_cents),\n          rc: data.rc,\n          eventCount: data.event_count,\n          status: data['status'],\n          calculatedAt: new Date(data.calculated_at),\n        } as RcCalculationV1_1;\n      }),\n      catchError((_error) => {\n        return of(null);\n      }),\n    );\n  }\n\n  /**\n   * Ajusta alpha dinámicamente según RC (solo ejecutable por admin/cron)\n   */\n  adjustAlphaDynamic(countryCode: string, bucket: string): Observable<AlphaAdjustment | null> {\n    return from(\n      this.supabaseClient.rpc('adjust_alpha_dynamic', {\n        p_country_code: countryCode,\n        p_bucket: bucket,\n      }),\n    ).pipe(\n      map((response) => {\n        if (response['error']) {\n          return null;\n        }\n\n        const data = response.data;\n        if (!data) return null;\n\n        return {\n          countryCode: data.country_code,\n          bucket: data.bucket,\n          rc: data.rc,\n          previousAlpha: data.previous_alpha,\n          newAlpha: data.new_alpha,\n          adjusted: data.adjusted,\n          adjustmentDelta: data.adjustment_delta,\n          timestamp: new Date(data.timestamp),\n        } as AlphaAdjustment;\n      }),\n      catchError((_error) => {\n        return of(null);\n      }),\n    );\n  }\n\n  // ============================================================================\n  // WATERFALL Y ELEGIBILIDAD\n  // ============================================================================\n\n  /**\n   * Evalúa la elegibilidad de un booking para cobertura FGO\n   */\n  assessEligibility(params: AssessEligibilityParams): Observable<EligibilityResult | null> {\n    return from(\n      this.supabaseClient.rpc('fgo_assess_eligibility', {\n        p_booking_id: params['bookingId'],\n        p_claim_amount_cents: params.claimAmountCents,\n      }),\n    ).pipe(\n      map((response) => {\n        if (response['error']) {\n          return null;\n        }\n\n        const data = response.data;\n        if (!data) return null;\n\n        return {\n          eligible: data.eligible,\n          reasons: data.reasons || [],\n          rc: data.rc,\n          rcStatus: data.rc_status,\n          franchisePercentage: data.franchise_percentage,\n          maxCoverCents: data.max_cover_cents,\n          maxCoverUsd: data.max_cover_usd,\n          eventCapUsd: data.event_cap_usd,\n          monthlyPayoutUsedCents: data.monthly_payout_used_cents,\n          monthlyCapCents: data.monthly_cap_cents,\n          userEventsQuarter: data.user_events_quarter,\n          userEventLimit: data.user_event_limit,\n          fgoBalanceCents: data.fgo_balance_cents,\n          snapshot: data.snapshot,\n        } as EligibilityResult;\n      }),\n      catchError((_error) => {\n        return of(null);\n      }),\n    );\n  }\n\n  /**\n   * Ejecuta el waterfall completo de cobros\n   * IMPORTANTE: Solo ejecutable por service role (admin/sistema)\n   */\n  executeWaterfall(params: ExecuteWaterfallParams): Observable<WaterfallResult | null> {\n    return from(\n      this.supabaseClient.rpc('fgo_execute_waterfall', {\n        p_booking_id: params['bookingId'],\n        p_total_claim_cents: params.totalClaimCents,\n        p_description: params['description'],\n        p_evidence_url: params.evidenceUrl || null,\n      }),\n    ).pipe(\n      map((response) => {\n        if (response['error']) {\n          return null;\n        }\n\n        const data = response.data;\n        if (!data) return null;\n\n        return {\n          ok: data.ok,\n          error: data['error'],\n          bookingId: data.booking_id,\n          totalClaimCents: data.total_claim_cents,\n          breakdown: {\n            holdCaptured: data.breakdown.hold_captured,\n            walletDebited: data.breakdown.wallet_debited,\n            extraCharged: data.breakdown.extra_charged,\n            fgoPaid: data.breakdown.fgo_paid,\n            remainingUncovered: data.breakdown.remaining_uncovered,\n          },\n          fgoMovementId: data.fgo_movement_id,\n          fgoRef: data.fgo_ref,\n          eligibility: data.eligibility,\n          executedAt: new Date(data.executed_at),\n        } as WaterfallResult;\n      }),\n      catchError((_error) => {\n        return of(null);\n      }),\n    );\n  }\n\n  // ============================================================================\n  // UTILIDADES\n  // ============================================================================\n\n  /**\n   * Verifica si el usuario actual es admin\n   */\n  async isAdmin(): Promise<boolean> {\n    const {\n      data: { user },\n    } = await this.supabaseClient.auth.getUser();\n    if (!user) return false;\n\n    const { data: profile } = await this.supabaseClient\n      .from('profiles')\n      .select('is_admin')\n      .eq('id', user['id'])\n      .single();\n\n    return profile?.['is_admin'] === true;\n  }\n\n  /**\n   * Obtiene el ID del usuario actual\n   */\n  async getCurrentUserId(): Promise<string | null> {\n    const {\n      data: { user },\n    } = await this.supabaseClient.auth.getUser();\n    return user?.['id'] || null;\n  }\n\n  getMovements(limit: number, offset: number): Observable<FgoMovementView[]> {\n    return from(\n      this.supabaseClient\n        .from('fgo_movements_view') // Assuming a view with this name exists\n        .select('*')\n        .limit(limit)\n        .range(offset, offset + limit - 1),\n    ).pipe(\n      map((response) => {\n        if (response['error']) {\n          return [];\n        }\n        return response.data as FgoMovementView[];\n      }),\n      catchError((_error) => {\n        return of([]);\n      }),\n    );\n  }\n\n  recalculateMetrics(): Observable<{ ok: boolean; error?: string }> {\n    return from(this.supabaseClient.rpc('recalculate_fgo_metrics')).pipe(\n      map((response) => {\n        if (response['error']) {\n          return { ok: false, error: response['error']['message'] };\n        }\n        return { ok: true };\n      }),\n      catchError((_error) => {\n        return of({ ok: false, error: _error['message'] });\n      }),\n    );\n  }\n\n  transferBetweenSubfunds(params: {\n    fromSubfund: string;\n    toSubfund: string;\n    amountCents: number;\n    reason: string;\n    adminId: string;\n  }): Observable<{ ok: boolean; ref?: string; error?: string }> {\n    return from(\n      this.supabaseClient.rpc('transfer_fgo_funds', {\n        p_from_subfund: params.fromSubfund,\n        p_to_subfund: params.toSubfund,\n        p_amount_cents: params.amountCents,\n        p_reason: params.reason,\n        p_admin_id: params.adminId,\n      }),\n    ).pipe(\n      map((response) => {\n        if (response['error']) {\n          return { ok: false, error: response['error']['message'] };\n        }\n        return { ok: true, ref: response.data };\n      }),\n      catchError((_error) => {\n        return of({ ok: false, error: _error['message'] });\n      }),\n    );\n  }\n\n  paySiniestro(params: {\n    bookingId: string;\n    amountCents: number;\n    description: string;\n  }): Observable<{ ok: boolean; ref?: string; error?: string }> {\n    return from(\n      this.supabaseClient.rpc('pay_fgo_siniestro', {\n        p_booking_id: params['bookingId'],\n        p_amount_cents: params.amountCents,\n        p_description: params['description'],\n      }),\n    ).pipe(\n      map((response) => {\n        if (response['error']) {\n          return { ok: false, error: response['error']['message'] };\n        }\n        return { ok: true, ref: response.data };\n      }),\n      catchError((_error) => {\n        return of({ ok: false, error: _error['message'] });\n      }),\n    );\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/core/services/verification/risk.service.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`@core/services/infrastructure/supabase-client.service` import should occur before import of `../models/booking-detail-payment.model`","line":12,"column":1,"nodeType":"ImportDeclaration","endLine":12,"endColumn":88,"fix":{"range":[114,461],"text":"import { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\nimport {\n  BucketType,\n  CalculateRiskSnapshotParams,\n  CoverageUpgrade,\n  RiskSnapshot,\n  applyUpgradeToDeductible,\n  calculateDeductibleUsd,\n} from '../models/booking-detail-payment.model';\nimport { RiskCalculatorService } from './risk-calculator.service';\n"}}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":156,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":156,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5065,5068],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5065,5068],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { Injectable, inject } from '@angular/core';\nimport { Observable, catchError, from, map, of } from 'rxjs';\nimport {\n  BucketType,\n  CalculateRiskSnapshotParams,\n  CoverageUpgrade,\n  RiskSnapshot,\n  applyUpgradeToDeductible,\n  calculateDeductibleUsd,\n} from '../models/booking-detail-payment.model';\nimport { RiskCalculatorService } from './risk-calculator.service';\nimport { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\n\n/**\n * Servicio para cálculo de riesgos y garantías\n * Calcula franquicias, holds y créditos de seguridad según reglas AR\n * ✅ NEW: Usa RiskCalculatorService para aplicar lógica de distancia\n */\n@Injectable({\n  providedIn: 'root',\n})\nexport class RiskService {\n  private supabaseClient = injectSupabase();\n  private riskCalculator = inject(RiskCalculatorService);\n  private readonly riskSnapshotTable = 'booking_risk_snapshots';\n\n  /**\n   * Calcula el risk snapshot completo para una reserva\n   * ✅ NEW: Usa RiskCalculatorService para aplicar lógica de distancia con criterio MAYOR\n   */\n  async calculateRiskSnapshot(params: CalculateRiskSnapshotParams): Promise<RiskSnapshot> {\n    const {\n      vehicleValueUsd,\n      bucket,\n      country,\n      fxRate,\n      coverageUpgrade = 'standard',\n      distanceKm,\n    } = params;\n\n    // 1. Calcular franquicia base según valor del vehículo\n    const baseDeductible = calculateDeductibleUsd(vehicleValueUsd);\n\n    // 2. Aplicar upgrade de cobertura\n    const deductibleUsd = applyUpgradeToDeductible(baseDeductible, coverageUpgrade);\n\n    // 3. Franquicia por vuelco = 1.5× franquicia estándar\n    const rolloverDeductibleUsd = deductibleUsd * 1.5;\n\n    // ✅ NEW: Usar RiskCalculatorService para calcular garantías con distancia\n    // Calculamos para ambas modalidades (con y sin tarjeta)\n\n    // Modalidad CON tarjeta (hold)\n    const riskCalcWithCard = await this.riskCalculator.calculateRisk(\n      vehicleValueUsd,\n      fxRate,\n      true, // hasCard=true\n      distanceKm?.toString(),\n    );\n\n    // Modalidad SIN tarjeta (crédito de seguridad)\n    const riskCalcWithoutCard = await this.riskCalculator.calculateRisk(\n      vehicleValueUsd,\n      fxRate,\n      false, // hasCard=false\n      distanceKm?.toString(),\n    );\n\n    // 4. Hold estimado en ARS con distancia aplicada (usa guaranteeAmountArs que incluye criterio MAYOR)\n    const holdEstimatedArs = riskCalcWithCard.guaranteeAmountArs;\n    const holdEstimatedUsd = riskCalcWithCard.guaranteeAmountUsd;\n\n    // 5. Crédito de Seguridad (modalidad sin tarjeta) con distancia aplicada\n    const creditSecurityUsd = riskCalcWithoutCard.guaranteeAmountUsd;\n\n    return {\n      deductibleUsd,\n      rolloverDeductibleUsd,\n      holdEstimatedArs,\n      holdEstimatedUsd,\n      creditSecurityUsd,\n      bucket,\n      vehicleValueUsd,\n      country,\n      fxRate,\n      calculatedAt: new Date(),\n      coverageUpgrade,\n    };\n  }\n\n  /**\n   * Persiste el risk snapshot en la base de datos\n   */\n  persistRiskSnapshot(\n    bookingId: string,\n    riskSnapshot: RiskSnapshot,\n    paymentMode: 'card' | 'wallet',\n  ): Observable<{ ok: boolean; snapshotId?: string; error?: string }> {\n    const snapshotData = {\n      booking_id: bookingId,\n      country_code: riskSnapshot.country,\n      bucket: riskSnapshot.bucket,\n      fx_snapshot: riskSnapshot.fxRate,\n      currency: 'ARS',\n      estimated_hold_amount: paymentMode === 'card' ? riskSnapshot.holdEstimatedArs : null,\n      estimated_deposit: paymentMode === 'wallet' ? riskSnapshot.creditSecurityUsd : null,\n      franchise_usd: riskSnapshot.deductibleUsd,\n      has_card: paymentMode === 'card',\n      has_wallet_security: paymentMode === 'wallet',\n      meta: {\n        vehicle_value_usd: riskSnapshot.vehicleValueUsd,\n        calculated_at: riskSnapshot.calculatedAt.toISOString(),\n        coverage_upgrade: riskSnapshot.coverageUpgrade,\n        rollover_deductible_usd: riskSnapshot.rolloverDeductibleUsd,\n      },\n    };\n\n    return from(\n      this.supabaseClient\n        .from(this.riskSnapshotTable)\n        .insert(snapshotData)\n        .select('booking_id')\n        .single(),\n    ).pipe(\n      map((response) => {\n        if (response.error) {\n          return { ok: false, error: response.error.message };\n        }\n        return { ok: true, snapshotId: response.data.booking_id };\n      }),\n      catchError((error) => {\n        return of({ ok: false, error: error.message || 'Error desconocido' });\n      }),\n    );\n  }\n\n  /**\n   * Obtiene un risk snapshot por booking ID\n   */\n  getRiskSnapshotByBookingId(\n    bookingId: string,\n  ): Observable<{ snapshot: RiskSnapshot | null; error?: string }> {\n    return from(\n      this.supabaseClient\n        .from(this.riskSnapshotTable)\n        .select('*')\n        .eq('booking_id', bookingId)\n        .single(),\n    ).pipe(\n      map((response) => {\n        if (response.error || !response.data) {\n          return { snapshot: null, error: response.error?.message };\n        }\n\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const data = response.data as any;\n        const snapshot: RiskSnapshot = {\n          deductibleUsd: data.franchise_usd,\n          rolloverDeductibleUsd:\n            data.rollover_franchise_usd ?? data.meta?.rollover_deductible_usd ?? 0,\n          holdEstimatedArs: data.estimated_hold_amount || 0,\n          holdEstimatedUsd: (data.estimated_hold_amount || 0) / data.fx_snapshot,\n          creditSecurityUsd: data.estimated_deposit || 0,\n          bucket: data.bucket as BucketType,\n          vehicleValueUsd: data.meta?.vehicle_value_usd || 0,\n          country: data.country_code,\n          fxRate: data.fx_snapshot,\n          calculatedAt: new Date(data.created_at),\n          coverageUpgrade:\n            (data.coverage_upgrade as CoverageUpgrade) ||\n            (data.meta?.coverage_upgrade as CoverageUpgrade) ||\n            'standard',\n        };\n\n        return { snapshot };\n      }),\n      catchError((error) => {\n        return of({ snapshot: null, error: error.message });\n      }),\n    );\n  }\n\n  /**\n   * Recalcula el risk snapshot cuando cambia el upgrade de cobertura\n   */\n  recalculateWithUpgrade(\n    currentSnapshot: RiskSnapshot,\n    newUpgrade: CoverageUpgrade,\n  ): Promise<RiskSnapshot> {\n    return this.calculateRiskSnapshot({\n      vehicleValueUsd: currentSnapshot.vehicleValueUsd,\n      bucket: currentSnapshot.bucket,\n      country: currentSnapshot.country,\n      fxRate: currentSnapshot.fxRate,\n      coverageUpgrade: newUpgrade,\n    });\n  }\n\n  /**\n   * Recalcula el risk snapshot cuando cambia el FX rate\n   */\n  recalculateWithNewFxRate(\n    currentSnapshot: RiskSnapshot,\n    newFxRate: number,\n  ): Promise<RiskSnapshot> {\n    return this.calculateRiskSnapshot({\n      vehicleValueUsd: currentSnapshot.vehicleValueUsd,\n      bucket: currentSnapshot.bucket,\n      country: currentSnapshot.country,\n      fxRate: newFxRate,\n      coverageUpgrade: currentSnapshot.coverageUpgrade,\n    });\n  }\n\n  /**\n   * Valida que el risk snapshot sea coherente con las reglas de negocio\n   */\n  validateRiskSnapshot(snapshot: RiskSnapshot): { valid: boolean; errors: string[] } {\n    const errors: string[] = [];\n\n    // 1. Franquicia debe ser positiva (excepto para upgrade 'zero')\n    if (snapshot.coverageUpgrade !== 'zero' && snapshot.deductibleUsd <= 0) {\n      errors.push('La franquicia debe ser mayor a 0');\n    }\n\n    // 2. Franquicia por vuelco debe ser 1.5× la estándar (si no es zero)\n    if (\n      snapshot.coverageUpgrade !== 'zero' &&\n      Math.abs(snapshot.rolloverDeductibleUsd - snapshot.deductibleUsd * 1.5) > 0.01\n    ) {\n      errors.push('La franquicia por vuelco debe ser 1.5× la franquicia estándar');\n    }\n\n    // 3. Hold debe ser razonable (entre USD 150 y USD 2000)\n    const holdUsd = snapshot.holdEstimatedArs / snapshot.fxRate;\n    if (holdUsd < 150 || holdUsd > 2000) {\n      errors.push(`Hold fuera de rango: ${holdUsd.toFixed(2)} USD (esperado: 150-2000)`);\n    }\n\n    // 4. Crédito de seguridad debe ser 600\n    if (snapshot.creditSecurityUsd !== 600) {\n      errors.push('Crédito de seguridad debe ser 600 USD');\n    }\n\n    // 5. FX rate debe ser razonable para ARS (>= 100, <= 10000)\n    if (snapshot.country === 'AR' && (snapshot.fxRate < 100 || snapshot.fxRate > 10000)) {\n      errors.push(`Tasa FX fuera de rango: ${snapshot.fxRate} (esperado: 100-10000 ARS/USD)`);\n    }\n\n    return {\n      valid: errors.length === 0,\n      errors,\n    };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/core/services/verification/trip-safety.service.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`./incident-detector.service` import should occur after import of `@core/services/infrastructure/supabase-client.service`","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":71,"fix":{"range":[324,561],"text":"import { LoggerService } from '@core/services/infrastructure/logger.service';\nimport { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\nimport { IncidentDetectorService } from './incident-detector.service';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { isPlatformBrowser } from '@angular/common';\nimport { Injectable, PLATFORM_ID, effect, inject } from '@angular/core';\nimport { Capacitor } from '@capacitor/core';\nimport { AuthService } from '@core/services/auth/auth.service';\nimport { FeatureFlagService } from '@core/services/infrastructure/feature-flag.service';\nimport { IncidentDetectorService } from './incident-detector.service';\nimport { LoggerService } from '@core/services/infrastructure/logger.service';\nimport { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\n\ntype ActiveBookingRow = {\n  id: string;\n  status: string;\n  renter_id: string | null;\n  created_at: string | null;\n};\n\n@Injectable({ providedIn: 'root' })\nexport class TripSafetyService {\n  private readonly platformId = inject(PLATFORM_ID);\n  private readonly isBrowser = isPlatformBrowser(this.platformId);\n  private readonly supabase = injectSupabase();\n\n  private readonly authService = inject(AuthService);\n  private readonly featureFlags = inject(FeatureFlagService);\n  private readonly incidentDetector = inject(IncidentDetectorService);\n  private readonly logger = inject(LoggerService).createChildLogger('TripSafetyService');\n\n  private pollId: ReturnType<typeof setInterval> | null = null;\n  private activeBookingId: string | null = null;\n  private lastUserId: string | null = null;\n  private syncing = false;\n\n  // Polling is a conservative fallback (works even without Realtime replication configured).\n  private readonly POLL_MS = 60_000;\n\n  constructor() {\n    if (!this.isBrowser) return;\n    if (!Capacitor.isNativePlatform()) return;\n\n    effect(() => {\n      const userId = this.authService.sessionSignal()?.user?.id ?? null;\n\n      if (!userId) {\n        void this.stop();\n        return;\n      }\n\n      if (this.lastUserId !== userId) {\n        this.lastUserId = userId;\n        this.activeBookingId = null;\n        void this.incidentDetector.stopMonitoring();\n      }\n\n      if (!this.pollId) {\n        void this.triggerSync();\n        this.pollId = setInterval(() => void this.triggerSync(), this.POLL_MS);\n      }\n    });\n  }\n\n  async triggerSync(): Promise<void> {\n    if (!this.isBrowser) return;\n    if (!Capacitor.isNativePlatform()) return;\n    if (this.syncing) return;\n\n    this.syncing = true;\n    try {\n      await this.syncActiveTrip();\n    } finally {\n      this.syncing = false;\n    }\n  }\n\n  async stop(): Promise<void> {\n    if (this.pollId) {\n      clearInterval(this.pollId);\n      this.pollId = null;\n    }\n\n    this.lastUserId = null;\n    this.activeBookingId = null;\n    await this.incidentDetector.stopMonitoring();\n  }\n\n  private async syncActiveTrip(): Promise<void> {\n    const userId = this.authService.sessionSignal()?.user?.id ?? null;\n    if (!userId) {\n      await this.stop();\n      return;\n    }\n\n    if (!this.featureFlags.isEnabled('incident_detector')) {\n      if (this.activeBookingId) {\n        this.activeBookingId = null;\n        await this.incidentDetector.stopMonitoring();\n      }\n      return;\n    }\n\n    try {\n      const { data, error } = await this.supabase\n        .from('my_bookings')\n        .select('id, status, renter_id, created_at')\n        .eq('status', 'in_progress')\n        .order('created_at', { ascending: false })\n        .limit(5);\n\n      if (error) throw error;\n\n      const rows = (data ?? []) as ActiveBookingRow[];\n      const activeRenterBooking = rows.find((b) => b.renter_id === userId) ?? null;\n\n      if (!activeRenterBooking) {\n        if (this.activeBookingId) {\n          this.activeBookingId = null;\n          await this.incidentDetector.stopMonitoring();\n        }\n        return;\n      }\n\n      if (this.activeBookingId === activeRenterBooking.id) {\n        return;\n      }\n\n      if (this.activeBookingId) {\n        await this.incidentDetector.stopMonitoring();\n      }\n\n      this.activeBookingId = activeRenterBooking.id;\n      await this.incidentDetector.startMonitoring(activeRenterBooking.id);\n    } catch (err) {\n      this.logger.warn('trip-safety-sync-failed', err);\n    }\n  }\n}\n\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/core/services/verification/vehicle-documents.service.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`@core/services/cars/cars.service` import should occur before import of `./car-owner-notifications.service`","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":64,"fix":{"range":[202,348],"text":"import { CarsService } from '@core/services/cars/cars.service';\nimport { CarOwnerNotificationsService } from './car-owner-notifications.service';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { Injectable, inject } from '@angular/core';\nimport { Observable, from, map, catchError, of } from 'rxjs';\nimport { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\nimport { CarOwnerNotificationsService } from './car-owner-notifications.service';\nimport { CarsService } from '@core/services/cars/cars.service';\n\n/**\n * VehicleDocumentsService\n *\n * Servicio para gestión de documentos del vehículo.\n *\n * Documentos soportados:\n * - registration: Cédula verde/título de propiedad\n * - insurance: Póliza de seguro\n * - technical_inspection: Revisión técnica (VTV)\n * - circulation_permit: Permiso de circulación\n * - ownership_proof: Comprobante de titularidad\n *\n * Estados:\n * - pending: Subido, esperando verificación\n * - verified: Verificado por admin\n * - rejected: Rechazado por admin\n *\n * Storage:\n * - Bucket: 'vehicle-documents'\n * - Path: {car_id}/{document_kind}_{timestamp}.{ext}\n */\n\nexport type VehicleDocumentKind =\n  | 'registration'\n  | 'insurance'\n  | 'technical_inspection'\n  | 'circulation_permit'\n  | 'ownership_proof';\n\nexport type VehicleDocumentStatus = 'pending' | 'verified' | 'rejected';\n\nexport interface VehicleDocument {\n  id: string;\n  car_id: string;\n  kind: VehicleDocumentKind;\n  storage_path: string;\n  status: VehicleDocumentStatus;\n  expiry_date?: string;\n  notes?: string;\n  created_at: string;\n  updated_at: string;\n  verified_by?: string;\n  verified_at?: string;\n}\n\nexport interface UploadDocumentParams {\n  car_id: string;\n  kind: VehicleDocumentKind;\n  file: File;\n  expiry_date?: string;\n  notes?: string;\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class VehicleDocumentsService {\n  private readonly supabase = injectSupabase();\n  private readonly BUCKET_NAME = 'vehicle-documents';\n  private readonly carOwnerNotifications = inject(CarOwnerNotificationsService);\n  private readonly carsService = inject(CarsService);\n\n  /**\n   * Obtener todos los documentos de un vehículo\n   */\n  getCarDocuments(carId: string): Observable<VehicleDocument[]> {\n    return from(\n      this.supabase\n        .from('vehicle_documents')\n        .select('*')\n        .eq('car_id', carId)\n        .order('created_at', { ascending: false }),\n    ).pipe(\n      map(({ data, error }) => {\n        if (error) throw error;\n        return (data as VehicleDocument[]) || [];\n      }),\n      catchError((error) => {\n        console.error('Error fetching car documents:', error);\n        return of([]);\n      }),\n    );\n  }\n\n  /**\n   * Obtener un documento específico\n   */\n  getDocument(documentId: string): Observable<VehicleDocument | null> {\n    return from(\n      this.supabase.from('vehicle_documents').select('*').eq('id', documentId).single(),\n    ).pipe(\n      map(({ data, error }) => {\n        if (error) {\n          if (error.code === 'PGRST116') return null;\n          throw error;\n        }\n        return data as VehicleDocument;\n      }),\n      catchError(() => of(null)),\n    );\n  }\n\n  /**\n   * Subir un documento\n   */\n  async uploadDocument(params: UploadDocumentParams): Promise<VehicleDocument> {\n    const { car_id, kind, file, expiry_date, notes } = params;\n\n    // 1. Upload file to storage\n    const timestamp = Date.now();\n    const ext = file.name.split('.').pop();\n    const fileName = `${kind}_${timestamp}.${ext}`;\n    const storagePath = `${car_id}/${fileName}`;\n\n    const { error: uploadError } = await this.supabase.storage\n      .from(this.BUCKET_NAME)\n      .upload(storagePath, file, {\n        cacheControl: '3600',\n        upsert: false,\n      });\n\n    if (uploadError) {\n      throw new Error(`Error uploading file: ${uploadError.message}`);\n    }\n\n    // 2. Create database record\n    const { data, error: dbError } = await this.supabase\n      .from('vehicle_documents')\n      .insert({\n        car_id,\n        kind,\n        storage_path: storagePath,\n        status: 'pending',\n        expiry_date,\n        notes,\n      })\n      .select()\n      .single();\n\n    if (dbError) {\n      // Rollback: delete uploaded file\n      await this.supabase.storage.from(this.BUCKET_NAME).remove([storagePath]);\n      throw new Error(`Error creating document record: ${dbError.message}`);\n    }\n\n    const document = data as VehicleDocument;\n\n    // ✅ NUEVO: Notificar al usuario que el documento fue subido\n    this.notifyDocumentUploaded(document).catch(() => {\n      // Silently fail - notification is optional\n    });\n\n    return document;\n  }\n\n  /**\n   * Notifica al usuario cuando se sube un documento\n   */\n  private async notifyDocumentUploaded(document: VehicleDocument): Promise<void> {\n    try {\n      const car = await this.carsService.getCarById(document.car_id);\n      if (!car) return;\n\n      const carName = car.title || `${car.brand || ''} ${car.model || ''}`.trim() || 'tu auto';\n      const documentType = this.getDocumentKindLabel(document.kind);\n      const documentsUrl = `/cars/${document.car_id}/documents`;\n\n      this.carOwnerNotifications.notifyDocumentStatusChanged(\n        documentType,\n        carName,\n        'verified',\n        undefined,\n        documentsUrl,\n      );\n    } catch {\n      // Silently fail\n    }\n  }\n\n  /**\n   * Actualizar un documento (solo si está pending)\n   */\n  async updateDocument(\n    documentId: string,\n    updates: { expiry_date?: string; notes?: string },\n  ): Promise<void> {\n    const { error } = await this.supabase\n      .from('vehicle_documents')\n      .update(updates)\n      .eq('id', documentId)\n      .eq('status', 'pending'); // Solo se puede actualizar si está pending\n\n    if (error) {\n      throw new Error(`Error updating document: ${error.message}`);\n    }\n  }\n\n  /**\n   * Eliminar un documento (solo si está pending)\n   */\n  async deleteDocument(documentId: string): Promise<void> {\n    // 1. Get document to get storage path\n    const { data: doc, error: fetchError } = await this.supabase\n      .from('vehicle_documents')\n      .select('storage_path, status')\n      .eq('id', documentId)\n      .single();\n\n    if (fetchError) {\n      throw new Error(`Error fetching document: ${fetchError.message}`);\n    }\n\n    if (doc.status !== 'pending') {\n      throw new Error('Cannot delete verified or rejected documents');\n    }\n\n    // 2. Delete from storage\n    const { error: storageError } = await this.supabase.storage\n      .from(this.BUCKET_NAME)\n      .remove([doc.storage_path]);\n\n    if (storageError) {\n      console.warn('Error deleting file from storage:', storageError);\n      // Continue anyway - mejor borrar el registro aunque falle el storage\n    }\n\n    // 3. Delete from database\n    const { error: deleteError } = await this.supabase\n      .from('vehicle_documents')\n      .delete()\n      .eq('id', documentId)\n      .eq('status', 'pending');\n\n    if (deleteError) {\n      throw new Error(`Error deleting document: ${deleteError.message}`);\n    }\n  }\n\n  /**\n   * Obtener URL pública de un documento\n   */\n  async getDocumentUrl(storagePath: string): Promise<string> {\n    const { data } = await this.supabase.storage\n      .from(this.BUCKET_NAME)\n      .createSignedUrl(storagePath, 3600); // 1 hour\n\n    if (!data?.signedUrl) {\n      throw new Error('Could not generate signed URL');\n    }\n\n    return data.signedUrl;\n  }\n\n  /**\n   * Verificar si un auto tiene todos los documentos requeridos\n   */\n  async hasRequiredDocuments(carId: string): Promise<boolean> {\n    const requiredKinds: VehicleDocumentKind[] = [\n      'registration',\n      'insurance',\n      'technical_inspection',\n    ];\n\n    const { data, error } = await this.supabase\n      .from('vehicle_documents')\n      .select('kind, status')\n      .eq('car_id', carId)\n      .in('kind', requiredKinds)\n      .eq('status', 'verified');\n\n    if (error) {\n      console.error('Error checking required documents:', error);\n      return false;\n    }\n\n    const verifiedKinds = new Set((data || []).map((d) => d.kind));\n    return requiredKinds.every((kind) => verifiedKinds.has(kind));\n  }\n\n  /**\n   * Obtener lista de documentos faltantes para un auto\n   */\n  async getMissingDocuments(carId: string): Promise<VehicleDocumentKind[]> {\n    const requiredKinds: VehicleDocumentKind[] = [\n      'registration',\n      'insurance',\n      'technical_inspection',\n    ];\n\n    const { data, error } = await this.supabase\n      .from('vehicle_documents')\n      .select('kind, status')\n      .eq('car_id', carId)\n      .in('kind', requiredKinds)\n      .eq('status', 'verified');\n\n    if (error) {\n      console.error('Error checking documents:', error);\n      return requiredKinds; // Si hay error, asumir que faltan todos\n    }\n\n    const verifiedKinds = new Set((data || []).map((d) => d.kind));\n    return requiredKinds.filter((kind) => !verifiedKinds.has(kind));\n  }\n\n  /**\n   * Suscribirse a cambios de estado de documentos para notificar al usuario\n   *\n   * @param carId - ID del auto\n   * @param callback - Callback cuando cambia el estado\n   */\n  subscribeToDocumentStatusChanges(\n    carId: string,\n    callback: (document: VehicleDocument) => void,\n  ): () => void {\n    const channel = this.supabase\n      .channel(`vehicle-documents-${carId}`)\n      .on(\n        'postgres_changes',\n        {\n          event: 'UPDATE',\n          schema: 'public',\n          table: 'vehicle_documents',\n          filter: `car_id=eq.${carId}`,\n        },\n        async (payload) => {\n          const document = payload.new as VehicleDocument;\n\n          // Solo notificar si cambió el status a verified o rejected\n          if (document.status === 'verified' || document.status === 'rejected') {\n            callback(document);\n          }\n        },\n      )\n      .subscribe((status) => {\n        if (status === 'SUBSCRIBED') {\n          console.debug('[VehicleDocuments] Realtime subscription active');\n        }\n      });\n\n    return () => {\n      this.supabase.removeChannel(channel);\n    };\n  }\n\n  /**\n   * Obtener documentos próximos a vencer (30 días)\n   */\n  getExpiringDocuments(carId: string): Observable<VehicleDocument[]> {\n    const thirtyDaysFromNow = new Date();\n    thirtyDaysFromNow.setDate(thirtyDaysFromNow.getDate() + 30);\n\n    return from(\n      this.supabase\n        .from('vehicle_documents')\n        .select('*')\n        .eq('car_id', carId)\n        .eq('status', 'verified')\n        .not('expiry_date', 'is', null)\n        .lte('expiry_date', thirtyDaysFromNow.toISOString().split('T')[0]),\n    ).pipe(\n      map(({ data, error }) => {\n        if (error) throw error;\n        return (data as VehicleDocument[]) || [];\n      }),\n      catchError(() => of([])),\n    );\n  }\n\n  /**\n   * Labels para tipos de documentos\n   */\n  getDocumentKindLabel(kind: VehicleDocumentKind): string {\n    const labels: Record<VehicleDocumentKind, string> = {\n      registration: 'Cédula Verde / Título',\n      insurance: 'Póliza de Seguro',\n      technical_inspection: 'Revisión Técnica (VTV)',\n      circulation_permit: 'Permiso de Circulación',\n      ownership_proof: 'Comprobante de Titularidad',\n    };\n    return labels[kind];\n  }\n\n  /**\n   * Labels para estados\n   */\n  getStatusLabel(status: VehicleDocumentStatus): string {\n    const labels: Record<VehicleDocumentStatus, string> = {\n      pending: 'Pendiente de Verificación',\n      verified: 'Verificado',\n      rejected: 'Rechazado',\n    };\n    return labels[status];\n  }\n\n  /**\n   * Iconos para tipos de documentos\n   */\n  getDocumentKindIcon(kind: VehicleDocumentKind): string {\n    const icons: Record<VehicleDocumentKind, string> = {\n      registration: '📋',\n      insurance: '🛡️',\n      technical_inspection: '🔧',\n      circulation_permit: '🚦',\n      ownership_proof: '📄',\n    };\n    return icons[kind];\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/core/services/verification/verification.service.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`@core/services/infrastructure/supabase-client.service` import should occur before type import of `../models`","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":88,"fix":{"range":[138,372],"text":"import { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\nimport type { UserDocument, UserVerificationStatus, VerificationRole } from '../models';\nimport type { Database } from '../types/database.types';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { LoggerService } from '@core/services/infrastructure/logger.service';\nimport { Injectable, inject, signal } from '@angular/core';\nimport type { UserDocument, UserVerificationStatus, VerificationRole } from '../models';\nimport type { Database } from '../types/database.types';\nimport { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\n\nexport interface VerificationStatus {\n  status: 'PENDIENTE' | 'VERIFICADO' | 'RECHAZADO';\n  missing_docs: string[]; // IDs de documentos faltantes (ej: 'license_front', 'license_back')\n  notes?: string;\n}\n\ntype UserVerificationRow = Database['public']['Tables']['user_verifications']['Row'];\ntype UserDocumentRow = Database['public']['Tables']['user_documents']['Row'];\n\n/**\n * Tipos de documento válidos según el enum de la base de datos.\n * SECURITY: Previene SQL injection validando contra whitelist.\n */\nconst VALID_DOC_TYPES = [\n  'gov_id_front',\n  'gov_id_back',\n  'driver_license',\n  'license_front',\n  'license_back',\n  'vehicle_registration',\n  'vehicle_insurance',\n  'utility_bill',\n  'selfie',\n] as const;\n\ntype ValidDocType = (typeof VALID_DOC_TYPES)[number];\n\n/**\n * Valida que el tipo de documento sea uno de los permitidos.\n * @throws Error si el tipo no es válido\n */\nfunction validateDocType(docType: string): asserts docType is ValidDocType {\n  if (!VALID_DOC_TYPES.includes(docType as ValidDocType)) {\n    throw new Error(\n      `Tipo de documento inválido: \"${docType}\". ` +\n      `Tipos válidos: ${VALID_DOC_TYPES.join(', ')}`\n    );\n  }\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class VerificationService {\n  private readonly logger = inject(LoggerService);\n  private supabase = injectSupabase();\n\n  // Reactive state consumed by guards/widgets/pages\n  readonly statuses = signal<UserVerificationStatus[]>([]);\n  readonly documents = signal<UserDocument[]>([]);\n  readonly loadingStatuses = signal(false);\n  readonly loadingDocuments = signal(false);\n\n  /**\n   * Sube una imagen de documento al bucket seguro y crea/actualiza el registro en user_documents.\n   *\n   * SECURITY:\n   * - Valida docType contra whitelist antes de usar en queries\n   * - Rollback automático: si el registro en DB falla, elimina el archivo subido\n   *\n   * @param file - Archivo de imagen a subir\n   * @param docType - Tipo de documento (debe ser uno de VALID_DOC_TYPES)\n   * @returns Path del archivo subido\n   * @throws Error si el tipo de documento es inválido o si falla la operación\n   */\n  async uploadDocument(\n    file: File,\n    docType: string,\n  ): Promise<string> {\n    // SECURITY FIX #1: Validar docType contra whitelist antes de usar\n    validateDocType(docType);\n\n    const {\n      data: { user },\n    } = await this.supabase.auth.getUser();\n    if (!user) throw new Error('No autenticado');\n\n    const fileExt = file.name.split('.').pop();\n    const filePath = `${user.id}/${docType}_${Date.now()}.${fileExt}`;\n\n    // Subir al bucket 'verification-docs' (asumimos que existe y es privado)\n    const { error: uploadError } = await this.supabase.storage\n      .from('verification-docs')\n      .upload(filePath, file);\n\n    if (uploadError) throw uploadError;\n\n    // Create or update user_documents record\n    const { error: upsertError } = await this.supabase\n      .from('user_documents')\n      .upsert(\n        {\n          user_id: user.id,\n          kind: docType,\n          storage_path: filePath,\n          status: 'pending',\n        },\n        { onConflict: 'user_id,kind' }\n      );\n\n    // SECURITY FIX #2: Rollback - eliminar archivo si el registro en DB falla\n    if (upsertError) {\n      console.error('Error creating document record, rolling back file upload:', upsertError);\n\n      // Intentar eliminar el archivo subido para mantener consistencia\n      try {\n        await this.supabase.storage\n          .from('verification-docs')\n          .remove([filePath]);\n        this.logger.debug('Rollback successful: file removed from storage');\n      } catch (rollbackError) {\n        // Log pero no fallar - el archivo huérfano se puede limpiar después\n        console.error('Rollback failed: could not remove uploaded file:', rollbackError);\n      }\n\n      throw new Error(\n        'Error al registrar documento. El archivo fue eliminado. Por favor, intenta de nuevo.'\n      );\n    }\n\n    return filePath;\n  }\n\n  /**\n   * Carga el estado de verificación del usuario (driver/owner) y actualiza la señal reactiva.\n   */\n  async loadStatuses(): Promise<UserVerificationStatus[]> {\n    const {\n      data: { user },\n    } = await this.supabase.auth.getUser();\n    if (!user) {\n      this.statuses.set([]);\n      return [];\n    }\n\n    this.loadingStatuses.set(true);\n\n    try {\n      const { data, error } = await this.supabase\n        .from('user_verifications')\n        .select('user_id, role, status, missing_docs, notes, metadata, created_at, updated_at')\n        .eq('user_id', user.id)\n        .order('updated_at', { ascending: false });\n\n      if (error) throw error;\n\n      const normalized: UserVerificationStatus[] = (data ?? []).map((row: UserVerificationRow) => ({\n        user_id: row.user_id,\n        role: (row.role ?? 'driver') as VerificationRole,\n        status: (row.status ?? 'PENDIENTE') as UserVerificationStatus['status'],\n        missing_docs: Array.isArray(row.missing_docs)\n          ? (row.missing_docs as string[])\n          : row.missing_docs\n            ? (Object.values(row.missing_docs) as string[])\n            : [],\n        notes: row.notes ?? null,\n        metadata: (row.metadata ?? null) as Record<string, unknown> | null,\n        created_at: row.created_at,\n        updated_at: row.updated_at,\n      }));\n\n      this.statuses.set(normalized);\n      return normalized;\n    } finally {\n      this.loadingStatuses.set(false);\n    }\n  }\n\n  /**\n   * Obtiene los documentos subidos por el usuario y los expone vía señal reactiva.\n   */\n  async loadDocuments(): Promise<UserDocument[]> {\n    const {\n      data: { user },\n    } = await this.supabase.auth.getUser();\n    if (!user) {\n      this.documents.set([]);\n      return [];\n    }\n\n    this.loadingDocuments.set(true);\n\n    try {\n      const { data, error } = await this.supabase\n        .from('user_documents')\n        .select(\n          'id, user_id, kind, storage_path, status, notes, reviewed_at, reviewed_by, created_at, analyzed_at',\n        )\n        .eq('user_id', user.id)\n        .order('created_at', { ascending: false });\n\n      if (error) throw error;\n\n      const normalized: UserDocument[] = (data ?? []).map((row: UserDocumentRow) => ({\n        id: String(row.id),\n        user_id: row.user_id,\n        kind: row.kind,\n        storage_path: row.storage_path,\n        status: row.status,\n        notes: row.notes ?? null,\n        created_at: row.created_at,\n        reviewed_by: row.reviewed_by ?? null,\n        reviewed_at: row.reviewed_at ?? null,\n        analyzed_at: (row as UserDocumentRow & { analyzed_at?: string | null }).analyzed_at ?? null,\n      }));\n\n      this.documents.set(normalized);\n      return normalized;\n    } finally {\n      this.loadingDocuments.set(false);\n    }\n  }\n\n  /**\n   * Dispara la verificación automática (edge function) y refresca estado/documentos.\n   */\n  async triggerVerification(role?: VerificationRole): Promise<void> {\n    const body = role ? { role } : {};\n\n    const { error } = await this.supabase.functions.invoke('verify-user-docs', { body });\n\n    if (error) {\n      throw error;\n    }\n\n    await Promise.all([this.loadStatuses(), this.loadDocuments()]);\n  }\n\n  /**\n   * Registra el intento de verificación en la tabla\n   */\n  async submitVerification(role: 'driver' | 'owner' = 'driver'): Promise<void> {\n    const {\n      data: { user },\n    } = await this.supabase.auth.getUser();\n    if (!user) throw new Error('No autenticado');\n\n    const { error } = await this.supabase.from('user_verifications').upsert({\n      user_id: user.id,\n      role,\n      status: 'PENDIENTE',\n      updated_at: new Date().toISOString(),\n    });\n\n    if (error) throw error;\n  }\n\n  /**\n   * Obtiene el estado actual\n   */\n  async getStatus(role: 'driver' | 'owner' = 'driver'): Promise<VerificationStatus | null> {\n    const {\n      data: { user },\n    } = await this.supabase.auth.getUser();\n    if (!user) return null;\n\n    const { data, error } = await this.supabase\n      .from('user_verifications')\n      .select('status, missing_docs, notes')\n      .eq('user_id', user.id)\n      .eq('role', role)\n      .single();\n\n    if (error && error.code !== 'PGRST116') throw error; // Ignorar \"no encontrado\"\n\n    return data as VerificationStatus;\n  }\n\n  /**\n   * Obtiene la lista de tipos de documento válidos.\n   * Útil para UI que necesita mostrar opciones disponibles.\n   */\n  getValidDocTypes(): readonly string[] {\n    return VALID_DOC_TYPES;\n  }\n\n  /**\n   * Verifica si un tipo de documento es válido.\n   */\n  isValidDocType(docType: string): boolean {\n    return VALID_DOC_TYPES.includes(docType as ValidDocType);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/core/services/verification/video-damage-detection.service.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`@core/services/infrastructure/supabase-client.service` import should occur before import of `../../../environments/environment`","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":95,"fix":{"range":[163,323],"text":"import { SupabaseClientService } from '@core/services/infrastructure/supabase-client.service';\nimport { environment } from '../../../environments/environment';\n"}},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":313,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":313,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8818,8821],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8818,8821],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { Injectable, inject, signal } from '@angular/core';\nimport { HttpClient, HttpHeaders } from '@angular/common/http';\nimport { firstValueFrom } from 'rxjs';\nimport { environment } from '../../../environments/environment';\nimport { SupabaseClientService } from '@core/services/infrastructure/supabase-client.service';\n\n/**\n * Resultado del análisis de video de inspección\n */\nexport interface VideoDamageAnalysis {\n  success: boolean;\n  bookingId: string;\n  inspectionType: 'checkin' | 'checkout';\n  damages: DetectedDamage[];\n  summary: string;\n  confidence: number;\n  videoUrl: string;\n  processedAt: string;\n  error?: string;\n}\n\n/**\n * Daño detectado en el video con timestamp\n */\nexport interface DetectedDamage {\n  id: string;\n  type: 'scratch' | 'dent' | 'broken_light' | 'tire_wear' | 'interior_damage' | 'other';\n  description: string;\n  severity: 'minor' | 'moderate' | 'severe';\n  confidence: number; // 0-1\n  timestamp: number; // segundos en el video\n  location: string; // \"front-left\", \"rear-bumper\", etc.\n  estimatedCostUsd: number;\n  requiresAction: boolean;\n}\n\n/**\n * Parámetros para subir video de inspección\n */\nexport interface UploadInspectionVideoParams {\n  bookingId: string;\n  inspectionType: 'checkin' | 'checkout';\n  videoFile: File;\n  carId: string;\n  userId: string;\n}\n\n/**\n * Response de la URL firmada para upload\n */\nexport interface SignedUploadUrlResponse {\n  uploadUrl: string;\n  videoPath: string;\n  expiresAt: string;\n}\n\n/**\n * Video Damage Detection Service\n * \n * Integración con GCP Video Processing Pipeline:\n * \n * FLUJO:\n * 1. Frontend sube video → Cloud Storage (signed URL)\n * 2. Cloud Storage → Pub/Sub notification\n * 3. Pub/Sub → Cloud Run (video-processing-service)\n * 4. Cloud Run → Vertex AI (análisis de daños)\n * 5. Cloud Run → Supabase (resultados estructurados)\n * 6. Frontend → Polling/Realtime subscription (resultados)\n * \n * ARQUITECTURA GCP:\n * - video-ingestion-service (Cloud Run): Genera signed URLs\n * - video-source-document-bucket (Cloud Storage): Almacena videos\n * - video-doc-upload-topic (Pub/Sub): Notificaciones de nuevos videos\n * - video-processing-service (Cloud Run): Orquesta análisis\n * - video-vertex-ai-service (Vertex AI): Detección de daños con IA\n * - video-processing-log-db (Cloud SQL): Log de procesamiento\n * - video-summarized-archive-bucket: Resultados procesados\n * \n * @example\n * ```typescript\n * const service = inject(VideoDamageDetectionService);\n * \n * // 1. Subir video de check-in\n * await service.uploadInspectionVideo({\n *   bookingId: 'booking_123',\n *   inspectionType: 'checkin',\n *   videoFile: videoBlob,\n *   carId: 'car_456',\n *   userId: 'user_789'\n * });\n * \n * // 2. Esperar resultados (realtime o polling)\n * service.analysisResults$.subscribe(result => {\n *   console.log('Daños detectados:', result.damages);\n * });\n * \n * // 3. Comparar check-in vs check-out\n * const comparison = await service.compareInspections(\n *   'booking_123'\n * );\n * ```\n */\n@Injectable({\n  providedIn: 'root',\n})\nexport class VideoDamageDetectionService {\n  private readonly http = inject(HttpClient);\n  private readonly supabase = inject(SupabaseClientService);\n\n  /**\n   * URL del servicio de ingesta de videos en GCP Cloud Run\n   * Configurable via env: NG_APP_VIDEO_INGESTION_URL\n   */\n  private readonly VIDEO_INGESTION_URL = environment.videoIngestionUrl || \n    'https://video-ingestion-service-XXXXX.run.app';\n\n  /**\n   * Estado de análisis en progreso\n   */\n  readonly isProcessing = signal(false);\n\n  /**\n   * Último error\n   */\n  readonly lastError = signal<string | null>(null);\n\n  /**\n   * Progreso de upload (0-100)\n   */\n  readonly uploadProgress = signal(0);\n\n  // ============================================\n  // 1. UPLOAD DE VIDEO\n  // ============================================\n\n  /**\n   * Sube un video de inspección a GCP Cloud Storage\n   * \n   * PASO 1: Solicita signed URL al servicio de ingesta\n   * PASO 2: Sube el video directamente a Cloud Storage\n   * PASO 3: Notifica a Supabase que el video está listo\n   * \n   * @param params - Datos de la inspección y archivo de video\n   * @returns Path del video en Cloud Storage\n   */\n  async uploadInspectionVideo(params: UploadInspectionVideoParams): Promise<string> {\n    try {\n      this.isProcessing.set(true);\n      this.lastError.set(null);\n      this.uploadProgress.set(0);\n\n      // Validaciones\n      if (!params.videoFile) {\n        throw new Error('No se proporcionó archivo de video');\n      }\n\n      if (!params.videoFile.type.startsWith('video/')) {\n        throw new Error('El archivo debe ser un video');\n      }\n\n      // Límite de tamaño: 500MB\n      const MAX_SIZE = 500 * 1024 * 1024;\n      if (params.videoFile.size > MAX_SIZE) {\n        throw new Error('El video no puede superar 500MB');\n      }\n\n      // PASO 1: Solicitar signed URL para upload\n      const signedUrlResponse = await this.getSignedUploadUrl({\n        bookingId: params.bookingId,\n        inspectionType: params.inspectionType,\n        fileName: params.videoFile.name,\n        contentType: params.videoFile.type,\n      });\n\n      this.uploadProgress.set(10);\n\n      // PASO 2: Subir video directamente a Cloud Storage\n      await this.uploadToCloudStorage(\n        signedUrlResponse.uploadUrl,\n        params.videoFile\n      );\n\n      this.uploadProgress.set(90);\n\n      // PASO 3: Registrar en Supabase que el video está listo para procesamiento\n      await this.registerVideoInSupabase({\n        bookingId: params.bookingId,\n        inspectionType: params.inspectionType,\n        videoPath: signedUrlResponse.videoPath,\n        carId: params.carId,\n        userId: params.userId,\n        status: 'processing',\n      });\n\n      this.uploadProgress.set(100);\n      this.isProcessing.set(false);\n\n      return signedUrlResponse.videoPath;\n\n    } catch (error) {\n      const errorMsg = error instanceof Error ? error.message : 'Error al subir video';\n      this.lastError.set(errorMsg);\n      this.isProcessing.set(false);\n      throw error;\n    }\n  }\n\n  /**\n   * Obtiene una URL firmada para subir el video a Cloud Storage\n   * \n   * Llama al servicio de ingesta en GCP Cloud Run:\n   * POST /api/upload-url\n   */\n  private async getSignedUploadUrl(params: {\n    bookingId: string;\n    inspectionType: 'checkin' | 'checkout';\n    fileName: string;\n    contentType: string;\n  }): Promise<SignedUploadUrlResponse> {\n    const response = await firstValueFrom(\n      this.http.post<SignedUploadUrlResponse>(\n        `${this.VIDEO_INGESTION_URL}/api/upload-url`,\n        params\n      )\n    );\n\n    return response;\n  }\n\n  /**\n   * Sube el video a Cloud Storage usando la URL firmada\n   */\n  private async uploadToCloudStorage(\n    signedUrl: string,\n    videoFile: File\n  ): Promise<void> {\n    const headers = new HttpHeaders({\n      'Content-Type': videoFile.type,\n    });\n\n    await firstValueFrom(\n      this.http.put(signedUrl, videoFile, {\n        headers,\n        reportProgress: true,\n        observe: 'events',\n      })\n    );\n  }\n\n  /**\n   * Registra el video en Supabase para tracking\n   */\n  private async registerVideoInSupabase(params: {\n    bookingId: string;\n    inspectionType: 'checkin' | 'checkout';\n    videoPath: string;\n    carId: string;\n    userId: string;\n    status: 'processing' | 'completed' | 'failed';\n  }): Promise<void> {\n    const { error } = await this.supabase.getClient()\n      .from('inspection_videos')\n      .insert({\n        booking_id: params.bookingId,\n        inspection_type: params.inspectionType,\n        video_path: params.videoPath,\n        car_id: params.carId,\n        user_id: params.userId,\n        status: params.status,\n        created_at: new Date().toISOString(),\n      });\n\n    if (error) {\n      throw new Error(`Error al registrar video: ${error.message}`);\n    }\n  }\n\n  // ============================================\n  // 2. OBTENER RESULTADOS DE ANÁLISIS\n  // ============================================\n\n  /**\n   * Obtiene los resultados del análisis de un video\n   * \n   * Los resultados son escritos por el video-processing-service\n   * en la tabla `video_damage_analysis`\n   * \n   * @param bookingId - ID del booking\n   * @param inspectionType - Tipo de inspección\n   * @returns Análisis de daños o null si aún no está procesado\n   */\n  async getAnalysisResults(\n    bookingId: string,\n    inspectionType: 'checkin' | 'checkout'\n  ): Promise<VideoDamageAnalysis | null> {\n    const { data, error } = await this.supabase.getClient()\n      .from('video_damage_analysis')\n      .select('*')\n      .eq('booking_id', bookingId)\n      .eq('inspection_type', inspectionType)\n      .single();\n\n    if (error || !data) {\n      return null;\n    }\n\n    return this.mapToVideoDamageAnalysis(data);\n  }\n\n  /**\n   * Mapea los datos de Supabase al formato del servicio\n   */\n  private mapToVideoDamageAnalysis(data: any): VideoDamageAnalysis {\n    return {\n      success: true,\n      bookingId: data.booking_id,\n      inspectionType: data.inspection_type,\n      damages: data.damages || [],\n      summary: data.summary || '',\n      confidence: data.confidence || 0,\n      videoUrl: data.video_url || '',\n      processedAt: data.processed_at,\n    };\n  }\n\n  // ============================================\n  // 3. COMPARACIÓN CHECK-IN vs CHECK-OUT\n  // ============================================\n\n  /**\n   * Compara los resultados de check-in y check-out\n   * para determinar daños nuevos\n   * \n   * @param bookingId - ID del booking\n   * @returns Lista de daños nuevos detectados en check-out\n   */\n  async compareInspections(bookingId: string): Promise<{\n    newDamages: DetectedDamage[];\n    summary: string;\n    totalEstimatedCost: number;\n  }> {\n    // Obtener ambos análisis\n    const [checkinAnalysis, checkoutAnalysis] = await Promise.all([\n      this.getAnalysisResults(bookingId, 'checkin'),\n      this.getAnalysisResults(bookingId, 'checkout'),\n    ]);\n\n    if (!checkinAnalysis || !checkoutAnalysis) {\n      throw new Error('Faltan videos de inspección para comparar');\n    }\n\n    // Detectar daños nuevos (presentes en checkout pero no en checkin)\n    const newDamages = this.detectNewDamages(\n      checkinAnalysis.damages,\n      checkoutAnalysis.damages\n    );\n\n    const totalEstimatedCost = newDamages.reduce(\n      (sum, damage) => sum + damage.estimatedCostUsd,\n      0\n    );\n\n    const summary = this.generateDamageSummary(newDamages);\n\n    return {\n      newDamages,\n      summary,\n      totalEstimatedCost,\n    };\n  }\n\n  /**\n   * Detecta daños nuevos comparando dos listas\n   */\n  private detectNewDamages(\n    checkinDamages: DetectedDamage[],\n    checkoutDamages: DetectedDamage[]\n  ): DetectedDamage[] {\n    // Simple heurística: buscar daños en checkout que no están en checkin\n    // basándose en type + location\n    return checkoutDamages.filter(checkoutDamage => {\n      const existsInCheckin = checkinDamages.some(checkinDamage =>\n        checkinDamage.type === checkoutDamage.type &&\n        checkinDamage.location === checkoutDamage.location\n      );\n      return !existsInCheckin;\n    });\n  }\n\n  /**\n   * Genera un resumen legible de los daños\n   */\n  private generateDamageSummary(damages: DetectedDamage[]): string {\n    if (damages.length === 0) {\n      return 'No se detectaron daños nuevos.';\n    }\n\n    const summary = damages.map(d =>\n      `${d.type} ${d.severity} en ${d.location} (${d.confidence * 100}% confianza)`\n    ).join(', ');\n\n    return `Se detectaron ${damages.length} daño(s) nuevo(s): ${summary}`;\n  }\n\n  // ============================================\n  // 4. REALTIME SUBSCRIPTION (OPCIONAL)\n  // ============================================\n\n  /**\n   * Suscribirse a cambios en los análisis de video\n   * \n   * Útil para mostrar resultados en tiempo real cuando\n   * el video-processing-service termina el análisis\n   */\n  subscribeToAnalysisResults(\n    bookingId: string,\n    callback: (analysis: VideoDamageAnalysis) => void\n  ) {\n    return this.supabase.getClient()\n      .channel(`video_analysis_${bookingId}`)\n      .on(\n        'postgres_changes',\n        {\n          event: 'INSERT',\n          schema: 'public',\n          table: 'video_damage_analysis',\n          filter: `booking_id=eq.${bookingId}`,\n        },\n        (payload) => {\n          const analysis = this.mapToVideoDamageAnalysis(payload.new);\n          callback(analysis);\n        }\n      )\n      .subscribe();\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/core/strategies/custom-route-reuse.strategy.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`@angular/router` import should occur before import of `../services/logger.service`","line":3,"column":1,"nodeType":"ImportDeclaration","endLine":3,"endColumn":99,"fix":{"range":[40,199],"text":"import { ActivatedRouteSnapshot, DetachedRouteHandle, RouteReuseStrategy } from '@angular/router';\nimport { LoggerService } from '../services/logger.service';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { inject } from '@angular/core';\nimport { LoggerService } from '../services/logger.service';\nimport { ActivatedRouteSnapshot, DetachedRouteHandle, RouteReuseStrategy } from '@angular/router';\n\n/**\n * Custom Route Reuse Strategy\n *\n * Keeps specific route components in memory when navigating away,\n * so they can be instantly restored when the user returns.\n *\n * USE CASE:\n * - User is on Marketplace (/) with 3D car model loaded\n * - User navigates to /cars/detail/123\n * - User navigates back to /\n * - WITHOUT this: 3D model reloads from scratch (2-4 seconds)\n * - WITH this: Component is instantly restored (< 100ms)\n *\n * ROUTES TO CACHE:\n * - '' (Marketplace) - Heavy 3D model\n * - 'cars/list' - Heavy Mapbox map\n */\nexport class CustomRouteReuseStrategy implements RouteReuseStrategy {\n  private readonly logger = inject(LoggerService);\n  /**\n   * Routes to keep in memory for instant restore\n   * Add route paths here (without leading slash)\n   */\n  private readonly routesToCache = new Set([\n    '',           // Marketplace with 3D model\n    'cars/list',  // Cars list with Mapbox map\n  ]);\n\n  /**\n   * Storage for detached route handles\n   * Key: route path, Value: detached component reference\n   */\n  private readonly handlers = new Map<string, DetachedRouteHandle>();\n\n  /**\n   * Maximum number of routes to cache (memory management)\n   */\n  private readonly maxCacheSize = 3;\n\n  /**\n   * Get the route path from snapshot\n   */\n  private getPath(route: ActivatedRouteSnapshot): string {\n    // Build full path from route tree\n    const path = route.pathFromRoot\n      .filter(r => r.url.length > 0)\n      .map(r => r.url.map(segment => segment.path).join('/'))\n      .join('/');\n    return path;\n  }\n\n  /**\n   * Determines if this route should be detached (stored) when leaving\n   * Return true to store the component in memory\n   */\n  shouldDetach(route: ActivatedRouteSnapshot): boolean {\n    const path = this.getPath(route);\n    const shouldCache = this.routesToCache.has(path);\n\n    if (shouldCache) {\n      this.logger.debug(`[RouteReuse] Detaching route for cache: \"${path}\"`);\n    }\n\n    return shouldCache;\n  }\n\n  /**\n   * Stores the detached route handle\n   * Called after shouldDetach returns true\n   */\n  store(route: ActivatedRouteSnapshot, handle: DetachedRouteHandle | null): void {\n    const path = this.getPath(route);\n\n    if (handle) {\n      // Enforce max cache size (LRU eviction)\n      if (this.handlers.size >= this.maxCacheSize && !this.handlers.has(path)) {\n        const oldestKey = this.handlers.keys().next().value;\n        if (oldestKey) {\n          this.logger.debug(`[RouteReuse] Evicting oldest cached route: \"${oldestKey}\"`);\n          this.handlers.delete(oldestKey);\n        }\n      }\n\n      this.handlers.set(path, handle);\n      this.logger.debug(`[RouteReuse] Stored route: \"${path}\" (cache size: ${this.handlers.size})`);\n    } else {\n      this.handlers.delete(path);\n    }\n  }\n\n  /**\n   * Determines if this route should be attached (restored) from cache\n   * Return true to restore the cached component\n   */\n  shouldAttach(route: ActivatedRouteSnapshot): boolean {\n    const path = this.getPath(route);\n    const hasHandle = this.handlers.has(path);\n\n    if (hasHandle) {\n      this.logger.debug(`[RouteReuse] Restoring cached route: \"${path}\"`);\n    }\n\n    return hasHandle;\n  }\n\n  /**\n   * Retrieves the stored route handle\n   * Called after shouldAttach returns true\n   */\n  retrieve(route: ActivatedRouteSnapshot): DetachedRouteHandle | null {\n    const path = this.getPath(route);\n    return this.handlers.get(path) || null;\n  }\n\n  /**\n   * Determines if the route should be reused\n   * Return true to keep the current component, false to create new\n   */\n  shouldReuseRoute(future: ActivatedRouteSnapshot, curr: ActivatedRouteSnapshot): boolean {\n    // Default behavior: reuse if same route config\n    return future.routeConfig === curr.routeConfig;\n  }\n\n  /**\n   * Clear all cached routes (call on logout, etc.)\n   */\n  clearCache(): void {\n    this.logger.debug(`[RouteReuse] Clearing all cached routes (${this.handlers.size} routes)`);\n    this.handlers.clear();\n  }\n\n  /**\n   * Clear a specific route from cache\n   */\n  clearRoute(path: string): void {\n    if (this.handlers.has(path)) {\n      this.handlers.delete(path);\n      this.logger.debug(`[RouteReuse] Cleared cached route: \"${path}\"`);\n    }\n  }\n\n  /**\n   * Get cache statistics\n   */\n  getCacheStats(): { size: number; routes: string[] } {\n    return {\n      size: this.handlers.size,\n      routes: Array.from(this.handlers.keys()),\n    };\n  }\n}\n\n/**\n * Factory function to create and export a singleton instance\n * This allows other services to clear the cache if needed\n */\nlet strategyInstance: CustomRouteReuseStrategy | null = null;\n\nexport function getRouteReuseStrategy(): CustomRouteReuseStrategy {\n  if (!strategyInstance) {\n    strategyInstance = new CustomRouteReuseStrategy();\n  }\n  return strategyInstance;\n}\n\n/**\n * Provider for the route reuse strategy\n * Add this to your app.config.ts providers\n */\nexport const routeReuseStrategyProvider = {\n  provide: RouteReuseStrategy,\n  useFactory: getRouteReuseStrategy,\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/features/admin/feature-flags/admin-feature-flags.page.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`@core/services/infrastructure/feature-flag.service` import should occur before import of `../../../core/models/feature-flag.model`","line":20,"column":1,"nodeType":"ImportDeclaration","endLine":20,"endColumn":89,"fix":{"range":[694,904],"text":"import { FeatureFlagService } from '@core/services/infrastructure/feature-flag.service';\nimport {\n  CreateFeatureFlagDto,\n  FeatureFlag,\n  FeatureFlagAuditLog,\n} from '../../../core/models/feature-flag.model';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { CommonModule } from '@angular/common';\nimport {Component, computed, inject, OnInit, signal,\n  ChangeDetectionStrategy} from '@angular/core';\nimport { FormsModule } from '@angular/forms';\nimport { MessageService, PrimeTemplate } from 'primeng/api';\nimport { ButtonModule } from 'primeng/button';\nimport { CardModule } from 'primeng/card';\nimport { DialogModule } from 'primeng/dialog';\nimport { InputNumberModule } from 'primeng/inputnumber';\nimport { ToggleSwitchModule } from 'primeng/toggleswitch';\nimport { InputTextModule } from 'primeng/inputtext';\nimport { TableModule } from 'primeng/table';\nimport { TagModule } from 'primeng/tag';\nimport { ToastModule } from 'primeng/toast';\nimport {\n  CreateFeatureFlagDto,\n  FeatureFlag,\n  FeatureFlagAuditLog,\n} from '../../../core/models/feature-flag.model';\nimport { FeatureFlagService } from '@core/services/infrastructure/feature-flag.service';\n\n@Component({\n  selector: 'app-admin-feature-flags',\n  standalone: true,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  imports: [\n    CommonModule,\n    FormsModule,\n    ButtonModule,\n    CardModule,\n    DialogModule,\n    InputNumberModule,\n    ToggleSwitchModule,\n    InputTextModule,\n    TableModule,\n    TagModule,\n    ToastModule,\n    PrimeTemplate,\n  ],\n  providers: [MessageService],\n  template: `\n    <p-toast></p-toast>\n\n    <div class=\"p-4\">\n      <div class=\"flex justify-between items-center mb-4\">\n        <h1 class=\"text-2xl font-bold\">Feature Flags</h1>\n        <p-button label=\"Nueva Flag\" icon=\"pi pi-plus\" (onClick)=\"showCreateDialog()\"></p-button>\n      </div>\n\n      <!-- Stats Cards -->\n      <div class=\"grid grid-cols-2 md:grid-cols-4 gap-3 md:gap-4 mb-6\">\n        <p-card>\n          <div class=\"text-center\">\n            <div class=\"text-2xl md:text-3xl font-bold text-blue-500\">{{ totalFlags() }}</div>\n            <div class=\"text-gray-500 text-sm md:text-base\">Total</div>\n          </div>\n        </p-card>\n        <p-card>\n          <div class=\"text-center\">\n            <div class=\"text-2xl md:text-3xl font-bold text-green-500\">{{ enabledFlags() }}</div>\n            <div class=\"text-gray-500 text-sm md:text-base\">Habilitadas</div>\n          </div>\n        </p-card>\n        <p-card>\n          <div class=\"text-center\">\n            <div class=\"text-2xl md:text-3xl font-bold text-red-500\">{{ disabledFlags() }}</div>\n            <div class=\"text-gray-500 text-sm md:text-base\">Deshabilitadas</div>\n          </div>\n        </p-card>\n        <p-card>\n          <div class=\"text-center\">\n            <div class=\"text-2xl md:text-3xl font-bold text-orange-500\">\n              {{ partialRolloutFlags() }}\n            </div>\n            <div class=\"text-gray-500 text-sm md:text-base\">Parcial</div>\n          </div>\n        </p-card>\n      </div>\n\n      <!-- Desktop: Table View -->\n      <p-card header=\"Feature Flags\" class=\"hidden md:block\">\n        <p-table\n          [value]=\"flags()\"\n          [loading]=\"loading()\"\n          styleClass=\"p-datatable-sm p-datatable-striped\"\n          [paginator]=\"true\"\n          [rows]=\"10\"\n          [rowsPerPageOptions]=\"[10, 25, 50]\"\n        >\n          <ng-template pTemplate=\"header\">\n            <tr>\n              <th>Nombre</th>\n              <th>Descripción</th>\n              <th>Estado</th>\n              <th>Rollout %</th>\n              <th>Actualizado</th>\n              <th>Acciones</th>\n            </tr>\n          </ng-template>\n          <ng-template pTemplate=\"body\" let-flag>\n            <tr>\n              <td>\n                <span class=\"font-mono text-sm\">{{ flag.name }}</span>\n              </td>\n              <td>{{ flag.description || '-' }}</td>\n              <td>\n                <p-toggleswitch\n                  [(ngModel)]=\"flag.enabled\"\n                  (onChange)=\"toggleFlag(flag)\"\n                ></p-toggleswitch>\n              </td>\n              <td>\n                <p-tag\n                  [value]=\"flag.rollout_percentage + '%'\"\n                  [severity]=\"getRolloutSeverity(flag.rollout_percentage)\"\n                ></p-tag>\n              </td>\n              <td>{{ flag.updated_at | date: 'short' }}</td>\n              <td>\n                <p-button\n                  icon=\"pi pi-pencil\"\n                  [rounded]=\"true\"\n                  [text]=\"true\"\n                  (onClick)=\"editFlag(flag)\"\n                ></p-button>\n                <p-button\n                  icon=\"pi pi-trash\"\n                  [rounded]=\"true\"\n                  [text]=\"true\"\n                  severity=\"danger\"\n                  (onClick)=\"confirmDelete(flag)\"\n                ></p-button>\n              </td>\n            </tr>\n          </ng-template>\n          <ng-template pTemplate=\"emptymessage\">\n            <tr>\n              <td colspan=\"6\" class=\"text-center py-4\">No hay feature flags configuradas</td>\n            </tr>\n          </ng-template>\n        </p-table>\n      </p-card>\n\n      <!-- Mobile: Card View -->\n      <div class=\"md:hidden space-y-3\">\n        <h2 class=\"text-lg font-semibold text-gray-700 dark:text-gray-500\">Feature Flags</h2>\n\n        @if (loading()) {\n          <div class=\"flex justify-center py-8\">\n            <div class=\"animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500\"></div>\n          </div>\n        } @else if (flags().length === 0) {\n          <div class=\"text-center py-8 text-gray-500\">\n            No hay feature flags configuradas\n          </div>\n        } @else {\n          @for (flag of flags(); track flag.id) {\n            <div class=\"bg-white dark:bg-gray-800 rounded-xl shadow-sm border border-gray-300 dark:border-gray-700 p-4\">\n              <!-- Header: Name + Toggle -->\n              <div class=\"flex items-center justify-between mb-3\">\n                <span class=\"font-mono text-sm font-medium text-gray-900 dark:text-gray-100 truncate max-w-[60%]\">\n                  {{ flag.name }}\n                </span>\n                <p-toggleswitch\n                  [(ngModel)]=\"flag.enabled\"\n                  (onChange)=\"toggleFlag(flag)\"\n                ></p-toggleswitch>\n              </div>\n\n              <!-- Description -->\n              @if (flag.description) {\n                <p class=\"text-sm text-gray-600 dark:text-gray-500 mb-3 line-clamp-2\">\n                  {{ flag.description }}\n                </p>\n              }\n\n              <!-- Meta row -->\n              <div class=\"flex items-center justify-between text-sm\">\n                <div class=\"flex items-center gap-2\">\n                  <p-tag\n                    [value]=\"flag.rollout_percentage + '%'\"\n                    [severity]=\"getRolloutSeverity(flag.rollout_percentage)\"\n                  ></p-tag>\n                  <span class=\"text-gray-500 text-xs\">\n                    {{ flag.updated_at | date: 'shortDate' }}\n                  </span>\n                </div>\n\n                <!-- Actions -->\n                <div class=\"flex gap-1\">\n                  <button\n                    class=\"p-2 rounded-full hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors\"\n                    (click)=\"editFlag(flag)\"\n                    aria-label=\"Editar\"\n                  >\n                    <svg class=\"w-5 h-5 text-gray-600 dark:text-gray-500\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                      <path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z\" />\n                    </svg>\n                  </button>\n                  <button\n                    class=\"p-2 rounded-full hover:bg-red-50 dark:hover:bg-red-900/20 transition-colors\"\n                    (click)=\"confirmDelete(flag)\"\n                    aria-label=\"Eliminar\"\n                  >\n                    <svg class=\"w-5 h-5 text-red-500\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                      <path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16\" />\n                    </svg>\n                  </button>\n                </div>\n              </div>\n            </div>\n          }\n        }\n      </div>\n\n      <!-- Audit Log - Desktop Table -->\n      <p-card header=\"Historial de Cambios\" class=\"mt-4 hidden md:block\">\n        <p-table\n          [value]=\"auditLog()\"\n          [loading]=\"loadingAudit()\"\n          styleClass=\"p-datatable-sm\"\n          [paginator]=\"true\"\n          [rows]=\"5\"\n        >\n          <ng-template pTemplate=\"header\">\n            <tr>\n              <th>Fecha</th>\n              <th>Flag</th>\n              <th>Acción</th>\n              <th>Cambios</th>\n            </tr>\n          </ng-template>\n          <ng-template pTemplate=\"body\" let-log>\n            <tr>\n              <td>{{ log.changed_at | date: 'medium' }}</td>\n              <td>\n                <span class=\"font-mono text-sm\">{{ log.feature_flag_name }}</span>\n              </td>\n              <td>\n                <p-tag [value]=\"log.action\" [severity]=\"getActionSeverity(log.action)\"></p-tag>\n              </td>\n              <td>\n                @if (log.action === 'updated' && log.old_value && log.new_value) {\n                  @if (log.old_value.enabled !== log.new_value.enabled) {\n                    <span class=\"text-sm\">\n                      enabled: {{ log.old_value.enabled }} →\n                      {{ log.new_value.enabled }}\n                    </span>\n                  }\n                  @if (log.old_value.rollout_percentage !== log.new_value.rollout_percentage) {\n                    <span class=\"text-sm\">\n                      rollout: {{ log.old_value.rollout_percentage }}% →\n                      {{ log.new_value.rollout_percentage }}%\n                    </span>\n                  }\n                }\n              </td>\n            </tr>\n          </ng-template>\n        </p-table>\n      </p-card>\n\n      <!-- Audit Log - Mobile Cards -->\n      <div class=\"mt-4 md:hidden\">\n        <h2 class=\"text-lg font-semibold text-gray-700 dark:text-gray-500 mb-3\">Historial de Cambios</h2>\n\n        @if (loadingAudit()) {\n          <div class=\"flex justify-center py-4\">\n            <div class=\"animate-spin rounded-full h-6 w-6 border-b-2 border-blue-500\"></div>\n          </div>\n        } @else {\n          <div class=\"space-y-2\">\n            @for (log of auditLog().slice(0, 5); track log.id) {\n              <div class=\"bg-white dark:bg-gray-800 rounded-lg border border-gray-300 dark:border-gray-700 p-3\">\n                <div class=\"flex items-center justify-between mb-1\">\n                  <span class=\"font-mono text-xs text-gray-900 dark:text-gray-100\">\n                    {{ log.feature_flag_name }}\n                  </span>\n                  <p-tag [value]=\"log.action\" [severity]=\"getActionSeverity(log.action)\" styleClass=\"text-xs\"></p-tag>\n                </div>\n                <div class=\"text-xs text-gray-500\">\n                  {{ log.changed_at | date: 'short' }}\n                </div>\n                @if (log.action === 'updated' && log.old_value && log.new_value) {\n                  <div class=\"mt-1 text-xs text-gray-600 dark:text-gray-500\">\n                    @if (log.old_value.enabled !== log.new_value.enabled) {\n                      enabled: {{ log.old_value.enabled }} → {{ log.new_value.enabled }}\n                    }\n                    @if (log.old_value.rollout_percentage !== log.new_value.rollout_percentage) {\n                      rollout: {{ log.old_value.rollout_percentage }}% → {{ log.new_value.rollout_percentage }}%\n                    }\n                  </div>\n                }\n              </div>\n            }\n          </div>\n        }\n      </div>\n    </div>\n\n    <!-- Create / Edit Dialog -->\n    <p-dialog\n      [(visible)]=\"dialogVisible\"\n      [header]=\"editingFlag() ? 'Editar Feature Flag' : 'Nueva Feature Flag'\"\n      [modal]=\"true\"\n      [style]=\"{ width: '500px' }\"\n    >\n      <div class=\"flex flex-col gap-4\">\n        <div>\n          <label class=\"block text-sm font-medium mb-1\">Nombre</label>\n          <input\n            pInputText\n            [(ngModel)]=\"formData.name\"\n            [disabled]=\"!!editingFlag()\"\n            class=\"w-full\"\n            placeholder=\"feature_name\"\n          />\n          <small class=\"text-gray-500\">Usar snake_case, ej: new_booking_flow</small>\n        </div>\n\n        <div>\n          <label class=\"block text-sm font-medium mb-1\">Descripción</label>\n          <input\n            pInputText\n            [(ngModel)]=\"formData.description\"\n            class=\"w-full\"\n            placeholder=\"Descripción de la feature\"\n          />\n        </div>\n\n        <div>\n          <label class=\"block text-sm font-medium mb-1\">Habilitada</label>\n          <p-toggleswitch [(ngModel)]=\"formData.enabled\"></p-toggleswitch>\n        </div>\n\n        <div>\n          <label class=\"block text-sm font-medium mb-1\">Rollout Percentage</label>\n          <p-inputNumber\n            [(ngModel)]=\"formData.rollout_percentage\"\n            [min]=\"0\"\n            [max]=\"100\"\n            suffix=\"%\"\n            class=\"w-full\"\n          ></p-inputNumber>\n          <small class=\"text-gray-500\">\n            Porcentaje de usuarios que verán la feature (0-100%)\n          </small>\n        </div>\n      </div>\n\n      <ng-template pTemplate=\"footer\">\n        <p-button label=\"Cancelar\" [text]=\"true\" (onClick)=\"dialogVisible = false\"></p-button>\n        <p-button\n          [label]=\"editingFlag() ? 'Guardar' : 'Crear'\"\n          (onClick)=\"saveFlag()\"\n          [loading]=\"saving()\"\n        ></p-button>\n      </ng-template>\n    </p-dialog>\n\n    <!-- Delete Confirmation Dialog -->\n    <p-dialog\n      [(visible)]=\"deleteDialogVisible\"\n      header=\"Confirmar Eliminación\"\n      [modal]=\"true\"\n      [style]=\"{ width: '400px' }\"\n    >\n      <p>\n        ¿Estás seguro de eliminar la flag\n        <strong class=\"font-mono\">{{ flagToDelete()?.name }}</strong\n        >?\n      </p>\n      <p class=\"text-sm text-red-500 mt-2\">Esta acción no se puede deshacer.</p>\n\n      <ng-template pTemplate=\"footer\">\n        <p-button label=\"Cancelar\" [text]=\"true\" (onClick)=\"deleteDialogVisible = false\"></p-button>\n        <p-button\n          label=\"Eliminar\"\n          severity=\"danger\"\n          (onClick)=\"deleteFlag()\"\n          [loading]=\"deleting()\"\n        ></p-button>\n      </ng-template>\n    </p-dialog>\n  `,\n})\nexport class AdminFeatureFlagsPage implements OnInit {\n  private readonly featureFlagService = inject(FeatureFlagService);\n  private readonly messageService = inject(MessageService);\n\n  // State\n  readonly flags = this.featureFlagService.flags;\n  readonly loading = this.featureFlagService.loading;\n  readonly auditLog = signal<FeatureFlagAuditLog[]>([]);\n  readonly loadingAudit = signal(false);\n  readonly saving = signal(false);\n  readonly deleting = signal(false);\n  readonly editingFlag = signal<FeatureFlag | null>(null);\n  readonly flagToDelete = signal<FeatureFlag | null>(null);\n\n  // Computed stats\n  readonly totalFlags = computed(() => this.flags().length);\n  readonly enabledFlags = computed(() => this.flags().filter((f) => f.enabled).length);\n  readonly disabledFlags = computed(() => this.flags().filter((f) => !f.enabled).length);\n  readonly partialRolloutFlags = computed(\n    () => this.flags().filter((f) => f.enabled && f.rollout_percentage < 100).length,\n  );\n\n  // Dialog state\n  dialogVisible = false;\n  deleteDialogVisible = false;\n\n  // Form data\n  formData: CreateFeatureFlagDto = {\n    name: '',\n    description: '',\n    enabled: false,\n    rollout_percentage: 100,\n  };\n\n  async ngOnInit(): Promise<void> {\n    await this.loadAuditLog();\n  }\n\n  async loadAuditLog(): Promise<void> {\n    this.loadingAudit.set(true);\n    try {\n      const logs = await this.featureFlagService.getAuditLog(50);\n      this.auditLog.set(logs);\n    } catch {\n      this.messageService.add({\n        severity: 'error',\n        summary: 'Error',\n        detail: 'No se pudo cargar el historial',\n      });\n    } finally {\n      this.loadingAudit.set(false);\n    }\n  }\n\n  showCreateDialog(): void {\n    this.editingFlag.set(null);\n    this.formData = {\n      name: '',\n      description: '',\n      enabled: false,\n      rollout_percentage: 100,\n    };\n    this.dialogVisible = true;\n  }\n\n  editFlag(flag: FeatureFlag): void {\n    this.editingFlag.set(flag);\n    this.formData = {\n      name: flag.name,\n      description: flag.description || '',\n      enabled: flag.enabled,\n      rollout_percentage: flag.rollout_percentage,\n    };\n    this.dialogVisible = true;\n  }\n\n  async saveFlag(): Promise<void> {\n    if (!this.formData.name) {\n      this.messageService.add({\n        severity: 'warn',\n        summary: 'Atención',\n        detail: 'El nombre es requerido',\n      });\n      return;\n    }\n\n    this.saving.set(true);\n    try {\n      const editing = this.editingFlag();\n      if (editing) {\n        await this.featureFlagService.updateFlag(editing.id, {\n          description: this.formData.description,\n          enabled: this.formData.enabled,\n          rollout_percentage: this.formData.rollout_percentage,\n        });\n        this.messageService.add({\n          severity: 'success',\n          summary: 'Guardado',\n          detail: 'Feature flag actualizada',\n        });\n      } else {\n        await this.featureFlagService.createFlag(this.formData);\n        this.messageService.add({\n          severity: 'success',\n          summary: 'Creada',\n          detail: 'Feature flag creada exitosamente',\n        });\n      }\n      this.dialogVisible = false;\n      await this.loadAuditLog();\n    } catch (err) {\n      this.messageService.add({\n        severity: 'error',\n        summary: 'Error',\n        detail: err instanceof Error ? err.message : 'Error al guardar',\n      });\n    } finally {\n      this.saving.set(false);\n    }\n  }\n\n  async toggleFlag(flag: FeatureFlag): Promise<void> {\n    try {\n      await this.featureFlagService.toggleFlag(flag.id, flag.enabled);\n      this.messageService.add({\n        severity: 'success',\n        summary: 'Actualizado',\n        detail: `${flag.name} ${flag.enabled ? 'habilitada' : 'deshabilitada'}`,\n      });\n      await this.loadAuditLog();\n    } catch {\n      // Revert the toggle\n      flag.enabled = !flag.enabled;\n      this.messageService.add({\n        severity: 'error',\n        summary: 'Error',\n        detail: 'No se pudo actualizar la flag',\n      });\n    }\n  }\n\n  confirmDelete(flag: FeatureFlag): void {\n    this.flagToDelete.set(flag);\n    this.deleteDialogVisible = true;\n  }\n\n  async deleteFlag(): Promise<void> {\n    const flag = this.flagToDelete();\n    if (!flag) return;\n\n    this.deleting.set(true);\n    try {\n      await this.featureFlagService.deleteFlag(flag.id);\n      this.messageService.add({\n        severity: 'success',\n        summary: 'Eliminada',\n        detail: `Feature flag ${flag.name} eliminada`,\n      });\n      this.deleteDialogVisible = false;\n      await this.loadAuditLog();\n    } catch {\n      this.messageService.add({\n        severity: 'error',\n        summary: 'Error',\n        detail: 'No se pudo eliminar la flag',\n      });\n    } finally {\n      this.deleting.set(false);\n    }\n  }\n\n  getRolloutSeverity(percentage: number): 'success' | 'info' | 'warn' | 'danger' {\n    if (percentage === 100) return 'success';\n    if (percentage >= 50) return 'info';\n    if (percentage > 0) return 'warn';\n    return 'danger';\n  }\n\n  getActionSeverity(action: string): 'success' | 'info' | 'warn' | 'danger' {\n    switch (action) {\n      case 'created':\n        return 'success';\n      case 'updated':\n        return 'info';\n      case 'deleted':\n        return 'danger';\n      default:\n        return 'info';\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/features/bookings/active-rental/active-rental.page.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`../../../core/models` import should occur after import of `@core/services/infrastructure/logger.service`","line":11,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":48,"fix":{"range":[233,499],"text":"import { AuthService } from '@core/services/auth/auth.service';\nimport { BookingsService } from '@core/services/bookings/bookings.service';\nimport { LoggerService } from '@core/services/infrastructure/logger.service';\nimport { Booking } from '../../../core/models';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { CommonModule } from '@angular/common';\nimport {\n  Component,\n  OnInit,\n  ChangeDetectionStrategy,\n  inject,\n  signal,\n  computed,\n} from '@angular/core';\nimport { ActivatedRoute, Router, RouterLink } from '@angular/router';\nimport { Booking } from '../../../core/models';\nimport { AuthService } from '@core/services/auth/auth.service';\nimport { BookingsService } from '@core/services/bookings/bookings.service';\nimport { LoggerService } from '@core/services/infrastructure/logger.service';\nimport { AiChecklistPanelComponent } from '../../../shared/components/ai-checklist-panel/ai-checklist-panel.component';\nimport { AiLegalPanelComponent } from '../../../shared/components/ai-legal-panel/ai-legal-panel.component';\nimport { AiTripPanelComponent } from '../../../shared/components/ai-trip-panel/ai-trip-panel.component';\nimport { TripTimerComponent } from './components/trip-timer/trip-timer.component';\nimport { QuickActionsComponent } from './components/quick-actions/quick-actions.component';\nimport { EmergencyPanelComponent } from './components/emergency-panel/emergency-panel.component';\nimport { DigitalKeyComponent } from './components/digital-key/digital-key.component';\n\n@Component({\n  selector: 'app-active-rental',\n  standalone: true,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  imports: [\n    CommonModule,\n    RouterLink,\n    TripTimerComponent,\n    QuickActionsComponent,\n    EmergencyPanelComponent,\n    DigitalKeyComponent,\n    AiLegalPanelComponent,\n    AiTripPanelComponent,\n    AiChecklistPanelComponent,\n  ],\n  templateUrl: './active-rental.page.html',\n  styleUrl: './active-rental.page.css',\n})\nexport class ActiveRentalPage implements OnInit {\n  private readonly route = inject(ActivatedRoute);\n  private readonly router = inject(Router);\n  private readonly bookingsService = inject(BookingsService);\n  private readonly authService = inject(AuthService);\n  private readonly logger = inject(LoggerService).createChildLogger('ActiveRentalPage');\n\n  // State\n  readonly booking = signal<Booking | null>(null);\n  readonly loading = signal(true);\n  readonly error = signal<string | null>(null);\n  readonly showEmergencyPanel = signal(false);\n\n  // Owner info\n  readonly ownerPhone = signal<string | null>(null);\n  readonly ownerName = signal<string>('Propietario');\n\n  // Car location (from tracking)\n  readonly carLocation = signal<{ lat: number; lng: number } | null>(null);\n\n  // AI Panels\n  readonly expandedAiPanel = signal<'legal' | 'trip' | 'checklist' | null>(null);\n\n  // Computed\n  readonly carImageUrl = computed(() => {\n    const booking = this.booking();\n    return booking?.car_image || booking?.main_photo_url || '/assets/images/car-placeholder.webp';\n  });\n\n  readonly carTitle = computed(() => {\n    const booking = this.booking();\n    if (!booking) return '';\n    return `${booking.car_brand} ${booking.car_model} ${booking.car_year || ''}`.trim();\n  });\n\n  readonly isActive = computed(() => {\n    const booking = this.booking();\n    return booking?.status === 'in_progress';\n  });\n\n  readonly startDate = computed(() => {\n    const booking = this.booking();\n    return booking ? new Date(booking.start_at) : null;\n  });\n\n  readonly endDate = computed(() => {\n    const booking = this.booking();\n    return booking ? new Date(booking.end_at) : null;\n  });\n\n  // Insurance info (static for now - could be enhanced with real data)\n  readonly insuranceInfo = computed(() => {\n    const booking = this.booking();\n    if (!booking) return null;\n    return {\n      policyNumber: `AR-${new Date(booking.created_at).getFullYear()}-${booking.id.slice(0, 8).toUpperCase()}`,\n      provider: 'AutoRenta Seguros',\n      phone: '0800-333-RENT',\n    };\n  });\n\n  async ngOnInit(): Promise<void> {\n    const bookingId = this.route.snapshot.paramMap.get('id');\n    if (!bookingId) {\n      this.error.set('ID de reserva inválido');\n      this.loading.set(false);\n      return;\n    }\n\n    try {\n      const booking = await this.bookingsService.getBookingById(bookingId);\n      if (!booking) {\n        this.error.set('Reserva no encontrada');\n        this.loading.set(false);\n        return;\n      }\n\n      // Verify booking is in_progress\n      if (booking.status !== 'in_progress') {\n        this.logger.warn('Booking not in progress, redirecting', { status: booking.status });\n        this.router.navigate(['/bookings', bookingId]);\n        return;\n      }\n\n      this.booking.set(booking);\n\n      // Load owner info\n      await this.loadOwnerInfo(booking.car_id);\n\n      // Load car location from tracking (if available)\n      await this.loadCarLocation(bookingId);\n    } catch (err) {\n      this.logger.error('Error loading booking', err);\n      this.error.set('Error al cargar la reserva');\n    } finally {\n      this.loading.set(false);\n    }\n  }\n\n  // ngOnDestroy not needed - using takeUntilDestroyed for subscriptions\n\n  private async loadOwnerInfo(carId: string): Promise<void> {\n    try {\n      const { data: car } = await this.bookingsService['supabase']\n        .from('cars')\n        .select('owner:profiles!cars_owner_id_fkey(full_name, phone, whatsapp)')\n        .eq('id', carId)\n        .single();\n\n      if (car?.owner) {\n        const owner = car.owner as { full_name?: string; phone?: string; whatsapp?: string };\n        this.ownerName.set(owner.full_name || 'Propietario');\n        this.ownerPhone.set(owner.whatsapp || owner.phone || null);\n      }\n    } catch {\n      // Silent fail - owner info is optional\n    }\n  }\n\n  private async loadCarLocation(bookingId: string): Promise<void> {\n    try {\n      // Get latest tracking point\n      const { data: session } = await this.bookingsService['supabase']\n        .from('tracking_sessions')\n        .select('id')\n        .eq('booking_id', bookingId)\n        .eq('active', true)\n        .single();\n\n      if (!session) return;\n\n      const { data: point } = await this.bookingsService['supabase']\n        .from('tracking_points')\n        .select('latitude, longitude')\n        .eq('session_id', session.id)\n        .order('recorded_at', { ascending: false })\n        .limit(1)\n        .single();\n\n      if (point) {\n        this.carLocation.set({ lat: point.latitude, lng: point.longitude });\n      }\n    } catch {\n      // Silent fail - location is optional\n    }\n  }\n\n  // Actions\n  toggleEmergencyPanel(): void {\n    this.showEmergencyPanel.update((v) => !v);\n  }\n\n  onQuickAction(action: string): void {\n    switch (action) {\n      case 'locate':\n        this.openCarLocation();\n        break;\n      case 'gas':\n        this.openGasStations();\n        break;\n      case 'call':\n        this.callOwner();\n        break;\n      case 'sos':\n        this.showEmergencyPanel.set(true);\n        break;\n    }\n  }\n\n  private openCarLocation(): void {\n    const location = this.carLocation();\n    if (location) {\n      window.open(\n        `https://www.google.com/maps/search/?api=1&query=${location.lat},${location.lng}`,\n        '_blank'\n      );\n    } else {\n      // Fallback to booking detail with tracking\n      const booking = this.booking();\n      if (booking) {\n        this.router.navigate(['/bookings', booking.id], { fragment: 'tracking' });\n      }\n    }\n  }\n\n  private openGasStations(): void {\n    const location = this.carLocation();\n    if (location) {\n      window.open(\n        `https://www.google.com/maps/search/estacion+de+servicio/@${location.lat},${location.lng},14z`,\n        '_blank'\n      );\n    } else {\n      window.open('https://www.google.com/maps/search/estacion+de+servicio', '_blank');\n    }\n  }\n\n  private callOwner(): void {\n    const phone = this.ownerPhone();\n    if (phone) {\n      window.location.href = `tel:${phone}`;\n    }\n  }\n\n  goBack(): void {\n    const booking = this.booking();\n    if (booking) {\n      this.router.navigate(['/bookings', booking.id]);\n    } else {\n      this.router.navigate(['/bookings']);\n    }\n  }\n\n  toggleAiPanel(panel: 'legal' | 'trip' | 'checklist'): void {\n    this.expandedAiPanel.update((current) => (current === panel ? null : panel));\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/features/bookings/booking-detail-payment/components/card-hold-panel.component.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`@core/services/payments/payment-authorization.service` import should occur before import of `../../../../shared/components/mercadopago-card-form/mercadopago-card-form.component`","line":13,"column":1,"nodeType":"ImportDeclaration","endLine":13,"endColumn":101,"fix":{"range":[238,638],"text":"import { PaymentAuthorizationService } from '@core/services/payments/payment-authorization.service';\nimport {\n  MercadopagoCardFormComponent,\n  MercadoPagoCardTokenGeneratedEvent,\n} from '../../../../shared/components/mercadopago-card-form/mercadopago-card-form.component';\nimport {\n  RiskSnapshot,\n  FxSnapshot,\n  PaymentAuthorization,\n} from '../../../../core/models/booking-detail-payment.model';\n"}},{"ruleId":"import/order","severity":1,"message":"`@core/services/auth/auth.service` import should occur before import of `../../../../shared/components/mercadopago-card-form/mercadopago-card-form.component`","line":14,"column":1,"nodeType":"ImportDeclaration","endLine":14,"endColumn":64,"fix":{"range":[238,702],"text":"import { AuthService } from '@core/services/auth/auth.service';\nimport {\n  MercadopagoCardFormComponent,\n  MercadoPagoCardTokenGeneratedEvent,\n} from '../../../../shared/components/mercadopago-card-form/mercadopago-card-form.component';\nimport {\n  RiskSnapshot,\n  FxSnapshot,\n  PaymentAuthorization,\n} from '../../../../core/models/booking-detail-payment.model';\nimport { PaymentAuthorizationService } from '@core/services/payments/payment-authorization.service';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import { Component, Input, Output, EventEmitter, inject, signal, ChangeDetectionStrategy, DestroyRef } from '@angular/core';\nimport { takeUntilDestroyed } from '@angular/core/rxjs-interop';\nimport { CommonModule } from '@angular/common';\nimport {\n  MercadopagoCardFormComponent,\n  MercadoPagoCardTokenGeneratedEvent,\n} from '../../../../shared/components/mercadopago-card-form/mercadopago-card-form.component';\nimport {\n  RiskSnapshot,\n  FxSnapshot,\n  PaymentAuthorization,\n} from '../../../../core/models/booking-detail-payment.model';\nimport { PaymentAuthorizationService } from '@core/services/payments/payment-authorization.service';\nimport { AuthService } from '@core/services/auth/auth.service';\nimport { ReembolsabilityBadgeComponent } from './reembolsability-badge.component';\n\n@Component({\n  selector: 'app-card-hold-panel',\n  standalone: true,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  imports: [CommonModule, MercadopagoCardFormComponent, ReembolsabilityBadgeComponent],\n  templateUrl: './card-hold-panel.component.html',\n  styleUrls: ['./card-hold-panel.component.css'],\n})\nexport class CardHoldPanelComponent {\n  @Input({ required: true }) riskSnapshot!: RiskSnapshot;\n  @Input({ required: true }) fxSnapshot!: FxSnapshot;\n  @Input() userId = '';\n  @Input() bookingId?: string;\n  @Input() currentAuthorization: PaymentAuthorization | null = null;\n\n  @Output() authorizationChange = new EventEmitter<PaymentAuthorization | null>();\n\n  private readonly paymentAuthorizationService = inject(PaymentAuthorizationService);\n  private readonly authService = inject(AuthService);\n  private readonly destroyRef = inject(DestroyRef);\n\n  readonly userEmail = this.authService.userEmail;\n\n  readonly authorizationStatus = signal<'idle' | 'authorized' | 'expired' | 'failed'>('idle');\n  readonly isLoading = signal(false);\n  readonly errorMessage = signal<string | null>(null);\n  readonly currentAuthSignal = signal<PaymentAuthorization | null>(null);\n\n  constructor() {\n    if (this.currentAuthorization) {\n      this.currentAuthSignal.set(this.currentAuthorization);\n      this.authorizationStatus.set(this.mapAuthStatus(this.currentAuthorization));\n    }\n  }\n\n  onCardTokenGenerated(event: MercadoPagoCardTokenGeneratedEvent): void {\n    this.onAuthorize(event.cardToken, event.last4, event.payer?.identification);\n  }\n\n  onAuthorize(\n    cardToken: string,\n    cardLast4: string,\n    payerIdentification?: { type: string; number: string },\n  ): void {\n    const email = this.userEmail();\n    if (!this.userId || !email) {\n      this.errorMessage.set('Error: Usuario no identificado');\n      this.authorizationStatus.set('failed');\n      return;\n    }\n\n    this.isLoading.set(true);\n    this.errorMessage.set(null);\n\n    this.paymentAuthorizationService\n      .authorizePayment({\n        userId: this.userId,\n        amountUsd: this.riskSnapshot.holdEstimatedUsd,\n        amountArs: this.riskSnapshot.holdEstimatedArs,\n        fxRate: this.fxSnapshot.rate,\n        cardToken,\n        payerEmail: email,\n        payerIdentification,\n        description: `Preautorización para reserva${this.bookingId ? ` ${this.bookingId}` : ''}`,\n        bookingId: this.bookingId,\n      })\n      .pipe(takeUntilDestroyed(this.destroyRef))\n      .subscribe({\n        next: (result) => {\n          this.isLoading.set(false);\n          if (result.ok && result.authorizedPaymentId) {\n            const authorization: PaymentAuthorization = {\n              authorizedPaymentId: result.authorizedPaymentId,\n              amountArs: this.riskSnapshot.holdEstimatedArs,\n              amountUsd: this.riskSnapshot.holdEstimatedUsd,\n              currency: 'ARS',\n              expiresAt: result.expiresAt || new Date(),\n              status: 'authorized',\n              cardLast4,\n              createdAt: new Date(),\n            };\n            this.currentAuthSignal.set(authorization);\n            this.authorizationStatus.set('authorized');\n            this.authorizationChange.emit(authorization);\n          } else {\n            this.errorMessage.set(result.error || 'Error desconocido');\n            this.authorizationStatus.set('failed');\n            this.authorizationChange.emit(null);\n          }\n        },\n        error: (err) => {\n          this.isLoading.set(false);\n          this.errorMessage.set(err.message || 'Error de red');\n          this.authorizationStatus.set('failed');\n          this.authorizationChange.emit(null);\n        },\n      });\n  }\n\n  onReauthorize(): void {\n    this.authorizationStatus.set('idle');\n  }\n\n  onRetry(): void {\n    this.authorizationStatus.set('idle');\n    this.errorMessage.set(null);\n  }\n\n  onChangeCard(): void {\n    const currentAuth = this.currentAuthSignal();\n    if (currentAuth) {\n      this.paymentAuthorizationService\n        .cancelAuthorization(currentAuth.authorizedPaymentId)\n        .pipe(takeUntilDestroyed(this.destroyRef))\n        .subscribe(() => {\n          this.currentAuthSignal.set(null);\n          this.authorizationStatus.set('idle');\n          this.authorizationChange.emit(null);\n        });\n    }\n  }\n\n  private mapAuthStatus(auth: PaymentAuthorization): 'idle' | 'authorized' | 'expired' | 'failed' {\n    if (auth.status === 'authorized') return 'authorized';\n    if (auth.status === 'expired') return 'expired';\n    if (auth.status === 'failed') return 'failed';\n    return 'idle';\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/features/bookings/booking-detail/booking-detail.page.spec.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`../../../core/models` type import should occur after import of `@core/services/infrastructure/traffic-infractions.service`","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":53,"fix":{"range":[294,1298],"text":"import { AuthService } from '@core/services/auth/auth.service';\nimport { BookingConfirmationService } from '@core/services/bookings/booking-confirmation.service';\nimport { BookingOpsService } from '@core/services/bookings/booking-ops.service';\nimport { BookingsService } from '@core/services/bookings/bookings.service';\nimport { ExchangeRateService } from '@core/services/payments/exchange-rate.service';\nimport { FgoV1_1Service } from '@core/services/verification/fgo-v1-1.service';\nimport { InsuranceService } from '@core/services/bookings/insurance.service';\nimport { LoggerService } from '@core/services/infrastructure/logger.service';\nimport { MetaService } from '@core/services/ui/meta.service';\nimport { PaymentsService } from '@core/services/payments/payments.service';\nimport { ReviewsService } from '@core/services/cars/reviews.service';\nimport { TrafficInfractionsService } from '@core/services/infrastructure/traffic-infractions.service';\nimport type { Booking } from '../../../core/models';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { CUSTOM_ELEMENTS_SCHEMA } from '@angular/core';\nimport { ComponentFixture, TestBed, fakeAsync, tick } from '@angular/core/testing';\nimport { ActivatedRoute, Router, convertToParamMap } from '@angular/router';\nimport { AlertController } from '@ionic/angular';\nimport { of } from 'rxjs';\nimport type { Booking } from '../../../core/models';\nimport { AuthService } from '@core/services/auth/auth.service';\nimport { BookingConfirmationService } from '@core/services/bookings/booking-confirmation.service';\nimport { BookingOpsService } from '@core/services/bookings/booking-ops.service';\nimport { BookingsService } from '@core/services/bookings/bookings.service';\nimport { ExchangeRateService } from '@core/services/payments/exchange-rate.service';\nimport { FgoV1_1Service } from '@core/services/verification/fgo-v1-1.service';\nimport { InsuranceService } from '@core/services/bookings/insurance.service';\nimport { LoggerService } from '@core/services/infrastructure/logger.service';\nimport { MetaService } from '@core/services/ui/meta.service';\nimport { PaymentsService } from '@core/services/payments/payments.service';\nimport { ReviewsService } from '@core/services/cars/reviews.service';\nimport { TrafficInfractionsService } from '@core/services/infrastructure/traffic-infractions.service';\nimport { BookingDetailPage } from './booking-detail.page';\n\ndescribe('BookingDetailPage - return checklist', () => {\n  let component: BookingDetailPage;\n  let fixture: ComponentFixture<BookingDetailPage>;\n  let bookingsService: jasmine.SpyObj<BookingsService>;\n  let loggerService: jasmine.SpyObj<LoggerService>;\n\n  beforeEach(async () => {\n    bookingsService = jasmine.createSpyObj('BookingsService', ['updateBooking']);\n    const baseBooking: Booking = {\n      id: 'booking-1',\n      car_id: 'car-1',\n      user_id: 'renter-1',\n      renter_id: 'renter-1',\n      start_at: new Date().toISOString(),\n      end_at: new Date(Date.now() + 3600000).toISOString(),\n      status: 'in_progress' as any,\n      total_amount: 10 as any,\n      currency: 'ARS' as any,\n      created_at: new Date().toISOString(),\n      metadata: {},\n    } as any;\n\n    bookingsService.updateBooking.and.callFake(async (_id: string, updates: Partial<Booking>) => {\n      const mergedMetadata = {\n        ...(baseBooking.metadata as any),\n        ...(((updates as any)?.metadata ?? {}) as any),\n      };\n\n      return {\n        ...baseBooking,\n        ...(updates as any),\n        metadata: mergedMetadata,\n      } as Booking;\n    });\n\n    loggerService = jasmine.createSpyObj('LoggerService', ['createChildLogger']);\n    loggerService.createChildLogger.and.returnValue({\n      warn: jasmine.createSpy('warn'),\n    } as any);\n\n    await TestBed.configureTestingModule({\n      imports: [BookingDetailPage],\n      providers: [\n        { provide: BookingsService, useValue: bookingsService },\n        { provide: LoggerService, useValue: loggerService },\n        {\n          provide: AuthService,\n          useValue: {\n            session$: () => ({ user: { id: 'renter-1' } }),\n            ensureSession: () => Promise.resolve({ user: { id: 'renter-1' } }),\n          },\n        },\n        { provide: ActivatedRoute, useValue: { snapshot: { paramMap: convertToParamMap({ id: 'booking-1' }) } } },\n        { provide: Router, useValue: jasmine.createSpyObj('Router', ['navigate']) },\n        { provide: PaymentsService, useValue: {} },\n        { provide: ReviewsService, useValue: {} },\n        { provide: BookingConfirmationService, useValue: {} },\n        { provide: AlertController, useValue: {} },\n        { provide: MetaService, useValue: {} },\n        { provide: ExchangeRateService, useValue: {} },\n        { provide: FgoV1_1Service, useValue: { getInspections: () => of([]) } },\n        { provide: InsuranceService, useValue: {} },\n        { provide: BookingOpsService, useValue: {} },\n        { provide: TrafficInfractionsService, useValue: {} },\n      ],\n      schemas: [CUSTOM_ELEMENTS_SCHEMA],\n    })\n      .overrideComponent(BookingDetailPage, {\n        set: { schemas: [CUSTOM_ELEMENTS_SCHEMA] },\n      })\n      .compileComponents();\n\n    fixture = TestBed.createComponent(BookingDetailPage);\n    component = fixture.componentInstance;\n  });\n\n  it('should merge checklist from metadata on load', () => {\n    const booking: any = {\n      id: 'booking-1',\n      car_id: 'car-1',\n      user_id: 'renter-1',\n      renter_id: 'renter-1',\n      start_at: new Date().toISOString(),\n      end_at: new Date(Date.now() + 3600000).toISOString(),\n      status: 'in_progress',\n      total_amount: 10,\n      currency: 'ARS',\n      created_at: new Date().toISOString(),\n      metadata: {\n        return_checklist: [{ id: 'fuel', checked: true }],\n      },\n    };\n\n    component.booking.set(booking);\n    (component as any).loadReturnChecklist(booking);\n\n    const items = component.returnChecklistItems();\n    const fuelItem = items.find((i) => i.id === 'fuel');\n    expect(fuelItem?.checked).toBeTrue();\n  });\n\n  it('should sync checklist to metadata on toggle', fakeAsync(() => {\n    const booking: any = {\n      id: 'booking-1',\n      car_id: 'car-1',\n      user_id: 'renter-1',\n      renter_id: 'renter-1',\n      start_at: new Date().toISOString(),\n      end_at: new Date(Date.now() + 3600000).toISOString(),\n      status: 'in_progress',\n      total_amount: 10,\n      currency: 'ARS',\n      created_at: new Date().toISOString(),\n      metadata: {},\n    };\n\n    component.booking.set(booking);\n    (component as any).loadReturnChecklist(booking);\n    component.toggleReturnChecklistItem('final-photos');\n\n    tick(600);\n\n    expect(bookingsService.updateBooking).toHaveBeenCalled();\n    const updateArg = bookingsService.updateBooking.calls.mostRecent().args[1] as any;\n    expect(updateArg.metadata.return_checklist).toBeDefined();\n  }));\n\n  it('should build car return considerations based on car rules', () => {\n    const booking: any = {\n      id: 'booking-1',\n      car_id: 'car-1',\n      user_id: 'renter-1',\n      renter_id: 'renter-1',\n      start_at: new Date().toISOString(),\n      end_at: new Date(Date.now() + 3600000).toISOString(),\n      status: 'in_progress',\n      total_amount: 10,\n      currency: 'ARS',\n      created_at: new Date().toISOString(),\n      delivery_required: true,\n      car: {\n        fuel_policy: 'full_to_full',\n        mileage_limit: 120,\n        extra_km_price: 50,\n        allow_smoking: false,\n        allow_pets: false,\n        allow_rideshare: false,\n        max_distance_km: 200,\n      },\n      metadata: {},\n    };\n\n    component.booking.set(booking);\n\n    const notes = component.carReturnConsiderations();\n    expect(notes.join(' ')).toContain('tanque lleno');\n    expect(notes.join(' ')).toContain('Kilometraje máximo');\n    expect(notes.join(' ')).toContain('No se permite fumar');\n    expect(notes.join(' ')).toContain('No se permiten mascotas');\n    expect(notes.join(' ')).toContain('Coordiná la devolución');\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/features/bookings/booking-detail/booking-detail.page.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`@core/services/auth/auth.service` import should occur before import of `../../../core/models`","line":12,"column":1,"nodeType":"ImportDeclaration","endLine":12,"endColumn":64,"fix":{"range":[375,784],"text":"import { AuthService } from '@core/services/auth/auth.service';\nimport { Booking, BookingExtensionRequest } from '../../../core/models';\nimport { TrafficInfraction } from '../../admin/traffic-infractions/admin-traffic-infractions.page'; // NEW\nimport { BookingInspection } from '../../../core/models/fgo-v1-1.model';\nimport { CLAIM_STATUS_LABELS, InsuranceClaim } from '../../../core/models/insurance.model';\n"}},{"ruleId":"import/order","severity":1,"message":"`@core/services/bookings/booking-confirmation.service` import should occur before import of `../../../core/models`","line":13,"column":1,"nodeType":"ImportDeclaration","endLine":16,"endColumn":63,"fix":{"range":[375,915],"text":"import {\n  BookingConfirmationService,\n  ConfirmAndReleaseResponse,\n} from '@core/services/bookings/booking-confirmation.service';\nimport { Booking, BookingExtensionRequest } from '../../../core/models';\nimport { TrafficInfraction } from '../../admin/traffic-infractions/admin-traffic-infractions.page'; // NEW\nimport { BookingInspection } from '../../../core/models/fgo-v1-1.model';\nimport { CLAIM_STATUS_LABELS, InsuranceClaim } from '../../../core/models/insurance.model';\nimport { AuthService } from '@core/services/auth/auth.service';\n"}},{"ruleId":"import/order","severity":1,"message":"`@core/services/bookings/bookings.service` import should occur before import of `../../../core/models`","line":17,"column":1,"nodeType":"ImportDeclaration","endLine":17,"endColumn":76,"fix":{"range":[375,991],"text":"import { BookingsService } from '@core/services/bookings/bookings.service';\nimport { Booking, BookingExtensionRequest } from '../../../core/models';\nimport { TrafficInfraction } from '../../admin/traffic-infractions/admin-traffic-infractions.page'; // NEW\nimport { BookingInspection } from '../../../core/models/fgo-v1-1.model';\nimport { CLAIM_STATUS_LABELS, InsuranceClaim } from '../../../core/models/insurance.model';\nimport { AuthService } from '@core/services/auth/auth.service';\nimport {\n  BookingConfirmationService,\n  ConfirmAndReleaseResponse,\n} from '@core/services/bookings/booking-confirmation.service';\n"}},{"ruleId":"import/order","severity":1,"message":"`@core/services/payments/exchange-rate.service` import should occur before import of `../../../core/models`","line":18,"column":1,"nodeType":"ImportDeclaration","endLine":18,"endColumn":85,"fix":{"range":[375,1076],"text":"import { ExchangeRateService } from '@core/services/payments/exchange-rate.service';\nimport { Booking, BookingExtensionRequest } from '../../../core/models';\nimport { TrafficInfraction } from '../../admin/traffic-infractions/admin-traffic-infractions.page'; // NEW\nimport { BookingInspection } from '../../../core/models/fgo-v1-1.model';\nimport { CLAIM_STATUS_LABELS, InsuranceClaim } from '../../../core/models/insurance.model';\nimport { AuthService } from '@core/services/auth/auth.service';\nimport {\n  BookingConfirmationService,\n  ConfirmAndReleaseResponse,\n} from '@core/services/bookings/booking-confirmation.service';\nimport { BookingsService } from '@core/services/bookings/bookings.service';\n"}},{"ruleId":"import/order","severity":1,"message":"`@core/services/verification/fgo-v1-1.service` import should occur before import of `../../../core/models`","line":19,"column":1,"nodeType":"ImportDeclaration","endLine":19,"endColumn":79,"fix":{"range":[375,1155],"text":"import { FgoV1_1Service } from '@core/services/verification/fgo-v1-1.service';\nimport { Booking, BookingExtensionRequest } from '../../../core/models';\nimport { TrafficInfraction } from '../../admin/traffic-infractions/admin-traffic-infractions.page'; // NEW\nimport { BookingInspection } from '../../../core/models/fgo-v1-1.model';\nimport { CLAIM_STATUS_LABELS, InsuranceClaim } from '../../../core/models/insurance.model';\nimport { AuthService } from '@core/services/auth/auth.service';\nimport {\n  BookingConfirmationService,\n  ConfirmAndReleaseResponse,\n} from '@core/services/bookings/booking-confirmation.service';\nimport { BookingsService } from '@core/services/bookings/bookings.service';\nimport { ExchangeRateService } from '@core/services/payments/exchange-rate.service';\n"}},{"ruleId":"import/order","severity":1,"message":"`@core/services/bookings/insurance.service` import should occur before import of `../../../core/models`","line":20,"column":1,"nodeType":"ImportDeclaration","endLine":20,"endColumn":78,"fix":{"range":[375,1233],"text":"import { InsuranceService } from '@core/services/bookings/insurance.service';\nimport { Booking, BookingExtensionRequest } from '../../../core/models';\nimport { TrafficInfraction } from '../../admin/traffic-infractions/admin-traffic-infractions.page'; // NEW\nimport { BookingInspection } from '../../../core/models/fgo-v1-1.model';\nimport { CLAIM_STATUS_LABELS, InsuranceClaim } from '../../../core/models/insurance.model';\nimport { AuthService } from '@core/services/auth/auth.service';\nimport {\n  BookingConfirmationService,\n  ConfirmAndReleaseResponse,\n} from '@core/services/bookings/booking-confirmation.service';\nimport { BookingsService } from '@core/services/bookings/bookings.service';\nimport { ExchangeRateService } from '@core/services/payments/exchange-rate.service';\nimport { FgoV1_1Service } from '@core/services/verification/fgo-v1-1.service';\n"}},{"ruleId":"import/order","severity":1,"message":"`@core/services/ui/meta.service` import should occur before import of `../../../core/models`","line":21,"column":1,"nodeType":"ImportDeclaration","endLine":21,"endColumn":62,"fix":{"range":[375,1295],"text":"import { MetaService } from '@core/services/ui/meta.service';\nimport { Booking, BookingExtensionRequest } from '../../../core/models';\nimport { TrafficInfraction } from '../../admin/traffic-infractions/admin-traffic-infractions.page'; // NEW\nimport { BookingInspection } from '../../../core/models/fgo-v1-1.model';\nimport { CLAIM_STATUS_LABELS, InsuranceClaim } from '../../../core/models/insurance.model';\nimport { AuthService } from '@core/services/auth/auth.service';\nimport {\n  BookingConfirmationService,\n  ConfirmAndReleaseResponse,\n} from '@core/services/bookings/booking-confirmation.service';\nimport { BookingsService } from '@core/services/bookings/bookings.service';\nimport { ExchangeRateService } from '@core/services/payments/exchange-rate.service';\nimport { FgoV1_1Service } from '@core/services/verification/fgo-v1-1.service';\nimport { InsuranceService } from '@core/services/bookings/insurance.service';\n"}},{"ruleId":"import/order","severity":1,"message":"`@core/services/payments/payments.service` import should occur before import of `../../../core/models`","line":22,"column":1,"nodeType":"ImportDeclaration","endLine":22,"endColumn":76,"fix":{"range":[375,1371],"text":"import { PaymentsService } from '@core/services/payments/payments.service';\nimport { Booking, BookingExtensionRequest } from '../../../core/models';\nimport { TrafficInfraction } from '../../admin/traffic-infractions/admin-traffic-infractions.page'; // NEW\nimport { BookingInspection } from '../../../core/models/fgo-v1-1.model';\nimport { CLAIM_STATUS_LABELS, InsuranceClaim } from '../../../core/models/insurance.model';\nimport { AuthService } from '@core/services/auth/auth.service';\nimport {\n  BookingConfirmationService,\n  ConfirmAndReleaseResponse,\n} from '@core/services/bookings/booking-confirmation.service';\nimport { BookingsService } from '@core/services/bookings/bookings.service';\nimport { ExchangeRateService } from '@core/services/payments/exchange-rate.service';\nimport { FgoV1_1Service } from '@core/services/verification/fgo-v1-1.service';\nimport { InsuranceService } from '@core/services/bookings/insurance.service';\nimport { MetaService } from '@core/services/ui/meta.service';\n"}},{"ruleId":"import/order","severity":1,"message":"`@core/services/cars/reviews.service` import should occur before import of `../../../core/models`","line":23,"column":1,"nodeType":"ImportDeclaration","endLine":23,"endColumn":70,"fix":{"range":[375,1441],"text":"import { ReviewsService } from '@core/services/cars/reviews.service';\nimport { Booking, BookingExtensionRequest } from '../../../core/models';\nimport { TrafficInfraction } from '../../admin/traffic-infractions/admin-traffic-infractions.page'; // NEW\nimport { BookingInspection } from '../../../core/models/fgo-v1-1.model';\nimport { CLAIM_STATUS_LABELS, InsuranceClaim } from '../../../core/models/insurance.model';\nimport { AuthService } from '@core/services/auth/auth.service';\nimport {\n  BookingConfirmationService,\n  ConfirmAndReleaseResponse,\n} from '@core/services/bookings/booking-confirmation.service';\nimport { BookingsService } from '@core/services/bookings/bookings.service';\nimport { ExchangeRateService } from '@core/services/payments/exchange-rate.service';\nimport { FgoV1_1Service } from '@core/services/verification/fgo-v1-1.service';\nimport { InsuranceService } from '@core/services/bookings/insurance.service';\nimport { MetaService } from '@core/services/ui/meta.service';\nimport { PaymentsService } from '@core/services/payments/payments.service';\n"}},{"ruleId":"import/order","severity":1,"message":"`@core/services/infrastructure/logger.service` import should occur before import of `../../../core/models`","line":24,"column":1,"nodeType":"ImportDeclaration","endLine":24,"endColumn":78,"fix":{"range":[375,1519],"text":"import { LoggerService } from '@core/services/infrastructure/logger.service';\nimport { Booking, BookingExtensionRequest } from '../../../core/models';\nimport { TrafficInfraction } from '../../admin/traffic-infractions/admin-traffic-infractions.page'; // NEW\nimport { BookingInspection } from '../../../core/models/fgo-v1-1.model';\nimport { CLAIM_STATUS_LABELS, InsuranceClaim } from '../../../core/models/insurance.model';\nimport { AuthService } from '@core/services/auth/auth.service';\nimport {\n  BookingConfirmationService,\n  ConfirmAndReleaseResponse,\n} from '@core/services/bookings/booking-confirmation.service';\nimport { BookingsService } from '@core/services/bookings/bookings.service';\nimport { ExchangeRateService } from '@core/services/payments/exchange-rate.service';\nimport { FgoV1_1Service } from '@core/services/verification/fgo-v1-1.service';\nimport { InsuranceService } from '@core/services/bookings/insurance.service';\nimport { MetaService } from '@core/services/ui/meta.service';\nimport { PaymentsService } from '@core/services/payments/payments.service';\nimport { ReviewsService } from '@core/services/cars/reviews.service';\n"}},{"ruleId":"import/order","severity":1,"message":"`@core/services/infrastructure/traffic-infractions.service` import should occur before import of `../../../core/models`","line":25,"column":1,"nodeType":"ImportDeclaration","endLine":25,"endColumn":103,"fix":{"range":[375,1629],"text":"import { TrafficInfractionsService } from '@core/services/infrastructure/traffic-infractions.service'; // NEW\nimport { Booking, BookingExtensionRequest } from '../../../core/models';\nimport { TrafficInfraction } from '../../admin/traffic-infractions/admin-traffic-infractions.page'; // NEW\nimport { BookingInspection } from '../../../core/models/fgo-v1-1.model';\nimport { CLAIM_STATUS_LABELS, InsuranceClaim } from '../../../core/models/insurance.model';\nimport { AuthService } from '@core/services/auth/auth.service';\nimport {\n  BookingConfirmationService,\n  ConfirmAndReleaseResponse,\n} from '@core/services/bookings/booking-confirmation.service';\nimport { BookingsService } from '@core/services/bookings/bookings.service';\nimport { ExchangeRateService } from '@core/services/payments/exchange-rate.service';\nimport { FgoV1_1Service } from '@core/services/verification/fgo-v1-1.service';\nimport { InsuranceService } from '@core/services/bookings/insurance.service';\nimport { MetaService } from '@core/services/ui/meta.service';\nimport { PaymentsService } from '@core/services/payments/payments.service';\nimport { ReviewsService } from '@core/services/cars/reviews.service';\nimport { LoggerService } from '@core/services/infrastructure/logger.service';\n"}},{"ruleId":"import/order","severity":1,"message":"`@core/services/bookings/booking-flow.service` import should occur before import of `../../../core/models`","line":26,"column":1,"nodeType":"ImportDeclaration","endLine":26,"endColumn":93,"fix":{"range":[375,1722],"text":"import { BookingFlowService, NextStep } from '@core/services/bookings/booking-flow.service';\nimport { Booking, BookingExtensionRequest } from '../../../core/models';\nimport { TrafficInfraction } from '../../admin/traffic-infractions/admin-traffic-infractions.page'; // NEW\nimport { BookingInspection } from '../../../core/models/fgo-v1-1.model';\nimport { CLAIM_STATUS_LABELS, InsuranceClaim } from '../../../core/models/insurance.model';\nimport { AuthService } from '@core/services/auth/auth.service';\nimport {\n  BookingConfirmationService,\n  ConfirmAndReleaseResponse,\n} from '@core/services/bookings/booking-confirmation.service';\nimport { BookingsService } from '@core/services/bookings/bookings.service';\nimport { ExchangeRateService } from '@core/services/payments/exchange-rate.service';\nimport { FgoV1_1Service } from '@core/services/verification/fgo-v1-1.service';\nimport { InsuranceService } from '@core/services/bookings/insurance.service';\nimport { MetaService } from '@core/services/ui/meta.service';\nimport { PaymentsService } from '@core/services/payments/payments.service';\nimport { ReviewsService } from '@core/services/cars/reviews.service';\nimport { LoggerService } from '@core/services/infrastructure/logger.service';\nimport { TrafficInfractionsService } from '@core/services/infrastructure/traffic-infractions.service'; // NEW\n"}},{"ruleId":"import/order","severity":1,"message":"`@core/services/bookings/booking-ops.service` import should occur before import of `../../../core/models`","line":43,"column":1,"nodeType":"ImportDeclaration","endLine":50,"endColumn":54,"fix":{"range":[375,3857],"text":"import {\n  BookingCancellationRow,\n  BookingConfirmationRow,\n  BookingInsuranceRow,\n  BookingOpsService,\n  BookingPaymentRow,\n  BookingPricingRow,\n} from '@core/services/bookings/booking-ops.service';\nimport { Booking, BookingExtensionRequest } from '../../../core/models';\nimport { TrafficInfraction } from '../../admin/traffic-infractions/admin-traffic-infractions.page'; // NEW\nimport { BookingInspection } from '../../../core/models/fgo-v1-1.model';\nimport { CLAIM_STATUS_LABELS, InsuranceClaim } from '../../../core/models/insurance.model';\nimport { AuthService } from '@core/services/auth/auth.service';\nimport {\n  BookingConfirmationService,\n  ConfirmAndReleaseResponse,\n} from '@core/services/bookings/booking-confirmation.service';\nimport { BookingsService } from '@core/services/bookings/bookings.service';\nimport { ExchangeRateService } from '@core/services/payments/exchange-rate.service';\nimport { FgoV1_1Service } from '@core/services/verification/fgo-v1-1.service';\nimport { InsuranceService } from '@core/services/bookings/insurance.service';\nimport { MetaService } from '@core/services/ui/meta.service';\nimport { PaymentsService } from '@core/services/payments/payments.service';\nimport { ReviewsService } from '@core/services/cars/reviews.service';\nimport { LoggerService } from '@core/services/infrastructure/logger.service';\nimport { TrafficInfractionsService } from '@core/services/infrastructure/traffic-infractions.service'; // NEW\nimport { BookingFlowService, NextStep } from '@core/services/bookings/booking-flow.service';\nimport { BookingChatComponent } from '../../../shared/components/booking-chat/booking-chat.component';\nimport { BookingConfirmationTimelineComponent } from '../../../shared/components/booking-confirmation-timeline/booking-confirmation-timeline.component';\nimport { BookingContractComponent } from '../../../shared/components/booking-contract/booking-contract.component';\nimport { DepositStatusBadgeComponent } from '../../../shared/components/deposit-status-badge/deposit-status-badge.component';\nimport { DisputeFormComponent } from '../../../shared/components/dispute-form/dispute-form.component';\nimport { DisputesListComponent } from '../../../shared/components/disputes-list/disputes-list.component';\nimport { OwnerConfirmationComponent } from '../../../shared/components/owner-confirmation/owner-confirmation.component';\nimport { RefundRequestComponent } from '../../../shared/components/refund-request/refund-request.component';\nimport { RefundStatusComponent } from '../../../shared/components/refund-status/refund-status.component';\nimport { RenterConfirmationComponent } from '../../../shared/components/renter-confirmation/renter-confirmation.component';\nimport { BookingOpsTimelineComponent } from '../../../shared/components/booking-ops-timeline/booking-ops-timeline.component';\nimport { BookingTrackingComponent } from '../../../shared/components/booking-tracking/booking-tracking.component';\nimport { BookingPricingBreakdownComponent } from '../../../shared/components/booking-pricing-breakdown/booking-pricing-breakdown.component';\nimport { BookingInsuranceSummaryComponent } from '../../../shared/components/booking-insurance-summary/booking-insurance-summary.component';\nimport { SettlementSimulatorComponent } from '../../../shared/components/settlement-simulator/settlement-simulator.component';\nimport { DamageComparisonComponent } from '../../../shared/components/damage-comparison/damage-comparison.component';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":13,"fixableErrorCount":0,"fixableWarningCount":13,"source":"import { CommonModule } from '@angular/common';\nimport {Component, OnDestroy, OnInit, computed, inject, signal,\n  ChangeDetectionStrategy} from '@angular/core';\nimport { ActivatedRoute, Router, RouterLink } from '@angular/router';\nimport { AlertController } from '@ionic/angular';\nimport { TranslateModule } from '@ngx-translate/core';\nimport { firstValueFrom } from 'rxjs';\nimport { Booking, BookingExtensionRequest } from '../../../core/models';\nimport { TrafficInfraction } from '../../admin/traffic-infractions/admin-traffic-infractions.page'; // NEW\nimport { BookingInspection } from '../../../core/models/fgo-v1-1.model';\nimport { CLAIM_STATUS_LABELS, InsuranceClaim } from '../../../core/models/insurance.model';\nimport { AuthService } from '@core/services/auth/auth.service';\nimport {\n  BookingConfirmationService,\n  ConfirmAndReleaseResponse,\n} from '@core/services/bookings/booking-confirmation.service';\nimport { BookingsService } from '@core/services/bookings/bookings.service';\nimport { ExchangeRateService } from '@core/services/payments/exchange-rate.service';\nimport { FgoV1_1Service } from '@core/services/verification/fgo-v1-1.service';\nimport { InsuranceService } from '@core/services/bookings/insurance.service';\nimport { MetaService } from '@core/services/ui/meta.service';\nimport { PaymentsService } from '@core/services/payments/payments.service';\nimport { ReviewsService } from '@core/services/cars/reviews.service';\nimport { LoggerService } from '@core/services/infrastructure/logger.service';\nimport { TrafficInfractionsService } from '@core/services/infrastructure/traffic-infractions.service'; // NEW\nimport { BookingFlowService, NextStep } from '@core/services/bookings/booking-flow.service';\nimport { BookingChatComponent } from '../../../shared/components/booking-chat/booking-chat.component';\nimport { BookingConfirmationTimelineComponent } from '../../../shared/components/booking-confirmation-timeline/booking-confirmation-timeline.component';\nimport { BookingContractComponent } from '../../../shared/components/booking-contract/booking-contract.component';\nimport { DepositStatusBadgeComponent } from '../../../shared/components/deposit-status-badge/deposit-status-badge.component';\nimport { DisputeFormComponent } from '../../../shared/components/dispute-form/dispute-form.component';\nimport { DisputesListComponent } from '../../../shared/components/disputes-list/disputes-list.component';\nimport { OwnerConfirmationComponent } from '../../../shared/components/owner-confirmation/owner-confirmation.component';\nimport { RefundRequestComponent } from '../../../shared/components/refund-request/refund-request.component';\nimport { RefundStatusComponent } from '../../../shared/components/refund-status/refund-status.component';\nimport { RenterConfirmationComponent } from '../../../shared/components/renter-confirmation/renter-confirmation.component';\nimport { BookingOpsTimelineComponent } from '../../../shared/components/booking-ops-timeline/booking-ops-timeline.component';\nimport { BookingTrackingComponent } from '../../../shared/components/booking-tracking/booking-tracking.component';\nimport { BookingPricingBreakdownComponent } from '../../../shared/components/booking-pricing-breakdown/booking-pricing-breakdown.component';\nimport { BookingInsuranceSummaryComponent } from '../../../shared/components/booking-insurance-summary/booking-insurance-summary.component';\nimport { SettlementSimulatorComponent } from '../../../shared/components/settlement-simulator/settlement-simulator.component';\nimport { DamageComparisonComponent } from '../../../shared/components/damage-comparison/damage-comparison.component';\nimport {\n  BookingCancellationRow,\n  BookingConfirmationRow,\n  BookingInsuranceRow,\n  BookingOpsService,\n  BookingPaymentRow,\n  BookingPricingRow,\n} from '@core/services/bookings/booking-ops.service';\nimport { ReportTrafficFineComponent } from '../../../shared/components/report-traffic-fine/report-traffic-fine.component'; // NEW\nimport { ReportOwnerNoShowComponent } from '../../../shared/components/report-owner-no-show/report-owner-no-show.component'; // NEW\nimport { ReportRenterNoShowComponent } from '../../../shared/components/report-renter-no-show/report-renter-no-show.component'; // NEW\nimport { AiLegalPanelComponent } from '../../../shared/components/ai-legal-panel/ai-legal-panel.component';\nimport { AiTripPanelComponent } from '../../../shared/components/ai-trip-panel/ai-trip-panel.component';\nimport { AiChecklistPanelComponent } from '../../../shared/components/ai-checklist-panel/ai-checklist-panel.component';\nimport { ErrorStateComponent } from '../../../shared/components/error-state/error-state.component';\nimport { BookingStatusComponent } from './booking-status.component';\nimport { ReviewManagementComponent } from './review-management.component';\n\ninterface ReturnChecklistItem {\n  id: string;\n  label: string;\n  checked: boolean;\n}\n\n/**\n * BookingDetailPage\n *\n * This component acts as a container for the booking detail view. It is responsible for:\n * - Fetching the booking data from the server.\n * - Passing the booking data to child components that handle specific aspects of the view.\n * - Handling general page-level concerns like loading and error states.\n *\n * The component has been refactored to delegate responsibilities to smaller, more focused child components:\n * - app-booking-status: Displays the current status of the booking.\n * - app-review-management: Manages the creation and display of reviews.\n */\n@Component({\n  selector: 'app-booking-detail',\n  standalone: true,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  imports: [\n    CommonModule,\n    RouterLink,\n    OwnerConfirmationComponent,\n    RenterConfirmationComponent,\n    BookingChatComponent,\n    TranslateModule,\n    BookingStatusComponent,\n    ReviewManagementComponent,\n    DepositStatusBadgeComponent,\n    DisputeFormComponent,\n    DisputesListComponent,\n    RefundRequestComponent,\n    BookingContractComponent,\n    RefundStatusComponent,\n    BookingConfirmationTimelineComponent,\n    BookingOpsTimelineComponent,\n    BookingTrackingComponent,\n    BookingPricingBreakdownComponent,\n    BookingInsuranceSummaryComponent,\n    SettlementSimulatorComponent,\n    DamageComparisonComponent,\n    ReportTrafficFineComponent, // NEW\n    ReportOwnerNoShowComponent, // NEW\n    ReportRenterNoShowComponent, // NEW\n    AiLegalPanelComponent,\n    AiTripPanelComponent,\n    AiChecklistPanelComponent,\n    ErrorStateComponent,\n  ],\n  templateUrl: './booking-detail.page.html',\n  styleUrl: './booking-detail.page.css',\n})\nexport class BookingDetailPage implements OnInit, OnDestroy {\n  private readonly route = inject(ActivatedRoute);\n  private readonly router = inject(Router);\n  private readonly bookingsService = inject(BookingsService);\n  private readonly paymentsService = inject(PaymentsService);\n  private readonly reviewsService = inject(ReviewsService);\n  private readonly bookingFlowService = inject(BookingFlowService);\n  private readonly authService = inject(AuthService);\n  private readonly confirmationService = inject(BookingConfirmationService);\n  private readonly alertController = inject(AlertController); // NEW\n  private readonly metaService = inject(MetaService);\n  private readonly exchangeRateService = inject(ExchangeRateService);\n  private readonly fgoService = inject(FgoV1_1Service);\n  private readonly insuranceService = inject(InsuranceService);\n  private readonly bookingOpsService = inject(BookingOpsService);\n  private readonly trafficInfractionsService = inject(TrafficInfractionsService); // NEW\n  private readonly logger = inject(LoggerService).createChildLogger('BookingDetailPage');\n\n  booking = signal<Booking | null>(null);\n  loading = signal(true);\n  error = signal<string | null>(null);\n  timeRemaining = signal<string | null>(null);\n  nextStep = signal<NextStep | null>(null);\n  nextStepLoading = signal(false);\n  deliveryTimeRemaining = signal<string | null>(null);\n  returnChecklistItems = signal<ReturnChecklistItem[]>([]);\n  private readonly isBrowser = typeof window !== 'undefined';\n  private readonly returnChecklistStoragePrefix = 'autorenta:return-checklist:';\n  private returnChecklistSaveTimeout: number | null = null;\n\n  readonly bookingFlowSteps = [\n    {\n      key: 'pending',\n      label: 'Solicitud enviada',\n      description: 'Solicitud creada correctamente.',\n    },\n    {\n      key: 'pending_payment',\n      label: 'Garantía bloqueada',\n      description: 'Fondos reservados en tu wallet.',\n    },\n    {\n      key: 'awaiting_approval',\n      label: 'Esperando aprobación',\n      description: 'El propietario está revisando tu solicitud.',\n    },\n    {\n      key: 'confirmed',\n      label: 'Aprobada por locador',\n      description: 'Reserva aprobada. Coordiná el check-in y la entrega.',\n    },\n    {\n      key: 'renter_checkin',\n      label: 'Recepción y documentación',\n      description: 'Confirmá la recepción, sacá fotos y registrá el estado del auto.',\n    },\n    {\n      key: 'in_progress',\n      label: 'Check-in y uso',\n      description: 'Check-in completado. Disfrutá del viaje y cuidá el vehículo.',\n    },\n    {\n      key: 'pending_review',\n      label: 'Revisión final',\n      description: 'Check-out realizado. Período de 24h para reportar incidentes.',\n    },\n    {\n      key: 'completed',\n      label: 'Cierre',\n      description: 'Reserva finalizada y fondos liberados.',\n    },\n  ] as const;\n\n  readonly effectiveStatus = computed(() => {\n    const booking = this.booking();\n    if (!booking) return null;\n\n    if (this.hasCheckOut()) return 'pending_review';\n    if (this.hasRenterCheckIn()) return 'in_progress';\n    if (this.hasOwnerCheckIn()) return 'renter_checkin';\n\n    return booking.status;\n  });\n\n  /**\n   * Determines the current step index in the booking flow.\n   * For P2P (wallet) bookings: pending status means steps 1-2 are done, waiting at step 3.\n   * For traditional bookings: pending status means at step 1, waiting for payment.\n   */\n  readonly currentBookingStageIndex = computed(() => {\n    const booking = this.booking();\n    const status = this.effectiveStatus();\n    if (!booking || !status) return 0;\n\n    // If return flow started (returned_at or pending confirmations), show review step\n    if (\n      booking.returned_at ||\n      booking.completion_status === 'returned' ||\n      booking.completion_status === 'pending_owner' ||\n      booking.completion_status === 'pending_renter' ||\n      booking.completion_status === 'pending_both'\n    ) {\n      return 6; // Step 7: Revisión final\n    }\n\n    // If marked in_progress but start date is in the future, treat as confirmed for UI\n    if (status === 'in_progress' && booking.start_at) {\n      const startAt = new Date(booking.start_at).getTime();\n      if (!Number.isNaN(startAt) && Date.now() < startAt) {\n        return 3; // Step 4: Aprobada por locador / Reserva confirmada\n      }\n    }\n\n    // P2P wallet flow: pending + wallet = already paid, waiting for owner approval\n    if (status === 'pending' && booking.payment_mode === 'wallet') {\n      return 2; // Step 3: \"Esperando aprobación\" (0-indexed = 2)\n    }\n\n    if (status === 'renter_checkin') {\n      return 4; // Step 5: Recepción y documentación\n    }\n\n    // Traditional flow or other statuses\n    const statusMap: Record<string, number> = {\n      'pending': 0,           // Step 1: Solicitud enviada\n      'pending_payment': 1,   // Step 2: Garantía bloqueada\n      'confirmed': 3,         // Step 4: Reserva confirmada\n      'in_progress': 5,       // Step 6: Check-in y uso (después de documentación)\n      'pending_review': 6,    // Step 7: Revisión final\n      'completed': 7,         // Step 8: Cierre\n      'disputed': 6,          // Map to pending_review\n    };\n\n    const idx = statusMap[status];\n    if (idx !== undefined) return idx;\n\n    if (status === 'cancelled' || status === 'expired') {\n      return 0; // Cancelled bookings show at start\n    }\n\n    // Default fallback\n    return this.bookingFlowSteps.length - 1;\n  });\n\n  // Exchange rate signals\n  exchangeRate = signal<number | null>(null);\n  totalInARS = signal<number | null>(null);\n  loadingRate = signal(false);\n\n  // FGO signals\n  inspections = signal<BookingInspection[]>([]);\n\n  // Claims signals\n  bookingClaims = signal<InsuranceClaim[]>([]);\n  loadingClaims = signal(false);\n\n  // Pricing / insurance / payment / tracking\n  pricing = signal<BookingPricingRow | null>(null);\n  insurance = signal<BookingInsuranceRow | null>(null);\n  payment = signal<BookingPaymentRow | null>(null);\n  tracking = signal<{\n    sessionId: string;\n    active: boolean;\n    started_at: string;\n    ended_at?: string | null;\n    points: number;\n  } | null>(null);\n  confirmation = signal<BookingConfirmationRow | null>(null);\n  cancellation = signal<BookingCancellationRow | null>(null);\n\n  readonly pricingView = computed(() => {\n    const pricing = this.pricing();\n    const booking = this.booking();\n    if (!pricing) return null;\n\n    return {\n      nightlyRate: (pricing.nightly_rate_cents ?? 0) / 100,\n      nights: pricing.days_count ?? booking?.days_count ?? 1,\n      fees: (pricing.fees_cents ?? 0) / 100,\n      discounts: (pricing.discounts_cents ?? 0) / 100,\n      insurance: (pricing.insurance_cents ?? 0) / 100,\n      total: (pricing.total_cents ?? pricing.subtotal_cents ?? 0) / 100,\n      currency: 'ARS' as const,\n    };\n  });\n\n  readonly insuranceView = computed(() => {\n    const insurance = this.insurance();\n    if (!insurance) return null;\n\n    return {\n      coverageName: insurance.coverage_upgrade || 'Estándar',\n      premium: insurance.insurance_premium_total ? insurance.insurance_premium_total / 100 : 0,\n      guaranteeType: insurance.guarantee_type || 'hold',\n      guaranteeAmount: insurance.guarantee_amount_cents\n        ? insurance.guarantee_amount_cents / 100\n        : undefined,\n      currency: 'ARS' as const,\n      notes: null,\n    };\n  });\n\n  readonly paymentView = computed(() => {\n    const payment = this.payment();\n    if (!payment) return null;\n\n    const status = payment.wallet_status || payment.deposit_status || 'pendiente';\n    const method = payment.payment_method || payment.payment_mode || 'sin método';\n    const date = payment.paid_at || payment.wallet_charged_at || null;\n\n    return { status, method, date };\n  });\n\n  /**\n   * P2P wallet booking pending owner approval\n   * When true: show \"waiting for approval\" UI instead of \"pay now\" UI\n   */\n  readonly isPendingOwnerApproval = computed(() => {\n    const booking = this.booking();\n    if (!booking) return false;\n    return booking.status === 'pending' && booking.payment_mode === 'wallet';\n  });\n\n  /**\n   * Traditional flow: booking needs payment\n   * When true: show \"Garantizar Reserva\" button\n   */\n  readonly needsPayment = computed(() => {\n    const booking = this.booking();\n    if (!booking) return false;\n    return booking.status === 'pending' && booking.payment_mode !== 'wallet';\n  });\n\n  private countdownInterval: number | null = null;\n  private deliveryCountdownInterval: number | null = null;\n\n  // Computed properties\n  isExpired = computed(() => {\n    const booking = this.booking();\n    return booking ? this.bookingsService.isExpired(booking) : false;\n  });\n\n  showConfirmedActions = computed(() => this.booking()?.status === 'confirmed');\n\n  // Confirmations - show if booking is in \"returned\" status\n  showConfirmationSection = computed(() => {\n    const booking = this.booking();\n    return (\n      booking?.completion_status === 'returned' ||\n      booking?.completion_status === 'pending_owner' ||\n      booking?.completion_status === 'pending_renter' ||\n      booking?.completion_status === 'pending_both' ||\n      booking?.completion_status === 'funds_released'\n    );\n  });\n\n  isOwner = computed(() => {\n    const booking = this.booking();\n    const currentUser = this.authService.session$()?.user;\n    if (!booking || !currentUser) return false;\n\n    // Need to check car owner_id - will load from car data\n    return this.carOwnerId() === currentUser.id;\n  });\n\n  isRenter = computed(() => {\n    const booking = this.booking();\n    const currentUser = this.authService.session$()?.user;\n    return booking?.renter_id === currentUser?.id;\n  });\n\n  readonly backLink = computed(() => (this.isOwner() ? '/bookings/owner' : '/bookings'));\n  readonly backLabel = computed(() =>\n    this.isOwner() ? 'Volver a reservas de propietarios' : 'Volver a mis reservas',\n  );\n\n  // Car owner ID and name (loaded separately)\n  carOwnerId = signal<string | null>(null);\n  carOwnerName = signal<string>('el anfitrión');\n\n  // 🆕 FGO v1.1: Computed properties para inspecciones\n  readonly canUploadInspection = computed(() => {\n    const booking = this.booking();\n    return booking?.status === 'in_progress' || booking?.status === 'completed';\n  });\n\n  readonly hasOwnerCheckIn = computed(() => {\n    return this.inspections().some((i: BookingInspection) => i.stage === 'check_in' && i.signedAt);\n  });\n\n  readonly hasRenterCheckIn = computed(() => {\n    return this.inspections().some(\n      (i: BookingInspection) => i.stage === 'renter_check_in' && i.signedAt,\n    );\n  });\n\n  readonly hasCheckOut = computed(() => {\n    return this.inspections().some((i: BookingInspection) => i.stage === 'check_out' && i.signedAt);\n  });\n\n  readonly hasClaim = computed(() => {\n    return this.bookingClaims().length > 0;\n  });\n\n  readonly canReportClaim = computed(() => {\n    const booking = this.booking();\n    if (!booking || !this.isRenter()) return false;\n    // Can report claim during in_progress or completed status\n    const validStatus = booking.status === 'in_progress' || booking.status === 'completed';\n    // Only allow if no claim already exists for this booking\n    return validStatus && !this.hasClaim();\n  });\n\n  readonly latestClaim = computed(() => {\n    const claims = this.bookingClaims();\n    return claims.length > 0 ? claims[0] : null;\n  });\n\n  // Disputes and refunds\n  showDisputeForm = signal(false);\n  showRefundForm = signal(false);\n  showReportTrafficFineModal = signal(false); // NEW\n  showReportOwnerNoShowModal = signal(false); // NEW\n\n  // NEW: Extension Requests\n  pendingExtensionRequests = signal<BookingExtensionRequest[]>([]);\n  loadingExtensionRequests = signal(false);\n\n  readonly canCreateDispute = computed(() => {\n    const booking = this.booking();\n    if (!booking) return false;\n    // Can create dispute for active or completed bookings\n    return booking.status === 'in_progress' || booking.status === 'completed';\n  });\n\n  readonly hasPendingExtensionRequest = computed(() => {\n    return this.pendingExtensionRequests().length > 0;\n  });\n\n  readonly canReportTrafficFine = computed(() => {\n    const booking = this.booking();\n    if (!booking || !this.isOwner()) return false;\n    // Owner can report a fine if the booking is completed or in_progress\n    return booking.status === 'completed' || booking.status === 'in_progress';\n  });\n\n  // NEW: Traffic Fines\n  trafficFines = signal<TrafficInfraction[]>([]);\n  loadingTrafficFines = signal(false);\n\n  readonly hasTrafficFines = computed(() => {\n    return this.trafficFines().length > 0;\n  });\n\n  readonly canReportOwnerNoShow = computed(() => {\n    const booking = this.booking();\n    if (!booking || !this.isRenter()) return false;\n    // Renter can report owner no-show if booking is confirmed and pickup date is in the past\n    const pickupDate = new Date(booking.start_at);\n    const now = new Date();\n    return booking.status === 'confirmed' && now > pickupDate;\n  });\n\n  readonly showReportRenterNoShowModal = signal(false); // NEW\n  readonly canReportRenterNoShow = computed(() => {\n    const booking = this.booking();\n    if (!booking || !this.isOwner()) return false;\n    // Owner can report renter no-show if booking is confirmed and pickup date is in the past\n    const pickupDate = new Date(booking.start_at);\n    const now = new Date();\n    return booking.status === 'confirmed' && now > pickupDate;\n  });\n\n  readonly canRequestRefund = computed(() => {\n    const booking = this.booking();\n    if (!booking) return false;\n    // Can request refund for completed or cancelled bookings\n    return booking.status === 'completed' || booking.status === 'cancelled';\n  });\n\n  // ============================================\n  // AI ASSISTANT PANELS\n  // ============================================\n  readonly expandedAiPanel = signal<'legal' | 'trip' | 'checklist' | null>(null);\n\n  /** Toggle AI panel accordion */\n  toggleAiPanel(panel: 'legal' | 'trip' | 'checklist'): void {\n    this.expandedAiPanel.update(current => current === panel ? null : panel);\n  }\n\n  /** Show trip planner only for confirmed/in_progress bookings */\n  readonly showTripPlanner = computed(() => {\n    const booking = this.booking();\n    return booking?.status === 'confirmed' || booking?.status === 'in_progress';\n  });\n\n  /** Show checklist panel for check-in/check-out eligibility */\n  readonly showChecklistPanel = computed(() => {\n    const booking = this.booking();\n    if (!booking) return false;\n    // Show checklist during confirmed, in_progress, or pending_review\n    return (\n      booking.status === 'confirmed' ||\n      booking.status === 'in_progress' ||\n      booking.status === 'pending_review'\n    );\n  });\n\n  /** Determine checklist inspection type based on booking state */\n  readonly checklistInspectionType = computed<'check_in' | 'check_out'>(() => {\n    // If already has check-in done, show check-out\n    if (this.hasRenterCheckIn()) return 'check_out';\n    return 'check_in';\n  });\n\n  readonly returnChecklistProgress = computed(() => {\n    const items = this.returnChecklistItems();\n    if (items.length === 0) return { completed: 0, total: 0 };\n    const completed = items.filter((i) => i.checked).length;\n    return { completed, total: items.length };\n  });\n\n  readonly carReturnConsiderations = computed(() => {\n    const booking = this.booking();\n    const car = booking?.car;\n    if (!booking || !car) return [];\n\n    const items: string[] = [];\n\n    if (car.fuel_policy === 'full_to_full') {\n      items.push('Combustible: devolvé el auto con tanque lleno.');\n    } else if (car.fuel_policy === 'same_to_same') {\n      items.push('Combustible: devolvé el auto con el mismo nivel.');\n    }\n\n    if (car.mileage_limit !== null && car.mileage_limit !== undefined) {\n      if (car.mileage_limit === 0) {\n        items.push('Kilometraje: ilimitado.');\n      } else {\n        items.push(`Kilometraje máximo incluido: ${car.mileage_limit} km.`);\n      }\n    }\n\n    if (car.extra_km_price !== null && car.extra_km_price !== undefined) {\n      items.push(`Exceso de km: ${car.extra_km_price} por km adicional.`);\n    }\n\n    if (car.allow_smoking === false) {\n      items.push('No se permite fumar dentro del vehículo.');\n    }\n\n    if (car.allow_pets === false) {\n      items.push('No se permiten mascotas en el vehículo.');\n    }\n\n    if (car.allow_rideshare === false) {\n      items.push('No se permite uso para rideshare.');\n    }\n\n    if (car.max_distance_km !== null && car.max_distance_km !== undefined) {\n      items.push(`Distancia máxima recomendada: ${car.max_distance_km} km.`);\n    }\n\n    if (booking.delivery_required) {\n      items.push('Coordiná la devolución en el punto de entrega acordado.');\n    }\n\n    if (items.length === 0) {\n      items.push('Respetá el estado del vehículo y devolvelo limpio y en horario.');\n    }\n\n    return items;\n  });\n\n  onDisputeCreated(): void {\n    // Reload disputes if needed\n    this.showDisputeForm.set(false);\n  }\n\n  onRefundRequested(): void {\n    // Reload booking to get updated refund status\n    const bookingId = this.booking()?.id;\n    if (bookingId) {\n      this.bookingsService.getBookingById(bookingId).then((updated) => {\n        if (updated) {\n          this.booking.set(updated);\n        }\n      });\n    }\n    this.showRefundForm.set(false);\n  }\n\n  // Computed properties para acciones de check-in/check-out\n  readonly canPerformCheckIn = computed(() => {\n    const booking = this.booking();\n    const status = this.effectiveStatus();\n    if (!booking || !this.isRenter() || !status) return false;\n    const validStatus = status === 'confirmed' || status === 'in_progress' || status === 'renter_checkin';\n    return validStatus && this.hasOwnerCheckIn() && !this.hasRenterCheckIn();\n  });\n\n  readonly canPerformCheckOut = computed(() => {\n    const booking = this.booking();\n    const status = this.effectiveStatus();\n    if (!booking || !this.isRenter() || !status) return false;\n    const validStatus = status === 'in_progress' || status === 'pending_review';\n    return validStatus && this.hasRenterCheckIn() && !this.hasCheckOut();\n  });\n\n  readonly canReportDamage = computed(() => {\n    const booking = this.booking();\n    if (!booking || !this.isOwner()) return false;\n    // Owner can report damage after vehicle return (completed status or returned_at is set)\n    const canReport =\n      (booking.status === 'completed' || booking.returned_at !== null) &&\n      !booking.owner_reported_damages;\n    return canReport;\n  });\n\n  readonly canExtendBooking = computed(() => {\n    const booking = this.booking();\n    return this.isRenter() && booking?.status === 'in_progress';\n  });\n\n  async extendBooking(): Promise<void> {\n    const booking = this.booking();\n    if (!booking) return;\n\n    // Simple prompt-based extension request\n    const daysStr = prompt('¿Cuántos días adicionales necesitas?', '1');\n    if (!daysStr) return;\n\n    const days = parseInt(daysStr, 10);\n    if (isNaN(days) || days < 1) {\n      alert('Por favor ingresa un número válido de días.');\n      return;\n    }\n\n    const currentEndDate = new Date(booking.end_at);\n    const newEndDate = new Date(currentEndDate);\n    newEndDate.setDate(newEndDate.getDate() + days);\n\n    if (!confirm(`¿Confirmas solicitar extender la reserva hasta el ${newEndDate.toLocaleDateString()}? El anfitrión deberá aprobarla.`)) {\n      return;\n    }\n\n    this.loading.set(true);\n    try {\n      const result = await this.bookingsService.requestExtension(booking.id, newEndDate);\n      if (result.success) {\n        alert(`Solicitud de extensión enviada exitosamente por un costo estimado de ${result.additionalCost}. Esperando aprobación del anfitrión.`);\n        // Reload booking to show pending extension status\n        const updated = await this.bookingsService.getBookingById(booking.id);\n        this.booking.set(updated);\n        await this.loadPendingExtensionRequests(booking.id);\n      } else {\n        alert('Error al solicitar extensión: ' + result.error);\n      }\n    } catch (error) {\n      console.error('Error requesting booking extension:', error);\n      alert('Ocurrió un error inesperado al solicitar la extensión.');\n    } finally {\n      this.loading.set(false);\n    }\n  }\n\n  async approveExtension(requestId: string): Promise<void> {\n    const confirmApproval = confirm('¿Confirmas que quieres aprobar esta solicitud de extensión?');\n    if (!confirmApproval) return;\n\n    this.loading.set(true);\n    try {\n      const result = await this.bookingsService.approveExtensionRequest(requestId);\n      if (result.success) {\n        alert('Solicitud de extensión aprobada y reserva actualizada.');\n        // Reload booking and requests to reflect changes\n        const updated = await this.bookingsService.getBookingById(this.booking()!.id);\n        this.booking.set(updated);\n        await this.loadPendingExtensionRequests(this.booking()!.id);\n      } else {\n        alert('Error al aprobar extensión: ' + result.error);\n      }\n    } catch (error) {\n      console.error('Error approving extension request:', error);\n      alert('Ocurrió un error inesperado al aprobar la extensión.');\n    } finally {\n      this.loading.set(false);\n    }\n  }\n\n  async rejectExtension(requestId: string): Promise<void> {\n    const reason = prompt('¿Por qué rechazas esta solicitud de extensión? (Opcional)');\n\n    const confirmRejection = confirm('¿Confirmas que quieres rechazar esta solicitud de extensión?');\n    if (!confirmRejection) return;\n\n    this.loading.set(true);\n    try {\n      const result = await this.bookingsService.rejectExtensionRequest(requestId, reason || '');\n      if (result.success) {\n        alert('Solicitud de extensión rechazada.');\n        // Reload requests to reflect changes\n        await this.loadPendingExtensionRequests(this.booking()!.id);\n      } else {\n        alert('Error al rechazar extensión: ' + result.error);\n      }\n    } catch (error) {\n      console.error('Error rejecting extension request:', error);\n      alert('Ocurrió un error inesperado al rechazar la extensión.');\n    } finally {\n      this.loading.set(false);\n    }\n  }\n\n  onTrafficFineReported(fine: TrafficInfraction): void {\n    this.logger.debug('Traffic fine reported:', fine);\n    this.showReportTrafficFineModal.set(false);\n    // Reload pending extension requests to ensure the UI is up-to-date.\n    this.loadPendingExtensionRequests(this.booking()!.id);\n  }\n\n  isStepCompleted(index: number): boolean {\n    return index < this.currentBookingStageIndex();\n  }\n\n  isStepCurrent(index: number): boolean {\n    return index === this.currentBookingStageIndex();\n  }\n\n  isStepUpcoming(index: number): boolean {\n    return index > this.currentBookingStageIndex();\n  }\n\n  async ngOnInit() {\n    const bookingId = this.route.snapshot.paramMap.get('id');\n    if (!bookingId) {\n      this.error.set('ID de reserva inválido');\n      this.loading.set(false);\n      return;\n    }\n\n    try {\n      const booking = await this.bookingsService.getBookingById(bookingId);\n      if (!booking) {\n        this.error.set('Reserva no encontrada');\n        this.loading.set(false);\n        return;\n      }\n\n      this.booking.set(booking);\n      await this.loadNextStep(booking);\n      this.startCountdown();\n      this.loadReturnChecklist(booking);\n\n      // Load pending extension requests\n      await this.loadPendingExtensionRequests(booking.id);\n      // Load traffic fines\n      await this.loadTrafficFines(booking.id); // NEW\n\n      // Update SEO meta tags (private page - noindex)\n      this.metaService.updateBookingDetailMeta(booking.id);\n\n      // Load exchange rate for ARS conversion\n      await this.loadExchangeRate();\n\n      // Load car owner ID for confirmation logic\n      await this.loadCarOwner();\n\n      // Load FGO inspections\n      await this.loadInspections();\n\n      // Load claims for this booking\n      await this.loadClaims();\n\n      // Load pricing / insurance / tracking (best-effort)\n      void this.loadPricing(booking.id);\n      void this.loadInsurance(booking.id);\n      void this.loadPayment(booking.id);\n      void this.loadTracking(booking.id);\n      void this.loadConfirmation(booking.id);\n      void this.loadCancellation(booking.id);\n    } catch {\n      this.error.set('Error al cargar la reserva');\n    } finally {\n      this.loading.set(false);\n    }\n  }\n\n  private async loadNextStep(booking: Booking): Promise<void> {\n    try {\n      this.nextStepLoading.set(true);\n      const role: 'owner' | 'renter' = this.isOwner() ? 'owner' : 'renter';\n      const step = await this.bookingFlowService.getNextStep(booking, role);\n      this.nextStep.set(step);\n    } catch {\n      this.nextStep.set(null);\n    } finally {\n      this.nextStepLoading.set(false);\n    }\n  }\n\n  async goToNextStep(): Promise<void> {\n    const booking = this.booking();\n    const next = this.nextStep();\n    if (!booking || !next) return;\n    await this.router.navigateByUrl(next.route);\n  }\n\n  toggleReturnChecklistItem(itemId: string): void {\n    const booking = this.booking();\n    if (!booking) return;\n\n    this.returnChecklistItems.update((items) =>\n      items.map((item) =>\n        item.id === itemId ? { ...item, checked: !item.checked } : item,\n      ),\n    );\n    this.persistReturnChecklist(booking.id);\n    this.scheduleReturnChecklistSave(booking.id);\n  }\n\n  private loadReturnChecklist(booking: Booking): void {\n    const bookingId = booking.id;\n    if (!this.isBrowser) {\n      this.returnChecklistItems.set(this.mergeChecklistFromMetadata(booking));\n      return;\n    }\n\n    const key = `${this.returnChecklistStoragePrefix}${bookingId}`;\n    const stored = window.localStorage.getItem(key);\n    const base = this.mergeChecklistFromMetadata(booking);\n\n    if (!stored) {\n      this.returnChecklistItems.set(base);\n      return;\n    }\n\n    try {\n      const parsed = JSON.parse(stored) as ReturnChecklistItem[];\n      const merged = base.map((item) => {\n        const storedItem = parsed.find((p) => p.id === item.id);\n        return storedItem ? { ...item, checked: !!storedItem.checked } : item;\n      });\n      this.returnChecklistItems.set(merged);\n    } catch {\n      this.returnChecklistItems.set(base);\n    }\n  }\n\n  private persistReturnChecklist(bookingId: string): void {\n    if (!this.isBrowser) return;\n    const key = `${this.returnChecklistStoragePrefix}${bookingId}`;\n    window.localStorage.setItem(key, JSON.stringify(this.returnChecklistItems()));\n  }\n\n  private mergeChecklistFromMetadata(booking: Booking): ReturnChecklistItem[] {\n    const base = this.buildReturnChecklist();\n    const raw = booking.metadata?.['return_checklist'];\n    if (!Array.isArray(raw)) return base;\n\n    return base.map((item) => {\n      const storedItem = raw.find((p: ReturnChecklistItem) => p?.id === item.id);\n      return storedItem ? { ...item, checked: !!storedItem.checked } : item;\n    });\n  }\n\n  private scheduleReturnChecklistSave(bookingId: string): void {\n    if (this.returnChecklistSaveTimeout !== null) {\n      clearTimeout(this.returnChecklistSaveTimeout);\n    }\n\n    this.returnChecklistSaveTimeout = window.setTimeout(async () => {\n      const booking = this.booking();\n      if (!booking) return;\n\n      const currentMetadata = booking.metadata ?? {};\n      const nextMetadata = {\n        ...currentMetadata,\n        return_checklist: this.returnChecklistItems(),\n      };\n\n      try {\n        const updated = await this.bookingsService.updateBooking(bookingId, {\n          metadata: nextMetadata,\n        });\n        if (updated) {\n          this.booking.set(updated);\n        }\n      } catch (error) {\n        this.logger.warn('No se pudo sincronizar el checklist de devolución', error);\n      }\n    }, 500);\n  }\n\n  private buildReturnChecklist(): ReturnChecklistItem[] {\n    return [\n      { id: 'final-photos', label: 'Subir fotos finales (exterior, interior, odómetro)', checked: false },\n      { id: 'fuel', label: 'Dejar el combustible según la política del auto', checked: false },\n      { id: 'clean', label: 'Retirar objetos personales y basura', checked: false },\n      { id: 'accessories', label: 'Devolver llaves y accesorios completos', checked: false },\n      { id: 'location-time', label: 'Confirmar lugar y horario de devolución', checked: false },\n      { id: 'damages', label: 'Reportar incidentes o daños si los hubo', checked: false },\n    ];\n  }\n\n  private async loadExchangeRate(): Promise<void> {\n    const booking = this.booking();\n    if (!booking || !booking.breakdown?.total_cents) return;\n\n    try {\n      this.loadingRate.set(true);\n      const rate = await this.exchangeRateService.getPlatformRate();\n      this.exchangeRate.set(rate);\n\n      // Convert total USD to ARS\n      const totalUSD = booking.breakdown.total_cents / 100; // Convertir centavos a dólares\n      const totalARS = await this.exchangeRateService.convertUsdToArs(totalUSD);\n      this.totalInARS.set(totalARS);\n    } catch {\n      // No fallar si no se puede obtener la tasa, solo no mostrar conversión\n    } finally {\n      this.loadingRate.set(false);\n    }\n  }\n\n  private async loadCarOwner(): Promise<void> {\n    const booking = this.booking();\n    if (!booking) return;\n\n    try {\n      const { data: car } = await this.bookingsService['supabase']\n        .from('cars')\n        .select('owner_id, owner:profiles!cars_owner_id_fkey(id, full_name)')\n        .eq('id', booking.car_id)\n        .single();\n\n      if (car) {\n        this.carOwnerId.set(car.owner_id);\n        const owner = car.owner as { full_name?: string } | undefined;\n        const ownerFullName = owner?.full_name || 'el anfitrión';\n        this.carOwnerName.set(ownerFullName);\n      }\n    } catch {\n      // Silently ignore errors loading owner name\n    }\n  }\n\n  private async loadInspections(): Promise<void> {\n    const booking = this.booking();\n    if (!booking) return;\n\n    try {\n      const inspections = await firstValueFrom(this.fgoService.getInspections(booking.id));\n      this.inspections.set(inspections);\n    } catch {\n      // Non-blocking error, inspections are optional\n    }\n  }\n\n  private async loadClaims(): Promise<void> {\n    const booking = this.booking();\n    if (!booking) return;\n\n    try {\n      this.loadingClaims.set(true);\n      // Get all claims and filter by booking_id\n      const allClaims = await firstValueFrom(this.insuranceService.getMyClaims());\n      const bookingClaims = allClaims.filter((c) => c.booking_id === booking.id);\n      this.bookingClaims.set(bookingClaims);\n    } catch {\n      // Non-blocking error, claims are optional\n    } finally {\n      this.loadingClaims.set(false);\n    }\n  }\n\n  private async loadPricing(bookingId: string): Promise<void> {\n    try {\n      const pricing = await this.bookingOpsService.getPricing(bookingId);\n      this.pricing.set(pricing);\n    } catch (error) {\n      this.logger.warn('booking-pricing-load', error);\n    }\n  }\n\n  private async loadInsurance(bookingId: string): Promise<void> {\n    try {\n      const insurance = await this.bookingOpsService.getInsurance(bookingId);\n      this.insurance.set(insurance);\n    } catch (error) {\n      this.logger.warn('booking-insurance-load', error);\n    }\n  }\n\n  private async loadPayment(bookingId: string): Promise<void> {\n    try {\n      const payment = await this.bookingOpsService.getPayment(bookingId);\n      this.payment.set(payment);\n    } catch (error) {\n      this.logger.warn('booking-payment-load', error);\n    }\n  }\n\n  private async loadTracking(bookingId: string): Promise<void> {\n    try {\n      const session = await this.bookingOpsService.getTrackingSession(bookingId);\n      if (!session) {\n        this.tracking.set(null);\n        return;\n      }\n\n      const points = await this.bookingOpsService.countTrackingPoints(session.id);\n      this.tracking.set({\n        sessionId: session.id,\n        active: session.active,\n        started_at: session.started_at,\n        ended_at: session.ended_at,\n        points,\n      });\n    } catch (error) {\n      this.logger.warn('booking-tracking-load', error);\n    }\n  }\n\n  private async loadConfirmation(bookingId: string): Promise<void> {\n    try {\n      const confirmation = await this.bookingOpsService.getConfirmation(bookingId);\n      this.confirmation.set(confirmation);\n    } catch (error) {\n      this.logger.warn('booking-confirmation-load', error);\n    }\n  }\n\n  private async loadCancellation(bookingId: string): Promise<void> {\n    try {\n      const cancellation = await this.bookingOpsService.getCancellation(bookingId);\n      this.cancellation.set(cancellation);\n    } catch (error) {\n      this.logger.warn('booking-cancellation-load', error);\n    }\n  }\n\n  getClaimStatusLabel(status: InsuranceClaim['status']): string {\n    return CLAIM_STATUS_LABELS[status];\n  }\n\n  getClaimStatusColor(status: InsuranceClaim['status']): string {\n    const colorMap = {\n      reported: 'orange',\n      pending: 'yellow',\n      investigating: 'purple',\n      under_review: 'blue',\n      approved: 'green',\n      rejected: 'red',\n      paid: 'green',\n      closed: 'gray',\n    };\n    return colorMap[status] || 'gray';\n  }\n\n  ngOnDestroy() {\n    this.stopCountdown();\n  }\n\n  private startCountdown() {\n    const booking = this.booking();\n    if (!booking) return;\n\n    this.stopCountdown();\n\n    if (booking.status === 'pending' && booking.expires_at) {\n      this.updateCountdown();\n      // Update every second\n      this.countdownInterval = window.setInterval(() => {\n        this.updateCountdown();\n      }, 1000);\n    }\n\n    if (booking.status === 'in_progress') {\n      this.updateDeliveryCountdown();\n      // Update every 30 seconds\n      this.deliveryCountdownInterval = window.setInterval(() => {\n        this.updateDeliveryCountdown();\n      }, 30000);\n    }\n\n  }\n\n  private stopCountdown() {\n    if (this.countdownInterval !== null) {\n      clearInterval(this.countdownInterval);\n      this.countdownInterval = null;\n    }\n    if (this.deliveryCountdownInterval !== null) {\n      clearInterval(this.deliveryCountdownInterval);\n      this.deliveryCountdownInterval = null;\n    }\n  }\n\n  private updateCountdown() {\n    const booking = this.booking();\n    if (!booking) return;\n\n    const remaining = this.bookingsService.getTimeUntilExpiration(booking);\n    if (remaining === null || remaining === 0) {\n      this.timeRemaining.set(null);\n      this.stopCountdown();\n      return;\n    }\n\n    this.timeRemaining.set(this.bookingsService.formatTimeRemaining(remaining));\n  }\n\n  private updateDeliveryCountdown() {\n    const booking = this.booking();\n    if (!booking || booking.status !== 'in_progress') {\n      this.deliveryTimeRemaining.set(null);\n      return;\n    }\n\n    const startAt = booking.start_at ? new Date(booking.start_at).getTime() : null;\n    if (startAt && !Number.isNaN(startAt) && Date.now() < startAt) {\n      const remainingMs = startAt - Date.now();\n      const totalMinutes = Math.ceil(remainingMs / (1000 * 60));\n      const hours = Math.floor(totalMinutes / 60);\n      const minutes = totalMinutes % 60;\n      const timeLabel = hours > 0 ? `${hours}h ${minutes}m` : `${minutes}m`;\n      this.deliveryTimeRemaining.set(`Comienza en ${timeLabel}`);\n      return;\n    }\n\n    const endAt = booking.end_at ? new Date(booking.end_at).getTime() : null;\n    if (!endAt) {\n      this.deliveryTimeRemaining.set(null);\n      return;\n    }\n\n    const remainingMs = endAt - Date.now();\n    if (remainingMs <= 0) {\n      this.deliveryTimeRemaining.set('Vencido');\n      return;\n    }\n\n    const totalMinutes = Math.ceil(remainingMs / (1000 * 60));\n    const hours = Math.floor(totalMinutes / 60);\n    const minutes = totalMinutes % 60;\n    const timeLabel = hours > 0 ? `${hours}h ${minutes}m` : `${minutes}m`;\n\n    this.deliveryTimeRemaining.set(`Entrega en ${timeLabel}`);\n  }\n\n  formatCurrency(cents: number, currency: string): string {\n    const amount = cents / 100;\n    return new Intl.NumberFormat('es-AR', {\n      style: 'currency',\n      currency: currency,\n      minimumFractionDigits: 0,\n      maximumFractionDigits: 0,\n    }).format(amount);\n  }\n\n  getBookingDetailsText(): string {\n    const booking = this.booking();\n    if (!booking) return 'Mi reserva en Autorentar';\n\n    const carInfo = `${booking.car_brand} ${booking.car_model}`;\n    const dates =\n      booking.start_at && booking.end_at\n        ? `${this.formatDateTime(booking.start_at)} - ${this.formatDateTime(booking.end_at)}`\n        : '';\n\n    return `Reserva: ${carInfo}${dates ? ` (${dates})` : ''}`;\n  }\n\n  private getTotalCents(booking: Booking): number {\n    if (booking.breakdown?.total_cents) {\n      return booking.breakdown.total_cents;\n    }\n    return Math.round((booking.total_amount ?? 0) * 100);\n  }\n\n  private formatUsd(amount: number): string {\n    const fractionDigits = Number.isInteger(amount) ? 0 : 2;\n    return new Intl.NumberFormat('es-AR', {\n      style: 'currency',\n      currency: 'USD',\n      minimumFractionDigits: fractionDigits,\n      maximumFractionDigits: fractionDigits,\n    }).format(amount);\n  }\n\n  formatDate(dateStr: string): string {\n    return new Date(dateStr).toLocaleDateString('es-AR', {\n      day: '2-digit',\n      month: '2-digit',\n      year: 'numeric',\n    });\n  }\n\n  formatDateTime(dateStr: string): string {\n    return new Date(dateStr).toLocaleString('es-AR', {\n      day: '2-digit',\n      month: '2-digit',\n      year: 'numeric',\n      hour: '2-digit',\n      minute: '2-digit',\n    });\n  }\n\n  // Confirmation handlers\n  async handleConfirmationSuccess(result: ConfirmAndReleaseResponse): Promise<void> {\n    // Reload booking to get updated status\n    const bookingId = this.booking()?.id;\n    if (bookingId) {\n      const updated = await this.bookingsService.getBookingById(bookingId);\n      this.booking.set(updated);\n    }\n\n    // Show success message\n    if (result.funds_released) {\n      alert(`✅ ${result.message}\\n\\n¡Los fondos fueron liberados automáticamente!`);\n    } else {\n      alert(`✅ ${result.message}`);\n    }\n  }\n\n  handleConfirmationError(errorMessage: string): void {\n    alert(`❌ Error: ${errorMessage}`);\n  }\n\n  async handleTimelineAction(event: {\n    action: 'owner_confirm' | 'renter_confirm' | 'mark_returned';\n    bookingId: string;\n  }): Promise<void> {\n    switch (event.action) {\n      case 'owner_confirm':\n        this.scrollToSection('owner-confirmation-section');\n        break;\n      case 'renter_confirm':\n        this.scrollToSection('renter-confirmation-section');\n        break;\n      case 'mark_returned':\n        await this.handleMarkAsReturned(event.bookingId);\n        break;\n      default:\n        console.warn('Acción de timeline desconocida', event);\n    }\n  }\n\n  private scrollToSection(elementId: string): void {\n    const element = document.getElementById(elementId);\n    if (element) {\n      element.scrollIntoView({ behavior: 'smooth', block: 'start' });\n    }\n  }\n\n  private async handleMarkAsReturned(bookingId: string): Promise<void> {\n    const userId = this.authService.session$()?.user?.id;\n    if (!userId) {\n      alert('Necesitas iniciar sesión para continuar.');\n      return;\n    }\n\n    const confirmReturn = confirm('¿Confirmás que devolviste el vehículo al propietario?');\n    if (!confirmReturn) {\n      return;\n    }\n\n    try {\n      await this.confirmationService.markAsReturned({\n        booking_id: bookingId,\n        returned_by: userId,\n      });\n\n      const updatedBooking = await this.bookingsService.getBookingById(bookingId);\n      if (updatedBooking) {\n        this.booking.set(updatedBooking);\n      }\n\n      alert('Marcaste la reserva como devuelta. Gracias por completar este paso.');\n    } catch (error) {\n      console.error('Error al marcar la reserva como devuelta', error);\n      alert('No pudimos marcar la devolución. Intentalo nuevamente en unos minutos.');\n    }\n  }\n\n  private async loadPendingExtensionRequests(bookingId: string): Promise<void> {\n    this.loadingExtensionRequests.set(true);\n    try {\n      const requests = await this.bookingsService.getPendingExtensionRequests(bookingId);\n      this.pendingExtensionRequests.set(requests);\n    } catch (error) {\n      this.logger.error('Error loading pending extension requests:', error);\n    } finally {\n      this.loadingExtensionRequests.set(false);\n    }\n  }\n\n  // NEW: Traffic Fines Methods\n  private async loadTrafficFines(bookingId: string): Promise<void> {\n    this.loadingTrafficFines.set(true);\n    try {\n      const fines = await this.trafficInfractionsService.getInfractionsByBooking(bookingId);\n      this.trafficFines.set(fines);\n    } catch (error) {\n      this.logger.error('Error loading traffic fines:', error);\n    } finally {\n      this.loadingTrafficFines.set(false);\n    }\n  }\n\n  async disputeTrafficFine(fine: TrafficInfraction): Promise<void> {\n    const reason = prompt('Por favor, ingresa la razón por la que deseas disputar esta multa:');\n    if (!reason) {\n      alert('Debes ingresar una razón para disputar la multa.');\n      return;\n    }\n\n    if (!confirm('¿Confirmas que deseas disputar esta multa de tránsito?')) {\n      return;\n    }\n\n    this.loading.set(true);\n    try {\n      await this.trafficInfractionsService.updateInfractionStatus(fine.id, 'disputed', reason);\n      alert('Multa disputada exitosamente. El propietario será notificado.');\n      // Reload fines to update UI\n      await this.loadTrafficFines(this.booking()!.id);\n    } catch (error) {\n      console.error('Error disputing traffic fine:', error);\n      alert('Ocurrió un error al disputar la multa.');\n    } finally {\n      this.loading.set(false);\n    }\n  }\n\n  onOwnerNoShowReported(result: { success: boolean; message?: string }): void {\n    this.logger.debug('Owner No-Show reported:', result);\n    this.showReportOwnerNoShowModal.set(false);\n    if (result.success) {\n      const alert = this.alertController.create({ // Assuming alertController is available\n        header: '✅ No-Show Reportado',\n        message: 'Hemos registrado tu reporte de no-show. Nuestro equipo ha sido notificado y se pondrá en contacto contigo a la brevedad para asistirte en buscar una alternativa o procesar un reembolso.',\n        buttons: [\n          {\n            text: 'Buscar otro auto',\n            handler: () => {\n              const booking = this.booking();\n              if (booking) {\n                this.router.navigate(['/cars'], {\n                  queryParams: {\n                    startDate: new Date(booking.start_at).toISOString().split('T')[0],\n                    endDate: new Date(booking.end_at).toISOString().split('T')[0],\n                    city: booking.car_city, // Pre-fill city from original booking\n                  },\n                });\n              }\n            },\n          },\n          {\n            text: 'Solicitar Reembolso',\n            handler: () => {\n              this.showRefundForm.set(true); // Trigger existing refund request modal\n            },\n          },\n          {\n            text: 'Cerrar',\n            role: 'cancel',\n            handler: () => {\n              // Reload booking data to reflect any status changes\n              this.bookingsService.getBookingById(this.booking()!.id).then(updated => {\n                if (updated) this.booking.set(updated);\n              });\n            },\n          },\n        ],\n      });\n      alert.then(a => a.present());\n    } else {\n      alert('Error al reportar no-show: ' + (result.message || 'Error desconocido.'));\n    }\n  }\n\n  onRenterNoShowReported(result: { success: boolean; message?: string }): void {\n    this.logger.debug('Renter No-Show reported:', result);\n    this.showReportRenterNoShowModal.set(false);\n    if (result.success) {\n      alert('Reporte de no-show enviado. Nuestro equipo se pondrá en contacto para validar la situación y aplicar las penalidades correspondientes.');\n      // For now, reload booking data to reflect any status changes\n      this.bookingsService.getBookingById(this.booking()!.id).then(updated => {\n        if (updated) this.booking.set(updated);\n      });\n    } else {\n      alert('Error al reportar no-show: ' + (result.message || 'Error desconocido.'));\n    }\n  }\n\n  // ============================================================================\n  // OWNER CANCELLATION WITH PENALTY\n  // ============================================================================\n\n  readonly canOwnerCancel = computed(() => {\n    const booking = this.booking();\n    if (!booking || !this.isOwner()) return false;\n    // Owner can cancel confirmed or pending bookings\n    return booking.status === 'confirmed' || booking.status === 'pending' || booking.status === 'pending_payment';\n  });\n\n  async ownerCancelBooking(): Promise<void> {\n    const booking = this.booking();\n    if (!booking) return;\n\n    const alert = await this.alertController.create({\n      header: '⚠️ Cancelar Reserva',\n      message: `\n        <p><strong>¿Estás seguro de cancelar esta reserva?</strong></p>\n        <p>Como propietario, al cancelar se aplicarán las siguientes penalizaciones:</p>\n        <ul>\n          <li>🔙 Reembolso del 100% al arrendatario</li>\n          <li>📉 -10% de visibilidad por 30 días</li>\n          <li>⚠️ 3+ cancelaciones en 90 días = suspensión temporal</li>\n        </ul>\n      `,\n      inputs: [\n        {\n          name: 'reason',\n          type: 'textarea',\n          placeholder: 'Motivo de la cancelación (requerido)',\n        },\n      ],\n      buttons: [\n        {\n          text: 'No cancelar',\n          role: 'cancel',\n        },\n        {\n          text: 'Sí, cancelar',\n          cssClass: 'danger',\n          handler: async (data) => {\n            if (!data.reason || data.reason.trim().length < 10) {\n              alert.message = 'Por favor, ingresa un motivo válido (mínimo 10 caracteres).';\n              return false; // Prevent closing\n            }\n\n            this.loading.set(true);\n            try {\n              const result = await this.bookingsService.ownerCancelBooking(booking.id, data.reason.trim());\n\n              if (result.success) {\n                const updated = await this.bookingsService.getBookingById(booking.id);\n                this.booking.set(updated);\n\n                const penaltyMessage = result.penaltyApplied\n                  ? 'Se ha aplicado una penalización de visibilidad.'\n                  : '';\n\n                const successAlert = await this.alertController.create({\n                  header: '✅ Reserva Cancelada',\n                  message: `La reserva ha sido cancelada y el arrendatario recibirá un reembolso completo. ${penaltyMessage}`,\n                  buttons: ['Entendido'],\n                });\n                await successAlert.present();\n              } else {\n                const errorAlert = await this.alertController.create({\n                  header: '❌ Error',\n                  message: result.error || 'No se pudo cancelar la reserva.',\n                  buttons: ['Cerrar'],\n                });\n                await errorAlert.present();\n              }\n            } catch {\n              const errorAlert = await this.alertController.create({\n                header: '❌ Error',\n                message: 'Ocurrió un error inesperado al cancelar la reserva.',\n                buttons: ['Cerrar'],\n              });\n              await errorAlert.present();\n            } finally {\n              this.loading.set(false);\n            }\n            return true;\n          },\n        },\n      ],\n    });\n\n    await alert.present();\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/features/bookings/booking-detail/booking-detail.page.vitest.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":27,"column":62,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":27,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1526,1529],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1526,1529],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":71,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":71,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3053,3056],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3053,3056],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":88,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":88,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3533,3536],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3533,3536],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":97,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":97,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3870,3873],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3870,3873],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":112,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":112,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4284,4287],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4284,4287],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":126,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":126,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4750,4753],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4750,4753],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { TestBed } from '@angular/core/testing';\nimport { ActivatedRoute, convertToParamMap } from '@angular/router';\nimport { of } from 'rxjs';\nimport { afterEach, describe, expect, it, vi } from 'vitest';\nimport { AuthService } from '@core/services/auth/auth.service';\nimport { BookingConfirmationService } from '@core/services/bookings/booking-confirmation.service';\nimport { BookingFlowService } from '@core/services/bookings/booking-flow.service';\nimport { BookingOpsService } from '@core/services/bookings/booking-ops.service';\nimport { BookingsService } from '@core/services/bookings/bookings.service';\nimport { ExchangeRateService } from '@core/services/payments/exchange-rate.service';\nimport { FgoV1_1Service } from '@core/services/verification/fgo-v1-1.service';\nimport { InsuranceService } from '@core/services/bookings/insurance.service';\nimport { LoggerService } from '@core/services/infrastructure/logger.service';\nimport { MetaService } from '@core/services/ui/meta.service';\nimport { PaymentsService } from '@core/services/payments/payments.service';\nimport { ReviewsService } from '@core/services/cars/reviews.service';\nimport { TrafficInfractionsService } from '@core/services/infrastructure/traffic-infractions.service';\nimport { BookingDetailPage } from './booking-detail.page';\n\ndescribe('BookingDetailPage (vitest)', () => {\n  afterEach(() => {\n    TestBed.resetTestingModule();\n    vi.useRealTimers();\n  });\n\n  const makeComponent = () => {\n    const updateBooking = vi.fn(async (_id: string, updates: any) => ({\n      id: 'booking-1',\n      metadata: updates?.metadata ?? {},\n    }));\n\n    const logger = {\n      warn: vi.fn(),\n      debug: vi.fn(),\n      error: vi.fn(),\n      info: vi.fn(),\n    };\n\n    TestBed.configureTestingModule({\n      providers: [\n        { provide: BookingsService, useValue: { updateBooking } },\n        { provide: LoggerService, useValue: { ...logger, createChildLogger: () => logger } },\n        {\n          provide: AuthService,\n          useValue: { session$: () => ({ user: { id: 'renter-1' } }) },\n        },\n        {\n          provide: ActivatedRoute,\n          useValue: { snapshot: { paramMap: convertToParamMap({ id: 'booking-1' }) } },\n        },\n        { provide: PaymentsService, useValue: {} },\n        { provide: ReviewsService, useValue: {} },\n        { provide: BookingFlowService, useValue: {} },\n        { provide: BookingConfirmationService, useValue: {} },\n        { provide: MetaService, useValue: {} },\n        { provide: ExchangeRateService, useValue: {} },\n        { provide: FgoV1_1Service, useValue: { getInspections: () => of([]) } },\n        { provide: InsuranceService, useValue: {} },\n        { provide: BookingOpsService, useValue: {} },\n        { provide: TrafficInfractionsService, useValue: {} },\n      ],\n    });\n\n    const component = TestBed.runInInjectionContext(() => new BookingDetailPage());\n\n    return { component, updateBooking };\n  };\n\n  it('merges return checklist from metadata', () => {\n    const { component } = makeComponent();\n    const booking: any = {\n      id: 'booking-1',\n      car_id: 'car-1',\n      user_id: 'renter-1',\n      renter_id: 'renter-1',\n      start_at: new Date().toISOString(),\n      end_at: new Date(Date.now() + 3600000).toISOString(),\n      status: 'in_progress',\n      total_amount: 10,\n      currency: 'ARS',\n      created_at: new Date().toISOString(),\n      metadata: {\n        return_checklist: [{ id: 'fuel', checked: true }],\n      },\n    };\n\n    component.booking.set(booking);\n    (component as any).loadReturnChecklist(booking);\n\n    const fuelItem = component.returnChecklistItems().find((i) => i.id === 'fuel');\n    expect(fuelItem?.checked).toBe(true);\n  });\n\n  it('syncs return checklist to metadata on toggle', async () => {\n    vi.useFakeTimers();\n    const { component, updateBooking } = makeComponent();\n    const booking: any = {\n      id: 'booking-1',\n      car_id: 'car-1',\n      user_id: 'renter-1',\n      renter_id: 'renter-1',\n      start_at: new Date().toISOString(),\n      end_at: new Date(Date.now() + 3600000).toISOString(),\n      status: 'in_progress',\n      total_amount: 10,\n      currency: 'ARS',\n      created_at: new Date().toISOString(),\n      metadata: {},\n    };\n\n    component.booking.set(booking);\n    (component as any).loadReturnChecklist(booking);\n\n    component.toggleReturnChecklistItem('final-photos');\n    vi.advanceTimersByTime(600);\n    await Promise.resolve();\n\n    expect(updateBooking).toHaveBeenCalled();\n    const call = updateBooking.mock.calls[0][1];\n    expect(call.metadata.return_checklist).toBeDefined();\n    vi.useRealTimers();\n  });\n\n  it('builds car return considerations from car rules', () => {\n    const { component } = makeComponent();\n    const booking: any = {\n      id: 'booking-1',\n      car_id: 'car-1',\n      user_id: 'renter-1',\n      renter_id: 'renter-1',\n      start_at: new Date().toISOString(),\n      end_at: new Date(Date.now() + 3600000).toISOString(),\n      status: 'in_progress',\n      total_amount: 10,\n      currency: 'ARS',\n      created_at: new Date().toISOString(),\n      delivery_required: true,\n      car: {\n        fuel_policy: 'full_to_full',\n        mileage_limit: 120,\n        extra_km_price: 50,\n        allow_smoking: false,\n        allow_pets: false,\n        allow_rideshare: false,\n        max_distance_km: 200,\n      },\n      metadata: {},\n    };\n\n    component.booking.set(booking);\n    const notes = component.carReturnConsiderations();\n\n    expect(notes.join(' ')).toContain('tanque lleno');\n    expect(notes.join(' ')).toContain('Kilometraje máximo');\n    expect(notes.join(' ')).toContain('No se permite fumar');\n    expect(notes.join(' ')).toContain('No se permiten mascotas');\n    expect(notes.join(' ')).toContain('Coordiná la devolución');\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/features/bookings/booking-detail/booking-status.component.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`@core/services/bookings/bookings.service` import should occur before import of `../../../core/models`","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":76,"fix":{"range":[133,257],"text":"import { BookingsService } from '@core/services/bookings/bookings.service';\nimport { Booking } from '../../../core/models';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import {Component, Input, computed,\n  ChangeDetectionStrategy} from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { Booking } from '../../../core/models';\nimport { BookingsService } from '@core/services/bookings/bookings.service';\n\n/**\n * BookingStatusComponent\n *\n * This component is responsible for displaying the status of a booking.\n * It receives a `Booking` object as input and uses computed properties to determine the appropriate class, label, and icon for the status.\n */\n@Component({\n  selector: 'app-booking-status',\n  standalone: true,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  imports: [CommonModule],\n  template: `\n    @if (booking) {\n      <div class=\"status-badge\" [ngClass]=\"statusClass()\">\n        {{ statusIcon() }} {{ statusLabel() }}\n        @if (showDeliveryCountdown()) {\n          <span class=\"delivery-countdown\">\n            ⏱ {{ deliveryCountdown }}\n          </span>\n        }\n      </div>\n    }\n    `,\n  styles: [\n    `\n      .status-badge {\n        display: inline-flex;\n        align-items: center;\n        gap: 0.5rem;\n        padding: 0.25rem 0.75rem;\n        border-radius: 9999px;\n        font-weight: 500;\n        font-size: 0.875rem;\n      }\n      .delivery-countdown {\n        display: inline-flex;\n        align-items: center;\n        gap: 0.25rem;\n        padding-left: 0.5rem;\n        border-left: 1px solid rgba(0, 0, 0, 0.1);\n        font-size: 0.75rem;\n        font-weight: 600;\n      }\n    `,\n  ],\n})\nexport class BookingStatusComponent {\n  @Input({ required: true }) booking!: Booking;\n  @Input() deliveryCountdown: string | null = null;\n\n  constructor(private bookingsService: BookingsService) {}\n\n  isExpired = computed(() => {\n    return this.bookingsService.isExpired(this.booking);\n  });\n\n  /** Check if this is a P2P wallet booking */\n  isWalletBooking = computed(() => {\n    return this.booking?.payment_mode === 'wallet';\n  });\n\n  /** Check if booking is pending owner approval (P2P flow) */\n  isPendingApproval = computed(() => {\n    return this.booking?.status === 'pending' && this.isWalletBooking();\n  });\n\n  statusClass = computed(() => {\n    const status = this.booking?.status;\n    const startAt = this.booking?.start_at ? new Date(this.booking.start_at).getTime() : null;\n    const isBeforeStart =\n      status === 'in_progress' && startAt && !Number.isNaN(startAt) && Date.now() < startAt;\n    const isReturnFlow =\n      !!this.booking?.returned_at ||\n      this.booking?.completion_status === 'returned' ||\n      this.booking?.completion_status === 'pending_owner' ||\n      this.booking?.completion_status === 'pending_renter' ||\n      this.booking?.completion_status === 'pending_both';\n\n    // P2P wallet: pending approval (amber, not error)\n    if (this.isPendingApproval()) {\n      return 'bg-amber-100 text-amber-700 dark:bg-amber-900/30 dark:text-amber-400';\n    }\n\n    if (isReturnFlow) {\n      return 'bg-warning-light/20 text-warning-strong';\n    }\n\n    // Traditional: expired payment\n    if (status === 'pending' && this.isExpired()) {\n      return 'bg-error-bg-hover text-error-strong';\n    }\n\n    switch (status) {\n      case 'pending':\n      case 'pending_payment':\n        return 'bg-warning-bg-hover text-warning-strong';\n      case 'confirmed':\n        return 'bg-success-light/20 text-success-strong';\n      case 'in_progress':\n        if (isBeforeStart) {\n          return 'bg-success-light/20 text-success-strong';\n        }\n        return 'bg-cta-default/20 text-cta-default';\n      case 'pending_review':\n        return 'bg-warning-light/20 text-warning-strong';\n      case 'completed':\n        return 'bg-surface-raised text-text-primary';\n      case 'disputed':\n        return 'bg-error-bg-hover text-error-strong';\n      case 'cancelled':\n      case 'expired':\n        return 'bg-error-bg-hover text-error-strong';\n      default:\n        return 'bg-surface-raised text-text-primary';\n    }\n  });\n\n  statusLabel = computed(() => {\n    const status = this.booking?.status;\n    const startAt = this.booking?.start_at ? new Date(this.booking.start_at).getTime() : null;\n    const isBeforeStart =\n      status === 'in_progress' && startAt && !Number.isNaN(startAt) && Date.now() < startAt;\n    const isReturnFlow =\n      !!this.booking?.returned_at ||\n      this.booking?.completion_status === 'returned' ||\n      this.booking?.completion_status === 'pending_owner' ||\n      this.booking?.completion_status === 'pending_renter' ||\n      this.booking?.completion_status === 'pending_both';\n\n    // P2P wallet: waiting for owner approval\n    if (this.isPendingApproval()) {\n      return 'Esperando aprobación';\n    }\n\n    if (isReturnFlow) {\n      return 'En revisión';\n    }\n\n    // Traditional: expired payment (only for non-wallet bookings)\n    if (status === 'pending' && this.isExpired() && !this.isWalletBooking()) {\n      return 'Pago vencido';\n    }\n\n    switch (status) {\n      case 'pending':\n      case 'pending_payment':\n        return 'Pendiente de pago';\n      case 'confirmed':\n        return 'Aprobada';\n      case 'in_progress':\n        if (isBeforeStart) {\n          return 'Check-in pendiente';\n        }\n        return 'En curso';\n      case 'pending_review':\n        return 'En revisión';\n      case 'completed':\n        return 'Completada';\n      case 'disputed':\n        return 'En disputa';\n      case 'cancelled':\n        return 'Cancelada';\n      case 'expired':\n        return 'Expirada';\n      case 'no_show':\n        return 'No show';\n      default:\n        return status ?? 'Desconocido';\n    }\n  });\n\n  statusIcon = computed(() => {\n    const status = this.booking?.status;\n    const startAt = this.booking?.start_at ? new Date(this.booking.start_at).getTime() : null;\n    const isBeforeStart =\n      status === 'in_progress' && startAt && !Number.isNaN(startAt) && Date.now() < startAt;\n    const isReturnFlow =\n      !!this.booking?.returned_at ||\n      this.booking?.completion_status === 'returned' ||\n      this.booking?.completion_status === 'pending_owner' ||\n      this.booking?.completion_status === 'pending_renter' ||\n      this.booking?.completion_status === 'pending_both';\n\n    // P2P wallet: clock icon for pending approval\n    if (this.isPendingApproval()) {\n      return '⏳';\n    }\n\n    if (isReturnFlow) {\n      return '🔍';\n    }\n\n    // Traditional: expired\n    if (this.isExpired() && !this.isWalletBooking()) {\n      return '⛔';\n    }\n\n    switch (status) {\n      case 'pending':\n      case 'pending_payment':\n        return '⏳';\n      case 'confirmed':\n        return '✅';\n      case 'in_progress':\n        if (isBeforeStart) {\n          return '✅';\n        }\n        return '🚗';\n      case 'pending_review':\n        return '🔍';\n      case 'completed':\n        return '🏁';\n      case 'disputed':\n        return '⚖️';\n      case 'cancelled':\n        return '⚠️';\n      case 'expired':\n        return '⛔';\n      default:\n        return 'ℹ️';\n    }\n  });\n\n  showDeliveryCountdown = computed(() => {\n    const startAt = this.booking?.start_at ? new Date(this.booking.start_at).getTime() : null;\n    const isBeforeStart =\n      this.booking?.status === 'in_progress' &&\n      startAt &&\n      !Number.isNaN(startAt) &&\n      Date.now() < startAt;\n\n    return this.booking?.status === 'in_progress' && !!this.deliveryCountdown && !isBeforeStart;\n  });\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/features/bookings/booking-detail/review-management.component.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`../../../core/models` import should occur after import of `@core/services/bookings/bookings.service`","line":4,"column":1,"nodeType":"ImportDeclaration","endLine":4,"endColumn":76,"fix":{"range":[110,396],"text":"import { ReviewsService } from '@core/services/cars/reviews.service';\nimport { AuthService } from '@core/services/auth/auth.service';\nimport { BookingsService } from '@core/services/bookings/bookings.service';\nimport { Booking, CreateReviewParams, Review } from '../../../core/models';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import {Component, Input, OnInit, computed, inject, signal,\n  ChangeDetectionStrategy} from '@angular/core';\n\nimport { Booking, CreateReviewParams, Review } from '../../../core/models';\nimport { ReviewsService } from '@core/services/cars/reviews.service';\nimport { AuthService } from '@core/services/auth/auth.service';\nimport { BookingsService } from '@core/services/bookings/bookings.service';\nimport { ReviewFormComponent } from '../../../shared/components/review-form/review-form.component';\nimport { ReviewCardComponent } from '../../../shared/components/review-card/review-card.component';\n\n/**\n * ReviewManagementComponent\n *\n * This component is responsible for managing the review process for a booking.\n * It handles showing the review form, submitting reviews, and displaying existing reviews.\n * It receives a `Booking` object as input.\n */\n@Component({\n  selector: 'app-review-management',\n  standalone: true,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  imports: [ReviewFormComponent, ReviewCardComponent],\n  template: `\n    <!-- Completed Actions -->\n    @if (showCompletedActions()) {\n      <div class=\"flex flex-col sm:flex-row gap-3\">\n        @if (canReview() && !existingReview()) {\n          <button\n            (click)=\"handleShowReviewForm()\"\n            class=\"btn-primary flex-1 px-6 py-3 font-semibold shadow-soft\"\n            >\n            ⭐ Dejar reseña\n          </button>\n        }\n        @if (existingReview()) {\n          <button\n            class=\"info-card-petrol flex-1 px-6 py-3 font-semibold cursor-default text-center\"\n            disabled\n            >\n            ✅ Ya calificaste esta reserva\n          </button>\n        }\n        <button class=\"btn-secondary flex-1 px-6 py-3 font-semibold\">📄 Ver factura</button>\n      </div>\n    }\n    \n    <!-- Review Form Modal -->\n    @if (showReviewForm() && reviewData()) {\n      <div\n        class=\"fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center p-4 overflow-y-auto\"\n        >\n        <div class=\"my-8\">\n          <app-review-form\n            [bookingId]=\"booking.id\"\n            [revieweeId]=\"reviewData()!.revieweeId\"\n            [carId]=\"reviewData()!.carId\"\n            [reviewType]=\"reviewData()!.reviewType\"\n            [revieweeName]=\"reviewData()!.revieweeName\"\n            [carTitle]=\"reviewData()!.carTitle\"\n            (submitReview)=\"handleSubmitReview($event)\"\n            (cancelReview)=\"handleCancelReview()\"\n          ></app-review-form>\n        </div>\n      </div>\n    }\n    \n    <!-- Existing Review Display -->\n    @if (existingReview() && !showReviewForm()) {\n      <div\n        class=\"card-premium rounded-2xl p-4 sm:p-6 shadow-soft\"\n        >\n        <h3 class=\"h5 mb-4\">📝 Tu Calificación</h3>\n        <div class=\"info-card-warm p-4 mb-4\">\n          <p class=\"text-sm font-semibold text-warning-strong\">⏳ Review pendiente de publicación</p>\n          <p class=\"text-xs text-text-secondary dark:text-text-secondary mt-1\">\n            Se publicará cuando ambas partes hayan calificado, o después de 14 días.\n          </p>\n        </div>\n        <app-review-card [review]=\"existingReview()!\" [showCarTitle]=\"false\"></app-review-card>\n      </div>\n    }\n    `,\n})\nexport class ReviewManagementComponent implements OnInit {\n  @Input({ required: true }) booking!: Booking;\n\n  private readonly reviewsService = inject(ReviewsService);\n  private readonly authService = inject(AuthService);\n  private readonly bookingsService = inject(BookingsService);\n\n  showReviewForm = signal(false);\n  canReview = signal(false);\n  existingReview = signal<Review | null>(null);\n  isSubmittingReview = signal(false);\n  reviewData = signal<{\n    revieweeId: string;\n    revieweeName: string;\n    carId: string;\n    carTitle: string;\n    reviewType: 'renter_to_owner' | 'owner_to_renter';\n  } | null>(null);\n\n  showCompletedActions = computed(() => this.booking?.status === 'completed');\n\n  async ngOnInit() {\n    if (this.booking.status === 'completed') {\n      await this.checkReviewStatus();\n      await this.loadReviewData();\n    }\n  }\n\n  async checkReviewStatus(): Promise<void> {\n    try {\n      const canReview = await this.reviewsService.canReviewBooking(this.booking.id);\n      this.canReview.set(canReview);\n\n      const currentUser = this.authService.session$()?.user;\n      if (!currentUser) return;\n\n      const { data: car } = await this.bookingsService['supabase']\n        .from('cars')\n        .select('id, owner_id')\n        .eq('id', this.booking.car_id)\n        .single();\n\n      if (!car) return;\n\n      const { data: review } = await this.reviewsService['supabase']\n        .from('reviews')\n        .select('*')\n        .eq('booking_id', this.booking.id)\n        .eq('reviewer_id', currentUser.id)\n        .maybeSingle();\n\n      if (review) {\n        this.existingReview.set(review as Review);\n        this.canReview.set(false);\n      }\n    } catch {\n      /* Silenced */\n    }\n  }\n\n  handleShowReviewForm(): void {\n    this.showReviewForm.set(true);\n  }\n\n  handleCancelReview(): void {\n    this.showReviewForm.set(false);\n  }\n\n  async handleSubmitReview(params: CreateReviewParams): Promise<void> {\n    this.isSubmittingReview.set(true);\n\n    try {\n      const result = await this.reviewsService.createReview(params);\n\n      if (result.success) {\n        alert(\n          '¡Review enviada exitosamente! Se publicará cuando ambas partes hayan calificado, o después de 14 días.',\n        );\n        this.showReviewForm.set(false);\n\n        await this.checkReviewStatus();\n      } else {\n        alert(`Error al enviar la review: ${result.error}`);\n      }\n    } catch {\n      alert('Error al enviar la review. Intentá nuevamente.');\n    } finally {\n      this.isSubmittingReview.set(false);\n    }\n  }\n\n  async loadReviewData(): Promise<void> {\n    try {\n      const currentUser = this.authService.session$()?.user;\n      if (!currentUser) return;\n\n      const { data: car } = await this.bookingsService['supabase']\n        .from('cars')\n        .select('id, title, owner_id, owner:profiles!cars_owner_id_fkey(id, full_name)')\n        .eq('id', this.booking.car_id)\n        .single();\n\n      if (!car) return;\n\n      const isRenter = this.booking.renter_id === currentUser.id;\n      const isOwner = car.owner_id === currentUser.id;\n\n      if (!isRenter && !isOwner) return;\n\n      let revieweeId: string;\n      let revieweeName: string;\n      let reviewType: 'renter_to_owner' | 'owner_to_renter';\n\n      if (isRenter) {\n        revieweeId = car.owner_id;\n        const owner = car.owner as { full_name?: string } | undefined;\n        revieweeName = owner?.full_name || 'Propietario';\n        reviewType = 'renter_to_owner';\n      } else {\n        const { data: renter } = await this.bookingsService['supabase']\n          .from('profiles')\n          .select('id, full_name')\n          .eq('id', this.booking.renter_id)\n          .single();\n\n        if (!renter) return;\n\n        revieweeId = renter.id;\n        revieweeName = renter.full_name || 'Arrendatario';\n        reviewType = 'owner_to_renter';\n      }\n\n      this.reviewData.set({\n        revieweeId,\n        revieweeName,\n        carId: car.id,\n        carTitle: car.title || 'Vehículo',\n        reviewType,\n      });\n    } catch {\n      /* Silenced */\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/features/bookings/check-in/booking-checkin.page.ts","messages":[{"ruleId":"@angular-eslint/use-lifecycle-interface","severity":1,"message":"Lifecycle interface 'OnInit' should be implemented for method 'ngOnInit'. (https://angular.dev/style-guide#use-lifecycle-hook-interfaces)","line":234,"column":3,"nodeType":"Identifier","messageId":"useLifecycleInterface","endLine":234,"endColumn":11,"fix":{"range":[82,5941],"text":", OnInit } from '@angular/core';\nimport { ActivatedRoute, Router } from '@angular/router';\nimport { IonicModule, ToastController } from '@ionic/angular';\nimport { VideoDamageAnalysis, VideoDamageDetectionService } from '@core/services/verification/video-damage-detection.service';\nimport { DamageReportComponent } from '../../../shared/components/damage-report/damage-report.component';\nimport { VideoInspectionRecorderComponent } from '../../../shared/components/video-inspection-recorder/video-inspection-recorder.component';\n\n/**\n * Booking Check-In Page\n *\n * Página para que el Owner grabe la inspección de check-in\n * antes de entregarle el auto al Renter.\n *\n * Flujo:\n * 1. Owner graba video del auto (90s mínimo)\n * 2. Video se sube automáticamente a GCP\n * 3. Vertex AI analiza el video (30-60s)\n * 4. Se muestran los daños detectados\n * 5. Owner confirma la inspección\n */\n@Component({\n  selector: 'app-booking-checkin',\n  standalone: true,\n  imports: [\n    CommonModule,\n    IonicModule,\n    VideoInspectionRecorderComponent,\n    DamageReportComponent\n  ],\n  template: `\n    <ion-header>\n      <ion-toolbar>\n        <ion-buttons slot=\"start\">\n          <ion-back-button defaultHref=\"/bookings\"></ion-back-button>\n        </ion-buttons>\n        <ion-title>Check-In: Inspección del Vehículo</ion-title>\n      </ion-toolbar>\n    </ion-header>\n\n    <ion-content>\n      <div class=\"checkin-container\">\n\n        <!-- Header Info -->\n        <ion-card class=\"info-card\">\n          <ion-card-content>\n            <h2>\n              <ion-icon name=\"car-sport\"></ion-icon>\n              {{ carBrand() }} {{ carModel() }}\n            </h2>\n            <p>Booking ID: <strong>{{ bookingId() }}</strong></p>\n            <ion-note>\n              Graba un video completo del vehículo antes de entregarlo.\n              La IA detectará automáticamente cualquier daño existente.\n            </ion-note>\n          </ion-card-content>\n        </ion-card>\n\n        <!-- Step 1: Record Video -->\n        @if (!videoUploaded()) {\n          <app-video-inspection-recorder\n            [bookingId]=\"bookingId()\"\n            [carId]=\"carId()\"\n            [inspectionType]=\"'checkin'\"\n            (videoUploaded)=\"onVideoUploaded($event)\"\n            (error)=\"onError($event)\">\n          </app-video-inspection-recorder>\n        }\n\n        <!-- Step 2: Analyzing Video -->\n        @if (videoUploaded() && !analysisResult()) {\n          <ion-card class=\"analyzing-card\">\n            <ion-card-content>\n              <div class=\"analyzing\">\n                <ion-spinner name=\"crescent\" color=\"primary\"></ion-spinner>\n                <h3>Analizando video con IA...</h3>\n                <p>Vertex AI está procesando el video</p>\n                <p class=\"small\">Esto tomará 30-60 segundos</p>\n                <ion-progress-bar type=\"indeterminate\"></ion-progress-bar>\n\n                <div class=\"tips\">\n                  <ion-note>\n                    <ion-icon name=\"information-circle\"></ion-icon>\n                    La IA está detectando:\n                  </ion-note>\n                  <ul>\n                    <li>Rayones y abolladuras</li>\n                    <li>Luces rotas o dañadas</li>\n                    <li>Desgaste de llantas</li>\n                    <li>Daños en el interior</li>\n                    <li>Comportamientos sospechosos</li>\n                  </ul>\n                </div>\n              </div>\n            </ion-card-content>\n          </ion-card>\n        }\n\n        <!-- Step 3: Show Results -->\n        @if (analysisResult()) {\n          <app-damage-report [analysis]=\"analysisResult()\"></app-damage-report>\n\n          <!-- Actions -->\n          <div class=\"actions\">\n            <ion-button\n              expand=\"block\"\n              color=\"primary\"\n              (click)=\"confirmInspection()\"\n              [disabled]=\"isSubmitting()\">\n              @if (!isSubmitting()) {\n                <ion-icon slot=\"start\" name=\"checkmark-circle\"></ion-icon>\n                Confirmar Inspección de Check-In\n              } @else {\n                <ion-spinner slot=\"start\"></ion-spinner>\n                Guardando...\n              }\n            </ion-button>\n\n            <ion-button\n              expand=\"block\"\n              fill=\"outline\"\n              (click)=\"retakeVideo()\">\n              <ion-icon slot=\"start\" name=\"videocam\"></ion-icon>\n              Grabar Nuevo Video\n            </ion-button>\n          </div>\n        }\n\n      </div>\n    </ion-content>\n  `,\n  styles: [`\n    .checkin-container {\n      padding: 16px;\n      max-width: 800px;\n      margin: 0 auto;\n    }\n\n    .info-card h2 {\n      display: flex;\n      align-items: center;\n      gap: 8px;\n      margin: 0 0 8px 0;\n    }\n\n    .info-card ion-note {\n      display: block;\n      margin-top: 12px;\n      line-height: 1.5;\n    }\n\n    .analyzing-card {\n      margin-top: 16px;\n    }\n\n    .analyzing {\n      text-align: center;\n      padding: 32px 16px;\n    }\n\n    .analyzing ion-spinner {\n      font-size: 48px;\n      margin-bottom: 16px;\n    }\n\n    .analyzing h3 {\n      margin: 16px 0 8px 0;\n    }\n\n    .analyzing p {\n      margin: 4px 0;\n      color: var(--ion-color-medium);\n    }\n\n    .analyzing .small {\n      font-size: 14px;\n    }\n\n    .analyzing ion-progress-bar {\n      margin: 16px 0;\n    }\n\n    .tips {\n      margin-top: 24px;\n      text-align: left;\n      background: var(--ion-color-light);\n      padding: 16px;\n      border-radius: 8px;\n    }\n\n    .tips ion-note {\n      display: flex;\n      align-items: center;\n      gap: 8px;\n      font-weight: bold;\n      margin-bottom: 12px;\n    }\n\n    .tips ul {\n      margin: 0;\n      padding-left: 20px;\n    }\n\n    .tips li {\n      margin-bottom: 8px;\n      line-height: 1.5;\n    }\n\n    .actions {\n      margin-top: 24px;\n      display: flex;\n      flex-direction: column;\n      gap: 12px;\n    }\n  `]\n})\nexport class BookingCheckinPage implements OnInit"}},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'videoPath' is defined but never used. Allowed unused args must match /^_/u.","line":242,"column":25,"nodeType":null,"messageId":"unusedVar","endLine":242,"endColumn":34},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":304,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":304,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { CommonModule } from '@angular/common';\nimport { Component, inject, signal } from '@angular/core';\nimport { ActivatedRoute, Router } from '@angular/router';\nimport { IonicModule, ToastController } from '@ionic/angular';\nimport { VideoDamageAnalysis, VideoDamageDetectionService } from '@core/services/verification/video-damage-detection.service';\nimport { DamageReportComponent } from '../../../shared/components/damage-report/damage-report.component';\nimport { VideoInspectionRecorderComponent } from '../../../shared/components/video-inspection-recorder/video-inspection-recorder.component';\n\n/**\n * Booking Check-In Page\n *\n * Página para que el Owner grabe la inspección de check-in\n * antes de entregarle el auto al Renter.\n *\n * Flujo:\n * 1. Owner graba video del auto (90s mínimo)\n * 2. Video se sube automáticamente a GCP\n * 3. Vertex AI analiza el video (30-60s)\n * 4. Se muestran los daños detectados\n * 5. Owner confirma la inspección\n */\n@Component({\n  selector: 'app-booking-checkin',\n  standalone: true,\n  imports: [\n    CommonModule,\n    IonicModule,\n    VideoInspectionRecorderComponent,\n    DamageReportComponent\n  ],\n  template: `\n    <ion-header>\n      <ion-toolbar>\n        <ion-buttons slot=\"start\">\n          <ion-back-button defaultHref=\"/bookings\"></ion-back-button>\n        </ion-buttons>\n        <ion-title>Check-In: Inspección del Vehículo</ion-title>\n      </ion-toolbar>\n    </ion-header>\n\n    <ion-content>\n      <div class=\"checkin-container\">\n\n        <!-- Header Info -->\n        <ion-card class=\"info-card\">\n          <ion-card-content>\n            <h2>\n              <ion-icon name=\"car-sport\"></ion-icon>\n              {{ carBrand() }} {{ carModel() }}\n            </h2>\n            <p>Booking ID: <strong>{{ bookingId() }}</strong></p>\n            <ion-note>\n              Graba un video completo del vehículo antes de entregarlo.\n              La IA detectará automáticamente cualquier daño existente.\n            </ion-note>\n          </ion-card-content>\n        </ion-card>\n\n        <!-- Step 1: Record Video -->\n        @if (!videoUploaded()) {\n          <app-video-inspection-recorder\n            [bookingId]=\"bookingId()\"\n            [carId]=\"carId()\"\n            [inspectionType]=\"'checkin'\"\n            (videoUploaded)=\"onVideoUploaded($event)\"\n            (error)=\"onError($event)\">\n          </app-video-inspection-recorder>\n        }\n\n        <!-- Step 2: Analyzing Video -->\n        @if (videoUploaded() && !analysisResult()) {\n          <ion-card class=\"analyzing-card\">\n            <ion-card-content>\n              <div class=\"analyzing\">\n                <ion-spinner name=\"crescent\" color=\"primary\"></ion-spinner>\n                <h3>Analizando video con IA...</h3>\n                <p>Vertex AI está procesando el video</p>\n                <p class=\"small\">Esto tomará 30-60 segundos</p>\n                <ion-progress-bar type=\"indeterminate\"></ion-progress-bar>\n\n                <div class=\"tips\">\n                  <ion-note>\n                    <ion-icon name=\"information-circle\"></ion-icon>\n                    La IA está detectando:\n                  </ion-note>\n                  <ul>\n                    <li>Rayones y abolladuras</li>\n                    <li>Luces rotas o dañadas</li>\n                    <li>Desgaste de llantas</li>\n                    <li>Daños en el interior</li>\n                    <li>Comportamientos sospechosos</li>\n                  </ul>\n                </div>\n              </div>\n            </ion-card-content>\n          </ion-card>\n        }\n\n        <!-- Step 3: Show Results -->\n        @if (analysisResult()) {\n          <app-damage-report [analysis]=\"analysisResult()\"></app-damage-report>\n\n          <!-- Actions -->\n          <div class=\"actions\">\n            <ion-button\n              expand=\"block\"\n              color=\"primary\"\n              (click)=\"confirmInspection()\"\n              [disabled]=\"isSubmitting()\">\n              @if (!isSubmitting()) {\n                <ion-icon slot=\"start\" name=\"checkmark-circle\"></ion-icon>\n                Confirmar Inspección de Check-In\n              } @else {\n                <ion-spinner slot=\"start\"></ion-spinner>\n                Guardando...\n              }\n            </ion-button>\n\n            <ion-button\n              expand=\"block\"\n              fill=\"outline\"\n              (click)=\"retakeVideo()\">\n              <ion-icon slot=\"start\" name=\"videocam\"></ion-icon>\n              Grabar Nuevo Video\n            </ion-button>\n          </div>\n        }\n\n      </div>\n    </ion-content>\n  `,\n  styles: [`\n    .checkin-container {\n      padding: 16px;\n      max-width: 800px;\n      margin: 0 auto;\n    }\n\n    .info-card h2 {\n      display: flex;\n      align-items: center;\n      gap: 8px;\n      margin: 0 0 8px 0;\n    }\n\n    .info-card ion-note {\n      display: block;\n      margin-top: 12px;\n      line-height: 1.5;\n    }\n\n    .analyzing-card {\n      margin-top: 16px;\n    }\n\n    .analyzing {\n      text-align: center;\n      padding: 32px 16px;\n    }\n\n    .analyzing ion-spinner {\n      font-size: 48px;\n      margin-bottom: 16px;\n    }\n\n    .analyzing h3 {\n      margin: 16px 0 8px 0;\n    }\n\n    .analyzing p {\n      margin: 4px 0;\n      color: var(--ion-color-medium);\n    }\n\n    .analyzing .small {\n      font-size: 14px;\n    }\n\n    .analyzing ion-progress-bar {\n      margin: 16px 0;\n    }\n\n    .tips {\n      margin-top: 24px;\n      text-align: left;\n      background: var(--ion-color-light);\n      padding: 16px;\n      border-radius: 8px;\n    }\n\n    .tips ion-note {\n      display: flex;\n      align-items: center;\n      gap: 8px;\n      font-weight: bold;\n      margin-bottom: 12px;\n    }\n\n    .tips ul {\n      margin: 0;\n      padding-left: 20px;\n    }\n\n    .tips li {\n      margin-bottom: 8px;\n      line-height: 1.5;\n    }\n\n    .actions {\n      margin-top: 24px;\n      display: flex;\n      flex-direction: column;\n      gap: 12px;\n    }\n  `]\n})\nexport class BookingCheckinPage {\n  private route = inject(ActivatedRoute);\n  private router = inject(Router);\n  private videoService = inject(VideoDamageDetectionService);\n  private toastCtrl = inject(ToastController);\n\n  // Route params\n  bookingId = signal('');\n  carId = signal('');\n  carBrand = signal('');\n  carModel = signal('');\n\n  // State\n  videoUploaded = signal(false);\n  analysisResult = signal<VideoDamageAnalysis | null>(null);\n  isSubmitting = signal(false);\n\n  ngOnInit() {\n    // Get params from route\n    this.bookingId.set(this.route.snapshot.params['id'] || 'booking_123');\n    this.carId.set(this.route.snapshot.queryParams['carId'] || 'car_456');\n    this.carBrand.set(this.route.snapshot.queryParams['brand'] || 'Tesla');\n    this.carModel.set(this.route.snapshot.queryParams['model'] || 'Model 3');\n  }\n\n  async onVideoUploaded(videoPath: string) {\n    this.videoUploaded.set(true);\n\n    // Show toast\n    const toast = await this.toastCtrl.create({\n      message: '✅ Video subido. Analizando con IA...',\n      duration: 3000,\n      color: 'success'\n    });\n    await toast.present();\n\n    // Subscribe to real-time results\n    this.videoService.subscribeToAnalysisResults(\n      this.bookingId(),\n      (analysis) => {\n        this.analysisResult.set(analysis);\n        this.showAnalysisToast(analysis);\n      }\n    );\n  }\n\n  async onError(error: string) {\n    const toast = await this.toastCtrl.create({\n      message: `❌ Error: ${error}`,\n      duration: 5000,\n      color: 'danger'\n    });\n    await toast.present();\n  }\n\n  async showAnalysisToast(analysis: VideoDamageAnalysis) {\n    const message = analysis.damages.length > 0\n      ? `⚠️ Se detectaron ${analysis.damages.length} daño(s)`\n      : '✅ No se detectaron daños';\n\n    const toast = await this.toastCtrl.create({\n      message,\n      duration: 5000,\n      color: analysis.damages.length > 0 ? 'warning' : 'success'\n    });\n    await toast.present();\n  }\n\n  async confirmInspection() {\n    this.isSubmitting.set(true);\n\n    try {\n      // TODO: Call booking service to update status\n      // await this.bookingService.confirmCheckin(this.bookingId());\n\n      const toast = await this.toastCtrl.create({\n        message: '✅ Check-In confirmado exitosamente',\n        duration: 3000,\n        color: 'success'\n      });\n      await toast.present();\n\n      // Navigate back to booking detail\n      setTimeout(() => {\n        this.router.navigate(['/bookings', this.bookingId()]);\n      }, 1000);\n\n    } catch (error) {\n      const toast = await this.toastCtrl.create({\n        message: '❌ Error al confirmar check-in',\n        duration: 5000,\n        color: 'danger'\n      });\n      await toast.present();\n    } finally {\n      this.isSubmitting.set(false);\n    }\n  }\n\n  retakeVideo() {\n    this.videoUploaded.set(false);\n    this.analysisResult.set(null);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/features/bookings/check-in/check-in.page.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`../../../core/models` import should occur after import of `@core/services/infrastructure/logger.service`","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":48,"fix":{"range":[259,801],"text":"import { BookingsService } from '@core/services/bookings/bookings.service';\nimport { FgoV1_1Service } from '@core/services/verification/fgo-v1-1.service';\nimport { AuthService } from '@core/services/auth/auth.service';\nimport { InspectionUploaderComponent } from '../../../shared/components/inspection-uploader/inspection-uploader.component';\nimport { BookingInspection } from '../../../core/models/fgo-v1-1.model';\nimport { LoggerService } from '@core/services/infrastructure/logger.service';\nimport { Booking } from '../../../core/models';\n"}},{"ruleId":"import/order","severity":1,"message":"`../../../shared/components/inspection-uploader/inspection-uploader.component` import should occur after import of `@core/services/infrastructure/logger.service`","line":10,"column":1,"nodeType":"ImportDeclaration","endLine":10,"endColumn":124,"fix":{"range":[526,801],"text":"import { BookingInspection } from '../../../core/models/fgo-v1-1.model';\nimport { LoggerService } from '@core/services/infrastructure/logger.service';\nimport { InspectionUploaderComponent } from '../../../shared/components/inspection-uploader/inspection-uploader.component';\n"}},{"ruleId":"import/order","severity":1,"message":"`../../../core/models/fgo-v1-1.model` import should occur after import of `@core/services/infrastructure/logger.service`","line":11,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":73,"fix":{"range":[650,801],"text":"import { LoggerService } from '@core/services/infrastructure/logger.service';\nimport { BookingInspection } from '../../../core/models/fgo-v1-1.model';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":3,"source":"import {Component, OnInit, inject, signal, computed,\n  ChangeDetectionStrategy} from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { ActivatedRoute, Router, RouterLink } from '@angular/router';\nimport { firstValueFrom } from 'rxjs';\nimport { Booking } from '../../../core/models';\nimport { BookingsService } from '@core/services/bookings/bookings.service';\nimport { FgoV1_1Service } from '@core/services/verification/fgo-v1-1.service';\nimport { AuthService } from '@core/services/auth/auth.service';\nimport { InspectionUploaderComponent } from '../../../shared/components/inspection-uploader/inspection-uploader.component';\nimport { BookingInspection } from '../../../core/models/fgo-v1-1.model';\nimport { LoggerService } from '@core/services/infrastructure/logger.service';\n\n/**\n * Página de Check-in para locatarios\n *\n * Permite realizar la inspección inicial del vehículo antes de iniciar el alquiler.\n * Integra con el sistema FGO v1.1 para registrar evidencias.\n */\n@Component({\n  selector: 'app-check-in',\n  standalone: true,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  imports: [CommonModule, RouterLink, InspectionUploaderComponent],\n  templateUrl: './check-in.page.html',\n  styleUrl: './check-in.page.css',\n})\nexport class CheckInPage implements OnInit {\n  private readonly route = inject(ActivatedRoute);\n  private readonly router = inject(Router);\n  private readonly bookingsService = inject(BookingsService);\n  private readonly fgoService = inject(FgoV1_1Service);\n  private readonly authService = inject(AuthService);\n  private readonly logger = inject(LoggerService);\n\n  booking = signal<Booking | null>(null);\n  loading = signal(true);\n  error = signal<string | null>(null);\n  inspectionCompleted = signal(false);\n  existingInspection = signal<BookingInspection | null>(null);\n  ownerCheckInInspection = signal<BookingInspection | null>(null);\n\n  // Computed properties\n  readonly canPerformCheckIn = computed(() => {\n    const booking = this.booking();\n    if (!booking) return false;\n\n    // Solo permite check-in si:\n    // 1. Booking está confirmado o en progreso\n    // 2. El usuario es el locatario\n    // 3. No hay check-in completado ya\n    const isRenter = booking.renter_id === this.authService.session$()?.user?.id;\n    const validStatus = booking.status === 'confirmed' || booking.status === 'in_progress';\n    const ownerCheckInReady = this.ownerCheckInInspection()?.signedAt !== undefined;\n    const hasCheckIn = this.existingInspection()?.signedAt !== undefined;\n\n    if (!isRenter || !validStatus || hasCheckIn) return false;\n\n    // Legacy fallback: allow renter documentation even if owner check-in is missing\n    if (booking.status === 'in_progress') {\n      return true;\n    }\n\n    return ownerCheckInReady;\n  });\n\n  readonly isRenter = computed(() => {\n    const booking = this.booking();\n    const currentUser = this.authService.session$()?.user;\n    return booking?.renter_id === currentUser?.id;\n  });\n\n  readonly ownerCheckInCompleted = computed(() => {\n    return this.ownerCheckInInspection()?.signedAt !== undefined;\n  });\n\n  readonly isLegacyInProgress = computed(() => {\n    const booking = this.booking();\n    return booking?.status === 'in_progress' && !this.ownerCheckInCompleted();\n  });\n\n  async ngOnInit(): Promise<void> {\n    const bookingId = this.route.snapshot.paramMap.get('id');\n    if (!bookingId) {\n      this.error.set('ID de reserva inválido');\n      this.loading.set(false);\n      return;\n    }\n\n    try {\n      // Cargar booking\n      const booking = await this.bookingsService.getBookingById(bookingId);\n      if (!booking) {\n        this.error.set('Reserva no encontrada');\n        this.loading.set(false);\n        return;\n      }\n\n      this.booking.set(booking);\n\n      // Verificar que el usuario es el locatario\n      if (!this.isRenter()) {\n        this.error.set('No tenés permisos para realizar el check-in de esta reserva');\n        this.loading.set(false);\n        return;\n      }\n\n      // Verificar estado del booking\n      if (booking.status !== 'confirmed' && booking.status !== 'in_progress') {\n        this.error.set('El check-in solo está disponible para reservas confirmadas o en progreso');\n        this.loading.set(false);\n        return;\n      }\n\n      // Cargar inspección del locador y del locatario\n      const [ownerCheckIn, renterCheckIn] = await Promise.all([\n        firstValueFrom(this.fgoService.getInspectionByStage(bookingId, 'check_in')),\n        firstValueFrom(this.fgoService.getInspectionByStage(bookingId, 'renter_check_in')),\n      ]);\n\n      if (ownerCheckIn?.signedAt) {\n        this.ownerCheckInInspection.set(ownerCheckIn);\n      }\n\n      if (renterCheckIn?.signedAt) {\n        this.existingInspection.set(renterCheckIn);\n        this.inspectionCompleted.set(true);\n      }\n    } catch (err) {\n      this.error.set('Error al cargar la reserva');\n      this.logger.error('Error loading booking', 'CheckInPage', err);\n    } finally {\n      this.loading.set(false);\n    }\n  }\n\n  /**\n   * Maneja la finalización exitosa del check-in\n   */\n  async onInspectionCompleted(inspection: BookingInspection): Promise<void> {\n    try {\n      this.inspectionCompleted.set(true);\n      this.existingInspection.set(inspection);\n\n      // Si el booking está en 'confirmed', actualizar a 'in_progress'\n      const booking = this.booking();\n      if (booking && booking.status === 'confirmed') {\n        await this.bookingsService.updateBooking(booking.id, {\n          status: 'in_progress',\n        });\n        // Recargar booking\n        const updated = await this.bookingsService.getBookingById(booking.id);\n        if (updated) {\n          this.booking.set(updated);\n        }\n      }\n\n      // Redirigir a detalle de booking después de un breve delay\n      setTimeout(() => {\n        this.router.navigate(['/bookings', booking?.id], {\n          queryParams: { checkInCompleted: 'true' },\n        });\n      }, 2000);\n    } catch (err) {\n      this.error.set('Error al completar el check-in');\n      this.logger.error('Error completing check-in', 'CheckInPage', err);\n    }\n  }\n\n  /**\n   * Redirige al detalle de booking\n   */\n  goToBookingDetail(): void {\n    const booking = this.booking();\n    if (booking) {\n      this.router.navigate(['/bookings', booking.id]);\n    }\n  }\n\n  formatDateTime(date: Date | string): string {\n    const d = typeof date === 'string' ? new Date(date) : date;\n    return d.toLocaleString('es-AR', {\n      day: '2-digit',\n      month: '2-digit',\n      year: 'numeric',\n      hour: '2-digit',\n      minute: '2-digit',\n    });\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/features/bookings/check-out/check-out.page.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`../../../core/models` import should occur after import of `@core/services/infrastructure/logger.service`","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":48,"fix":{"range":[259,900],"text":"import { BookingsService } from '@core/services/bookings/bookings.service';\nimport { BookingConfirmationService } from '@core/services/bookings/booking-confirmation.service';\nimport { FgoV1_1Service } from '@core/services/verification/fgo-v1-1.service';\nimport { AuthService } from '@core/services/auth/auth.service';\nimport { InspectionUploaderComponent } from '../../../shared/components/inspection-uploader/inspection-uploader.component';\nimport { BookingInspection } from '../../../core/models/fgo-v1-1.model';\nimport { LoggerService } from '@core/services/infrastructure/logger.service';\nimport { Booking } from '../../../core/models';\n"}},{"ruleId":"import/order","severity":1,"message":"`../../../shared/components/inspection-uploader/inspection-uploader.component` import should occur after import of `@core/services/infrastructure/logger.service`","line":11,"column":1,"nodeType":"ImportDeclaration","endLine":11,"endColumn":124,"fix":{"range":[625,900],"text":"import { BookingInspection } from '../../../core/models/fgo-v1-1.model';\nimport { LoggerService } from '@core/services/infrastructure/logger.service';\nimport { InspectionUploaderComponent } from '../../../shared/components/inspection-uploader/inspection-uploader.component';\n"}},{"ruleId":"import/order","severity":1,"message":"`../../../core/models/fgo-v1-1.model` import should occur after import of `@core/services/infrastructure/logger.service`","line":12,"column":1,"nodeType":"ImportDeclaration","endLine":12,"endColumn":73,"fix":{"range":[749,900],"text":"import { LoggerService } from '@core/services/infrastructure/logger.service';\nimport { BookingInspection } from '../../../core/models/fgo-v1-1.model';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":3,"source":"import {Component, OnInit, inject, signal, computed,\n  ChangeDetectionStrategy} from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { ActivatedRoute, Router, RouterLink } from '@angular/router';\nimport { firstValueFrom } from 'rxjs';\nimport { Booking } from '../../../core/models';\nimport { BookingsService } from '@core/services/bookings/bookings.service';\nimport { BookingConfirmationService } from '@core/services/bookings/booking-confirmation.service';\nimport { FgoV1_1Service } from '@core/services/verification/fgo-v1-1.service';\nimport { AuthService } from '@core/services/auth/auth.service';\nimport { InspectionUploaderComponent } from '../../../shared/components/inspection-uploader/inspection-uploader.component';\nimport { BookingInspection } from '../../../core/models/fgo-v1-1.model';\nimport { LoggerService } from '@core/services/infrastructure/logger.service';\n\n/**\n * Página de Check-out para locatarios\n *\n * Permite realizar la inspección final del vehículo al devolver el auto.\n * Muestra comparación con check-in (odómetro, combustible) y permite reportar daños.\n * Integra con el sistema FGO v1.1 para registrar evidencias.\n */\n@Component({\n  selector: 'app-check-out',\n  standalone: true,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  imports: [CommonModule, RouterLink, InspectionUploaderComponent],\n  templateUrl: './check-out.page.html',\n  styleUrl: './check-out.page.css',\n})\nexport class CheckOutPage implements OnInit {\n  private readonly route = inject(ActivatedRoute);\n  private readonly router = inject(Router);\n  private readonly bookingsService = inject(BookingsService);\n  private readonly confirmationService = inject(BookingConfirmationService);\n  private readonly fgoService = inject(FgoV1_1Service);\n  private readonly authService = inject(AuthService);\n  private readonly logger = inject(LoggerService);\n\n  booking = signal<Booking | null>(null);\n  loading = signal(true);\n  error = signal<string | null>(null);\n  missingReception = signal(false);\n  inspectionCompleted = signal(false);\n  existingInspection = signal<BookingInspection | null>(null);\n  checkInInspection = signal<BookingInspection | null>(null);\n  renterCheckInInspection = signal<BookingInspection | null>(null);\n\n  // Computed properties\n  readonly canPerformCheckOut = computed(() => {\n    const booking = this.booking();\n    if (!booking) return false;\n\n    // Solo permite check-out si:\n    // 1. Booking está en progreso o completado\n    // 2. El usuario es el locatario\n    // 3. No hay check-out completado ya\n    // 4. Existe check-in completado\n    const isRenter = booking.renter_id === this.authService.session$()?.user?.id;\n    const validStatus = booking.status === 'in_progress' || booking.status === 'completed';\n    const hasCheckOut = this.existingInspection()?.signedAt !== undefined;\n    const hasCheckIn = this.renterCheckInInspection()?.signedAt !== undefined;\n\n    return isRenter && validStatus && !hasCheckOut && hasCheckIn;\n  });\n\n  readonly isRenter = computed(() => {\n    const booking = this.booking();\n    const currentUser = this.authService.session$()?.user;\n    return booking?.renter_id === currentUser?.id;\n  });\n\n  readonly kilometersDriven = computed(() => {\n    const checkIn = this.checkInInspection();\n    const checkOut = this.existingInspection();\n    if (!checkIn?.odometer || !checkOut?.odometer) return null;\n    return checkOut.odometer - checkIn.odometer;\n  });\n\n  readonly fuelDifference = computed(() => {\n    const checkIn = this.checkInInspection();\n    const checkOut = this.existingInspection();\n    if (checkIn?.fuelLevel === undefined || checkOut?.fuelLevel === undefined) return null;\n    return checkOut.fuelLevel - checkIn.fuelLevel;\n  });\n\n  /**\n   * Calcula la penalidad por combustible faltante\n   * Precio por litro: ~$1.50 USD/litro Argentina\n   * Tanque promedio: 50 litros\n   * Penalización: diferencia% * 50L * $1.50 + 20% margen servicio\n   */\n  readonly fuelPenalty = computed(() => {\n    const diff = this.fuelDifference();\n    if (diff === null || diff >= 0) return null;\n\n    const LITERS_PER_TANK = 50;\n    const PRICE_PER_LITER_USD = 1.5;\n    const SERVICE_MARGIN = 1.2; // 20% margen por servicio de carga\n\n    const litersNeeded = (Math.abs(diff) / 100) * LITERS_PER_TANK;\n    const baseCost = litersNeeded * PRICE_PER_LITER_USD;\n    const totalCost = baseCost * SERVICE_MARGIN;\n\n    return {\n      liters: Math.round(litersNeeded * 10) / 10,\n      baseCost: Math.round(baseCost * 100) / 100,\n      totalCost: Math.round(totalCost * 100) / 100,\n      percentageMissing: Math.abs(diff)\n    };\n  });\n\n  async ngOnInit(): Promise<void> {\n    const bookingId = this.route.snapshot.paramMap.get('id');\n    if (!bookingId) {\n      this.error.set('ID de reserva inválido');\n      this.loading.set(false);\n      return;\n    }\n\n    try {\n      // Cargar booking\n      const booking = await this.bookingsService.getBookingById(bookingId);\n      if (!booking) {\n        this.error.set('Reserva no encontrada');\n        this.loading.set(false);\n        return;\n      }\n\n      this.booking.set(booking);\n\n      // Verificar que el usuario es el locatario\n      if (!this.isRenter()) {\n        this.error.set('No tenés permisos para realizar el check-out de esta reserva');\n        this.loading.set(false);\n        return;\n      }\n\n      // Verificar estado del booking\n      if (booking.status !== 'in_progress' && booking.status !== 'completed') {\n        this.error.set('El check-out solo está disponible para reservas en progreso');\n        this.loading.set(false);\n        return;\n      }\n\n      // Cargar inspecciones (check-in locador, recepción locatario y check-out)\n      const [checkIn, renterCheckIn, checkOut] = await Promise.all([\n        firstValueFrom(this.fgoService.getInspectionByStage(bookingId, 'check_in')),\n        firstValueFrom(this.fgoService.getInspectionByStage(bookingId, 'renter_check_in')),\n        firstValueFrom(this.fgoService.getInspectionByStage(bookingId, 'check_out')),\n      ]);\n\n      if (!renterCheckIn?.signedAt) {\n        this.missingReception.set(true);\n        this.error.set('Debés completar la recepción del vehículo antes del check-out');\n        this.loading.set(false);\n        return;\n      }\n\n      if (renterCheckIn?.signedAt) {\n        this.renterCheckInInspection.set(renterCheckIn);\n      }\n\n      if (checkIn?.signedAt) {\n        this.checkInInspection.set(checkIn);\n      } else if (renterCheckIn?.signedAt) {\n        // Fallback for comparison if owner check-in is missing\n        this.checkInInspection.set(renterCheckIn);\n      }\n\n      if (checkOut?.signedAt) {\n        this.existingInspection.set(checkOut);\n        this.inspectionCompleted.set(true);\n      }\n    } catch (err) {\n      this.error.set('Error al cargar la reserva');\n      this.logger.error('Error loading booking', 'CheckOutPage', err);\n    } finally {\n      this.loading.set(false);\n    }\n  }\n\n  /**\n   * Maneja la finalización exitosa del check-out\n   */\n  async onInspectionCompleted(inspection: BookingInspection): Promise<void> {\n    try {\n      this.inspectionCompleted.set(true);\n      this.existingInspection.set(inspection);\n\n      // Marcar devolución y confirmar como locatario (no cerrar hasta confirmación del locador)\n      const booking = this.booking();\n      const renterId = this.authService.session$()?.user?.id;\n      if (booking && renterId) {\n        await this.confirmationService.markAsReturned({\n          booking_id: booking.id,\n          returned_by: renterId,\n        });\n        await this.confirmationService.confirmRenter({\n          booking_id: booking.id,\n          confirming_user_id: renterId,\n        });\n        const updated = await this.bookingsService.getBookingById(booking.id);\n        if (updated) this.booking.set(updated);\n      }\n\n      // Redirigir a detalle de booking después de un breve delay\n      setTimeout(() => {\n        this.router.navigate(['/bookings', booking?.id], {\n          queryParams: { checkOutCompleted: 'true' },\n        });\n      }, 2000);\n    } catch (err) {\n      this.error.set('Error al completar el check-out');\n      this.logger.error('Error completing check-out', 'CheckOutPage', err);\n    }\n  }\n\n  /**\n   * Redirige al detalle de booking\n   */\n  goToBookingDetail(): void {\n    const booking = this.booking();\n    if (booking) {\n      this.router.navigate(['/bookings', booking.id]);\n    }\n  }\n\n  formatDateTime(date: Date | string): string {\n    const d = typeof date === 'string' ? new Date(date) : date;\n    return d.toLocaleString('es-AR', {\n      day: '2-digit',\n      month: '2-digit',\n      year: 'numeric',\n      hour: '2-digit',\n      minute: '2-digit',\n    });\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/features/bookings/checkout/services/checkout-payment.service.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`../../../../core/models` import should occur after import of `@core/services/payments/wallet.service`","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":51,"fix":{"range":[183,692],"text":"import { BookingPaymentMethod } from '../../../../core/models/wallet.model';\nimport { BookingsService } from '@core/services/bookings/bookings.service';\nimport { FgoV1_1Service } from '@core/services/verification/fgo-v1-1.service';\nimport { LoggerService } from '@core/services/infrastructure/logger.service';\nimport { PaymentsService } from '@core/services/payments/payments.service';\nimport { WalletService } from '@core/services/payments/wallet.service';\nimport { Booking } from '../../../../core/models';\n"}},{"ruleId":"import/order","severity":1,"message":"`../../../../core/models/wallet.model` import should occur after import of `@core/services/payments/wallet.service`","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":77,"fix":{"range":[234,692],"text":"import { BookingsService } from '@core/services/bookings/bookings.service';\nimport { FgoV1_1Service } from '@core/services/verification/fgo-v1-1.service';\nimport { LoggerService } from '@core/services/infrastructure/logger.service';\nimport { PaymentsService } from '@core/services/payments/payments.service';\nimport { WalletService } from '@core/services/payments/wallet.service';\nimport { BookingPaymentMethod } from '../../../../core/models/wallet.model';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import { Injectable } from '@angular/core';\nimport { Router } from '@angular/router';\nimport { firstValueFrom, of } from 'rxjs';\nimport { catchError, timeout } from 'rxjs/operators';\nimport { Booking } from '../../../../core/models';\nimport { BookingPaymentMethod } from '../../../../core/models/wallet.model';\nimport { BookingsService } from '@core/services/bookings/bookings.service';\nimport { FgoV1_1Service } from '@core/services/verification/fgo-v1-1.service';\nimport { LoggerService } from '@core/services/infrastructure/logger.service';\nimport { PaymentsService } from '@core/services/payments/payments.service';\nimport { WalletService } from '@core/services/payments/wallet.service';\nimport { CheckoutStateService } from '../state/checkout-state.service';\nimport {\n  MercadoPagoBookingGateway,\n  type MercadoPagoPreferenceResponse,\n} from '../support/mercadopago-booking.gateway';\nimport { CheckoutRiskCalculator } from '../support/risk-calculator';\n\nexport type CheckoutPaymentOutcome =\n  | { kind: 'wallet_success'; bookingId: string }\n  | { kind: 'redirect_to_mercadopago'; initPoint: string; preferenceId: string; bookingId: string };\n\n@Injectable()\nexport class CheckoutPaymentService {\n  private readonly logger;\n\n  constructor(\n    private readonly state: CheckoutStateService,\n    private readonly wallet: WalletService,\n    private readonly payments: PaymentsService,\n    private readonly bookings: BookingsService,\n    private readonly router: Router,\n    private readonly mpGateway: MercadoPagoBookingGateway,\n    private readonly riskCalculator: CheckoutRiskCalculator,\n    private readonly fgoService: FgoV1_1Service,\n    private readonly loggerService: LoggerService,\n  ) {\n    this.logger = this.loggerService.createChildLogger('CheckoutPaymentService');\n  }\n\n  async processPayment(): Promise<CheckoutPaymentOutcome> {\n    const booking = this.state.getBooking();\n    const bookingId = this.state.getBookingId();\n\n    if (!booking || !bookingId) {\n      throw new Error('No hay una reserva válida para procesar el pago.');\n    }\n\n    const method = this.state.getPaymentMethod();\n\n    switch (method) {\n      case 'wallet':\n        return this.payWithWallet(booking);\n      case 'partial_wallet':\n        return this.payWithPartialWallet(booking);\n      case 'credit_card':\n      default:\n        return this.payWithCreditCard(booking);\n    }\n  }\n\n  private async payWithWallet(booking: Booking): Promise<CheckoutPaymentOutcome> {\n    const bookingId = booking.id;\n    const depositUsd = this.state.getDepositUsd();\n    const rentalAmount = booking.total_amount;\n\n    const lock = await firstValueFrom(\n      this.wallet.lockRentalAndDeposit(bookingId, rentalAmount, depositUsd),\n    );\n\n    if (!lock.success) {\n      throw new Error(lock.message ?? 'No se pudo bloquear la garantía en wallet');\n    }\n\n    try {\n      await this.bookings.updateBooking(bookingId, {\n        payment_method: 'wallet',\n        rental_amount_cents: Math.round(rentalAmount * 100),\n        deposit_amount_cents: Math.round(depositUsd * 100),\n        rental_lock_transaction_id: lock.rental_lock_transaction_id,\n        deposit_lock_transaction_id: lock.deposit_lock_transaction_id,\n        deposit_status: 'locked',\n        status: 'confirmed',\n      });\n\n      await this.bookings.recalculatePricing(bookingId);\n\n      this.state.setStatus('paid_with_wallet');\n      this.state.setMessage('Pago confirmado con wallet. Redirigiendo al detalle de tu reserva.');\n\n      this.scheduleRiskSnapshot(booking, 'wallet').catch((_err) => {\n        // Silent error - risk snapshot is non-critical\n      });\n\n      await this.router.navigate(['/bookings', bookingId]);\n\n      return { kind: 'wallet_success', bookingId };\n    } catch (_error) {\n      await this.safeUnlockWallet(bookingId, 'Reversión por error en checkout (wallet)');\n      throw _error instanceof Error\n        ? _error\n        : new Error('Error inesperado al actualizar la reserva.');\n    }\n  }\n\n  private async payWithCreditCard(booking: Booking): Promise<CheckoutPaymentOutcome> {\n    const bookingId = booking.id;\n\n    const intent = await this.payments.createIntent(bookingId);\n    this.state.setStatus(intent.status);\n\n    await this.bookings.updateBooking(bookingId, {\n      payment_method: 'credit_card',\n      wallet_amount_cents: 0,\n      deposit_amount_cents: Math.round(this.state.getDepositUsd() * 100),\n    });\n\n    await this.bookings.recalculatePricing(bookingId);\n\n    this.state.setMessage('Redirigiendo a Mercado Pago...');\n\n    const preference = await this.requestPreferenceOrThrow(bookingId);\n    this.state.setStatus('redirecting_to_mercadopago');\n\n    this.scheduleRiskSnapshot(booking, 'credit_card').catch((_err) => {\n      // Silent error - risk snapshot is non-critical\n    });\n\n    return {\n      kind: 'redirect_to_mercadopago',\n      initPoint: preference.initPoint,\n      preferenceId: preference.preferenceId,\n      bookingId,\n    };\n  }\n\n  private async payWithPartialWallet(booking: Booking): Promise<CheckoutPaymentOutcome> {\n    const bookingId = booking.id;\n    const split = this.state.getWalletSplit();\n    const walletAmount = Math.max(0, Number(split.wallet ?? 0));\n    const cardAmount = Math.max(0, Number(split.card ?? 0));\n\n    if (walletAmount <= 0) {\n      throw new Error('Seleccioná un monto a bloquear de tu wallet mayor a 0.');\n    }\n\n    if (cardAmount <= 0) {\n      throw new Error('El monto restante en tarjeta debe ser mayor a 0 para pago mixto.');\n    }\n\n    const depositUsd = this.state.getDepositUsd();\n    let walletLocked = false;\n\n    try {\n      const lockResult = await firstValueFrom(\n        this.wallet.lockFunds(\n          bookingId,\n          walletAmount,\n          `Pago parcial Autorentar (${bookingId.slice(0, 8)})`,\n        ),\n      );\n\n      if (!lockResult.success) {\n        throw new Error(lockResult.message ?? 'No se pudo bloquear fondos en tu wallet.');\n      }\n\n      walletLocked = true;\n\n      const intent = await this.payments.createIntent(bookingId);\n      this.state.setStatus(intent.status);\n\n      await this.bookings.updateBooking(bookingId, {\n        status: 'pending_payment',\n        payment_method: 'partial_wallet',\n        wallet_amount_cents: Math.round(walletAmount * 100),\n        wallet_status: 'locked',\n        wallet_lock_transaction_id: lockResult.transaction_id ?? undefined,\n        payment_intent_id: intent.id,\n        deposit_amount_cents: Math.round(depositUsd * 100),\n      });\n\n      await this.bookings.recalculatePricing(bookingId);\n\n      const preference = await this.requestPreferenceOrThrow(bookingId);\n\n      const walletText = this.formatUsd(walletAmount);\n      const cardText = this.formatUsd(cardAmount);\n\n      this.state.setStatus('redirecting_to_mercadopago');\n      this.state.setMessage(\n        `${walletText} bloqueados de tu wallet. Redirigiendo a Mercado Pago para pagar ${cardText}...`,\n      );\n\n      this.scheduleRiskSnapshot(booking, 'partial_wallet').catch((_err) => {\n        // Silently ignore risk snapshot errors\n      });\n\n      return {\n        kind: 'redirect_to_mercadopago',\n        initPoint: preference.initPoint,\n        preferenceId: preference.preferenceId,\n        bookingId,\n      };\n    } catch (_error) {\n      if (walletLocked) {\n        await this.safeUnlockWallet(bookingId, 'Reversión pago parcial fallido');\n      }\n\n      try {\n        await this.bookings.updateBooking(bookingId, {\n          status: 'pending',\n          payment_method: booking.payment_method ?? null,\n          wallet_amount_cents: booking.wallet_amount_cents ?? undefined,\n          wallet_status: booking.wallet_status ?? 'none',\n          wallet_lock_transaction_id: booking.wallet_lock_transaction_id ?? undefined,\n          payment_intent_id: booking.payment_intent_id ?? undefined,\n        });\n      } catch {\n        // Silently ignore rollback errors\n      }\n\n      throw _error instanceof Error\n        ? _error\n        : new Error('No pudimos completar el pago mixto. Intentá nuevamente.');\n    }\n  }\n\n  private async requestPreferenceOrThrow(\n    bookingId: string,\n  ): Promise<MercadoPagoPreferenceResponse> {\n    try {\n      return await this.mpGateway.createPreference(bookingId);\n    } catch (_error) {\n      if (this.isOwnerOnboardingError(_error)) {\n        this.handleOwnerOnboardingBlock(_error);\n      }\n\n      throw _error instanceof Error\n        ? _error\n        : new Error('No pudimos iniciar el pago con Mercado Pago.');\n    }\n  }\n\n  private isOwnerOnboardingError(\n    error: unknown,\n  ): error is Error & { code?: string; meta?: unknown } {\n    return (\n      !!error &&\n      typeof error === 'object' &&\n      'code' in error &&\n      (error as { code?: string }).code === 'OWNER_ONBOARDING_REQUIRED'\n    );\n  }\n\n  private handleOwnerOnboardingBlock(_error: Error & { code?: string; meta?: unknown }): never {\n    const message =\n      _error.message ||\n      'El propietario todavía no completó la vinculación de Mercado Pago. Tu reserva quedará pendiente y te avisaremos cuando pueda cobrar.';\n    this.state.setStatus('owner_onboarding_blocked');\n    this.state.setMessage(message);\n    throw _error;\n  }\n\n  private async scheduleRiskSnapshot(\n    booking: Booking,\n    method: BookingPaymentMethod,\n  ): Promise<void> {\n    const bucket = this.state.getBucket();\n    if (!bucket) {\n      return;\n    }\n\n    const franchise = this.state.getFranchiseInfo();\n    if (!franchise) {\n      return;\n    }\n\n    const guarantee = this.riskCalculator.calculateGuarantee({\n      booking,\n      franchise,\n      fxSnapshot: this.state.getFxSnapshot(),\n      paymentMethod: method,\n      walletSplit: this.state.getWalletSplit(),\n    });\n\n    const request$ = this.fgoService\n      .createRiskSnapshot({\n        bookingId: booking.id,\n        countryCode: 'AR',\n        bucket,\n        fxSnapshot: this.state.getFxSnapshot(),\n        currency: booking.currency as 'USD' | 'ARS',\n        estimatedHoldAmount: guarantee.holdUsd,\n        estimatedDeposit: guarantee.creditSecurityUsd,\n        franchiseUsd: guarantee.franchiseStandardUsd,\n        hasCard: method === 'credit_card' || method === 'partial_wallet',\n        hasWalletSecurity: method === 'wallet' || method === 'partial_wallet',\n      })\n      .pipe(\n        timeout({ each: 10_000 }),\n        catchError((_error) => {\n          return of(null);\n        }),\n      );\n\n    await firstValueFrom(request$);\n  }\n\n  /**\n   * Unlock wallet funds with retry logic and proper error handling\n   *\n   * ✅ P0-002 FIX: Wallet unlock con retry automático y alertas\n   *\n   * Features:\n   * - 3 retry attempts con exponential backoff (1s, 2s, 4s)\n   * - Logging detallado de cada intento\n   * - Alertas críticas a Sentry si falla completamente\n   * - Registro en DB para background job retry\n   *\n   * @param bookingId - ID de la reserva\n   * @param reason - Razón del unlock\n   */\n  private async safeUnlockWallet(bookingId: string, reason: string): Promise<void> {\n    const maxRetries = 3;\n    let lastError: unknown;\n\n    for (let attempt = 1; attempt <= maxRetries; attempt++) {\n      try {\n        this.logger.info(`Attempting wallet unlock (attempt ${attempt}/${maxRetries})`, {\n          bookingId,\n          reason,\n          attempt,\n        });\n\n        await firstValueFrom(this.wallet.unlockFunds(bookingId, reason));\n\n        this.logger.info('Wallet unlocked successfully', {\n          bookingId,\n          reason,\n          attempt,\n          totalAttempts: attempt,\n        });\n\n        return; // ✅ Success - exit\n      } catch (error) {\n        lastError = error;\n\n        this.logger.warn(`Wallet unlock failed (attempt ${attempt}/${maxRetries})`, {\n          bookingId,\n          reason,\n          attempt,\n          error: error instanceof Error ? error.message : String(error),\n        });\n\n        // Si no es el último intento, esperar con exponential backoff\n        if (attempt < maxRetries) {\n          const delayMs = Math.pow(2, attempt - 1) * 1000; // 1s, 2s, 4s\n          await this.delay(delayMs);\n        }\n      }\n    }\n\n    // ❌ Si llegamos aquí, fallaron todos los reintentos\n    await this.handleUnlockFailure(bookingId, reason, lastError);\n  }\n\n  /**\n   * Handle critical wallet unlock failure after all retries exhausted\n   *\n   * Actions:\n   * 1. Log critical error to Sentry\n   * 2. Create payment issue record in DB for manual review\n   * 3. Attempt to schedule background retry job\n   *\n   * @param bookingId - ID de la reserva\n   * @param reason - Razón del unlock\n   * @param error - Error que causó el fallo\n   */\n  private async handleUnlockFailure(\n    bookingId: string,\n    reason: string,\n    error: unknown,\n  ): Promise<void> {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    const errorStack = error instanceof Error ? error.stack : undefined;\n\n    // 1. ❌ CRITICAL LOG - Alerta a Sentry con máxima prioridad\n    this.logger.critical(\n      'CRITICAL: Wallet unlock failed completely after all retries',\n      error instanceof Error ? error : new Error(`Wallet unlock failed: ${errorMessage}`),\n    );\n\n    // 2. Log detallado para debugging\n    this.logger.error('Wallet unlock failure details', {\n      bookingId,\n      reason,\n      error: errorMessage,\n      stack: errorStack,\n      timestamp: new Date().toISOString(),\n      severity: 'CRITICAL',\n      impact: 'FUNDS_LOCKED',\n      userImpact: 'User funds may be permanently locked',\n      actionRequired: 'IMMEDIATE_MANUAL_INTERVENTION',\n    });\n\n    // 3. Guardar en tabla payment_issues para background retry\n    try {\n      await this.bookings.createPaymentIssue({\n        booking_id: bookingId,\n        issue_type: 'wallet_unlock_failed',\n        severity: 'critical',\n        description: `Failed to unlock wallet funds after ${3} retry attempts`,\n        metadata: {\n          reason,\n          error: errorMessage,\n          stack: errorStack,\n          timestamp: new Date().toISOString(),\n          retry_count: 3,\n        },\n        status: 'pending_review',\n      });\n\n      this.logger.info('Payment issue created for manual review', {\n        bookingId,\n        issueType: 'wallet_unlock_failed',\n      });\n    } catch (issueError) {\n      // Si falla la creación de issue, al menos logueamos\n      this.logger.error('Failed to create payment issue record', {\n        bookingId,\n        originalError: errorMessage,\n        issueCreationError: issueError instanceof Error ? issueError.message : String(issueError),\n      });\n    }\n\n    // ⚠️ NO lanzamos error porque no queremos bloquear el flujo principal\n    // El usuario ya vio el error del pago/cancelación\n    // El equipo de soporte recibirá la alerta de Sentry\n  }\n\n  /**\n   * Utility: Delay execution for specified milliseconds\n   */\n  private delay(ms: number): Promise<void> {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n  }\n\n  private formatUsd(amount: number): string {\n    const fractionDigits = Number.isInteger(amount) ? 0 : 2;\n    return new Intl.NumberFormat('es-AR', {\n      style: 'currency',\n      currency: 'USD',\n      minimumFractionDigits: fractionDigits,\n      maximumFractionDigits: fractionDigits,\n    }).format(amount);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/features/bookings/checkout/state/checkout-state.service.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`../../../../core/models` import should occur after import of `@core/services/verification/fgo-v1-1.service`","line":4,"column":1,"nodeType":"ImportDeclaration","endLine":4,"endColumn":51,"fix":{"range":[159,527],"text":"import { BookingPaymentMethod } from '../../../../core/models/wallet.model';\nimport { BookingsService } from '@core/services/bookings/bookings.service';\nimport { ExchangeRateService } from '@core/services/payments/exchange-rate.service';\nimport { FgoV1_1Service } from '@core/services/verification/fgo-v1-1.service';\nimport { Booking } from '../../../../core/models';\n"}},{"ruleId":"import/order","severity":1,"message":"`../../../../core/models/wallet.model` import should occur after import of `@core/services/verification/fgo-v1-1.service`","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":77,"fix":{"range":[210,527],"text":"import { BookingsService } from '@core/services/bookings/bookings.service';\nimport { ExchangeRateService } from '@core/services/payments/exchange-rate.service';\nimport { FgoV1_1Service } from '@core/services/verification/fgo-v1-1.service';\nimport { BookingPaymentMethod } from '../../../../core/models/wallet.model';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import { Injectable, computed, effect, signal } from '@angular/core';\nimport { firstValueFrom } from 'rxjs';\nimport { ActivatedRoute } from '@angular/router';\nimport { Booking } from '../../../../core/models';\nimport { BookingPaymentMethod } from '../../../../core/models/wallet.model';\nimport { BookingsService } from '@core/services/bookings/bookings.service';\nimport { ExchangeRateService } from '@core/services/payments/exchange-rate.service';\nimport { FgoV1_1Service } from '@core/services/verification/fgo-v1-1.service';\nimport { BucketType, FgoParameters } from '../../../../core/models/fgo-v1-1.model';\nimport { FranchiseInfo, FranchiseTableService } from '../support/franchise-table.service';\nimport { GuaranteeCopy, GuaranteeCopyBuilder } from '../support/guarantee-copy.builder';\nimport { CheckoutRiskCalculator, GuaranteeBreakdown } from '../support/risk-calculator';\n\n@Injectable()\nexport class CheckoutStateService {\n  private readonly bookingId = signal<string | null>(null);\n  private readonly booking = signal<Booking | null>(null);\n  private readonly fgoParams = signal<FgoParameters | null>(null);\n  private readonly exchangeRate = signal<number | null>(null);\n  private readonly paymentMethod = signal<BookingPaymentMethod>('credit_card');\n  private readonly walletSplit = signal<{ wallet: number; card: number }>({ wallet: 0, card: 0 });\n\n  readonly loading = signal(false);\n  readonly message = signal<string | null>(null);\n  readonly status = signal<string>('requires_payment_method');\n  readonly fgoLoading = signal(false);\n  readonly fxLoading = signal(false);\n\n  readonly bookingSignal = this.booking.asReadonly();\n  readonly statusSignal = this.status.asReadonly();\n  readonly messageSignal = this.message.asReadonly();\n  readonly paymentMethodSignal = this.paymentMethod.asReadonly();\n  readonly walletSplitSignal = this.walletSplit.asReadonly();\n  readonly loadingSignal = this.loading.asReadonly();\n\n  constructor(\n    private readonly route: ActivatedRoute,\n    private readonly bookings: BookingsService,\n    private readonly exchangeRates: ExchangeRateService,\n    private readonly fgoService: FgoV1_1Service,\n    private readonly franchiseTable: FranchiseTableService,\n    private readonly copyBuilder: GuaranteeCopyBuilder,\n    private readonly riskCalculator: CheckoutRiskCalculator,\n  ) {\n    effect(() => {\n      const booking = this.booking();\n      if (!booking) {\n        return;\n      }\n\n      // Sync selección con método real de la reserva si aún no hay override manual.\n      if (\n        this.paymentMethod() === 'credit_card' &&\n        booking.payment_method &&\n        booking.payment_method !== 'credit_card'\n      ) {\n        this.paymentMethod.set(booking.payment_method);\n      }\n    });\n  }\n\n  readonly bucket = computed<BucketType | null>(() => {\n    const booking = this.booking();\n    if (!booking) return null;\n    return this.franchiseTable.determineBucket(booking);\n  });\n\n  readonly fxSnapshot = computed(() => this.exchangeRate() ?? 1);\n\n  readonly franchise = computed(() => {\n    const booking = this.booking();\n    if (!booking) return null;\n    return this.franchiseTable.getFranchiseForBooking(booking);\n  });\n\n  readonly guarantee = computed(() => {\n    const booking = this.booking();\n    const franchise = this.franchise();\n    if (!booking || !franchise) return null;\n    return this.riskCalculator.calculateGuarantee({\n      booking,\n      franchise,\n      fxSnapshot: this.fxSnapshot(),\n      paymentMethod: this.paymentMethod(),\n      walletSplit: this.walletSplit(),\n    });\n  });\n\n  readonly guaranteeCopy = computed(() => {\n    const booking = this.booking();\n    const guarantee = this.guarantee();\n    if (!booking || !guarantee) return null;\n    return this.copyBuilder.buildGuaranteeCopy(booking, guarantee);\n  });\n\n  readonly depositUsd = computed(() => {\n    const booking = this.booking();\n    if (!booking) return 0;\n\n    const depositFromBooking = this.getDepositFromBooking(booking);\n    const recommended = this.recommendByNightlyRate(booking);\n    const franchise = this.franchise();\n\n    const walletFloor = (() => {\n      if (!franchise) return 0;\n      const method = this.paymentMethod();\n      if (method === 'wallet' || method === 'partial_wallet') {\n        return franchise.walletCreditUsd;\n      }\n      return 0;\n    })();\n\n    return Math.max(depositFromBooking, recommended, walletFloor);\n  });\n\n  readonly depositArs = computed(() => this.depositUsd() * this.fxSnapshot());\n\n  getBooking(): Booking | null {\n    return this.booking();\n  }\n\n  getBookingId(): string | null {\n    return this.bookingId();\n  }\n\n  getPaymentMethod(): BookingPaymentMethod {\n    return this.paymentMethod();\n  }\n\n  getDepositUsd(): number {\n    return this.depositUsd();\n  }\n\n  getDepositArs(): number {\n    return this.depositArs();\n  }\n\n  getBucket(): BucketType | null {\n    return this.bucket();\n  }\n\n  getFgoParameters(): FgoParameters | null {\n    return this.fgoParams();\n  }\n\n  getFxSnapshot(): number {\n    return this.fxSnapshot();\n  }\n\n  getFranchiseInfo(): FranchiseInfo | null {\n    return this.franchise();\n  }\n\n  getGuarantee(): GuaranteeBreakdown | null {\n    return this.guarantee();\n  }\n\n  getGuaranteeCopy(): GuaranteeCopy | null {\n    return this.guaranteeCopy();\n  }\n\n  getWalletSplit(): { wallet: number; card: number } {\n    return this.walletSplit();\n  }\n\n  setMessage(message: string | null): void {\n    this.message.set(message);\n  }\n\n  setStatus(status: string): void {\n    this.status.set(status);\n  }\n\n  setPaymentSelection(\n    method: BookingPaymentMethod,\n    walletAmount: number,\n    cardAmount: number,\n  ): void {\n    this.paymentMethod.set(method);\n    this.walletSplit.set({ wallet: walletAmount, card: cardAmount });\n  }\n\n  async initialize(): Promise<void> {\n    const routeBookingId = this.route.snapshot.paramMap.get('bookingId');\n    if (!routeBookingId) {\n      this.message.set('Reserva no encontrada');\n      return;\n    }\n\n    this.bookingId.set(routeBookingId);\n    await this.loadBooking(routeBookingId);\n    await Promise.all([this.loadFgoParameters(), this.loadExchangeRate()]);\n  }\n\n  private async loadBooking(bookingId: string): Promise<void> {\n    try {\n      this.loading.set(true);\n      const booking = await this.bookings.getBookingById(bookingId);\n      if (!booking) {\n        throw new Error('Reserva no encontrada');\n      }\n\n      this.booking.set(booking);\n      if (booking.payment_method) {\n        this.paymentMethod.set(booking.payment_method);\n      }\n    } catch {\n      this.message.set('No pudimos cargar la reserva.');\n    } finally {\n      this.loading.set(false);\n    }\n  }\n\n  private async loadFgoParameters(): Promise<void> {\n    const booking = this.booking();\n    if (!booking) return;\n\n    try {\n      this.fgoLoading.set(true);\n      const bucket = this.franchiseTable.determineBucket(booking);\n      const params = await firstValueFrom(this.fgoService.getParameters('AR', bucket));\n      this.fgoParams.set(params);\n    } catch {\n      this.fgoParams.set(null);\n    } finally {\n      this.fgoLoading.set(false);\n    }\n  }\n\n  private async loadExchangeRate(): Promise<void> {\n    const booking = this.booking();\n    if (!booking || booking.currency === 'USD') {\n      this.exchangeRate.set(1);\n      return;\n    }\n\n    try {\n      this.fxLoading.set(true);\n      const rate = await this.exchangeRates.getPlatformRate();\n      this.exchangeRate.set(rate);\n    } catch {\n      this.exchangeRate.set(1);\n    } finally {\n      this.fxLoading.set(false);\n    }\n  }\n\n  private getDepositFromBooking(booking: Booking): number {\n    const depositCents = booking.deposit_amount_cents ?? booking.breakdown?.deposit_cents ?? null;\n    return depositCents ? depositCents / 100 : 0;\n  }\n\n  private recommendByNightlyRate(booking: Booking): number {\n    const nightlyRateCents =\n      booking.breakdown?.nightly_rate_cents ?? booking.nightly_rate_cents ?? null;\n    if (!nightlyRateCents) {\n      return 300;\n    }\n    const nightlyRate = nightlyRateCents / 100;\n\n    if (nightlyRate < 80) return 300;\n    if (nightlyRate < 120) return 400;\n    if (nightlyRate < 180) return 600;\n    return 900;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/features/bookings/claims/my-claims.page.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`@core/services/infrastructure/notification-manager.service` import should occur before import of `../../../core/models/insurance.model`","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":8,"endColumn":105,"fix":{"range":[359,535],"text":"import { NotificationManagerService } from '@core/services/infrastructure/notification-manager.service';\nimport { InsuranceClaim } from '../../../core/models/insurance.model';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import {Component, OnInit, inject, signal, computed,\n  ChangeDetectionStrategy, DestroyRef} from '@angular/core';\nimport { takeUntilDestroyed } from '@angular/core/rxjs-interop';\nimport { CommonModule } from '@angular/common';\nimport { Router, RouterLink } from '@angular/router';\nimport { InsuranceService } from '@core/services/bookings/insurance.service';\nimport { InsuranceClaim } from '../../../core/models/insurance.model';\nimport { NotificationManagerService } from '@core/services/infrastructure/notification-manager.service';\n\n/**\n * MyClaimsPage\n *\n * Dashboard de siniestros reportados por el usuario.\n *\n * Características:\n * - Lista de todos los siniestros del usuario\n * - Filtros por estado (todos, pending, investigating, approved, rejected, closed)\n * - Vista rápida del estado y detalles\n * - Navegación a detalle de claim\n * - Indicadores visuales por tipo y estado\n *\n * Ruta: /bookings/claims\n */\n@Component({\n  selector: 'app-my-claims',\n  standalone: true,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  imports: [CommonModule, RouterLink],\n  templateUrl: './my-claims.page.html',\n  styleUrls: ['./my-claims.page.css'],\n})\nexport class MyClaimsPage implements OnInit {\n  private readonly router = inject(Router);\n  private readonly insuranceService = inject(InsuranceService);\n  private readonly toastService = inject(NotificationManagerService);\n  private readonly destroyRef = inject(DestroyRef);\n\n  readonly claims = signal<InsuranceClaim[]>([]);\n  readonly loading = signal(true);\n  readonly filterStatus = signal<InsuranceClaim['status'] | 'all'>('all');\n\n  // Computed: Claims filtrados\n  readonly filteredClaims = computed(() => {\n    const allClaims = this.claims();\n    const filter = this.filterStatus();\n\n    if (filter === 'all') {\n      return allClaims;\n    }\n\n    return allClaims.filter((c) => c.status === filter);\n  });\n\n  readonly hasClaims = computed(() => this.filteredClaims().length > 0);\n\n  // Stats\n  readonly stats = computed(() => {\n    const allClaims = this.claims();\n    return {\n      total: allClaims.length,\n      pending: allClaims.filter((c) => c.status === 'pending').length,\n      investigating: allClaims.filter((c) => c.status === 'investigating').length,\n      approved: allClaims.filter((c) => c.status === 'approved').length,\n      rejected: allClaims.filter((c) => c.status === 'rejected').length,\n      closed: allClaims.filter((c) => c.status === 'closed').length,\n    };\n  });\n\n  // Filter options\n  readonly statusFilters = [\n    { value: 'all' as const, label: 'Todos', icon: '📋' },\n    { value: 'pending' as const, label: 'Pendientes', icon: '⏳' },\n    { value: 'investigating' as const, label: 'En Investigación', icon: '🔍' },\n    { value: 'approved' as const, label: 'Aprobados', icon: '✅' },\n    { value: 'rejected' as const, label: 'Rechazados', icon: '❌' },\n    { value: 'closed' as const, label: 'Cerrados', icon: '🔒' },\n  ];\n\n  async ngOnInit() {\n    await this.loadClaims();\n  }\n\n  async loadClaims() {\n    this.loading.set(true);\n    try {\n      this.insuranceService.getMyClaims().pipe(\n        takeUntilDestroyed(this.destroyRef)\n      ).subscribe({\n        next: (claims) => {\n          this.claims.set(claims);\n          this.loading.set(false);\n        },\n        error: (error) => {\n          console.error('Error loading claims:', error);\n          this.toastService.error('Error al cargar siniestros', '');\n          this.loading.set(false);\n        },\n      });\n    } catch (error) {\n      console.error('Error loading claims:', error);\n      this.toastService.error('Error al cargar siniestros', '');\n      this.loading.set(false);\n    }\n  }\n\n  setFilter(status: InsuranceClaim['status'] | 'all') {\n    this.filterStatus.set(status);\n  }\n\n  viewClaim(claimId: string) {\n    this.router.navigate(['/bookings/claims', claimId]);\n  }\n\n  reportNewClaim() {\n    // Navigate to booking selection or ask which booking\n    this.router.navigate(['/bookings']);\n    this.toastService.info('Siniestros', 'Selecciona una reserva para reportar un siniestro');\n  }\n\n  getStatusColor(status: InsuranceClaim['status']): string {\n    switch (status) {\n      case 'pending':\n        return 'status-pending';\n      case 'investigating':\n        return 'status-investigating';\n      case 'approved':\n        return 'status-approved';\n      case 'rejected':\n        return 'status-rejected';\n      case 'closed':\n        return 'status-closed';\n      default:\n        return '';\n    }\n  }\n\n  getStatusLabel(status: InsuranceClaim['status']): string {\n    switch (status) {\n      case 'pending':\n        return 'Pendiente';\n      case 'investigating':\n        return 'En Investigación';\n      case 'approved':\n        return 'Aprobado';\n      case 'rejected':\n        return 'Rechazado';\n      case 'closed':\n        return 'Cerrado';\n      default:\n        return status;\n    }\n  }\n\n  getClaimTypeLabel(type: InsuranceClaim['claim_type']): string {\n    const labels: Record<string, string> = {\n      collision: 'Colisión',\n      theft: 'Robo',\n      vandalism: 'Vandalismo',\n      natural_disaster: 'Desastre Natural',\n      fire: 'Incendio',\n      glass_damage: 'Daño de Cristales',\n      other: 'Otro',\n    };\n    return labels[type] || type;\n  }\n\n  getClaimTypeIcon(type: InsuranceClaim['claim_type']): string {\n    const icons: Record<string, string> = {\n      collision: '🚗💥',\n      theft: '🚨',\n      vandalism: '🔨',\n      natural_disaster: '🌪️',\n      fire: '🔥',\n      glass_damage: '🪟',\n      other: '📋',\n    };\n    return icons[type] || '📋';\n  }\n\n  formatDate(date: string): string {\n    return new Date(date).toLocaleDateString('es-AR', {\n      day: '2-digit',\n      month: 'short',\n      year: 'numeric',\n      hour: '2-digit',\n      minute: '2-digit',\n    });\n  }\n\n  formatCurrency(cents: number): string {\n    return new Intl.NumberFormat('es-AR', {\n      style: 'currency',\n      currency: 'ARS',\n      minimumFractionDigits: 0,\n    }).format(cents / 100);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/features/bookings/components/booking-dates-step/booking-dates-step.component.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`@core/services/cars/car-availability.service` import should occur before import of `../../../../shared/components/date-range-picker/date-range-picker.component`","line":22,"column":1,"nodeType":"ImportDeclaration","endLine":22,"endColumn":87,"fix":{"range":[312,770],"text":"import { CarAvailabilityService } from '@core/services/cars/car-availability.service';\nimport { DateRangePickerComponent } from '../../../../shared/components/date-range-picker/date-range-picker.component';\nimport { BookingLocationFormComponent } from '../../components/booking-location-form/booking-location-form.component';\n\nimport { BookingWizardData } from '../../pages/booking-wizard/booking-wizard.page';\nimport { Car } from '../../../../core/models';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import {\n  ChangeDetectionStrategy,\n  Component,\n  Input,\n  Output,\n  EventEmitter,\n  signal,\n  computed,\n  OnInit,\n  inject,\n} from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { FormsModule } from '@angular/forms';\nimport { IonicModule } from '@ionic/angular';\n\n// Shared Components\nimport { DateRangePickerComponent } from '../../../../shared/components/date-range-picker/date-range-picker.component';\nimport { BookingLocationFormComponent } from '../../components/booking-location-form/booking-location-form.component';\n\nimport { BookingWizardData } from '../../pages/booking-wizard/booking-wizard.page';\nimport { Car } from '../../../../core/models';\nimport { CarAvailabilityService } from '@core/services/cars/car-availability.service';\nimport type { BlockedDateRange } from '../../../../shared/components/date-range-picker/date-range-picker.component';\n\ninterface LocationData {\n  address: string;\n  lat: number;\n  lng: number;\n}\n\n@Component({\n  selector: 'app-booking-dates-step',\n  standalone: true,\n  imports: [\n    CommonModule,\n    FormsModule,\n    IonicModule,\n    DateRangePickerComponent,\n    BookingLocationFormComponent,\n  ],\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  templateUrl: './booking-dates-step.component.html',\n  styleUrls: ['./booking-dates-step.component.scss'],\n})\nexport class BookingDatesStepComponent implements OnInit {\n  @Input() car: Car | null = null;\n  @Input() data: BookingWizardData | null = null;\n  @Output() dataChange = new EventEmitter<Partial<BookingWizardData>>();\n\n  private readonly availabilityService = inject(CarAvailabilityService);\n\n  startDate = signal<Date | null>(null);\n  endDate = signal<Date | null>(null);\n  pickupLocation = signal<LocationData | null>(null);\n  dropoffLocation = signal<LocationData | null>(null);\n  sameLocation = signal(true);\n  blockedRanges = signal<BlockedDateRange[]>([]);\n  handoverPoints = signal<\n    { address: string; lat: number; lng: number; label?: string; radius_m?: number | null }[]\n  >([]);\n\n  // Computed values\n  totalDays = computed(() => {\n    const start = this.startDate();\n    const end = this.endDate();\n    if (!start || !end) return 0;\n    const diff = end.getTime() - start.getTime();\n    return Math.ceil(diff / (1000 * 60 * 60 * 24));\n  });\n\n  estimatedPrice = computed(() => {\n    const days = this.totalDays();\n    if (!days || !this.car) return 0;\n    return days * (this.car.price_per_day || 0);\n  });\n\n  // Minimum date for date picker (today)\n  readonly minDate = new Date();\n\n  canProceed = computed(() => {\n    return (\n      this.startDate() !== null &&\n      this.endDate() !== null &&\n      this.pickupLocation() !== null &&\n      (!this.sameLocation() ? this.dropoffLocation() !== null : true)\n    );\n  });\n\n  ngOnInit() {\n    if (this.data) {\n      this.startDate.set(this.data.startDate);\n      this.endDate.set(this.data.endDate);\n      this.pickupLocation.set(this.data.pickupLocation);\n      this.dropoffLocation.set(this.data.dropoffLocation);\n\n      // If dropoff is different from pickup, set sameLocation to false\n      if (this.data.pickupLocation && this.data.dropoffLocation) {\n        this.sameLocation.set(\n          this.data.pickupLocation.address === this.data.dropoffLocation.address,\n        );\n      }\n    }\n\n    // Cargar blackouts del auto para bloquear fechas no disponibles\n    void this.loadBlackouts();\n    // Cargar puntos de entrega del auto\n    void this.loadHandoverPoints();\n  }\n\n  onDateRangeChange(dateRange: { from: string | null; to: string | null }) {\n    // P0-029 FIX: Validate dates are not in the past\n    const today = new Date();\n    today.setHours(0, 0, 0, 0); // Reset time to start of day for comparison\n\n    const startDate = dateRange.from ? new Date(dateRange.from) : null;\n    const endDate = dateRange.to ? new Date(dateRange.to) : null;\n\n    // Validate start date is not in the past\n    if (startDate && startDate < today) {\n      console.warn('[P0-029] Start date cannot be in the past');\n      this.startDate.set(null);\n      this.endDate.set(null);\n      alert('La fecha de inicio no puede ser en el pasado');\n      return;\n    }\n\n    // Validate end date is after start date and not in the past\n    if (endDate) {\n      if (endDate < today) {\n        console.warn('[P0-029] End date cannot be in the past');\n        this.endDate.set(null);\n        alert('La fecha de fin no puede ser en el pasado');\n        return;\n      }\n      if (startDate && endDate <= startDate) {\n        console.warn('[P0-029] End date must be after start date');\n        this.endDate.set(null);\n        alert('La fecha de fin debe ser posterior a la fecha de inicio');\n        return;\n      }\n    }\n\n    this.startDate.set(startDate);\n    this.endDate.set(endDate);\n    this.emitChanges();\n  }\n\n  onPickupLocationChange(location: LocationData) {\n    this.pickupLocation.set(location);\n\n    // If same location checkbox is checked, copy to dropoff\n    if (this.sameLocation()) {\n      this.dropoffLocation.set(location);\n    }\n\n    this.emitChanges();\n  }\n\n  onDropoffLocationChange(location: LocationData) {\n    this.dropoffLocation.set(location);\n    this.emitChanges();\n  }\n\n  onSameLocationToggle() {\n    if (this.sameLocation()) {\n      // Copy pickup to dropoff\n      this.dropoffLocation.set(this.pickupLocation());\n    } else {\n      // Clear dropoff\n      this.dropoffLocation.set(null);\n    }\n    this.emitChanges();\n  }\n\n  private emitChanges() {\n    this.dataChange.emit({\n      startDate: this.startDate(),\n      endDate: this.endDate(),\n      pickupLocation: this.pickupLocation(),\n      dropoffLocation: this.sameLocation() ? this.pickupLocation() : this.dropoffLocation(),\n    });\n  }\n\n  private async loadBlackouts(): Promise<void> {\n    if (!this.car?.id) return;\n    try {\n      const blackouts = await this.availabilityService.getBlackouts(this.car.id);\n      const ranges: BlockedDateRange[] = blackouts.map((b) => ({\n        from: b.starts_at.split('T')[0],\n        to: b.ends_at.split('T')[0],\n      }));\n      this.blockedRanges.set(ranges);\n    } catch (error) {\n      // No bloquear el flujo si falla; solo log en consola\n      console.warn('blackouts-load', error);\n    }\n  }\n\n  private async loadHandoverPoints(): Promise<void> {\n    if (!this.car?.id) return;\n    try {\n      const points = await this.availabilityService.getHandoverPoints(this.car.id);\n      const mapped = points.map((p) => ({\n        address: p.kind,\n        lat: p.lat,\n        lng: p.lng,\n        label: p.kind,\n        radius_m: p.radius_m,\n      }));\n      this.handoverPoints.set(mapped);\n    } catch (error) {\n      console.warn('handover-points-load', error);\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/features/bookings/contracts/contracts-management.page.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`../../../core/models` import should occur after import of `@core/services/bookings/contracts.service`","line":7,"column":1,"nodeType":"ImportDeclaration","endLine":7,"endColumn":48,"fix":{"range":[249,468],"text":"import { BookingsService } from '@core/services/bookings/bookings.service';\nimport { BookingContract, ContractsService } from '@core/services/bookings/contracts.service';\nimport { Booking } from '../../../core/models';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"\nimport {Component, inject, OnInit, signal,\n  ChangeDetectionStrategy} from '@angular/core';\nimport { FormsModule } from '@angular/forms';\nimport { ActivatedRoute, RouterModule } from '@angular/router';\nimport { IonicModule } from '@ionic/angular';\nimport { Booking } from '../../../core/models';\nimport { BookingsService } from '@core/services/bookings/bookings.service';\nimport { BookingContract, ContractsService } from '@core/services/bookings/contracts.service';\n\n@Component({\n  selector: 'app-contracts-management',\n  standalone: true,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  imports: [FormsModule, IonicModule, RouterModule],\n  templateUrl: './contracts-management.page.html',\n  styleUrls: ['./contracts-management.page.scss'],\n})\nexport class ContractsManagementPage implements OnInit {\n  private readonly contractsService = inject(ContractsService);\n  private readonly bookingsService = inject(BookingsService);\n  private readonly route = inject(ActivatedRoute);\n\n  readonly loading = signal(false);\n  readonly contracts = signal<Array<BookingContract & { booking?: Booking }>>([]);\n  readonly selectedBookingId = signal<string | null>(null);\n  readonly showCreateModal = signal(false);\n  readonly error = signal<string | null>(null);\n  readonly success = signal<string | null>(null);\n\n  readonly newContract = signal({\n    bookingId: '',\n    termsVersion: '1.0',\n    pdfUrl: '',\n  });\n\n  async ngOnInit(): Promise<void> {\n    const bookingId = this.route.snapshot.queryParams['bookingId'];\n    if (bookingId) {\n      this.selectedBookingId.set(bookingId);\n      await this.loadContractForBooking(bookingId);\n    } else {\n      await this.loadAllContracts();\n    }\n  }\n\n  async loadAllContracts(): Promise<void> {\n    this.loading.set(true);\n    this.error.set(null);\n\n    try {\n      // Obtener todos los bookings con contratos\n      const { bookings } = await this.bookingsService.getMyBookings();\n      if (!bookings) {\n        this.contracts.set([]);\n        return;\n      }\n\n      const contractsWithBookings = await Promise.all(\n        bookings.map(async (booking: Booking) => {\n          try {\n            const contract = await this.contractsService.getContractByBooking(booking.id);\n            return contract ? { ...contract, booking: booking || undefined } : null;\n          } catch {\n            return null;\n          }\n        }),\n      );\n\n      this.contracts.set(\n        contractsWithBookings.filter((c) => c !== null) as Array<\n          BookingContract & { booking?: Booking }\n        >,\n      );\n    } catch (err) {\n      console.error('Error loading contracts:', err);\n      this.error.set('Error al cargar contratos');\n    } finally {\n      this.loading.set(false);\n    }\n  }\n\n  async loadContractForBooking(bookingId: string): Promise<void> {\n    this.loading.set(true);\n    this.error.set(null);\n\n    try {\n      const contract = await this.contractsService.getContractByBooking(bookingId);\n      if (contract) {\n        const booking = await this.bookingsService.getBookingById(bookingId);\n        this.contracts.set([{ ...contract, booking: booking || undefined }]);\n      } else {\n        this.contracts.set([]);\n      }\n    } catch (err) {\n      console.error('Error loading contract:', err);\n      this.error.set('Error al cargar contrato');\n    } finally {\n      this.loading.set(false);\n    }\n  }\n\n  openCreateModal(): void {\n    this.showCreateModal.set(true);\n    this.newContract.set({\n      bookingId: this.selectedBookingId() || '',\n      termsVersion: '1.0',\n      pdfUrl: '',\n    });\n  }\n\n  closeCreateModal(): void {\n    this.showCreateModal.set(false);\n    this.newContract.set({\n      bookingId: '',\n      termsVersion: '1.0',\n      pdfUrl: '',\n    });\n  }\n\n  async createContract(): Promise<void> {\n    if (!this.newContract().bookingId) {\n      this.error.set('ID de booking es requerido');\n      return;\n    }\n\n    this.loading.set(true);\n    this.error.set(null);\n    this.success.set(null);\n\n    try {\n      const contract = await this.contractsService.prepareContract({\n        bookingId: this.newContract().bookingId,\n        termsVersion: this.newContract().termsVersion,\n        pdfUrl: this.newContract().pdfUrl || undefined,\n      });\n\n      this.success.set(`Contrato creado exitosamente: ${contract.id}`);\n      this.closeCreateModal();\n      await this.loadContractForBooking(contract.booking_id);\n    } catch (err) {\n      console.error('Error creating contract:', err);\n      this.error.set(err instanceof Error ? err.message : 'Error al crear contrato');\n    } finally {\n      this.loading.set(false);\n    }\n  }\n\n  async acceptContract(contractId: string): Promise<void> {\n    this.loading.set(true);\n    this.error.set(null);\n    this.success.set(null);\n\n    try {\n      await this.contractsService.acceptContract(contractId);\n      this.success.set('Contrato aceptado exitosamente');\n      await this.loadAllContracts();\n    } catch (err) {\n      console.error('Error accepting contract:', err);\n      this.error.set(err instanceof Error ? err.message : 'Error al aceptar contrato');\n    } finally {\n      this.loading.set(false);\n    }\n  }\n\n  getStatusBadgeColor(status: boolean): string {\n    return status ? 'success' : 'warning';\n  }\n\n  formatDate(date: string | null): string {\n    if (!date) return 'No aceptado';\n    return new Date(date).toLocaleDateString('es-AR', {\n      year: 'numeric',\n      month: 'long',\n      day: 'numeric',\n      hour: '2-digit',\n      minute: '2-digit',\n    });\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/features/bookings/disputes/disputes-management.page.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`../../../core/models` import should occur after import of `@core/services/infrastructure/supabase-client.service`","line":14,"column":1,"nodeType":"ImportDeclaration","endLine":14,"endColumn":48,"fix":{"range":[501,749],"text":"import { NotificationManagerService } from '@core/services/infrastructure/notification-manager.service';\nimport { SupabaseClientService } from '@core/services/infrastructure/supabase-client.service';\nimport { Booking } from '../../../core/models';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import {Component, OnInit, signal, inject,\n  ChangeDetectionStrategy} from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { FormsModule } from '@angular/forms';\nimport { IonicModule } from '@ionic/angular';\nimport { ActivatedRoute, Router, RouterModule } from '@angular/router';\nimport {\n  DisputesService,\n  Dispute,\n  DisputeEvidence,\n  DisputeKind,\n} from '@core/services/admin/disputes.service';\nimport { BookingsService } from '@core/services/bookings/bookings.service';\nimport { Booking } from '../../../core/models';\nimport { NotificationManagerService } from '@core/services/infrastructure/notification-manager.service';\nimport { SupabaseClientService } from '@core/services/infrastructure/supabase-client.service';\n\n@Component({\n  selector: 'app-disputes-management',\n  standalone: true,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  imports: [CommonModule, FormsModule, IonicModule, RouterModule],\n  templateUrl: './disputes-management.page.html',\n  styleUrls: ['./disputes-management.page.scss'],\n})\nexport class DisputesManagementPage implements OnInit {\n  private readonly disputesService = inject(DisputesService);\n  private readonly bookingsService = inject(BookingsService);\n  private readonly toastService = inject(NotificationManagerService);\n  private readonly supabaseService = inject(SupabaseClientService);\n  private readonly route = inject(ActivatedRoute);\n  private readonly router = inject(Router);\n\n  readonly bookingId = signal<string>('');\n  readonly booking = signal<Booking | null>(null);\n  readonly loading = signal(false);\n  readonly disputes = signal<Dispute[]>([]);\n  readonly selectedDispute = signal<Dispute | null>(null);\n  readonly showCreateModal = signal(false);\n  readonly showEvidenceModal = signal(false);\n  readonly evidence = signal<DisputeEvidence[]>([]);\n  readonly uploadingEvidence = signal(false);\n\n  readonly newDispute = signal({\n    kind: '' as DisputeKind | '',\n    description: '',\n  });\n\n  readonly evidenceFiles = signal<File[]>([]);\n  readonly evidenceNote = signal('');\n  readonly newComment = signal(''); // New signal for comment input\n\n  async ngOnInit(): Promise<void> {\n    const id = this.route.snapshot.paramMap.get('id');\n    if (!id) {\n      this.toastService.error('Error', 'ID de booking no encontrado');\n      await this.router.navigate(['/bookings']);\n      return;\n    }\n\n    this.bookingId.set(id);\n    await Promise.all([this.loadBooking(), this.loadDisputes()]);\n  }\n\n  async loadBooking(): Promise<void> {\n    try {\n      const booking = await this.bookingsService.getBookingById(this.bookingId());\n      this.booking.set(booking);\n    } catch (err) {\n      console.error('Error loading booking:', err);\n      this.toastService.error('Error', 'No se pudo cargar la reserva');\n    }\n  }\n\n  async loadDisputes(): Promise<void> {\n    this.loading.set(true);\n    try {\n      const disputesList = await this.disputesService.listByBooking(this.bookingId());\n      this.disputes.set(disputesList);\n    } catch (err) {\n      console.error('Error loading disputes:', err);\n      this.toastService.error('Error', 'No se pudieron cargar las disputas');\n    } finally {\n      this.loading.set(false);\n    }\n  }\n\n  openCreateModal(): void {\n    this.showCreateModal.set(true);\n    this.newDispute.set({ kind: '', description: '' });\n  }\n\n  closeCreateModal(): void {\n    this.showCreateModal.set(false);\n    this.newDispute.set({ kind: '', description: '' });\n    this.evidenceFiles.set([]);\n  }\n\n  async createDispute(): Promise<void> {\n    if (!this.newDispute().kind || !this.newDispute().description.trim()) {\n      this.toastService.error('Error', 'Debe completar todos los campos');\n      return;\n    }\n\n    this.loading.set(true);\n    try {\n      const dispute = await this.disputesService.createDispute({\n        bookingId: this.bookingId(),\n        kind: this.newDispute().kind as DisputeKind,\n        description: this.newDispute().description.trim(),\n      });\n\n      // Upload evidence if any\n      if (this.evidenceFiles().length > 0) {\n        await this.uploadEvidenceFiles(dispute.id);\n      }\n\n      this.toastService.success('Disputa creada exitosamente', '');\n      this.closeCreateModal();\n      await this.loadDisputes();\n    } catch (err) {\n      console.error('Error creating dispute:', err);\n      this.toastService.error(\n        'Error',\n        err instanceof Error ? err.message : 'Error al crear disputa',\n      );\n    } finally {\n      this.loading.set(false);\n    }\n  }\n\n  async openEvidenceModal(dispute: Dispute): Promise<void> {\n    this.selectedDispute.set(dispute);\n    this.loading.set(true);\n    try {\n      const evidenceList = await this.disputesService.listEvidence(dispute.id);\n      this.evidence.set(evidenceList);\n      this.showEvidenceModal.set(true);\n    } catch (err) {\n      console.error('Error loading evidence:', err);\n      this.toastService.error('Error', 'No se pudieron cargar las evidencias');\n    } finally {\n      this.loading.set(false);\n    }\n  }\n\n  closeEvidenceModal(): void {\n    this.showEvidenceModal.set(false);\n    this.selectedDispute.set(null);\n    this.evidence.set([]);\n    this.evidenceFiles.set([]);\n    this.evidenceNote.set('');\n    this.newComment.set(''); // Clear newComment when closing the modal\n  }\n\n  onEvidenceFilesSelected(event: Event): void {\n    const input = event.target as HTMLInputElement;\n    if (input.files) {\n      this.evidenceFiles.set(Array.from(input.files));\n    }\n  }\n\n  async uploadEvidenceFiles(disputeId: string): Promise<void> {\n    if (this.evidenceFiles().length === 0) return;\n\n    this.uploadingEvidence.set(true);\n    const supabase = this.supabaseService.getClient();\n\n    try {\n      for (const file of this.evidenceFiles()) {\n        // Upload to storage\n        const filePath = `disputes/${disputeId}/${Date.now()}_${file.name}`;\n        const { error: uploadError } = await supabase.storage\n          .from('documents')\n          .upload(filePath, file);\n\n        if (uploadError) {\n          console.error('Error uploading file:', uploadError);\n          continue;\n        }\n\n        // Get public URL\n        const { data: urlData } = supabase.storage.from('documents').getPublicUrl(filePath);\n\n        // Add evidence record\n        await this.disputesService.addEvidence(\n          disputeId,\n          urlData.publicUrl,\n          this.evidenceNote() || undefined,\n        );\n      }\n\n      this.toastService.success('Evidencias subidas exitosamente', '');\n      this.evidenceFiles.set([]);\n      this.evidenceNote.set('');\n      await this.loadDisputes();\n    } catch (err) {\n      console.error('Error uploading evidence:', err);\n      this.toastService.error('Error', 'Error al subir evidencias');\n    } finally {\n      this.uploadingEvidence.set(false);\n    }\n  }\n\n  async addEvidenceToSelectedDispute(): Promise<void> {\n    const dispute = this.selectedDispute();\n    if (!dispute) return;\n\n    await this.uploadEvidenceFiles(dispute.id);\n    await this.openEvidenceModal(dispute); // Reload evidence\n  }\n\n  async addCommentToSelectedDispute(): Promise<void> {\n    const dispute = this.selectedDispute();\n    const comment = this.newComment();\n\n    if (!dispute || !comment.trim()) {\n      this.toastService.error('Error', 'El comentario no puede estar vacío');\n      return;\n    }\n\n    this.uploadingEvidence.set(true); // Reusing this for loading state\n    try {\n      await this.disputesService.addEvidence(\n        dispute.id,\n        '', // Empty path for text-only comment\n        comment.trim()\n      );\n      this.toastService.success('Comentario agregado exitosamente', '');\n      this.newComment.set(''); // Clear comment input\n      await this.openEvidenceModal(dispute); // Reload evidence to show new comment\n    } catch (err) {\n      console.error('Error adding comment:', err);\n      this.toastService.error('Error', 'Error al agregar comentario');\n    } finally {\n      this.uploadingEvidence.set(false);\n    }\n  }\n\n  getStatusLabel(status: Dispute['status']): string {\n    const labels: Record<Dispute['status'], string> = {\n      open: 'Abierta',\n      in_review: 'En revisión',\n      resolved: 'Resuelta',\n      rejected: 'Rechazada',\n    };\n    return labels[status] || status;\n  }\n\n  getStatusColor(status: Dispute['status']): string {\n    switch (status) {\n      case 'open':\n        return 'warning';\n      case 'in_review':\n        return 'primary';\n      case 'resolved':\n        return 'success';\n      case 'rejected':\n        return 'danger';\n      default:\n        return 'medium';\n    }\n  }\n\n  getKindLabel(kind: Dispute['kind']): string {\n    const labels: Record<Dispute['kind'], string> = {\n      damage: 'Daños',\n      no_show: 'No se presentó',\n      late_return: 'Devolución tardía',\n      other: 'Otro',\n    };\n    return labels[kind] || kind;\n  }\n\n  formatDate(dateStr: string): string {\n    return new Date(dateStr).toLocaleDateString('es-AR', {\n      day: '2-digit',\n      month: '2-digit',\n      year: 'numeric',\n      hour: '2-digit',\n      minute: '2-digit',\n    });\n  }\n\n  isImage(path: string): boolean {\n    return /\\.(jpg|jpeg|png|gif|webp)$/i.test(path);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/features/bookings/my-bookings/my-bookings.page.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`../../../core/models` import should occur after import of `@core/services/ui/toast.service`","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":48,"fix":{"range":[309,497],"text":"import { BookingsService } from '@core/services/bookings/bookings.service';\nimport { ToastService } from '@core/services/ui/toast.service';\nimport { Booking } from '../../../core/models';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { CommonModule } from '@angular/common';\nimport { ChangeDetectionStrategy, Component, OnInit, computed, signal } from '@angular/core';\nimport { Router, RouterLink } from '@angular/router';\nimport { ScrollingModule } from '@angular/cdk/scrolling';\nimport { TranslateModule } from '@ngx-translate/core';\nimport { Booking } from '../../../core/models';\nimport { BookingsService } from '@core/services/bookings/bookings.service';\nimport { ToastService } from '@core/services/ui/toast.service';\nimport { IconComponent } from '../../../shared/components/icon/icon.component';\nimport { MoneyPipe } from '../../../shared/pipes/money.pipe';\nimport { formatDateRange } from '../../../shared/utils/date.utils';\n\ntype BookingStatusFilter =\n  | 'all'\n  | 'pending'\n  | 'confirmed'\n  | 'in_progress'\n  | 'completed'\n  | 'cancelled';\n\n// Section configuration for collapsible groups\ninterface BookingSection {\n  id: string;\n  title: string;\n  icon: string;\n  expanded: boolean;\n  priority: number;\n  statuses: string[];\n  accentClass: string;\n}\n\n@Component({\n  standalone: true,\n  selector: 'app-my-bookings-page',\n  imports: [\n    CommonModule,\n    MoneyPipe,\n    RouterLink,\n    ScrollingModule,\n    TranslateModule,\n    IconComponent,\n  ],\n  templateUrl: './my-bookings.page.html',\n  styleUrl: './my-bookings.page.css',\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class MyBookingsPage implements OnInit {\n  readonly bookings = signal<Booking[]>([]);\n  readonly loading = signal(false);\n  readonly error = signal<string | null>(null);\n  readonly statusFilter = signal<BookingStatusFilter>('all');\n\n  // Collapsible sections state\n  readonly sections = signal<BookingSection[]>([\n    {\n      id: 'action-required',\n      title: 'Requieren Acción',\n      icon: '⚠️',\n      expanded: true, // Always expanded by default\n      priority: 1,\n      statuses: ['pending'],\n      accentClass: 'border-l-amber-500 bg-amber-50 dark:bg-amber-950/20',\n    },\n    {\n      id: 'active',\n      title: 'Activas',\n      icon: '✅',\n      expanded: true,\n      priority: 2,\n      statuses: ['confirmed', 'in_progress'],\n      accentClass: 'border-l-green-500 bg-green-50 dark:bg-green-950/20',\n    },\n    {\n      id: 'history',\n      title: 'Historial',\n      icon: '📋',\n      expanded: false, // Collapsed by default\n      priority: 3,\n      statuses: ['completed', 'cancelled', 'expired'],\n      accentClass: 'border-l-gray-400 bg-gray-50 dark:bg-gray-900/20',\n    },\n  ]);\n\n  // Array tipado de filtros disponibles\n  readonly statusFilters: readonly BookingStatusFilter[] = [\n    'all',\n    'pending',\n    'confirmed',\n    'in_progress',\n    'completed',\n    'cancelled',\n  ] as const;\n\n  // Computed: Filtered bookings based on selected status\n  readonly filteredBookings = computed(() => {\n    const allBookings = this.bookings();\n    const filter = this.statusFilter();\n\n    if (filter === 'all') {\n      return allBookings;\n    }\n\n    return allBookings.filter((booking) => booking.status === filter);\n  });\n\n  // Computed: Bookings grouped by section (using effective status)\n  readonly bookingsBySection = computed(() => {\n    const allBookings = this.bookings();\n    const sectionList = this.sections();\n\n    return sectionList.map((section) => ({\n      ...section,\n      bookings: allBookings.filter((b) => section.statuses.includes(this.getEffectiveStatus(b))),\n      count: allBookings.filter((b) => section.statuses.includes(this.getEffectiveStatus(b))).length,\n    }));\n  });\n\n  // Computed: Count of bookings per status (using effective status)\n  readonly statusCounts = computed(() => {\n    const bookings = this.bookings();\n    return {\n      all: bookings.length,\n      pending: bookings.filter((b) => this.getEffectiveStatus(b) === 'pending').length,\n      confirmed: bookings.filter((b) => this.getEffectiveStatus(b) === 'confirmed').length,\n      in_progress: bookings.filter((b) => this.getEffectiveStatus(b) === 'in_progress').length,\n      completed: bookings.filter((b) => this.getEffectiveStatus(b) === 'completed').length,\n      expired: bookings.filter((b) => this.getEffectiveStatus(b) === 'expired').length,\n      cancelled: bookings.filter((b) => this.getEffectiveStatus(b) === 'cancelled').length,\n    };\n  });\n\n  // Computed: Summary stats for dashboard (using effective status)\n  readonly dashboardStats = computed(() => {\n    const counts = this.statusCounts();\n    return {\n      actionRequired: counts.pending, // Only truly pending (can still be paid)\n      active: counts.confirmed + counts.in_progress,\n      history: counts.completed + counts.cancelled + counts.expired, // Include expired\n      total: counts.all,\n    };\n  });\n\n  constructor(\n    private readonly bookingsService: BookingsService,\n    private readonly router: Router,\n    private readonly toastService: ToastService,\n  ) {}\n\n  ngOnInit(): void {\n    void this.loadBookings();\n  }\n\n  async loadBookings(): Promise<void> {\n    this.loading.set(true);\n    this.error.set(null);\n    try {\n      const { bookings } = await this.bookingsService.getMyBookings();\n      this.bookings.set(bookings);\n    } catch {\n      this.error.set('No pudimos cargar tus reservas. Por favor intentá de nuevo más tarde.');\n    } finally {\n      this.loading.set(false);\n    }\n  }\n\n  rangeLabel(booking: Booking): string {\n    return formatDateRange(booking.start_at, booking.end_at);\n  }\n\n  /**\n   * Determina el estado efectivo de una reserva.\n   * Si está pendiente pero la fecha de inicio ya pasó, se considera \"vencida\".\n   */\n  getEffectiveStatus(booking: Booking): string {\n    if (booking.status === 'pending' && this.isStartDatePassed(booking)) {\n      return 'expired';\n    }\n    return booking.status;\n  }\n\n  /**\n   * Verifica si la fecha de inicio de la reserva ya pasó\n   */\n  isStartDatePassed(booking: Booking): boolean {\n    if (!booking.start_at) return false;\n    const startDate = new Date(booking.start_at);\n    const now = new Date();\n    return startDate < now;\n  }\n\n  statusLabel(booking: Booking): string {\n    const effectiveStatus = this.getEffectiveStatus(booking);\n    switch (effectiveStatus) {\n      case 'pending':\n        // P2P flow: wallet bookings are awaiting owner approval, not payment\n        return this.isWalletBooking(booking) ? 'Esperando aprobación' : 'Pendiente de pago';\n      case 'confirmed':\n        return 'Aprobada';\n      case 'in_progress':\n        return 'En uso';\n      case 'completed':\n        return 'Finalizada';\n      case 'cancelled':\n        return 'Cancelada';\n      case 'expired':\n        return 'Vencida';\n      default:\n        return booking.status;\n    }\n  }\n\n  /**\n   * Check if booking uses wallet payment mode (P2P flow)\n   */\n  isWalletBooking(booking: Booking): boolean {\n    return booking.payment_mode === 'wallet';\n  }\n\n  statusHint(booking: Booking): string | null {\n    const effectiveStatus = this.getEffectiveStatus(booking);\n    switch (effectiveStatus) {\n      case 'pending':\n        // P2P flow: wallet bookings are awaiting owner approval\n        return this.isWalletBooking(booking)\n          ? 'El propietario está revisando tu solicitud. Te notificaremos cuando responda.'\n          : 'Completá el checkout para confirmar tu reserva.';\n      case 'confirmed':\n        return 'Tu reserva fue aprobada. Coordiná el check-in con el propietario.';\n      case 'completed':\n        return 'Gracias por viajar con nosotros.';\n      case 'cancelled':\n        return 'Se canceló esta reserva. Podés generar una nueva cuando quieras.';\n      case 'expired':\n        return this.isWalletBooking(booking)\n          ? 'La solicitud expiró sin respuesta del propietario.'\n          : 'La fecha de alquiler ya pasó sin completar el pago.';\n      default:\n        return null;\n    }\n  }\n\n  statusBannerClass(booking: Booking): string {\n    const effectiveStatus = this.getEffectiveStatus(booking);\n    switch (effectiveStatus) {\n      case 'pending':\n        return 'status-banner--pending';\n      case 'confirmed':\n      case 'in_progress':\n        return 'status-banner--success';\n      case 'completed':\n        return 'status-banner--neutral';\n      case 'cancelled':\n      case 'expired':\n        return 'status-banner--danger';\n      default:\n        return '';\n    }\n  }\n\n  statusBadgeClass(booking: Booking): string {\n    const effectiveStatus = this.getEffectiveStatus(booking);\n    switch (effectiveStatus) {\n      case 'pending':\n        return 'badge-warning';\n      case 'confirmed':\n        return 'badge-success';\n      case 'in_progress':\n        return 'badge-info';\n      case 'completed':\n        return 'badge-neutral';\n      case 'cancelled':\n      case 'expired':\n        return 'badge-danger';\n      default:\n        return 'badge-neutral';\n    }\n  }\n\n  statusCardClass(booking: Booking): string {\n    const effectiveStatus = this.getEffectiveStatus(booking);\n    switch (effectiveStatus) {\n      case 'pending':\n        return 'booking-card--pending';\n      case 'confirmed':\n      case 'in_progress':\n        return 'booking-card--success';\n      case 'completed':\n        return 'booking-card--neutral';\n      case 'cancelled':\n      case 'expired':\n        return 'booking-card--danger';\n      default:\n        return 'booking-card--neutral';\n    }\n  }\n\n  statusIcon(booking: Booking): string {\n    const effectiveStatus = this.getEffectiveStatus(booking);\n    switch (effectiveStatus) {\n      case 'pending':\n        return '⏳';\n      case 'confirmed':\n      case 'in_progress':\n        return '✅';\n      case 'completed':\n        return '🚗';\n      case 'cancelled':\n      case 'expired':\n        return '❌';\n      default:\n        return 'ℹ️';\n    }\n  }\n\n  /** Short status label for compact cards */\n  statusLabelShort(booking: Booking): string {\n    const effectiveStatus = this.getEffectiveStatus(booking);\n    switch (effectiveStatus) {\n      case 'pending':\n        // P2P flow: wallet bookings show \"En revisión\" instead of \"Pendiente\"\n        return this.isWalletBooking(booking) ? 'En revisión' : 'Pendiente';\n      case 'confirmed':\n        return 'Aprobada';\n      case 'in_progress':\n        return 'En uso';\n      case 'completed':\n        return 'Finalizada';\n      case 'cancelled':\n        return 'Cancelada';\n      case 'expired':\n        return 'Vencida';\n      default:\n        return effectiveStatus;\n    }\n  }\n\n  /** Border color class for compact cards */\n  statusBorderClass(booking: Booking): string {\n    const effectiveStatus = this.getEffectiveStatus(booking);\n    switch (effectiveStatus) {\n      case 'pending':\n        return 'border-l-amber-500';\n      case 'confirmed':\n      case 'in_progress':\n        return 'border-l-green-500';\n      case 'completed':\n        return 'border-l-gray-400';\n      case 'cancelled':\n      case 'expired':\n        return 'border-l-red-500';\n      default:\n        return 'border-l-gray-300';\n    }\n  }\n\n  /** Status icon background class */\n  statusIconBgClass(booking: Booking): string {\n    const effectiveStatus = this.getEffectiveStatus(booking);\n    switch (effectiveStatus) {\n      case 'pending':\n        return 'bg-amber-100 dark:bg-amber-900/50';\n      case 'confirmed':\n      case 'in_progress':\n        return 'bg-green-100 dark:bg-green-900/50';\n      case 'completed':\n        return 'bg-gray-100 dark:bg-gray-800';\n      case 'cancelled':\n      case 'expired':\n        return 'bg-red-100 dark:bg-red-900/50';\n      default:\n        return 'bg-gray-100 dark:bg-gray-800';\n    }\n  }\n\n  /** Compact badge class with colors */\n  statusBadgeCompactClass(booking: Booking): string {\n    const effectiveStatus = this.getEffectiveStatus(booking);\n    switch (effectiveStatus) {\n      case 'pending':\n        return 'bg-amber-100 text-amber-700 dark:bg-amber-900/50 dark:text-amber-300';\n      case 'confirmed':\n        return 'bg-green-100 text-green-700 dark:bg-green-900/50 dark:text-green-300';\n      case 'in_progress':\n        return 'bg-blue-100 text-blue-700 dark:bg-blue-900/50 dark:text-blue-300';\n      case 'completed':\n        return 'bg-gray-100 text-gray-600 dark:bg-gray-800 dark:text-gray-500';\n      case 'cancelled':\n      case 'expired':\n        return 'bg-red-100 text-red-700 dark:bg-red-900/50 dark:text-red-300';\n      default:\n        return 'bg-gray-100 text-gray-600 dark:bg-gray-800 dark:text-gray-500';\n    }\n  }\n\n  /**\n   * Check if booking can still be paid (pending AND start date not passed)\n   * For P2P (wallet) bookings, funds are already locked so no payment action needed\n   */\n  canCompletePay(booking: Booking): boolean {\n    // Wallet bookings have already locked funds - no payment action needed\n    if (this.isWalletBooking(booking)) {\n      return false;\n    }\n    return booking.status === 'pending' && !this.isStartDatePassed(booking);\n  }\n\n  /**\n   * Check if booking is pending owner approval (P2P flow)\n   */\n  isPendingApproval(booking: Booking): boolean {\n    return booking.status === 'pending' && this.isWalletBooking(booking) && !this.isStartDatePassed(booking);\n  }\n\n  // Actions\n  completePay(_bookingId: string): void {\n    // RouterLink handles navigation\n  }\n\n  /**\n   * ✅ SPRINT 3: Cancelar reserva con validación\n   */\n  async cancelBooking(bookingId: string): Promise<void> {\n    const confirmed = confirm(\n      '¿Estás seguro de cancelar esta reserva?\\n\\n' + 'Esta acción no se puede deshacer.',\n    );\n\n    if (!confirmed) return;\n\n    this.loading.set(true);\n    try {\n      const result = await this.bookingsService.cancelBooking(bookingId);\n\n      if (!result.success) {\n        this.toastService.error('Error', result.error || 'No se pudo cancelar la reserva');\n        return;\n      }\n\n      this.toastService.success('Reserva cancelada', 'La reserva ha sido cancelada exitosamente.');\n      await this.loadBookings(); // Recargar lista\n    } catch {\n      this.toastService.error('Error', 'Ocurrió un error inesperado al cancelar la reserva');\n    } finally {\n      this.loading.set(false);\n    }\n  }\n\n  showInstructions(booking: Booking): void {\n    const location =\n      booking.car_city && booking.car_province\n        ? `${booking.car_city}, ${booking.car_province}`\n        : 'Ver en detalle';\n    \n    // Usar Toast info en lugar de alert\n    this.toastService.info(\n      'Instrucciones de Retiro',\n      `Ubicación: ${location}. Recordá llevar tu DNI y Licencia de Conducir.`, \n      8000\n    );\n  }\n\n  /**\n   * ✅ SPRINT 3: Abrir chat interno\n   * Navega al sistema de mensajería de la plataforma\n   */\n  openChat(booking: Booking): void {\n    if (!booking.owner_id) {\n      this.toastService.error('Error', 'No se pudo obtener información del propietario');\n      return;\n    }\n\n    // Navegar al chat interno pasando el contexto\n    this.router.navigate(['/messages/chat'], {\n      queryParams: {\n        bookingId: booking.id,\n        userId: booking.owner_id,\n        userName: booking.car?.owner?.full_name || 'Propietario', // Intentar obtener nombre real\n      },\n    });\n  }\n\n  /**\n   * ✅ SPRINT 3: Mostrar mapa de ubicación\n   * Usa Google Maps con la ubicación del auto\n   */\n  showMap(booking: Booking): void {\n    const { car_city, car_province } = booking;\n\n    // Show location based on available data\n    if (car_city && car_province) {\n      // Open Google Maps search with city/province\n      const location = `${car_city}, ${car_province}`;\n      const mapsUrl = `https://www.google.com/maps/search/?api=1&query=${encodeURIComponent(location)}`;\n      window.open(mapsUrl, '_blank');\n    } else {\n      this.toastService.warning('Ubicación no disponible', 'No tenemos la ubicación exacta para esta reserva.');\n    }\n  }\n\n  /**\n   * Cambia el filtro de estado\n   */\n  setStatusFilter(filter: BookingStatusFilter): void {\n    this.statusFilter.set(filter);\n  }\n\n  /**\n   * Obtiene la etiqueta del filtro\n   */\n  getFilterLabel(filter: BookingStatusFilter): string {\n    switch (filter) {\n      case 'all':\n        return 'Todas';\n      case 'pending':\n        return 'Pendientes';\n      case 'confirmed':\n        return 'Confirmadas';\n      case 'in_progress':\n        return 'En curso';\n      case 'completed':\n        return 'Finalizadas';\n      case 'cancelled':\n        return 'Canceladas';\n      default:\n        return filter;\n    }\n  }\n\n  /**\n   * Toggle section expanded/collapsed state\n   */\n  toggleSection(sectionId: string): void {\n    const currentSections = this.sections();\n    const updatedSections = currentSections.map((section) =>\n      section.id === sectionId ? { ...section, expanded: !section.expanded } : section,\n    );\n    this.sections.set(updatedSections);\n  }\n\n  /**\n   * Expand all sections\n   */\n  expandAllSections(): void {\n    const currentSections = this.sections();\n    this.sections.set(currentSections.map((s) => ({ ...s, expanded: true })));\n  }\n\n  /**\n   * Check if booking is from history (older than 3 months)\n   */\n  isOldBooking(booking: Booking): boolean {\n    if (!booking.end_at) return false;\n    const threeMonthsAgo = new Date();\n    threeMonthsAgo.setMonth(threeMonthsAgo.getMonth() - 3);\n    return new Date(booking.end_at) < threeMonthsAgo;\n  }\n}","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/features/bookings/owner-booking-detail/owner-booking-detail.page.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`../../../core/models` import should occur after import of `@core/services/infrastructure/notification-manager.service`","line":12,"column":1,"nodeType":"ImportDeclaration","endLine":12,"endColumn":48,"fix":{"range":[296,589],"text":"import { AuthService } from '@core/services/auth/auth.service';\nimport { BookingsService } from '@core/services/bookings/bookings.service';\nimport { NotificationManagerService } from '@core/services/infrastructure/notification-manager.service';\nimport { Booking } from '../../../core/models';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { CommonModule } from '@angular/common';\nimport {\n  ChangeDetectionStrategy,\n  Component,\n  OnInit,\n  computed,\n  inject,\n  signal,\n} from '@angular/core';\nimport { ActivatedRoute, Router, RouterLink } from '@angular/router';\nimport { AlertController, IonicModule } from '@ionic/angular';\nimport { Booking } from '../../../core/models';\nimport { AuthService } from '@core/services/auth/auth.service';\nimport { BookingsService } from '@core/services/bookings/bookings.service';\nimport { NotificationManagerService } from '@core/services/infrastructure/notification-manager.service';\nimport { BookingChatComponent } from '../../../shared/components/booking-chat/booking-chat.component';\nimport {\n  BookingPricingBreakdownComponent,\n  PricingBreakdownInput,\n} from '../../../shared/components/booking-pricing-breakdown/booking-pricing-breakdown.component';\nimport { ErrorStateComponent } from '../../../shared/components/error-state/error-state.component';\n\ninterface ReturnChecklistItem {\n  id: string;\n  label: string;\n  checked: boolean;\n}\n\n@Component({\n  selector: 'app-owner-booking-detail',\n  standalone: true,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  imports: [\n    CommonModule,\n    IonicModule,\n    RouterLink,\n    BookingChatComponent,\n    BookingPricingBreakdownComponent,\n    ErrorStateComponent,\n  ],\n  templateUrl: './owner-booking-detail.page.html',\n  styleUrl: './owner-booking-detail.page.css',\n})\nexport class OwnerBookingDetailPage implements OnInit {\n  private readonly route = inject(ActivatedRoute);\n  private readonly router = inject(Router);\n  private readonly bookingsService = inject(BookingsService);\n  private readonly authService = inject(AuthService);\n  private readonly alertController = inject(AlertController);\n  private readonly toastService = inject(NotificationManagerService);\n\n  readonly booking = signal<Booking | null>(null);\n  readonly loading = signal(true);\n  readonly error = signal<string | null>(null);\n  readonly processing = signal(false);\n  readonly renterVerification = signal<RenterVerification | null>(null);\n  readonly renterLoading = signal(false);\n\n  readonly renterName = computed(() => this.booking()?.renter_name || 'Locatario');\n  readonly renterAvatar = computed(() => this.booking()?.renter_avatar || null);\n\n  readonly renterReturnChecklist = computed<ReturnChecklistItem[]>(() => {\n    const booking = this.booking();\n    const raw = booking?.metadata?.['return_checklist'];\n    if (!Array.isArray(raw)) return [];\n    return raw.filter((item) => item && typeof item.id === 'string') as ReturnChecklistItem[];\n  });\n\n  readonly renterReturnChecklistProgress = computed(() => {\n    const items = this.renterReturnChecklist();\n    if (items.length === 0) return { completed: 0, total: 0 };\n    const completed = items.filter((i) => i.checked).length;\n    return { completed, total: items.length };\n  });\n\n  readonly shouldShowReturnChecklist = computed(() => {\n    const status = this.booking()?.status;\n    return status === 'in_progress' || status === 'pending_review' || status === 'completed';\n  });\n\n  readonly canApprove = computed(() => this.booking()?.status === 'pending');\n  readonly canOwnerCheckIn = computed(() => this.booking()?.status === 'confirmed');\n  readonly canOwnerCheckOut = computed(() => this.booking()?.status === 'in_progress');\n\n  readonly pricingView = computed<PricingBreakdownInput | null>(() => {\n    const booking = this.booking();\n    if (!booking) return null;\n\n    return {\n      nightlyRate: (booking.nightly_rate_cents ?? 0) / 100,\n      nights: booking.days_count ?? 1,\n      fees: (booking.fees_cents ?? 0) / 100,\n      discounts: (booking.discounts_cents ?? 0) / 100,\n      insurance: (booking.insurance_cents ?? 0) / 100,\n      total: (booking.total_cents ?? booking.subtotal_cents ?? 0) / 100,\n      currency: 'ARS' as const,\n    };\n  });\n\n  readonly driverScore = computed(() => this.renterVerification()?.driver_score ?? null);\n  readonly driverClass = computed(() => this.renterVerification()?.driver_class ?? null);\n  readonly classDescription = computed(() => this.renterVerification()?.class_description ?? null);\n  readonly feeMultiplier = computed(() => this.renterVerification()?.fee_multiplier ?? null);\n  readonly guaranteeMultiplier = computed(() => this.renterVerification()?.guarantee_multiplier ?? null);\n\n  readonly renterPhone = computed(() => this.renterVerification()?.phone ?? null);\n  readonly renterWhatsApp = computed(() => this.renterVerification()?.whatsapp ?? null);\n  readonly renterDni = computed(() => this.renterVerification()?.gov_id_number ?? null);\n  readonly renterDniType = computed(() => this.renterVerification()?.gov_id_type ?? 'DNI');\n  readonly renterLicenseCountry = computed(\n    () => this.renterVerification()?.driver_license_country ?? null,\n  );\n  readonly renterLicenseExpiry = computed(\n    () => this.renterVerification()?.driver_license_expiry ?? null,\n  );\n  readonly renterLicenseClass = computed(() => this.renterVerification()?.driver_license_class ?? null);\n  readonly renterLicenseProfessional = computed(\n    () => this.renterVerification()?.driver_license_professional ?? null,\n  );\n  readonly renterLicensePoints = computed(\n    () => this.renterVerification()?.driver_license_points ?? null,\n  );\n\n  readonly emailVerified = computed(() => this.renterVerification()?.email_verified ?? null);\n  readonly phoneVerified = computed(() => this.renterVerification()?.phone_verified ?? null);\n  readonly idVerified = computed(() => this.renterVerification()?.id_verified ?? null);\n  readonly licenseVerified = computed(\n    () => this.renterVerification()?.driver_license_verified_at ?? null,\n  );\n\n  readonly videoCallUrl = computed(() => {\n    const booking = this.booking();\n    if (!booking) return null;\n    return `https://meet.jit.si/autorenta-${booking.id}`;\n  });\n\n  async ngOnInit() {\n    const bookingId = this.route.snapshot.paramMap.get('id');\n    if (!bookingId) {\n      this.error.set('ID de reserva inválido');\n      this.loading.set(false);\n      return;\n    }\n\n    await this.loadBooking(bookingId);\n  }\n\n  private async loadBooking(bookingId: string): Promise<void> {\n    try {\n      this.loading.set(true);\n      this.error.set(null);\n\n      const session = await this.authService.ensureSession();\n      const currentUserId = session?.user?.id ?? null;\n      if (!currentUserId) {\n        this.error.set('No se encontró sesión activa');\n        return;\n      }\n\n      const booking = await this.bookingsService.getOwnerBookingById(bookingId);\n      if (!booking) {\n        this.error.set('Reserva no encontrada');\n        return;\n      }\n\n      // Validar propietario\n      const { data: car } = await this.bookingsService['supabase']\n        .from('cars')\n        .select('owner_id')\n        .eq('id', booking.car_id)\n        .single();\n\n      if (!car?.owner_id || car.owner_id !== currentUserId) {\n        this.error.set('No tienes permiso para ver esta reserva');\n        return;\n      }\n\n      this.booking.set(booking);\n      await this.loadRenterVerification(booking.id);\n    } catch {\n      this.error.set('Error al cargar la reserva');\n    } finally {\n      this.loading.set(false);\n    }\n  }\n\n  private async loadRenterVerification(bookingId: string): Promise<void> {\n    try {\n      this.renterLoading.set(true);\n      const data = await this.bookingsService.getRenterVerificationForOwner(bookingId);\n      if (!data) {\n        this.renterVerification.set(null);\n        return;\n      }\n      this.renterVerification.set(data as RenterVerification);\n    } catch {\n      this.renterVerification.set(null);\n    } finally {\n      this.renterLoading.set(false);\n    }\n  }\n\n  statusLabel(status?: string): string {\n    switch (status) {\n      case 'pending':\n        return 'Pendiente de aprobación';\n      case 'confirmed':\n        return 'Confirmada';\n      case 'in_progress':\n        return 'En curso';\n      case 'completed':\n        return 'Finalizada';\n      case 'cancelled':\n        return 'Cancelada';\n      case 'expired':\n        return 'Vencida';\n      default:\n        return status || 'Desconocido';\n    }\n  }\n\n  async approveBooking(): Promise<void> {\n    const booking = this.booking();\n    if (!booking || this.processing()) return;\n\n    try {\n      this.processing.set(true);\n      const result = await this.bookingsService.approveBooking(booking.id);\n      if (!result.success) {\n        this.toastService.error('Error', result.error || 'No se pudo aprobar la reserva');\n        return;\n      }\n      this.toastService.success('Reserva aprobada', result.message || 'La reserva fue aprobada');\n      await this.loadBooking(booking.id);\n    } catch {\n      this.toastService.error('Error', 'No se pudo aprobar la reserva');\n    } finally {\n      this.processing.set(false);\n    }\n  }\n\n  async rejectBooking(): Promise<void> {\n    const booking = this.booking();\n    if (!booking || this.processing()) return;\n\n    const alert = await this.alertController.create({\n      header: 'Rechazar reserva',\n      message: 'Podés agregar un motivo opcional para el locatario.',\n      inputs: [\n        {\n          name: 'reason',\n          type: 'textarea',\n          placeholder: 'Motivo (opcional)',\n        },\n      ],\n      buttons: [\n        { text: 'Cancelar', role: 'cancel' },\n        {\n          text: 'Rechazar',\n          role: 'confirm',\n          handler: async (data) => {\n            try {\n              this.processing.set(true);\n              const result = await this.bookingsService.rejectBooking(booking.id, data?.reason);\n              if (!result.success) {\n                this.toastService.error('Error', result.error || 'No se pudo rechazar la reserva');\n                return;\n              }\n              this.toastService.success(\n                'Reserva rechazada',\n                result.message || 'La reserva fue rechazada',\n              );\n              await this.loadBooking(booking.id);\n            } catch {\n              this.toastService.error('Error', 'No se pudo rechazar la reserva');\n            } finally {\n              this.processing.set(false);\n            }\n          },\n        },\n      ],\n    });\n\n    await alert.present();\n  }\n\n  goBack(): void {\n    this.router.navigate(['/bookings/owner']);\n  }\n\n  docStatus(kind: RenterDocumentKind): RenterDocumentStatus {\n    const doc = this.findDoc(kind);\n    if (!doc) return { label: 'Faltante', tone: 'danger' };\n    if (doc.status === 'verified') return { label: 'Verificado', tone: 'success' };\n    if (doc.status === 'rejected') return { label: 'Rechazado', tone: 'danger' };\n    return { label: 'Pendiente', tone: 'warning' };\n  }\n\n  residenceDocStatus(): RenterDocumentStatus {\n    const doc = this.findDoc('utility_bill');\n    if (!doc) return { label: 'Faltante', tone: 'danger' };\n    if (doc.status !== 'verified') return { label: 'Pendiente', tone: 'warning' };\n    if (!doc.created_at) return { label: 'Verificado', tone: 'success' };\n    const ageDays = Math.floor((Date.now() - new Date(doc.created_at).getTime()) / 86400000);\n    if (ageDays <= 90) return { label: 'Vigente', tone: 'success' };\n    return { label: 'Vencido', tone: 'danger' };\n  }\n\n  private findDoc(kind: RenterDocumentKind): RenterDocument | null {\n    const docs = this.renterVerification()?.documents ?? [];\n    return docs.find((d) => d.kind === kind) ?? null;\n  }\n}\n\ntype RenterDocumentKind =\n  | 'gov_id_front'\n  | 'gov_id_back'\n  | 'driver_license'\n  | 'license_front'\n  | 'license_back'\n  | 'utility_bill'\n  | 'selfie'\n  | 'criminal_record';\n\ntype RenterDocument = {\n  kind: RenterDocumentKind;\n  status: 'not_started' | 'pending' | 'verified' | 'rejected';\n  created_at: string | null;\n  reviewed_at: string | null;\n};\n\ntype RenterVerification = {\n  renter_id: string;\n  full_name: string | null;\n  phone: string | null;\n  whatsapp: string | null;\n  gov_id_type: string | null;\n  gov_id_number: string | null;\n  driver_license_country: string | null;\n  driver_license_expiry: string | null;\n  driver_license_class: string | null;\n  driver_license_professional: boolean | null;\n  driver_license_points: number | null;\n  email_verified: boolean | null;\n  phone_verified: boolean | null;\n  id_verified: boolean | null;\n  location_verified_at: string | null;\n  driver_license_verified_at: string | null;\n  driver_class: number | null;\n  driver_score: number | null;\n  fee_multiplier: number | null;\n  guarantee_multiplier: number | null;\n  class_description: string | null;\n  documents: RenterDocument[];\n};\n\ntype RenterDocumentStatus = {\n  label: string;\n  tone: 'success' | 'warning' | 'danger';\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/features/bookings/owner-bookings/owner-bookings.page.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`../../../core/models` import should occur after import of `@core/services/bookings/messages.service`","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":48,"fix":{"range":[331,731],"text":"import { AuthService } from '@core/services/auth/auth.service';\nimport { BookingsService } from '@core/services/bookings/bookings.service';\nimport {\n  MarketplaceOnboardingService,\n  MarketplaceStatus,\n} from '@core/services/bookings/marketplace-onboarding.service';\nimport { Message, MessagesService } from '@core/services/bookings/messages.service';\nimport { Booking } from '../../../core/models';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { CommonModule } from '@angular/common';\nimport { ChangeDetectionStrategy, Component, computed, OnInit, signal } from '@angular/core';\nimport { Router, RouterLink } from '@angular/router';\nimport { AlertController, IonicModule, ToastController } from '@ionic/angular';\nimport { TranslateModule } from '@ngx-translate/core';\nimport { Booking } from '../../../core/models';\nimport { AuthService } from '@core/services/auth/auth.service';\nimport { BookingsService } from '@core/services/bookings/bookings.service';\nimport {\n  MarketplaceOnboardingService,\n  MarketplaceStatus,\n} from '@core/services/bookings/marketplace-onboarding.service';\nimport { Message, MessagesService } from '@core/services/bookings/messages.service';\nimport { DepositStatusBadgeComponent } from '../../../shared/components/deposit-status-badge/deposit-status-badge.component';\nimport { MoneyPipe } from '../../../shared/pipes/money.pipe';\nimport { formatDateRange } from '../../../shared/utils/date.utils';\n\ninterface CarLead {\n  carId: string;\n  carTitle: string;\n  participantId: string;\n  participantName: string | null;\n  lastMessage: Message;\n  unreadCount: number;\n}\n\n@Component({\n  standalone: true,\n  selector: 'app-owner-bookings-page',\n  imports: [\n    CommonModule,\n    MoneyPipe,\n    RouterLink,\n    TranslateModule,\n    IonicModule,\n    DepositStatusBadgeComponent,\n  ],\n  templateUrl: './owner-bookings.page.html',\n  styleUrl: './owner-bookings.page.css',\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class OwnerBookingsPage implements OnInit {\n  readonly bookings = signal<Booking[]>([]);\n  readonly loading = signal(false);\n  readonly error = signal<string | null>(null);\n  readonly processingAction = signal<string | null>(null);\n  readonly renterContacts = signal<\n    Record<string, { name?: string; email?: string; phone?: string }>\n  >({});\n  readonly carLeads = signal<CarLead[]>([]);\n  readonly leadsLoading = signal(false);\n  readonly marketplaceStatus = signal<MarketplaceStatus | null>(null);\n\n  /** Count of bookings pending owner approval */\n  readonly pendingApprovalCount = computed(() =>\n    this.bookings().filter((b) => b.status === 'pending').length\n  );\n\n  private currentUserId: string | null = null;\n\n  constructor(\n    private readonly bookingsService: BookingsService,\n    private readonly alertController: AlertController,\n    private readonly toastController: ToastController,\n    private readonly messagesService: MessagesService,\n    private readonly authService: AuthService,\n    private readonly router: Router,\n    private readonly marketplaceService: MarketplaceOnboardingService,\n  ) {}\n\n  ngOnInit(): void {\n    void this.initialize();\n  }\n\n  private async initialize(): Promise<void> {\n    try {\n      const session = await this.authService.ensureSession();\n      this.currentUserId = session?.user?.id ?? null;\n      if (this.currentUserId) {\n        await this.loadMarketplaceStatus(this.currentUserId);\n      } else {\n        this.marketplaceStatus.set(null);\n      }\n    } catch {\n      this.currentUserId = null;\n      this.marketplaceStatus.set(null);\n    } finally {\n      await this.loadBookings();\n    }\n  }\n\n  async loadBookings(): Promise<void> {\n    this.loading.set(true);\n    this.error.set(null);\n    this.renterContacts.set({});\n    try {\n      // ✅ NUEVO: Obtener reservas de AUTOS DEL LOCADOR\n      const { bookings } = await this.bookingsService.getOwnerBookings();\n      await this.loadRenterContacts(bookings);\n      this.bookings.set(bookings);\n      await this.loadCarLeads();\n    } catch {\n      this.error.set('No pudimos cargar las reservas. Por favor intentá de nuevo más tarde.');\n    } finally {\n      this.loading.set(false);\n    }\n  }\n\n  rangeLabel(booking: Booking): string {\n    return formatDateRange(booking.start_at, booking.end_at);\n  }\n\n  statusLabel(booking: Booking): string {\n    switch (booking.status) {\n      case 'pending':\n        return 'Pendiente de confirmación';\n      case 'confirmed':\n        return 'Confirmada';\n      case 'in_progress':\n        return 'En curso';\n      case 'completed':\n        return 'Finalizada';\n      case 'cancelled':\n        return 'Cancelada';\n      case 'expired':\n        return 'Vencida';\n      default:\n        return booking.status;\n    }\n  }\n\n  statusHint(booking: Booking): string | null {\n    switch (booking.status) {\n      case 'pending':\n        return 'El locatario debe completar el pago.';\n      case 'confirmed':\n        return 'Coordiná la entrega del auto con el locatario.';\n      case 'in_progress':\n        return 'El auto está siendo utilizado.';\n      case 'completed':\n        return 'Alquiler finalizado correctamente.';\n      case 'cancelled':\n        return 'Esta reserva fue cancelada.';\n      default:\n        return null;\n    }\n  }\n\n  statusBadgeClass(booking: Booking): string {\n    switch (booking.status) {\n      case 'pending':\n        return 'badge-warning';\n      case 'confirmed':\n        return 'badge-success';\n      case 'in_progress':\n        return 'badge-info';\n      case 'completed':\n        return 'badge-neutral';\n      case 'cancelled':\n      case 'expired':\n        return 'badge-danger';\n      default:\n        return 'badge-neutral';\n    }\n  }\n\n  statusIcon(booking: Booking): string {\n    switch (booking.status) {\n      case 'pending':\n        return '⏳';\n      case 'confirmed':\n        return '✅';\n      case 'in_progress':\n        return '🚗';\n      case 'completed':\n        return '🏁';\n      case 'cancelled':\n      case 'expired':\n        return '❌';\n      default:\n        return 'ℹ️';\n    }\n  }\n\n  // ✅ NUEVO: Acciones del locador\n  canDoOwnerCheckIn(booking: Booking): boolean {\n    // Check-in cuando está confirmed y llega la fecha\n    return booking.status === 'confirmed' && new Date(booking.start_at) <= new Date();\n  }\n\n  canDoOwnerCheckOut(booking: Booking): boolean {\n    // Check-out cuando está in_progress\n    return booking.status === 'in_progress';\n  }\n\n  canCompleteRental(booking: Booking): boolean {\n    return booking.status === 'in_progress';\n  }\n\n  canCancelBooking(booking: Booking): boolean {\n    return booking.status === 'pending' || booking.status === 'confirmed';\n  }\n\n  canOpenDispute(booking: Booking): boolean {\n    // An owner can open a dispute if the booking is completed or in_progress,\n    // and there isn't an active dispute already.\n    const validStatusForDispute = ['completed', 'in_progress'].includes(booking.status);\n\n    // Check if a dispute is already open or in review\n    const existingDisputeActive = booking.dispute_status && ['open', 'in_review'].includes(booking.dispute_status);\n\n    return validStatusForDispute && !existingDisputeActive;\n  }\n\n  async onCompleteRental(bookingId: string): Promise<void> {\n    // Redirect owner to proper check-out flow (inspection + confirmation)\n    this.router.navigate(['/bookings', bookingId, 'owner-check-out']);\n  }\n\n  async onCancelBooking(bookingId: string): Promise<void> {\n    const confirmed = await this.presentConfirmation({\n      header: 'Cancelar reserva',\n      message: 'Esta acción cancelará la reserva actual. ¿Deseás continuar?',\n      confirmText: 'Cancelar reserva',\n      confirmColor: 'danger',\n    });\n    if (!confirmed) return;\n\n    this.processingAction.set(bookingId);\n    try {\n      await this.bookingsService.cancelBooking(bookingId, false);\n      await this.loadBookings();\n      await this.presentToast('Reserva cancelada');\n    } catch (error) {\n      console.error('Error cancelling booking:', error);\n      await this.presentToast('Error al cancelar la reserva', 'danger');\n    } finally {\n      this.processingAction.set(null);\n    }\n  }\n\n  renterDisplayName(booking: Booking): string {\n    const contact = this.renterContacts()[booking.id];\n    return contact?.name || contact?.email || booking.renter_id || 'Locatario';\n  }\n\n  renterEmail(booking: Booking): string | null {\n    const contact = this.renterContacts()[booking.id];\n    return contact?.email ?? null;\n  }\n\n  renterPhone(booking: Booking): string | null {\n    const contact = this.renterContacts()[booking.id];\n    return contact?.phone ?? null;\n  }\n\n  async loadCarLeads(): Promise<void> {\n    if (!this.currentUserId) {\n      this.carLeads.set([]);\n      return;\n    }\n\n    this.leadsLoading.set(true);\n\n    try {\n      const rows = await this.messagesService.listCarLeadsForOwner(this.currentUserId);\n\n      const threads = new Map<\n        string,\n        {\n          carId: string;\n          carTitle: string;\n          participantId: string;\n          lastMessage: Message;\n          unreadCount: number;\n        }\n      >();\n\n      for (const row of rows) {\n        if (!row.car?.id) {\n          continue;\n        }\n\n        const key = `${row.car.id}:${row.otherUserId}`;\n        const existing = threads.get(key);\n        const isUnread = row.message.recipient_id === this.currentUserId && !row.message.read_at;\n\n        if (!existing) {\n          threads.set(key, {\n            carId: row.car.id,\n            carTitle: row.car.title ?? 'Auto sin título',\n            participantId: row.otherUserId,\n            lastMessage: row.message,\n            unreadCount: isUnread ? 1 : 0,\n          });\n        } else {\n          const existingDate = new Date(existing.lastMessage.created_at).getTime();\n          const currentDate = new Date(row.message.created_at).getTime();\n\n          if (currentDate > existingDate) {\n            existing.lastMessage = row.message;\n          }\n\n          if (isUnread) {\n            existing.unreadCount += 1;\n          }\n        }\n      }\n\n      const leadsOrdered = Array.from(threads.values()).sort((a, b) => {\n        const aDate = new Date(a.lastMessage.created_at).getTime();\n        const bDate = new Date(b.lastMessage.created_at).getTime();\n        return bDate - aDate;\n      });\n\n      const enriched = await Promise.all(\n        leadsOrdered.map(async (lead) => {\n          let participantName: string | null = null;\n\n          try {\n            const contact = await this.bookingsService.getOwnerContact(lead.participantId);\n            if (contact.success) {\n              participantName = contact.name || contact.email || null;\n            }\n          } catch {\n            // Silently ignore error, participant name is optional\n          }\n\n          return {\n            ...lead,\n            participantName,\n          };\n        }),\n      );\n\n      this.carLeads.set(enriched);\n    } catch (error) {\n      console.error('Error loading car leads:', error);\n    } finally {\n      this.leadsLoading.set(false);\n    }\n  }\n\n  async openCarChat(lead: CarLead): Promise<void> {\n    await this.router.navigate(['/messages'], {\n      queryParams: {\n        carId: lead.carId,\n        userId: lead.participantId,\n        carName: lead.carTitle,\n        userName: lead.participantName ?? 'Usuario',\n      },\n    });\n  }\n\n  goToPendingApprovals(): void {\n    void this.router.navigate(['/bookings/pending-approval']);\n  }\n\n  private async loadMarketplaceStatus(userId: string): Promise<void> {\n    try {\n      const status = await this.marketplaceService.getMarketplaceStatus(userId);\n      this.marketplaceStatus.set(status);\n    } catch {\n      this.marketplaceStatus.set(null);\n    }\n  }\n\n  private async loadRenterContacts(bookings: Booking[]): Promise<void> {\n    const contacts: Record<string, { name?: string; email?: string; phone?: string }> = {};\n\n    await Promise.all(\n      bookings.map(async (booking) => {\n        if (!booking?.id || !booking?.renter_id) {\n          return;\n        }\n\n        try {\n          const contact = await this.bookingsService.getOwnerContact(booking.renter_id);\n          if (contact.success) {\n            contacts[booking.id] = {\n              name: contact.name,\n              email: contact.email,\n              phone: contact.phone,\n            };\n          } else {\n            // No action needed if contact is not found\n          }\n        } catch {\n          // Silently ignore errors\n        }\n      }),\n    );\n\n    this.renterContacts.set(contacts);\n  }\n\n  private async presentConfirmation(options: {\n    header: string;\n    message: string;\n    confirmText?: string;\n    cancelText?: string;\n    confirmColor?: 'primary' | 'danger';\n  }): Promise<boolean> {\n    const alert = await this.alertController.create({\n      header: options.header,\n      message: options.message,\n      buttons: [\n        {\n          text: options.cancelText ?? 'Volver',\n          role: 'cancel',\n        },\n        {\n          text: options.confirmText ?? 'Confirmar',\n          role: 'confirm',\n          cssClass: options.confirmColor === 'danger' ? 'alert-button-danger' : undefined,\n        },\n      ],\n    });\n\n    await alert.present();\n    const { role } = await alert.onDidDismiss();\n    return role === 'confirm';\n  }\n\n  private async presentToast(\n    message: string,\n    color: 'success' | 'danger' | 'warning' = 'success',\n  ): Promise<void> {\n    const toast = await this.toastController.create({\n      message,\n      duration: 2500,\n      position: 'top',\n      color,\n    });\n    await toast.present();\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/features/bookings/owner-check-in/owner-check-in.page.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`../../../core/models` import should occur after import of `@core/services/infrastructure/notification-manager.service`","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":48,"fix":{"range":[255,832],"text":"import { BookingInspection } from '../../../core/models/fgo-v1-1.model';\nimport { AuthService } from '@core/services/auth/auth.service';\nimport { BookingsService } from '@core/services/bookings/bookings.service';\nimport { BookingNotificationsService } from '@core/services/bookings/booking-notifications.service';\nimport {\n  LocationTrackingService,\n  TrackingSession,\n} from '@core/services/geo/location-tracking.service';\nimport { NotificationManagerService } from '@core/services/infrastructure/notification-manager.service';\nimport { Booking } from '../../../core/models';\n"}},{"ruleId":"import/order","severity":1,"message":"`../../../core/models/fgo-v1-1.model` import should occur after import of `@core/services/infrastructure/notification-manager.service`","line":7,"column":1,"nodeType":"ImportDeclaration","endLine":7,"endColumn":73,"fix":{"range":[303,832],"text":"import { AuthService } from '@core/services/auth/auth.service';\nimport { BookingsService } from '@core/services/bookings/bookings.service';\nimport { BookingNotificationsService } from '@core/services/bookings/booking-notifications.service';\nimport {\n  LocationTrackingService,\n  TrackingSession,\n} from '@core/services/geo/location-tracking.service';\nimport { NotificationManagerService } from '@core/services/infrastructure/notification-manager.service';\nimport { BookingInspection } from '../../../core/models/fgo-v1-1.model';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import { CommonModule } from '@angular/common';\nimport {Component, OnDestroy, OnInit, inject, signal,\n  ChangeDetectionStrategy} from '@angular/core';\nimport { ActivatedRoute, Router } from '@angular/router';\nimport { IonicModule } from '@ionic/angular';\nimport { Booking } from '../../../core/models';\nimport { BookingInspection } from '../../../core/models/fgo-v1-1.model';\nimport { AuthService } from '@core/services/auth/auth.service';\nimport { BookingsService } from '@core/services/bookings/bookings.service';\nimport { BookingNotificationsService } from '@core/services/bookings/booking-notifications.service';\nimport {\n  LocationTrackingService,\n  TrackingSession,\n} from '@core/services/geo/location-tracking.service';\nimport { NotificationManagerService } from '@core/services/infrastructure/notification-manager.service';\nimport { InspectionUploaderComponent } from '../../../shared/components/inspection-uploader/inspection-uploader.component';\nimport { LiveTrackingMapComponent } from '../../../shared/components/live-tracking-map/live-tracking-map.component';\n\n/**\n * Owner Check-In Page\n *\n * Permite al dueño realizar la inspección inicial del auto antes de entregarlo al locatario\n * - Registra estado inicial (odómetro, combustible, daños) usando InspectionUploaderComponent\n * - Comparte ubicación en tiempo real\n */\n@Component({\n  selector: 'app-owner-check-in',\n  standalone: true,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  imports: [CommonModule, IonicModule, LiveTrackingMapComponent, InspectionUploaderComponent],\n  templateUrl: './owner-check-in.page.html',\n  styleUrl: './owner-check-in.page.css',\n})\nexport class OwnerCheckInPage implements OnInit, OnDestroy {\n  private readonly bookingsService = inject(BookingsService);\n  private readonly authService = inject(AuthService);\n  private readonly toastService = inject(NotificationManagerService);\n  private readonly bookingNotifications = inject(BookingNotificationsService);\n  private readonly locationTracking = inject(LocationTrackingService);\n  private readonly router = inject(Router);\n  private readonly route = inject(ActivatedRoute);\n\n  readonly loading = signal(true);\n  readonly booking = signal<Booking | null>(null);\n  readonly currentUserId = signal<string | null>(null);\n\n  // Location tracking signals\n  readonly isSharing = signal(false);\n  readonly trackingSessions = signal<TrackingSession[]>([]);\n  private unsubscribeTracking?: () => void;\n\n  async ngOnInit() {\n    const bookingId = this.route.snapshot.paramMap.get('id');\n    if (!bookingId) {\n      this.toastService.error('Error', 'ID de reserva inválido');\n      this.router.navigate(['/bookings/owner']);\n      return;\n    }\n\n    try {\n      const session = await this.authService.ensureSession();\n      this.currentUserId.set(session?.user?.id ?? null);\n\n      const booking = await this.bookingsService.getBookingById(bookingId);\n      if (!booking) {\n        this.toastService.error('Error', 'Reserva no encontrada');\n        this.router.navigate(['/bookings/owner']);\n        return;\n      }\n\n      // Validar que es el dueño del auto\n      const currentUserId = this.currentUserId();\n      if (!booking.car?.owner_id || !currentUserId || booking.car.owner_id !== currentUserId) {\n        this.toastService.error('Error', 'No tienes permiso para hacer check-in de esta reserva');\n        this.router.navigate(['/bookings/owner']);\n        return;\n      }\n\n      // Validar estado\n      if (booking.status !== 'confirmed') {\n        this.toastService.error(\n          'Error',\n          `La reserva debe estar en estado \"Confirmada\". Estado actual: ${booking.status}`,\n        );\n        this.router.navigate(['/bookings/owner']);\n        return;\n      }\n\n      this.booking.set(booking);\n\n      // Subscribe to location tracking updates for this booking\n      this.subscribeToLocationUpdates(bookingId);\n    } catch {\n      this.toastService.error('Error', 'No se pudo cargar la reserva');\n      this.router.navigate(['/bookings/owner']);\n    } finally {\n      this.loading.set(false);\n    }\n  }\n\n  ngOnDestroy() {\n    // Clean up tracking subscription\n    if (this.unsubscribeTracking) {\n      this.unsubscribeTracking();\n    }\n\n    // Stop tracking if currently sharing\n    if (this.isSharing()) {\n      this.locationTracking.stopTracking('inactive');\n    }\n  }\n\n  // ============================================================================\n  // LOCATION TRACKING METHODS\n  // ============================================================================\n\n  async startSharing() {\n    const booking = this.booking();\n    if (!booking) return;\n\n    try {\n      // Request location permission\n      const granted = await this.locationTracking.requestLocationPermission();\n      if (!granted) {\n        this.toastService.error(\n          'Permiso requerido',\n          'Necesitas activar la ubicación para compartir tu posición',\n        );\n        return;\n      }\n\n      // Start tracking\n      await this.locationTracking.startTracking(booking.id, 'check_in');\n      this.isSharing.set(true);\n      this.toastService.success(\n        'Ubicación compartida',\n        'El locatario puede ver tu ubicación en tiempo real',\n      );\n    } catch (error) {\n      console.error('Error starting location sharing:', error);\n      this.toastService.error('Error', 'No se pudo iniciar el compartir ubicación');\n    }\n  }\n\n  async stopSharing() {\n    try {\n      await this.locationTracking.stopTracking('inactive');\n      this.isSharing.set(false);\n      this.toastService.success('Ubicación detenida', 'Ya no estás compartiendo tu ubicación');\n    } catch (error) {\n      console.error('Error stopping location sharing:', error);\n      this.toastService.error('Error', 'No se pudo detener el compartir ubicación');\n    }\n  }\n\n  async arriveAtDestination() {\n    try {\n      await this.locationTracking.stopTracking('arrived');\n      this.isSharing.set(false);\n      this.toastService.success('Llegada registrada', 'Has llegado al punto de encuentro');\n    } catch (error) {\n      console.error('Error marking arrival:', error);\n      this.toastService.error('Error', 'No se pudo registrar la llegada');\n    }\n  }\n\n  private subscribeToLocationUpdates(bookingId: string) {\n    this.unsubscribeTracking = this.locationTracking.subscribeToLocationUpdates(\n      bookingId,\n      (sessions) => {\n        this.trackingSessions.set(sessions);\n\n        // Check if renter is nearby (less than 500m)\n        const renterSession = sessions.find((s) => s.user_role === 'locatario');\n        if (renterSession && renterSession.distance_remaining) {\n          const distance = Number(renterSession.distance_remaining);\n          if (distance < 500 && distance > 0) {\n            // Only show once\n            const notificationKey = `renter-nearby-${bookingId}`;\n            if (!sessionStorage.getItem(notificationKey)) {\n              this.toastService.success(\n                '📍 Locatario cerca',\n                `${renterSession.user_name} está a menos de 500m`,\n              );\n              sessionStorage.setItem(notificationKey, 'true');\n            }\n          }\n        }\n      },\n    );\n  }\n\n  getTimeSince(timestamp: string): string {\n    const now = new Date();\n    const lastUpdate = new Date(timestamp);\n    const diffMs = now.getTime() - lastUpdate.getTime();\n    const diffSeconds = Math.floor(diffMs / 1000);\n\n    if (diffSeconds < 10) return 'hace un momento';\n    if (diffSeconds < 60) return `${diffSeconds} seg`;\n\n    const diffMinutes = Math.floor(diffSeconds / 60);\n    if (diffMinutes < 60) return `${diffMinutes} min`;\n\n    const diffHours = Math.floor(diffMinutes / 60);\n    return `${diffHours} h`;\n  }\n\n  // ============================================================================\n  // INSPECTION METHODS\n  // ============================================================================\n\n  async onInspectionCompleted(_inspection: BookingInspection) {\n    const booking = this.booking();\n    if (!booking) return;\n\n    try {\n      // Notificar al locatario para que documente la recepción\n      const currentUserId = this.currentUserId();\n      if (currentUserId) {\n        await this.bookingNotifications.notifyInspectionCompleted(\n          booking,\n          'check_in',\n          currentUserId,\n        );\n      }\n\n      this.toastService.success(\n        'Éxito',\n        '✅ Check-in completado. El locatario ahora debe documentar la recepción.',\n      );\n\n      // Navegar al detalle de la reserva\n      this.router.navigate(['/bookings/detail', booking.id]);\n    } catch (error) {\n      console.error('Error en check-in:', error);\n      this.toastService.error(\n        'Error',\n        error instanceof Error ? error.message : 'Error al completar check-in',\n      );\n    }\n  }\n\n  cancel() {\n    this.router.navigate(['/bookings/owner']);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/features/bookings/owner-check-out/owner-check-out.page.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`../../../core/models` import should occur after import of `@core/services/infrastructure/notification-manager.service`","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":48,"fix":{"range":[254,719],"text":"import { BookingInspection } from '../../../core/models/fgo-v1-1.model';\nimport { AuthService } from '@core/services/auth/auth.service';\nimport { BookingConfirmationService } from '@core/services/bookings/booking-confirmation.service';\nimport { BookingsService } from '@core/services/bookings/bookings.service';\nimport { NotificationManagerService } from '@core/services/infrastructure/notification-manager.service';\nimport { Booking } from '../../../core/models';\n"}},{"ruleId":"import/order","severity":1,"message":"`../../../core/models/fgo-v1-1.model` import should occur after import of `@core/services/infrastructure/notification-manager.service`","line":7,"column":1,"nodeType":"ImportDeclaration","endLine":7,"endColumn":73,"fix":{"range":[302,719],"text":"import { AuthService } from '@core/services/auth/auth.service';\nimport { BookingConfirmationService } from '@core/services/bookings/booking-confirmation.service';\nimport { BookingsService } from '@core/services/bookings/bookings.service';\nimport { NotificationManagerService } from '@core/services/infrastructure/notification-manager.service';\nimport { BookingInspection } from '../../../core/models/fgo-v1-1.model';\n"}}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":56,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":56,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2494,2497],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2494,2497],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import { CommonModule } from '@angular/common';\nimport {Component, OnInit, computed, inject, signal,\n  ChangeDetectionStrategy} from '@angular/core';\nimport { ActivatedRoute, Router } from '@angular/router';\nimport { IonicModule } from '@ionic/angular';\nimport { Booking } from '../../../core/models';\nimport { BookingInspection } from '../../../core/models/fgo-v1-1.model';\nimport { AuthService } from '@core/services/auth/auth.service';\nimport { BookingConfirmationService } from '@core/services/bookings/booking-confirmation.service';\nimport { BookingsService } from '@core/services/bookings/bookings.service';\nimport { NotificationManagerService } from '@core/services/infrastructure/notification-manager.service';\nimport { InspectionUploaderComponent } from '../../../shared/components/inspection-uploader/inspection-uploader.component';\n\n/**\n * Owner Check-Out Page\n *\n * Permite al dueño realizar la inspección final del auto cuando el locatario lo devuelve\n * - Registra estado final (odómetro, combustible, daños) usando InspectionUploaderComponent\n * - Marca como 'returned' e inicia confirmación bilateral\n */\n@Component({\n  selector: 'app-owner-check-out',\n  standalone: true,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  imports: [CommonModule, IonicModule, InspectionUploaderComponent],\n  templateUrl: './owner-check-out.page.html',\n  styleUrl: './owner-check-out.page.css',\n})\nexport class OwnerCheckOutPage implements OnInit {\n  private readonly bookingsService = inject(BookingsService);\n  private readonly confirmationService = inject(BookingConfirmationService);\n  private readonly authService = inject(AuthService);\n  private readonly toastService = inject(NotificationManagerService);\n  private readonly router = inject(Router);\n  private readonly route = inject(ActivatedRoute);\n\n  readonly loading = signal(true);\n  // Estado del flujo\n  readonly step = signal<'inspection' | 'damages'>('inspection');\n\n  // Datos del formulario de daños\n  readonly hasDamages = signal(false);\n  readonly damagesNotes = signal('');\n  readonly damageAmount = signal<number>(0);\n\n  readonly canSubmitDamages = computed(() => {\n    return (\n      !this.hasDamages() ||\n      (this.damageAmount() > 0 && this.damageAmount() <= 250 && this.damagesNotes().length > 0)\n    );\n  });\n\n  readonly booking = signal<Booking | null>(null);\n  readonly currentUserId = signal<string | null>(null);\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  readonly checkInData = signal<any>(null);\n  readonly submitting = signal(false);\n\n  async ngOnInit() {\n    const bookingId = this.route.snapshot.paramMap.get('id');\n    if (!bookingId) {\n      this.toastService.error('Error', 'ID de reserva inválido');\n      this.router.navigate(['/bookings/owner']);\n      return;\n    }\n\n    try {\n      const session = await this.authService.ensureSession();\n      this.currentUserId.set(session?.user?.id ?? null);\n\n      const booking = await this.bookingsService.getBookingById(bookingId);\n      if (!booking) {\n        this.toastService.error('Error', 'Reserva no encontrada');\n        this.router.navigate(['/bookings/owner']);\n        return;\n      }\n\n      // Validar que es el dueño del auto\n      const currentUserId = this.currentUserId();\n      if (!booking.car?.owner_id || !currentUserId || booking.car.owner_id !== currentUserId) {\n        this.toastService.error('Error', 'No tienes permiso para hacer check-out de esta reserva');\n        this.router.navigate(['/bookings/owner']);\n        return;\n      }\n\n      // Validar estado\n      if (booking.status !== 'in_progress') {\n        this.toastService.error(\n          'Error',\n          `La reserva debe estar en estado \"En curso\". Estado actual: ${booking.status}`,\n        );\n        this.router.navigate(['/bookings/owner']);\n        return;\n      }\n\n      this.booking.set(booking);\n\n      // Cargar datos del check-in\n      // FIXME: Implement once FGO (Fast Global Onboarding) service is ready\n      this.checkInData.set({ odometer_reading: 0, fuel_level: 100 });\n    } catch {\n      this.toastService.error('Error', 'No se pudo cargar la reserva');\n      this.router.navigate(['/bookings/owner']);\n    } finally {\n      this.loading.set(false);\n    }\n  }\n\n  /**\n   * Paso 1: Inspección completada\n   * Avanza al paso de reclamo de daños\n   */\n  onInspectionCompleted(_inspection: BookingInspection) {\n    this.step.set('damages');\n    this.toastService.success('Inspección guardada', 'Ahora confirma si hay daños a reportar');\n  }\n\n  toggleDamages() {\n    this.hasDamages.set(!this.hasDamages());\n    if (!this.hasDamages()) {\n      this.damageAmount.set(0);\n      this.damagesNotes.set('');\n    }\n  }\n\n  /**\n   * Paso 2: Confirmar devolución y daños\n   */\n  async submitCheckOut() {\n    if (!this.canSubmitDamages() || this.submitting()) return;\n\n    const booking = this.booking();\n    if (!booking) return;\n\n    this.submitting.set(true);\n\n    try {\n      // 2. Marcar como devuelto (in_progress → returned)\n      await this.confirmationService.markAsReturned({\n        booking_id: booking.id,\n        returned_by: this.currentUserId()!,\n      });\n\n      // 3. Confirmar como propietario con los daños reportados\n      const confirmResult = await this.confirmationService.confirmOwner({\n        booking_id: booking.id,\n        confirming_user_id: this.currentUserId()!,\n        has_damages: this.hasDamages(),\n        damage_amount: this.damageAmount(),\n        damage_description: this.damagesNotes() || undefined,\n      });\n\n      if (confirmResult.funds_released) {\n        this.toastService.success(\n          'Éxito',\n          '✅ Check-out completado. Fondos liberados automáticamente.',\n        );\n      } else {\n        this.toastService.success(\n          'Éxito',\n          '✅ Check-out completado. Esperando confirmación del locatario para liberar fondos.',\n        );\n      }\n\n      // Navegar al detalle de la reserva\n      this.router.navigate(['/bookings/detail', booking.id]);\n    } catch (error) {\n      console.error('Error en check-out:', error);\n      this.toastService.error(\n        'Error',\n        error instanceof Error ? error.message : 'Error al completar check-out',\n      );\n    } finally {\n      this.submitting.set(false);\n    }\n  }\n\n  cancel() {\n    this.router.navigate(['/bookings/owner']);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/features/bookings/owner-damage-report/owner-damage-report.page.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`../../../core/models` import should occur after import of `@core/services/infrastructure/supabase-client.service`","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":8,"endColumn":48,"fix":{"range":[337,718],"text":"import { AuthService } from '@core/services/auth/auth.service';\nimport { BookingsService } from '@core/services/bookings/bookings.service';\nimport { NotificationManagerService } from '@core/services/infrastructure/notification-manager.service';\nimport { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\nimport { Booking } from '../../../core/models';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { CommonModule } from '@angular/common';\nimport {Component, OnInit, computed, inject, signal,\n  ChangeDetectionStrategy} from '@angular/core';\nimport { FormsModule } from '@angular/forms';\nimport { ActivatedRoute, Router } from '@angular/router';\nimport { IonicModule } from '@ionic/angular';\nimport { v4 as uuidv4 } from 'uuid';\nimport { Booking } from '../../../core/models';\nimport { AuthService } from '@core/services/auth/auth.service';\nimport { BookingsService } from '@core/services/bookings/bookings.service';\nimport { NotificationManagerService } from '@core/services/infrastructure/notification-manager.service';\nimport { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\n\n/**\n * Owner Damage Report Page\n *\n * Permite al dueño reportar daños después de completar el check-out\n * - Descripción detallada del daño\n * - Monto del daño (máx $250 USD o el depósito disponible)\n * - Fotos de evidencia (almacenadas en bucket 'documents')\n * - Envía notificación al locatario\n * - Se deshabilita después del envío\n */\n@Component({\n  selector: 'app-owner-damage-report',\n  standalone: true,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  imports: [CommonModule, FormsModule, IonicModule],\n  templateUrl: './owner-damage-report.page.html',\n  styleUrl: './owner-damage-report.page.css',\n})\nexport class OwnerDamageReportPage implements OnInit {\n  private readonly bookingsService = inject(BookingsService);\n  private readonly authService = inject(AuthService);\n  private readonly toastService = inject(NotificationManagerService);\n  private readonly supabase = injectSupabase();\n  private readonly router = inject(Router);\n  private readonly route = inject(ActivatedRoute);\n\n  readonly loading = signal(true);\n  readonly submitting = signal(false);\n  readonly booking = signal<Booking | null>(null);\n  readonly currentUserId = signal<string | null>(null);\n\n  // Form fields\n  readonly damageDescription = signal('');\n  readonly damageAmount = signal<number>(0);\n  readonly uploadedFiles = signal<File[]>([]);\n  readonly uploadedPreviews = signal<string[]>([]);\n\n  readonly maxDepositAmount = computed(() => {\n    const booking = this.booking();\n    if (!booking) return 250;\n    // Convert cents to dollars, default to $250 if not set\n    return (booking.deposit_amount_cents ?? 25000) / 100;\n  });\n\n  readonly canSubmit = computed(() => {\n    return (\n      this.damageDescription().trim().length >= 20 &&\n      this.damageDescription().trim().length <= 1000 &&\n      this.damageAmount() > 0 &&\n      this.damageAmount() <= this.maxDepositAmount() &&\n      this.uploadedFiles().length > 0 &&\n      this.uploadedFiles().length <= 10\n    );\n  });\n\n  readonly descriptionCharCount = computed(() => this.damageDescription().trim().length);\n\n  async ngOnInit() {\n    const bookingId = this.route.snapshot.paramMap.get('id');\n    if (!bookingId) {\n      this.toastService.error('Error', 'ID de reserva inválido');\n      this.router.navigate(['/bookings/owner']);\n      return;\n    }\n\n    try {\n      const session = await this.authService.ensureSession();\n      this.currentUserId.set(session?.user?.id ?? null);\n\n      const booking = await this.bookingsService.getBookingById(bookingId);\n      if (!booking) {\n        this.toastService.error('Error', 'Reserva no encontrada');\n        this.router.navigate(['/bookings/owner']);\n        return;\n      }\n\n      // Validar que es el dueño del auto\n      const currentUserId = this.currentUserId();\n      if (!booking.car?.owner_id || !currentUserId || booking.car.owner_id !== currentUserId) {\n        this.toastService.error('Error', 'No tienes permiso para reportar daños en esta reserva');\n        this.router.navigate(['/bookings/owner']);\n        return;\n      }\n\n      // Validar que la reserva está en estado apropiado para reportar daños\n      // Puede reportar daños después del checkout (completed o returned)\n      if (booking.status !== 'completed' && booking.returned_at === null) {\n        this.toastService.error(\n          'Error',\n          'Solo puedes reportar daños después de completar el check-out del vehículo',\n        );\n        this.router.navigate(['/bookings/owner']);\n        return;\n      }\n\n      // Validar que no haya reportado daños ya\n      if (booking.owner_reported_damages) {\n        this.toastService.error('Error', 'Ya has reportado daños para esta reserva');\n        this.router.navigate(['/bookings/detail', bookingId]);\n        return;\n      }\n\n      this.booking.set(booking);\n    } catch (error) {\n      console.error('Error loading booking:', error);\n      this.toastService.error('Error', 'No se pudo cargar la reserva');\n      this.router.navigate(['/bookings/owner']);\n    } finally {\n      this.loading.set(false);\n    }\n  }\n\n  onFilesSelected(event: Event) {\n    const input = event.target as HTMLInputElement;\n    if (!input.files) return;\n\n    const files = Array.from(input.files);\n    const currentFiles = this.uploadedFiles();\n\n    // Check max files limit (10 total)\n    if (currentFiles.length + files.length > 10) {\n      this.toastService.error('Error', 'Puedes subir máximo 10 fotos');\n      return;\n    }\n\n    // Validate each file\n    const validFiles: File[] = [];\n    const previews: string[] = [];\n\n    files.forEach((file) => {\n      // Check file type\n      if (!file.type.startsWith('image/')) {\n        this.toastService.error('Error', `${file.name} no es una imagen válida`);\n        return;\n      }\n\n      // Check file size (max 5MB)\n      if (file.size > 5 * 1024 * 1024) {\n        this.toastService.error('Error', `${file.name} supera el tamaño máximo de 5MB`);\n        return;\n      }\n\n      validFiles.push(file);\n\n      // Generate preview\n      const reader = new FileReader();\n      reader.onload = (e) => {\n        previews.push(e.target?.result as string);\n        if (previews.length === validFiles.length) {\n          this.uploadedPreviews.set([...this.uploadedPreviews(), ...previews]);\n        }\n      };\n      reader.readAsDataURL(file);\n    });\n\n    if (validFiles.length > 0) {\n      this.uploadedFiles.set([...currentFiles, ...validFiles]);\n    }\n  }\n\n  removeFile(index: number) {\n    const files = this.uploadedFiles();\n    const previews = this.uploadedPreviews();\n\n    files.splice(index, 1);\n    previews.splice(index, 1);\n\n    this.uploadedFiles.set([...files]);\n    this.uploadedPreviews.set([...previews]);\n  }\n\n  async submitDamageReport() {\n    if (!this.canSubmit() || this.submitting()) return;\n\n    const booking = this.booking();\n    if (!booking) return;\n\n    this.submitting.set(true);\n\n    try {\n      const currentUserId = this.currentUserId();\n      if (!currentUserId) throw new Error('Usuario no autenticado');\n\n      // 1. Upload photos to documents bucket\n      const uploadedPhotoUrls: string[] = [];\n\n      for (const file of this.uploadedFiles()) {\n        const extension = file.name.split('.').pop() ?? 'jpg';\n        const filename = `${uuidv4()}.${extension}`;\n        const filePath = `${currentUserId}/damage-reports/${booking.id}/${filename}`;\n\n        const { error: uploadError } = await this.supabase.storage\n          .from('documents')\n          .upload(filePath, file, {\n            cacheControl: '3600',\n            upsert: false,\n          });\n\n        if (uploadError) {\n          console.error('Error uploading photo:', uploadError);\n          throw new Error(`Error al subir la foto ${file.name}`);\n        }\n\n        uploadedPhotoUrls.push(filePath);\n      }\n\n      // 2. Update booking with damage information\n      const damageAmountCents = Math.round(this.damageAmount() * 100);\n\n      await this.bookingsService.updateBooking(booking.id, {\n        owner_reported_damages: true,\n        owner_damage_amount: damageAmountCents,\n        owner_damage_description: this.damageDescription().trim(),\n      });\n\n      // 3. Store photo references in database (create a damage_reports table entry or store in metadata)\n      // For now, we'll store the photo URLs in a JSON field or separate table\n      // This requires a database migration to add a damage_evidence_photos column or create a damage_reports table\n\n      // 4. Send notification to renter\n      await this.sendRenterNotification(booking, damageAmountCents);\n\n      // 5. Optionally deduct from security deposit\n      // await this.bookingsService.deductFromSecurityDeposit(\n      //   booking.id,\n      //   damageAmountCents,\n      //   this.damageDescription().trim()\n      // );\n\n      this.toastService.success(\n        'Reporte enviado',\n        'El reporte de daños ha sido enviado al locatario. Se deducirá del depósito de garantía.',\n      );\n\n      // Navigate to booking detail\n      this.router.navigate(['/bookings/detail', booking.id]);\n    } catch (error) {\n      console.error('Error submitting damage report:', error);\n      this.toastService.error(\n        'Error',\n        error instanceof Error ? error.message : 'Error al enviar el reporte de daños',\n      );\n    } finally {\n      this.submitting.set(false);\n    }\n  }\n\n  private async sendRenterNotification(booking: Booking, damageAmountCents: number) {\n    const damageAmountUsd = damageAmountCents / 100;\n\n    await this.supabase.from('notifications').insert({\n      user_id: booking.renter_id,\n      type: 'damage_reported',\n      title: 'Reporte de daños en tu reserva',\n      body: `El propietario ha reportado daños por $${damageAmountUsd} USD en el vehículo ${booking.car_title}. El monto será deducido de tu depósito de garantía.`,\n      cta_link: `/bookings/detail/${booking.id}`,\n      metadata: {\n        booking_id: booking.id,\n        damage_amount_cents: damageAmountCents,\n      },\n      is_read: false,\n    });\n  }\n\n  cancel() {\n    this.router.navigate(['/bookings/owner']);\n  }\n\n  get formattedAmount(): string {\n    return `$${this.damageAmount()} USD`;\n  }\n\n  get maxFormattedAmount(): string {\n    return `$${this.maxDepositAmount()} USD`;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/features/bookings/pages/booking-checkout/booking-checkout.page.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`../../../../core/interfaces/payment-gateway.interface` import should occur after import of `@core/services/payments/payment-gateway.factory`","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":89,"fix":{"range":[298,635],"text":"import { BookingsService } from '@core/services/bookings/bookings.service';\nimport { DriverProfileService } from '@core/services/auth/driver-profile.service';\nimport { PaymentGatewayFactory } from '@core/services/payments/payment-gateway.factory';\nimport { PaymentProvider } from '../../../../core/interfaces/payment-gateway.interface';\n"}}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":59,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":59,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2329,2332],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2329,2332],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { LoggerService } from '@core/services/infrastructure/logger.service';\nimport { CommonModule } from '@angular/common';\nimport {Component, computed, inject, OnInit, signal,\n  ChangeDetectionStrategy} from '@angular/core';\nimport { ActivatedRoute, Router, RouterLink } from '@angular/router';\nimport { PaymentProvider } from '../../../../core/interfaces/payment-gateway.interface';\nimport { BookingsService } from '@core/services/bookings/bookings.service';\nimport { DriverProfileService } from '@core/services/auth/driver-profile.service';\nimport { PaymentGatewayFactory } from '@core/services/payments/payment-gateway.factory';\nimport { PaymentProviderSelectorComponent } from '../../../../shared/components/payment-provider-selector/payment-provider-selector.component';\nimport { PayPalButtonComponent } from '../../../../shared/components/paypal-button/paypal-button.component';\n\n/**\n * Booking Checkout Page\n *\n * Página de pago que integra múltiples proveedores de pago:\n * - MercadoPago (ARS)\n * - PayPal (USD)\n *\n * Flujo:\n * 1. Usuario selecciona proveedor (PaymentProviderSelectorComponent)\n * 2. Se muestra el botón/UI del proveedor seleccionado\n * 3. Usuario completa el pago\n * 4. Redirección a página de confirmación\n *\n * @example\n * Route: /bookings/:bookingId/checkout\n */\n@Component({\n  selector: 'app-booking-checkout',\n  standalone: true,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  imports: [CommonModule, RouterLink, PaymentProviderSelectorComponent, PayPalButtonComponent],\n  templateUrl: './booking-checkout.page.html',\n  styleUrls: ['./booking-checkout.page.css'],\n})\nexport class BookingCheckoutPage implements OnInit {\n  private readonly logger = inject(LoggerService);\n  private readonly route = inject(ActivatedRoute);\n  private readonly router = inject(Router);\n  private readonly gatewayFactory = inject(PaymentGatewayFactory);\n  private readonly bookingsService = inject(BookingsService);\n  readonly driverProfileService = inject(DriverProfileService);\n\n  // Expose Math for template\n  readonly Math = Math;\n\n  // ==================== SIGNALS ====================\n\n  /**\n   * ID del booking a pagar\n   */\n  bookingId = signal<string>('');\n\n  /**\n   * Detalles del booking cargados desde la DB\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  booking = signal<any>(null);\n\n  /**\n   * Proveedor de pago seleccionado\n   */\n  selectedProvider = signal<PaymentProvider>('mercadopago');\n\n  /**\n   * Monto a pagar en la moneda del proveedor\n   */\n  amountInProviderCurrency = signal<number>(0);\n\n  /**\n   * Moneda del proveedor (ARS o USD)\n   */\n  providerCurrency = signal<string>('ARS');\n\n  /**\n   * Estado de carga inicial\n   */\n  isLoading = signal<boolean>(true);\n\n  /**\n   * Error durante la carga o el pago\n   */\n  error = signal<string>('');\n\n  /**\n   * Estado de procesamiento del pago\n   */\n  isProcessingPayment = signal<boolean>(false);\n\n  /**\n   * Preference ID de MercadoPago (si corresponde)\n   */\n  mercadoPagoPreferenceId = signal<string>('');\n\n  /**\n   * Init point de MercadoPago (si corresponde)\n   */\n  mercadoPagoInitPoint = signal<string>('');\n\n  /**\n   * Mostrar/ocultar oferta de Bonus Protector\n   */\n  showProtectorOffer = signal<boolean>(false);\n\n  // ==================== COMPUTED SIGNALS ====================\n\n  /**\n   * ¿Está el botón de pago habilitado?\n   */\n  readonly isPaymentButtonEnabled = computed(() => {\n    return (\n      !this.isLoading() &&\n      !this.isProcessingPayment() &&\n      this.booking() !== null &&\n      this.amountInProviderCurrency() > 0\n    );\n  });\n\n  /**\n   * ¿El proveedor seleccionado es MercadoPago?\n   */\n  readonly isMercadoPago = computed(() => {\n    return this.selectedProvider() === 'mercadopago';\n  });\n\n  /**\n   * ¿El proveedor seleccionado es PayPal?\n   */\n  readonly isPayPal = computed(() => {\n    return this.selectedProvider() === 'paypal';\n  });\n\n  // ==================== DRIVER PROFILE COMPUTED ====================\n\n  /**\n   * Clase de conductor del usuario\n   */\n  readonly driverClass = computed(() => this.driverProfileService.driverClass());\n\n  /**\n   * Descuento/recargo de tarifa (%)\n   */\n  readonly feeDiscountPct = computed(() => this.driverProfileService.feeDiscountPct());\n\n  /**\n   * Descuento/recargo de garantía (%)\n   */\n  readonly guaranteeDiscountPct = computed(() => this.driverProfileService.guaranteeDiscountPct());\n\n  /**\n   * ¿Tiene descuentos por buena clase?\n   */\n  readonly hasDiscount = computed(() => this.driverProfileService.hasDiscount());\n\n  /**\n   * ¿Tiene recargos por mala clase?\n   */\n  readonly hasSurcharge = computed(() => this.driverProfileService.hasSurcharge());\n\n  /**\n   * Badge de clase (color e icono)\n   */\n  readonly classBadge = computed(() => this.driverProfileService.getClassBadge());\n\n  // ==================== LIFECYCLE ====================\n\n  async ngOnInit(): Promise<void> {\n    // Obtener booking ID de la ruta\n    const id = this.route.snapshot.paramMap.get('bookingId');\n    if (!id) {\n      this.error.set('ID de booking no encontrado');\n      this.isLoading.set(false);\n      return;\n    }\n\n    this.bookingId.set(id);\n\n    try {\n      // Cargar booking y perfil de conductor en paralelo\n      await Promise.all([this.loadBooking(), this.driverProfileService.loadProfile()]);\n    } catch (err) {\n      this.error.set(err instanceof Error ? err.message : 'Error cargando el booking');\n    } finally {\n      this.isLoading.set(false);\n    }\n  }\n\n  // ==================== PUBLIC METHODS ====================\n\n  /**\n   * Carga los detalles del booking desde la DB\n   */\n  private async loadBooking(): Promise<void> {\n    const bookingData = await this.bookingsService.getBookingById(this.bookingId());\n\n    if (!bookingData) {\n      throw new Error('Booking no encontrado');\n    }\n\n    // Validar que el booking está en estado pendiente de pago\n    if (bookingData.status !== 'pending') {\n      throw new Error(`Este booking está en estado \"${bookingData.status}\" y no se puede pagar`);\n    }\n\n    this.booking.set(bookingData);\n  }\n\n  /**\n   * Maneja el cambio de proveedor de pago\n   */\n  handleProviderChange(event: {\n    provider: PaymentProvider;\n    amountInProviderCurrency: number;\n    providerCurrency: string;\n  }): void {\n    this.selectedProvider.set(event.provider);\n    this.amountInProviderCurrency.set(event.amountInProviderCurrency);\n    this.providerCurrency.set(event.providerCurrency);\n\n    // Limpiar preferencia previa de MercadoPago\n    this.mercadoPagoPreferenceId.set('');\n    this.mercadoPagoInitPoint.set('');\n\n    this.logger.debug('Provider changed:', event);\n  }\n\n  /**\n   * Inicia el flujo de pago con MercadoPago\n   */\n  async handleMercadoPagoPayment(): Promise<void> {\n    if (!this.isPaymentButtonEnabled()) return;\n\n    this.isProcessingPayment.set(true);\n    this.error.set('');\n\n    try {\n      const gateway = this.gatewayFactory.createBookingGateway('mercadopago');\n\n      // Crear preferencia de pago\n      const preference = await gateway.createBookingPreference(this.bookingId(), true).toPromise();\n\n      if (!preference || !preference.success || !preference.init_point) {\n        throw new Error('Error creando preferencia de pago');\n      }\n\n      this.mercadoPagoPreferenceId.set(preference.preference_id);\n      this.mercadoPagoInitPoint.set(preference.init_point);\n\n      // Redirigir a MercadoPago\n      gateway.redirectToCheckout(preference.init_point, false);\n    } catch (err) {\n      this.error.set(err instanceof Error ? err.message : 'Error procesando pago con MercadoPago');\n      this.isProcessingPayment.set(false);\n    }\n  }\n\n  /**\n   * Maneja la aprobación del pago de PayPal\n   */\n  handlePayPalApprove(event: { orderId: string; captureId: string }): void {\n    this.logger.debug('PayPal payment approved:', event);\n\n    // Redirigir a página de confirmación\n    this.router.navigate(['/bookings', this.bookingId(), 'confirmation'], {\n      queryParams: {\n        provider: 'paypal',\n        orderId: event.orderId,\n        captureId: event.captureId,\n      },\n    });\n  }\n\n  /**\n   * Maneja errores del pago de PayPal\n   */\n  handlePayPalError(error: Error): void {\n    console.error('PayPal payment error:', error);\n    this.error.set(`Error procesando pago con PayPal: ${error.message}`);\n    this.isProcessingPayment.set(false);\n  }\n\n  /**\n   * Cancela el pago y vuelve atrás\n   */\n  cancelPayment(): void {\n    this.router.navigate(['/bookings', this.bookingId()]);\n  }\n\n  /**\n   * Formatea un monto como moneda\n   */\n  formatCurrency(amount: number, currency: string): string {\n    return new Intl.NumberFormat(currency === 'ARS' ? 'es-AR' : 'en-US', {\n      style: 'currency',\n      currency: currency,\n      minimumFractionDigits: 2,\n      maximumFractionDigits: 2,\n    }).format(amount);\n  }\n\n  /**\n   * Toggle de la oferta de Bonus Protector\n   */\n  toggleProtectorOffer(): void {\n    this.showProtectorOffer.update((value) => !value);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/features/bookings/pages/booking-confirmation/booking-confirmation.page.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`@core/services/bookings/bookings.service` import should occur before import of `../../../../core/interfaces/payment-gateway.interface`","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":76,"fix":{"range":[208,373],"text":"import { BookingsService } from '@core/services/bookings/bookings.service';\nimport { PaymentProvider } from '../../../../core/interfaces/payment-gateway.interface';\n"}}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":59,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":59,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1841,1844],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1841,1844],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":191,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":191,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4930,4933],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4930,4933],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":193,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":193,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5070,5073],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5070,5073],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":195,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":195,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5192,5195],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5192,5195],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":197,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":197,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5319,5322],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5319,5322],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":199,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":199,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5447,5450],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5447,5450],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":201,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":201,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5571,5574],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5571,5574],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":334,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":334,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9366,9369],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9366,9369],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":346,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":346,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9698,9701],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9698,9701],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { CommonModule } from '@angular/common';\nimport {Component, computed, inject, OnInit, signal,\n  ChangeDetectionStrategy} from '@angular/core';\nimport { ActivatedRoute, Router } from '@angular/router';\nimport { PaymentProvider } from '../../../../core/interfaces/payment-gateway.interface';\nimport { BookingsService } from '@core/services/bookings/bookings.service';\n\ntype ConfirmationStatus = 'success' | 'pending' | 'error';\n\ninterface PaymentDetails {\n  provider: PaymentProvider;\n  orderId?: string;\n  captureId?: string;\n  preferenceId?: string;\n  paymentId?: string;\n}\n\n/**\n * Booking Confirmation Page\n *\n * Página de confirmación después de completar un pago.\n * Soporta múltiples proveedores (MercadoPago, PayPal).\n *\n * Query Params:\n * - provider: 'mercadopago' | 'paypal'\n * - orderId: ID de la orden (PayPal)\n * - captureId: ID de la captura (PayPal)\n * - preferenceId: ID de la preferencia (MercadoPago)\n * - paymentId: ID del pago (MercadoPago)\n * - status: 'approved' | 'pending' | 'rejected' (MercadoPago)\n *\n * @example\n * Route: /bookings/:bookingId/confirmation?provider=paypal&orderId=xxx&captureId=yyy\n */\n@Component({\n  selector: 'app-booking-confirmation',\n  standalone: true,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  imports: [CommonModule],\n  templateUrl: './booking-confirmation.page.html',\n  styleUrls: ['./booking-confirmation.page.css'],\n})\nexport class BookingConfirmationPage implements OnInit {\n  private readonly route = inject(ActivatedRoute);\n  readonly router = inject(Router);\n  private readonly bookingsService = inject(BookingsService);\n\n  // ==================== SIGNALS ====================\n\n  /**\n   * ID del booking\n   */\n  bookingId = signal<string>('');\n\n  /**\n   * Detalles del booking\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  booking = signal<any>(null);\n\n  /**\n   * Estado de la confirmación\n   */\n  status = signal<ConfirmationStatus>('pending');\n\n  /**\n   * Detalles del pago\n   */\n  paymentDetails = signal<PaymentDetails | null>(null);\n\n  /**\n   * Estado de carga\n   */\n  isLoading = signal<boolean>(true);\n\n  /**\n   * Mensaje de error\n   */\n  errorMessage = signal<string>('');\n\n  /**\n   * Timestamp de la confirmación\n   */\n  confirmedAt = signal<Date>(new Date());\n\n  // ==================== COMPUTED SIGNALS ====================\n\n  /**\n   * ¿El pago fue exitoso?\n   */\n  readonly isSuccess = computed(() => {\n    return this.status() === 'success';\n  });\n\n  /**\n   * ¿El pago está pendiente?\n   */\n  readonly isPending = computed(() => {\n    return this.status() === 'pending';\n  });\n\n  /**\n   * ¿Hubo un error?\n   */\n  readonly isError = computed(() => {\n    return this.status() === 'error';\n  });\n\n  /**\n   * Nombre del proveedor para mostrar\n   */\n  readonly providerDisplayName = computed(() => {\n    const provider = this.paymentDetails()?.provider;\n    if (!provider) return '';\n\n    switch (provider) {\n      case 'mercadopago':\n        return 'MercadoPago';\n      case 'paypal':\n        return 'PayPal';\n      default:\n        return provider;\n    }\n  });\n\n  /**\n   * Mensaje de confirmación\n   */\n  readonly confirmationMessage = computed(() => {\n    const status = this.status();\n    const provider = this.providerDisplayName();\n\n    if (status === 'success') {\n      return `¡Pago confirmado con ${provider}!`;\n    } else if (status === 'pending') {\n      return `Pago pendiente de confirmación`;\n    } else {\n      return `Error procesando el pago`;\n    }\n  });\n\n  /**\n   * ID de referencia del pago para mostrar\n   */\n  readonly paymentReferenceId = computed(() => {\n    const details = this.paymentDetails();\n    if (!details) return '';\n\n    if (details.provider === 'paypal') {\n      return details.orderId || details.captureId || '';\n    } else {\n      return details.paymentId || details.preferenceId || '';\n    }\n  });\n\n  // ==================== LIFECYCLE ====================\n\n  async ngOnInit(): Promise<void> {\n    // Obtener booking ID de la ruta\n    const id = this.route.snapshot.paramMap.get('bookingId');\n    if (!id) {\n      this.status.set('error');\n      this.errorMessage.set('ID de booking no encontrado');\n      this.isLoading.set(false);\n      return;\n    }\n\n    this.bookingId.set(id);\n\n    // Obtener parámetros de query\n    const queryParams = this.route.snapshot.queryParams;\n    this.extractPaymentDetails(queryParams);\n\n    try {\n      await this.loadBookingAndVerifyPayment();\n    } catch (err) {\n      this.status.set('error');\n      this.errorMessage.set(err instanceof Error ? err.message : 'Error cargando la confirmación');\n    } finally {\n      this.isLoading.set(false);\n    }\n  }\n\n  // ==================== PRIVATE METHODS ====================\n\n  /**\n   * Extrae detalles del pago de los query params\n   */\n  private extractPaymentDetails(queryParams: unknown): void {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const provider = (queryParams as any)['provider'] as PaymentProvider;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const orderId = (queryParams as any)['orderId'];\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const captureId = (queryParams as any)['captureId'];\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const preferenceId = (queryParams as any)['preference_id'];\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const paymentId = (queryParams as any)['payment_id'];\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const mpStatus = (queryParams as any)['status'];\n\n    if (!provider) {\n      this.status.set('error');\n      this.errorMessage.set('Proveedor de pago no especificado');\n      return;\n    }\n\n    this.paymentDetails.set({\n      provider,\n      orderId,\n      captureId,\n      preferenceId,\n      paymentId,\n    });\n\n    // Determinar estado inicial basado en query params\n    if (provider === 'mercadopago' && mpStatus) {\n      if (mpStatus === 'approved') {\n        this.status.set('success');\n      } else if (mpStatus === 'pending') {\n        this.status.set('pending');\n      } else {\n        this.status.set('error');\n        this.errorMessage.set('El pago fue rechazado o cancelado');\n      }\n    } else if (provider === 'paypal' && captureId) {\n      // Si hay captureId, el pago fue capturado exitosamente\n      this.status.set('success');\n    } else if (provider === 'paypal' && orderId) {\n      // Solo orderId, puede estar pendiente\n      this.status.set('pending');\n    }\n  }\n\n  /**\n   * Carga el booking y verifica el estado del pago\n   */\n  private async loadBookingAndVerifyPayment(): Promise<void> {\n    const bookingData = await this.bookingsService.getBookingById(this.bookingId());\n\n    if (!bookingData) {\n      throw new Error('Booking no encontrado');\n    }\n\n    this.booking.set(bookingData);\n\n    // Verificar estado del booking\n    if (bookingData.status === 'confirmed') {\n      this.status.set('success');\n    } else if (bookingData.status === 'pending_payment') {\n      // El webhook puede tardar unos segundos\n      this.status.set('pending');\n      // Opcional: polling para verificar actualización\n      this.startPollingBookingStatus();\n    } else if (bookingData.status === 'cancelled') {\n      this.status.set('error');\n      this.errorMessage.set(`El booking está en estado \"${bookingData.status}\"`);\n    }\n  }\n\n  /**\n   * Inicia polling para verificar actualización del booking\n   */\n  private startPollingBookingStatus(): void {\n    let attempts = 0;\n    const maxAttempts = 10;\n    const interval = 3000; // 3 segundos\n\n    const pollInterval = setInterval(async () => {\n      attempts++;\n\n      try {\n        const bookingData = await this.bookingsService.getBookingById(this.bookingId());\n\n        if (bookingData && bookingData.status === 'confirmed') {\n          this.status.set('success');\n          this.booking.set(bookingData);\n          clearInterval(pollInterval);\n        } else if (attempts >= maxAttempts) {\n          // Después de 30 segundos, dejar en pending\n          clearInterval(pollInterval);\n        }\n      } catch (_error) {\n        console.error('Error polling booking status:', _error);\n        clearInterval(pollInterval);\n      }\n    }, interval);\n  }\n\n  // ==================== PUBLIC METHODS ====================\n\n  /**\n   * Navega a la página de detalles del booking\n   */\n  viewBookingDetails(): void {\n    this.router.navigate(['/bookings', this.bookingId()]);\n  }\n\n  /**\n   * Navega al inicio\n   */\n  goToHome(): void {\n    this.router.navigate(['/']);\n  }\n\n  /**\n   * Navega a la lista de bookings del usuario\n   */\n  goToMyBookings(): void {\n    this.router.navigate(['/bookings']);\n  }\n\n  /**\n   * Descarga recibo de pago\n   */\n  downloadReceipt(): void {\n    const booking = this.booking();\n    const payment = this.paymentDetails();\n\n    if (!booking || !payment) {\n      alert('No hay información disponible para generar el recibo');\n      return;\n    }\n\n    const receiptHtml = this.generateReceiptHTML(booking, payment);\n\n    // Crear blob y descargar\n    const blob = new Blob([receiptHtml], { type: 'text/html;charset=utf-8' });\n    const url = URL.createObjectURL(blob);\n    const link = document.createElement('a');\n    link.href = url;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    link.download = `recibo-${(booking as any).id}.html`;\n    link.click();\n\n    // Cleanup\n    setTimeout(() => URL.revokeObjectURL(url), 100);\n  }\n\n  /**\n   * Genera HTML del recibo de pago\n   */\n  private generateReceiptHTML(booking: unknown, _payment: PaymentDetails): string {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const b = booking as any;\n    const confirmDate = this.formatDate(this.confirmedAt());\n    const totalAmount = this.formatCurrency(b.total_price, b.currency || 'ARS');\n\n    return `\n<!DOCTYPE html>\n<html lang=\"es\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Recibo de Pago - ${b.id}</title>\n  <style>\n    body {\n      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;\n      max-width: 800px;\n      margin: 2rem auto;\n      padding: 2rem;\n      background: #f9fafb;\n    }\n    .receipt {\n      background: white;\n      border: 1px solid #e5e7eb;\n      border-radius: 8px;\n      padding: 2rem;\n      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);\n    }\n    .header {\n      text-align: center;\n      border-bottom: 2px solid #3b82f6;\n      padding-bottom: 1rem;\n      margin-bottom: 2rem;\n    }\n    .header h1 {\n      color: #1f2937;\n      margin: 0 0 0.5rem 0;\n      font-size: 2rem;\n    }\n    .header p {\n      color: #6b7280;\n      margin: 0;\n    }\n    .section {\n      margin-bottom: 1.5rem;\n    }\n    .section-title {\n      font-size: 1.125rem;\n      font-weight: 600;\n      color: #374151;\n      margin-bottom: 0.75rem;\n      border-bottom: 1px solid #e5e7eb;\n      padding-bottom: 0.5rem;\n    }\n    .detail-row {\n      display: flex;\n      justify-content: space-between;\n      padding: 0.5rem 0;\n      border-bottom: 1px solid #f3f4f6;\n    }\n    .detail-row:last-child {\n      border-bottom: none;\n    }\n    .detail-label {\n      color: #6b7280;\n      font-weight: 500;\n    }\n    .detail-value {\n      color: #1f2937;\n      font-weight: 600;\n    }\n    .total-row {\n      background: #f0fdf4;\n      padding: 1rem;\n      border-radius: 6px;\n      margin-top: 1rem;\n    }\n    .total-row .detail-label {\n      font-size: 1.125rem;\n      color: #166534;\n    }\n    .total-row .detail-value {\n      font-size: 1.5rem;\n      color: #16a34a;\n    }\n    .footer {\n      text-align: center;\n      margin-top: 2rem;\n      padding-top: 1rem;\n      border-top: 1px solid #e5e7eb;\n      color: #6b7280;\n      font-size: 0.875rem;\n    }\n    .status-badge {\n      display: inline-block;\n      padding: 0.25rem 0.75rem;\n      border-radius: 9999px;\n      font-size: 0.75rem;\n      font-weight: 600;\n      background: #d1fae5;\n      color: #065f46;\n    }\n    @media print {\n      body {\n        background: white;\n        margin: 0;\n        padding: 1rem;\n      }\n      .receipt {\n        box-shadow: none;\n        border: none;\n      }\n    }\n  </style>\n</head>\n<body>\n  <div class=\"receipt\">\n    <div class=\"header\">\n      <h1>🚗 AutoRenta</h1>\n      <p>Recibo de Pago</p>\n    </div>\n\n    <div class=\"section\">\n      <h2 class=\"section-title\">Información de la Reserva</h2>\n      <div class=\"detail-row\">\n        <span class=\"detail-label\">ID de Reserva:</span>\n        <span class=\"detail-value\">${b.id}</span>\n      </div>\n      <div class=\"detail-row\">\n        <span class=\"detail-label\">Vehículo:</span>\n        <span class=\"detail-value\">${b.car?.brand || ''} ${b.car?.model || ''}</span>\n      </div>\n      <div class=\"detail-row\">\n        <span class=\"detail-label\">Desde:</span>\n        <span class=\"detail-value\">${this.formatDate(b.start_date)}</span>\n      </div>\n      <div class=\"detail-row\">\n        <span class=\"detail-label\">Hasta:</span>\n        <span class=\"detail-value\">${this.formatDate(b.end_date)}</span>\n      </div>\n      <div class=\"detail-row\">\n        <span class=\"detail-label\">Estado:</span>\n        <span class=\"status-badge\">Confirmada</span>\n      </div>\n    </div>\n\n    <div class=\"section\">\n      <h2 class=\"section-title\">Detalles del Pago</h2>\n      <div class=\"detail-row\">\n        <span class=\"detail-label\">Proveedor:</span>\n        <span class=\"detail-value\">${this.providerDisplayName()}</span>\n      </div>\n      <div class=\"detail-row\">\n        <span class=\"detail-label\">ID de Referencia:</span>\n        <span class=\"detail-value\">${this.paymentReferenceId()}</span>\n      </div>\n      <div class=\"detail-row\">\n        <span class=\"detail-label\">Fecha de Pago:</span>\n        <span class=\"detail-value\">${confirmDate}</span>\n      </div>\n      <div class=\"total-row detail-row\">\n        <span class=\"detail-label\">Total Pagado:</span>\n        <span class=\"detail-value\">${totalAmount}</span>\n      </div>\n    </div>\n\n    <div class=\"footer\">\n      <p>Este recibo confirma el pago de tu reserva en AutoRenta.</p>\n      <p>Para cualquier consulta, contacta a soporte&#64;autorentar.com</p>\n      <p style=\"margin-top: 1rem; font-size: 0.75rem; color: #9ca3af;\">\n        Generado el ${this.formatDate(new Date())}\n      </p>\n    </div>\n  </div>\n</body>\n</html>\n    `.trim();\n  }\n\n  /**\n   * Reintenta cargar la confirmación\n   */\n  async retry(): Promise<void> {\n    this.isLoading.set(true);\n    this.errorMessage.set('');\n\n    try {\n      await this.loadBookingAndVerifyPayment();\n    } catch (err) {\n      this.errorMessage.set(err instanceof Error ? err.message : 'Error cargando la confirmación');\n    } finally {\n      this.isLoading.set(false);\n    }\n  }\n\n  /**\n   * Formatea un monto como moneda\n   */\n  formatCurrency(amount: number, currency: string): string {\n    return new Intl.NumberFormat(currency === 'ARS' ? 'es-AR' : 'en-US', {\n      style: 'currency',\n      currency: currency,\n      minimumFractionDigits: 2,\n      maximumFractionDigits: 2,\n    }).format(amount);\n  }\n\n  /**\n   * Formatea una fecha\n   */\n  formatDate(date: Date | string): string {\n    const d = typeof date === 'string' ? new Date(date) : date;\n    return new Intl.DateTimeFormat('es-AR', {\n      year: 'numeric',\n      month: 'long',\n      day: 'numeric',\n      hour: '2-digit',\n      minute: '2-digit',\n    }).format(d);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/features/bookings/pages/booking-wizard/booking-wizard.page.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`@core/services/bookings/bookings.service` import should occur before import of `../../components/booking-dates-step/booking-dates-step.component`","line":19,"column":1,"nodeType":"ImportDeclaration","endLine":19,"endColumn":76,"fix":{"range":[354,1299],"text":"import { BookingsService } from '@core/services/bookings/bookings.service';\nimport { BookingDatesStepComponent } from '../../components/booking-dates-step/booking-dates-step.component';\nimport { BookingDriverStepComponent } from '../../components/booking-driver-step/booking-driver-step.component';\nimport { BookingExtrasStepComponent } from '../../components/booking-extras-step/booking-extras-step.component';\nimport { BookingInsuranceStepComponent } from '../../components/booking-insurance-step/booking-insurance-step.component';\nimport { BookingPaymentStepComponent } from '../../components/booking-payment-step/booking-payment-step.component';\nimport { BookingReviewStepComponent } from '../../components/booking-review-step/booking-review-step.component';\nimport { BookingStepIndicatorComponent } from '../../components/booking-step-indicator/booking-step-indicator.component';\n\n// Services\nimport { Car } from '../../../../core/models';\n"}},{"ruleId":"import/order","severity":1,"message":"`@core/services/cars/cars.service` import should occur before import of `../../components/booking-dates-step/booking-dates-step.component`","line":20,"column":1,"nodeType":"ImportDeclaration","endLine":20,"endColumn":64,"fix":{"range":[354,1363],"text":"import { CarsService } from '@core/services/cars/cars.service';\nimport { BookingDatesStepComponent } from '../../components/booking-dates-step/booking-dates-step.component';\nimport { BookingDriverStepComponent } from '../../components/booking-driver-step/booking-driver-step.component';\nimport { BookingExtrasStepComponent } from '../../components/booking-extras-step/booking-extras-step.component';\nimport { BookingInsuranceStepComponent } from '../../components/booking-insurance-step/booking-insurance-step.component';\nimport { BookingPaymentStepComponent } from '../../components/booking-payment-step/booking-payment-step.component';\nimport { BookingReviewStepComponent } from '../../components/booking-review-step/booking-review-step.component';\nimport { BookingStepIndicatorComponent } from '../../components/booking-step-indicator/booking-step-indicator.component';\n\n// Services\nimport { Car } from '../../../../core/models';\nimport { BookingsService } from '@core/services/bookings/bookings.service';\n"}},{"ruleId":"import/order","severity":1,"message":"`@core/services/geo/distance-calculator.service` import should occur before import of `../../components/booking-dates-step/booking-dates-step.component`","line":21,"column":1,"nodeType":"ImportDeclaration","endLine":21,"endColumn":92,"fix":{"range":[354,1455],"text":"import { DistanceCalculatorService } from '@core/services/geo/distance-calculator.service';\nimport { BookingDatesStepComponent } from '../../components/booking-dates-step/booking-dates-step.component';\nimport { BookingDriverStepComponent } from '../../components/booking-driver-step/booking-driver-step.component';\nimport { BookingExtrasStepComponent } from '../../components/booking-extras-step/booking-extras-step.component';\nimport { BookingInsuranceStepComponent } from '../../components/booking-insurance-step/booking-insurance-step.component';\nimport { BookingPaymentStepComponent } from '../../components/booking-payment-step/booking-payment-step.component';\nimport { BookingReviewStepComponent } from '../../components/booking-review-step/booking-review-step.component';\nimport { BookingStepIndicatorComponent } from '../../components/booking-step-indicator/booking-step-indicator.component';\n\n// Services\nimport { Car } from '../../../../core/models';\nimport { BookingsService } from '@core/services/bookings/bookings.service';\nimport { CarsService } from '@core/services/cars/cars.service';\n"}},{"ruleId":"import/order","severity":1,"message":"`@core/services/auth/email-verification.service` import should occur before import of `../../components/booking-dates-step/booking-dates-step.component`","line":22,"column":1,"nodeType":"ImportDeclaration","endLine":22,"endColumn":91,"fix":{"range":[354,1546],"text":"import { EmailVerificationService } from '@core/services/auth/email-verification.service';\nimport { BookingDatesStepComponent } from '../../components/booking-dates-step/booking-dates-step.component';\nimport { BookingDriverStepComponent } from '../../components/booking-driver-step/booking-driver-step.component';\nimport { BookingExtrasStepComponent } from '../../components/booking-extras-step/booking-extras-step.component';\nimport { BookingInsuranceStepComponent } from '../../components/booking-insurance-step/booking-insurance-step.component';\nimport { BookingPaymentStepComponent } from '../../components/booking-payment-step/booking-payment-step.component';\nimport { BookingReviewStepComponent } from '../../components/booking-review-step/booking-review-step.component';\nimport { BookingStepIndicatorComponent } from '../../components/booking-step-indicator/booking-step-indicator.component';\n\n// Services\nimport { Car } from '../../../../core/models';\nimport { BookingsService } from '@core/services/bookings/bookings.service';\nimport { CarsService } from '@core/services/cars/cars.service';\nimport { DistanceCalculatorService } from '@core/services/geo/distance-calculator.service';\n"}},{"ruleId":"import/order","severity":1,"message":"`@core/services/infrastructure/error-handler.service` import should occur before import of `../../components/booking-dates-step/booking-dates-step.component`","line":23,"column":1,"nodeType":"ImportDeclaration","endLine":23,"endColumn":91,"fix":{"range":[354,1637],"text":"import { ErrorHandlerService } from '@core/services/infrastructure/error-handler.service';\nimport { BookingDatesStepComponent } from '../../components/booking-dates-step/booking-dates-step.component';\nimport { BookingDriverStepComponent } from '../../components/booking-driver-step/booking-driver-step.component';\nimport { BookingExtrasStepComponent } from '../../components/booking-extras-step/booking-extras-step.component';\nimport { BookingInsuranceStepComponent } from '../../components/booking-insurance-step/booking-insurance-step.component';\nimport { BookingPaymentStepComponent } from '../../components/booking-payment-step/booking-payment-step.component';\nimport { BookingReviewStepComponent } from '../../components/booking-review-step/booking-review-step.component';\nimport { BookingStepIndicatorComponent } from '../../components/booking-step-indicator/booking-step-indicator.component';\n\n// Services\nimport { Car } from '../../../../core/models';\nimport { BookingsService } from '@core/services/bookings/bookings.service';\nimport { CarsService } from '@core/services/cars/cars.service';\nimport { DistanceCalculatorService } from '@core/services/geo/distance-calculator.service';\nimport { EmailVerificationService } from '@core/services/auth/email-verification.service';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":5,"source":"import { isPlatformBrowser } from '@angular/common';\nimport {Component, computed, inject, OnInit, PLATFORM_ID, signal,\n  ChangeDetectionStrategy} from '@angular/core';\nimport { FormsModule } from '@angular/forms';\nimport { ActivatedRoute, Router } from '@angular/router';\nimport { IonicModule } from '@ionic/angular';\n\n// Step Components (to be created)\nimport { BookingDatesStepComponent } from '../../components/booking-dates-step/booking-dates-step.component';\nimport { BookingDriverStepComponent } from '../../components/booking-driver-step/booking-driver-step.component';\nimport { BookingExtrasStepComponent } from '../../components/booking-extras-step/booking-extras-step.component';\nimport { BookingInsuranceStepComponent } from '../../components/booking-insurance-step/booking-insurance-step.component';\nimport { BookingPaymentStepComponent } from '../../components/booking-payment-step/booking-payment-step.component';\nimport { BookingReviewStepComponent } from '../../components/booking-review-step/booking-review-step.component';\nimport { BookingStepIndicatorComponent } from '../../components/booking-step-indicator/booking-step-indicator.component';\n\n// Services\nimport { Car } from '../../../../core/models';\nimport { BookingsService } from '@core/services/bookings/bookings.service';\nimport { CarsService } from '@core/services/cars/cars.service';\nimport { DistanceCalculatorService } from '@core/services/geo/distance-calculator.service';\nimport { EmailVerificationService } from '@core/services/auth/email-verification.service';\nimport { ErrorHandlerService } from '@core/services/infrastructure/error-handler.service';\n\nexport interface BookingWizardData {\n  // Step 1: Dates & Location\n  carId: string;\n  startDate: Date | null;\n  endDate: Date | null;\n  pickupLocation: {\n    address: string;\n    lat: number;\n    lng: number;\n  } | null;\n  dropoffLocation: {\n    address: string;\n    lat: number;\n    lng: number;\n  } | null;\n\n  // Step 2: Insurance\n  insuranceLevel: 'basic' | 'standard' | 'premium' | null;\n\n  // Step 3: Extras\n  extras: {\n    id: string;\n    type: 'gps' | 'child_seat' | 'additional_driver' | 'toll_pass' | 'fuel_prepaid' | 'delivery';\n    quantity: number;\n    dailyRate: number;\n  }[];\n\n  // Step 4: Driver Details\n  driverLicense: {\n    number: string;\n    expirationDate: Date | null;\n    frontPhoto: string | null;\n    backPhoto: string | null;\n  } | null;\n  emergencyContact: {\n    name: string;\n    phone: string;\n    relationship: string;\n  } | null;\n\n  // Step 5: Payment\n  paymentMethod: 'wallet' | 'card' | 'bank_transfer' | 'split' | null;\n  paymentPlan: 'full' | 'split_50_50' | 'deposit_20' | 'installments' | null;\n  promoCode: string | null;\n\n  // Step 6: Review\n  termsAccepted: boolean;\n  cancellationPolicyAccepted: boolean;\n}\n\n/**\n * Tipo específico para los datos de reserva preparados\n * Asegura que todos los campos requeridos estén presentes\n */\ninterface PreparedBookingData {\n  car_id: string;\n  start_date: Date;\n  end_date: Date;\n  pickup_location: {\n    address: string;\n    lat: number;\n    lng: number;\n  };\n  dropoff_location: {\n    address: string;\n    lat: number;\n    lng: number;\n  };\n  insurance_level: 'basic' | 'standard' | 'premium' | null;\n  extras: {\n    id: string;\n    type: 'gps' | 'child_seat' | 'additional_driver' | 'toll_pass' | 'fuel_prepaid' | 'delivery';\n    quantity: number;\n    dailyRate: number;\n  }[];\n  driver_license: {\n    number: string;\n    expirationDate: Date | null;\n    frontPhoto: string | null;\n    backPhoto: string | null;\n  } | null;\n  emergency_contact: {\n    name: string;\n    phone: string;\n    relationship: string;\n  } | null;\n  payment_method: 'wallet' | 'card' | 'bank_transfer' | 'split' | null;\n  payment_plan: 'full' | 'split_50_50' | 'deposit_20' | 'installments' | null;\n  promo_code: string | null;\n}\n\n@Component({\n  selector: 'app-booking-wizard',\n  standalone: true,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  imports: [\n    FormsModule,\n    IonicModule,\n    BookingStepIndicatorComponent,\n    BookingDatesStepComponent,\n    BookingInsuranceStepComponent,\n    BookingExtrasStepComponent,\n    BookingDriverStepComponent,\n    BookingPaymentStepComponent,\n    BookingReviewStepComponent\n],\n  templateUrl: './booking-wizard.page.html',\n  styleUrls: ['./booking-wizard.page.scss'],\n})\nexport class BookingWizardPage implements OnInit {\n  private readonly platformId = inject(PLATFORM_ID);\n  private readonly isBrowser = isPlatformBrowser(this.platformId);\n\n  currentStep = signal(1);\n  totalSteps = 6;\n\n  wizardData = signal<BookingWizardData>({\n    carId: '',\n    startDate: null,\n    endDate: null,\n    pickupLocation: null,\n    dropoffLocation: null,\n    insuranceLevel: null,\n    extras: [],\n    driverLicense: null,\n    emergencyContact: null,\n    paymentMethod: null,\n    paymentPlan: null,\n    promoCode: null,\n    termsAccepted: false,\n    cancellationPolicyAccepted: false,\n  });\n\n  car = signal<Car | null>(null);\n  isLoading = signal(false);\n  isSavingDraft = signal(false);\n\n  // Computed values\n  canProceed = computed(() => {\n    const step = this.currentStep();\n    const data = this.wizardData();\n\n    switch (step) {\n      case 1:\n        return data.startDate && data.endDate && data.pickupLocation;\n      case 2:\n        return data.insuranceLevel !== null;\n      case 3:\n        return true; // Extras are optional\n      case 4:\n        return data.driverLicense && data.emergencyContact;\n      case 5:\n        return data.paymentMethod && data.paymentPlan;\n      case 6:\n        return data.termsAccepted && data.cancellationPolicyAccepted;\n      default:\n        return false;\n    }\n  });\n\n  canGoBack = computed(() => this.currentStep() > 1);\n  canGoForward = computed(() => this.currentStep() < this.totalSteps && this.canProceed());\n  isLastStep = computed(() => this.currentStep() === this.totalSteps);\n\n  constructor(\n    private router: Router,\n    private route: ActivatedRoute,\n    private carsService: CarsService,\n    private bookingsService: BookingsService,\n    private errorHandler: ErrorHandlerService,\n    private emailVerificationService: EmailVerificationService,\n    private distanceCalculator: DistanceCalculatorService,\n  ) {}\n\n  async ngOnInit() {\n    // Get car ID from route params\n    const carId = this.route.snapshot.queryParamMap.get('carId');\n    if (!carId) {\n      console.error('No car ID provided');\n      this.router.navigate(['/marketplace']);\n      return;\n    }\n\n    this.wizardData.update((data) => ({ ...data, carId }));\n\n    // Load car details\n    await this.loadCar(carId);\n\n    // Try to load saved draft\n    await this.loadDraft();\n  }\n\n  async loadCar(carId: string) {\n    this.isLoading.set(true);\n    try {\n      const car = await this.carsService.getCarById(carId);\n      this.car.set(car);\n    } catch (error) {\n      console.error('Error loading car:', error);\n      this.router.navigate(['/marketplace']);\n    } finally {\n      this.isLoading.set(false);\n    }\n  }\n\n  async loadDraft() {\n    if (!this.isBrowser) return;\n    try {\n      const carId = this.wizardData().carId;\n      const draftKey = `booking_draft_${carId}`;\n      const savedDraft = localStorage.getItem(draftKey);\n\n      if (savedDraft) {\n        const draft = JSON.parse(savedDraft);\n        this.wizardData.set(draft);\n      }\n    } catch (error) {\n      console.error('Error loading draft:', error);\n    }\n  }\n\n  async saveDraft() {\n    if (!this.isBrowser) return;\n    this.isSavingDraft.set(true);\n    try {\n      const carId = this.wizardData().carId;\n      const draftKey = `booking_draft_${carId}`;\n      localStorage.setItem(draftKey, JSON.stringify(this.wizardData()));\n    } catch (error) {\n      console.error('Error saving draft:', error);\n    } finally {\n      this.isSavingDraft.set(false);\n    }\n  }\n\n  nextStep() {\n    if (this.canGoForward()) {\n      this.currentStep.update((step) => step + 1);\n      this.saveDraft();\n      window.scrollTo(0, 0);\n    }\n  }\n\n  previousStep() {\n    if (this.canGoBack()) {\n      this.currentStep.update((step) => step - 1);\n      window.scrollTo(0, 0);\n    }\n  }\n\n  goToStep(step: number) {\n    if (step >= 1 && step <= this.totalSteps) {\n      this.currentStep.set(step);\n      window.scrollTo(0, 0);\n    }\n  }\n\n  onStepDataChange(stepData: Partial<BookingWizardData>) {\n    this.wizardData.update((data) => ({ ...data, ...stepData }));\n    this.saveDraft();\n  }\n\n  async submitBooking() {\n    if (!this.canProceed()) {\n      return;\n    }\n\n    // P0-013: Check email verification before allowing booking\n    const emailStatus = await this.emailVerificationService.checkStatus();\n    if (!emailStatus.isVerified) {\n      this.errorHandler.handleError(\n        new Error('Please verify your email before booking'),\n        'Email Verification Required',\n        true,\n      );\n      return;\n    }\n\n    this.isLoading.set(true);\n    try {\n      const bookingData = this.prepareBookingData();\n      const car = this.car();\n\n      if (!car) {\n        throw new Error('Car details not loaded');\n      }\n\n      // Calculate distance and delivery fee\n      const distanceKm =\n        this.distanceCalculator.calculateDistanceBetweenLocations(\n          { lat: bookingData.pickup_location.lat, lng: bookingData.pickup_location.lng },\n          { lat: car.location_lat ?? 0, lng: car.location_lng ?? 0 },\n        ) || 0;\n\n      const distanceMetadata = this.distanceCalculator.calculateDistanceMetadata(distanceKm);\n\n      const result = await this.bookingsService.createBookingWithValidation(\n        bookingData.car_id,\n        bookingData.start_date.toISOString(),\n        bookingData.end_date.toISOString(),\n        {\n          pickupLat: bookingData.pickup_location.lat,\n          pickupLng: bookingData.pickup_location.lng,\n          dropoffLat: bookingData.dropoff_location.lat,\n          dropoffLng: bookingData.dropoff_location.lng,\n          deliveryRequired: distanceKm > 0.5, // Consider delivery if > 500m\n          distanceKm: distanceKm,\n          deliveryFeeCents: distanceMetadata.deliveryFeeCents,\n          distanceTier: distanceMetadata.tier,\n        },\n      );\n\n      if (!result.success || !result.booking) {\n        throw new Error(result.error || 'Error creating booking');\n      }\n\n      const booking = result.booking;\n\n      // Clear draft\n      const carId = this.wizardData().carId;\n      if (this.isBrowser) localStorage.removeItem(`booking_draft_${carId}`);\n\n      // Navigate to payment page\n      this.router.navigate(['/bookings', booking.id, 'payment']);\n    } catch (error) {\n      this.errorHandler.handleError(error, 'Crear reserva', true);\n    } finally {\n      this.isLoading.set(false);\n    }\n  }\n\n  private prepareBookingData(): PreparedBookingData {\n    const data = this.wizardData();\n\n    return {\n      car_id: data.carId,\n      start_date: data.startDate!,\n      end_date: data.endDate!,\n      pickup_location: data.pickupLocation!,\n      dropoff_location: data.dropoffLocation || data.pickupLocation!,\n      insurance_level: data.insuranceLevel,\n      extras: data.extras,\n      driver_license: data.driverLicense,\n      emergency_contact: data.emergencyContact,\n      payment_method: data.paymentMethod,\n      payment_plan: data.paymentPlan,\n      promo_code: data.promoCode,\n    };\n  }\n\n  cancel() {\n    if (confirm('¿Estás seguro de que quieres cancelar? Se perderá tu progreso.')) {\n      const carId = this.wizardData().carId;\n      if (this.isBrowser) localStorage.removeItem(`booking_draft_${carId}`);\n      this.router.navigate(['/cars', carId]);\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/features/bookings/urgent-booking/urgent-booking.page.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`../../../core/models` type import should occur after import of `@core/services/bookings/urgent-rental.service`","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":49,"fix":{"range":[244,547],"text":"import { CarsService } from '@core/services/cars/cars.service';\nimport { NotificationManagerService } from '@core/services/infrastructure/notification-manager.service';\nimport { UrgentRentalService } from '@core/services/bookings/urgent-rental.service';\nimport type { Car } from '../../../core/models';\n"}}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":27,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":27,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1236,1239],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1236,1239],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":29,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":29,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1339,1342],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1339,1342],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { CommonModule } from '@angular/common';\nimport {Component, OnInit, inject, signal,\n  ChangeDetectionStrategy} from '@angular/core';\nimport { FormsModule } from '@angular/forms';\nimport { ActivatedRoute, Router } from '@angular/router';\nimport type { Car } from '../../../core/models';\nimport { CarsService } from '@core/services/cars/cars.service';\nimport { NotificationManagerService } from '@core/services/infrastructure/notification-manager.service';\nimport { UrgentRentalService } from '@core/services/bookings/urgent-rental.service';\n\n@Component({\n  selector: 'app-urgent-booking',\n  standalone: true,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  imports: [CommonModule, FormsModule],\n  templateUrl: './urgent-booking.page.html',\n})\nexport class UrgentBookingPage implements OnInit {\n  private readonly route = inject(ActivatedRoute);\n  private readonly router = inject(Router);\n  private readonly urgentRentalService = inject(UrgentRentalService);\n  private readonly carsService = inject(CarsService);\n  private readonly toastService = inject(NotificationManagerService);\n\n  readonly car = signal<Car | null>(null);\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  readonly availability = signal<any>(null);\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  readonly quote = signal<any>(null);\n  readonly loading = signal(false);\n  readonly creating = signal(false);\n  readonly error = signal<string | null>(null);\n\n  durationHours = 5;\n  carId = '';\n  regionId = '';\n\n  async ngOnInit(): Promise<void> {\n    this.carId = this.route.snapshot.paramMap.get('carId') || '';\n    this.regionId = this.route.snapshot.queryParamMap.get('regionId') || '';\n\n    if (!this.carId) {\n      this.error.set('ID de auto no proporcionado');\n      return;\n    }\n\n    await Promise.all([this.loadCar(), this.loadAvailability(), this.loadUserLocation()]);\n    await this.updateQuote();\n  }\n\n  async loadCar(): Promise<void> {\n    this.loading.set(true);\n\n    try {\n      const car = await this.carsService.getCarById(this.carId);\n      this.car.set(car);\n    } catch {\n      this.error.set('Error al cargar información del auto');\n    } finally {\n      this.loading.set(false);\n    }\n  }\n\n  async loadAvailability(): Promise<void> {\n    try {\n      const availability = await this.urgentRentalService.checkImmediateAvailability(this.carId);\n      this.availability.set(availability);\n    } catch (err) {\n      console.error('Error checking availability:', err);\n    }\n  }\n\n  async loadUserLocation(): Promise<void> {\n    try {\n      await this.urgentRentalService.getCurrentLocation();\n    } catch (err) {\n      console.warn('No se pudo obtener ubicación del usuario:', err);\n    }\n  }\n\n  async updateQuote(): Promise<void> {\n    if (!this.regionId || !this.carId) return;\n\n    try {\n      const quote = await this.urgentRentalService.getUrgentQuote(\n        this.carId,\n        this.regionId,\n        this.durationHours,\n      );\n      this.quote.set(quote);\n    } catch (err) {\n      console.error('Error getting quote:', err);\n    }\n  }\n\n  canCreateBooking(): boolean {\n    const avail = this.availability();\n    return avail?.available === true && this.quote() !== null;\n  }\n\n  async createBooking(): Promise<void> {\n    if (!this.canCreateBooking()) return;\n\n    this.creating.set(true);\n    this.error.set(null);\n\n    try {\n      const userLocation = this.urgentRentalService.userLocation();\n      const result = await this.urgentRentalService.createUrgentBooking(\n        this.carId,\n        this.durationHours,\n        userLocation || undefined,\n      );\n\n      if (result.success && result.bookingId) {\n        this.toastService.success('Reserva urgente creada correctamente', '');\n        await this.router.navigate(['/bookings', result.bookingId]);\n      } else {\n        this.error.set(result.error || 'Error al crear la reserva');\n      }\n    } catch (err) {\n      this.error.set(err instanceof Error ? err.message : 'Error desconocido');\n    } finally {\n      this.creating.set(false);\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/features/calendar/calendar.page.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`@core/services/infrastructure/supabase-client.service` import should occur before import of `../../core/models`","line":12,"column":1,"nodeType":"ImportDeclaration","endLine":12,"endColumn":95,"fix":{"range":[329,542],"text":"import { SupabaseClientService } from '@core/services/infrastructure/supabase-client.service';\nimport { Car } from '../../core/models';\nimport { IconComponent } from '../../shared/components/icon/icon.component';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"\nimport {Component, OnInit, computed, inject, signal,\n  ChangeDetectionStrategy} from '@angular/core';\nimport { RouterModule } from '@angular/router';\nimport { CarsService } from '@core/services/cars/cars.service';\nimport {\n  CarAvailabilityService,\n  DetailedBlockedRange,\n} from '@core/services/cars/car-availability.service';\nimport { Car } from '../../core/models';\nimport { IconComponent } from '../../shared/components/icon/icon.component';\nimport { SupabaseClientService } from '@core/services/infrastructure/supabase-client.service';\n\ninterface CalendarDay {\n  day: number | null;\n  date: string | null;\n  isToday: boolean;\n  isPast: boolean;\n  isBlocked: boolean;\n  blockType: 'booking' | 'blackout' | 'manual_block' | null;\n  blockReason: string | null;\n  isSelected: boolean;\n}\n\n@Component({\n  selector: 'app-calendar',\n  standalone: true,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  imports: [RouterModule, IconComponent],\n  templateUrl: './calendar.page.html',\n  styleUrls: ['./calendar.page.css'],\n})\nexport class CalendarPage implements OnInit {\n  private readonly carsService = inject(CarsService);\n  private readonly availabilityService = inject(CarAvailabilityService);\n  private readonly supabaseClient = inject(SupabaseClientService);\n\n  // State signals\n  readonly currentDate = signal(new Date());\n  readonly myCars = signal<Car[]>([]);\n  readonly selectedCarId = signal<string | null>(null);\n  readonly blockedRanges = signal<DetailedBlockedRange[]>([]);\n  readonly loading = signal(true);\n  readonly loadingBlocks = signal(false);\n  readonly selectedDates = signal<Set<string>>(new Set());\n  readonly isAddingBlackout = signal(false);\n  readonly blackoutReason = signal('');\n  readonly error = signal<string | null>(null);\n\n  // Computed values\n  readonly selectedCar = computed(() => {\n    const carId = this.selectedCarId();\n    return this.myCars().find((c) => c.id === carId) || null;\n  });\n\n  readonly monthName = computed(() => {\n    return this.currentDate().toLocaleDateString('es-AR', { month: 'long', year: 'numeric' });\n  });\n\n  readonly calendarDays = computed((): CalendarDay[] => {\n    const date = this.currentDate();\n    const year = date.getFullYear();\n    const month = date.getMonth();\n    const today = new Date();\n    today.setHours(0, 0, 0, 0);\n\n    const daysInMonth = new Date(year, month + 1, 0).getDate();\n    const firstDayOfMonth = new Date(year, month, 1).getDay();\n    const blockedRanges = this.blockedRanges();\n    const selectedDates = this.selectedDates();\n\n    const days: CalendarDay[] = [];\n\n    // Add empty cells for days before month starts\n    for (let i = 0; i < firstDayOfMonth; i++) {\n      days.push({\n        day: null,\n        date: null,\n        isToday: false,\n        isPast: false,\n        isBlocked: false,\n        blockType: null,\n        blockReason: null,\n        isSelected: false,\n      });\n    }\n\n    // Add all days of the month\n    for (let d = 1; d <= daysInMonth; d++) {\n      const dateObj = new Date(year, month, d);\n      const dateStr = this.formatDate(dateObj);\n      const isPast = dateObj < today;\n      const isToday = dateObj.getTime() === today.getTime();\n\n      // Check if date is blocked\n      const block = this.findBlockForDate(dateStr, blockedRanges);\n\n      days.push({\n        day: d,\n        date: dateStr,\n        isToday,\n        isPast,\n        isBlocked: !!block,\n        blockType: block?.type || null,\n        blockReason: block?.reason || null,\n        isSelected: selectedDates.has(dateStr),\n      });\n    }\n\n    return days;\n  });\n\n  async ngOnInit(): Promise<void> {\n    await this.loadMyCars();\n  }\n\n  private async loadMyCars(): Promise<void> {\n    try {\n      this.loading.set(true);\n      const cars = await this.carsService.listMyCars();\n      this.myCars.set(cars);\n\n      // Auto-select first car if available\n      if (cars.length > 0) {\n        await this.selectCar(cars[0].id);\n      }\n    } catch (err) {\n      console.error('Error loading cars:', err);\n      this.error.set('Error al cargar tus autos');\n    } finally {\n      this.loading.set(false);\n    }\n  }\n\n  async selectCar(carId: string): Promise<void> {\n    this.selectedCarId.set(carId);\n    this.selectedDates.set(new Set());\n    this.isAddingBlackout.set(false);\n    await this.loadBlockedDates();\n  }\n\n  private async loadBlockedDates(): Promise<void> {\n    const carId = this.selectedCarId();\n    if (!carId) return;\n\n    try {\n      this.loadingBlocks.set(true);\n\n      // Load blocked dates for 6 months ahead\n      const start = new Date();\n      const end = new Date();\n      end.setMonth(end.getMonth() + 6);\n\n      const ranges = await this.availabilityService.getBlockedDates(carId, start, end);\n      this.blockedRanges.set(ranges);\n    } catch (err) {\n      console.error('Error loading blocked dates:', err);\n    } finally {\n      this.loadingBlocks.set(false);\n    }\n  }\n\n  previousMonth(): void {\n    const current = this.currentDate();\n    this.currentDate.set(new Date(current.getFullYear(), current.getMonth() - 1, 1));\n  }\n\n  nextMonth(): void {\n    const current = this.currentDate();\n    this.currentDate.set(new Date(current.getFullYear(), current.getMonth() + 1, 1));\n  }\n\n  onDateClick(calDay: CalendarDay): void {\n    if (!calDay.date || calDay.isPast) return;\n\n    // If blocked by a booking, cannot select\n    if (calDay.isBlocked && calDay.blockType === 'booking') {\n      return;\n    }\n\n    const selected = new Set(this.selectedDates());\n    if (selected.has(calDay.date)) {\n      selected.delete(calDay.date);\n    } else {\n      selected.add(calDay.date);\n    }\n    this.selectedDates.set(selected);\n  }\n\n  startAddBlackout(): void {\n    if (this.selectedDates().size === 0) return;\n    this.isAddingBlackout.set(true);\n  }\n\n  cancelAddBlackout(): void {\n    this.isAddingBlackout.set(false);\n    this.blackoutReason.set('');\n  }\n\n  async confirmAddBlackout(): Promise<void> {\n    const carId = this.selectedCarId();\n    const dates = Array.from(this.selectedDates()).sort();\n    if (!carId || dates.length === 0) return;\n\n    try {\n      this.loading.set(true);\n\n      const startsAt = dates[0];\n      const endsAt = dates[dates.length - 1];\n      const reason = this.blackoutReason().trim() || 'Bloqueado manualmente';\n\n      const supabase = this.supabaseClient.getClient();\n      // Persist bloqueo manual en car_blocked_dates (tabla vigente en Supabase)\n      const { error } = await supabase.from('car_blocked_dates').insert({\n        car_id: carId,\n        blocked_from: startsAt,\n        blocked_to: endsAt,\n        reason,\n      });\n\n      if (error) throw error;\n\n      // Refresh data\n      await this.loadBlockedDates();\n      this.selectedDates.set(new Set());\n      this.isAddingBlackout.set(false);\n      this.blackoutReason.set('');\n    } catch (err) {\n      console.error('Error adding blackout:', err);\n      this.error.set('Error al agregar bloqueo');\n    } finally {\n      this.loading.set(false);\n    }\n  }\n\n  async removeBlackout(blockId: string): Promise<void> {\n    if (!blockId) return;\n\n    try {\n      this.loading.set(true);\n\n      const supabase = this.supabaseClient.getClient();\n      const { error } = await supabase.from('car_blocked_dates').delete().eq('id', blockId);\n\n      if (error) throw error;\n\n      await this.loadBlockedDates();\n    } catch (err) {\n      console.error('Error removing blackout:', err);\n      this.error.set('Error al eliminar bloqueo');\n    } finally {\n      this.loading.set(false);\n    }\n  }\n\n  clearSelection(): void {\n    this.selectedDates.set(new Set());\n  }\n\n  onReasonInput(event: Event): void {\n    const target = event.target as HTMLInputElement;\n    this.blackoutReason.set(target.value);\n  }\n\n  // Helpers\n  carLabel(car: Car | null | undefined): string {\n    if (!car) return 'Auto sin título';\n    const parts = [car.brand, car.model, car.year].filter(Boolean);\n    const label = parts.join(' ').trim();\n    return label.length > 0 ? label : 'Auto sin título';\n  }\n\n  private findBlockForDate(\n    dateStr: string,\n    ranges: DetailedBlockedRange[],\n  ): DetailedBlockedRange | null {\n    for (const range of ranges) {\n      if (dateStr >= range.from && dateStr <= range.to) {\n        return range;\n      }\n    }\n    return null;\n  }\n\n  private formatDate(date: Date): string {\n    const year = date.getFullYear();\n    const month = String(date.getMonth() + 1).padStart(2, '0');\n    const day = String(date.getDate()).padStart(2, '0');\n    return `${year}-${month}-${day}`;\n  }\n\n  getBlockTypeLabel(type: string | null): string {\n    switch (type) {\n      case 'booking':\n        return 'Reservado';\n      case 'blackout':\n        return 'Bloqueado';\n      case 'manual_block':\n        return 'Bloqueado';\n      default:\n        return '';\n    }\n  }\n\n  trackByCar(index: number, car: Car): string {\n    return car.id;\n  }\n\n  trackByDay(index: number): number {\n    return index;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/features/cars/bulk-blocking/bulk-blocking.page.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`../../../core/models` import should occur after import of `@core/services/cars/cars.service`","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":44,"fix":{"range":[185,372],"text":"import { CarBlockingService } from '@core/services/cars/car-blocking.service';\nimport { CarsService } from '@core/services/cars/cars.service';\nimport { Car } from '../../../core/models';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"\nimport {Component, inject, OnInit, signal,\n  ChangeDetectionStrategy} from '@angular/core';\nimport { FormsModule } from '@angular/forms';\nimport { IonicModule } from '@ionic/angular';\nimport { Car } from '../../../core/models';\nimport { CarBlockingService } from '@core/services/cars/car-blocking.service';\nimport { CarsService } from '@core/services/cars/cars.service';\n\n@Component({\n  selector: 'app-bulk-blocking',\n  standalone: true,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  imports: [FormsModule, IonicModule],\n  templateUrl: './bulk-blocking.page.html',\n  styleUrls: ['./bulk-blocking.page.scss'],\n})\nexport class BulkBlockingPage implements OnInit {\n  private readonly blockingService = inject(CarBlockingService);\n  private readonly carsService = inject(CarsService);\n\n  readonly loading = signal(false);\n  readonly cars = signal<Car[]>([]);\n  readonly selectedCarIds = signal<string[]>([]);\n  readonly startDate = signal<string>('');\n  readonly endDate = signal<string>('');\n  readonly reason = signal<'maintenance' | 'personal_use' | 'vacation' | 'other'>('maintenance');\n  readonly notes = signal<string>('');\n  readonly error = signal<string | null>(null);\n  readonly success = signal<string | null>(null);\n  readonly result = signal<{ success: number; failed: number; errors: string[] } | null>(null);\n\n  async ngOnInit(): Promise<void> {\n    await this.loadCars();\n  }\n\n  async loadCars(): Promise<void> {\n    this.loading.set(true);\n    try {\n      const myCars = await this.carsService.listMyCars();\n      this.cars.set(myCars || []);\n    } catch (err) {\n      console.error('Error loading cars:', err);\n      this.error.set('Error al cargar autos');\n    } finally {\n      this.loading.set(false);\n    }\n  }\n\n  toggleCarSelection(carId: string): void {\n    this.selectedCarIds.update((ids) => {\n      if (ids.includes(carId)) {\n        return ids.filter((id) => id !== carId);\n      } else {\n        return [...ids, carId];\n      }\n    });\n  }\n\n  isCarSelected(carId: string): boolean {\n    return this.selectedCarIds().includes(carId);\n  }\n\n  selectAllCars(): void {\n    this.selectedCarIds.set(this.cars().map((car) => car.id));\n  }\n\n  deselectAllCars(): void {\n    this.selectedCarIds.set([]);\n  }\n\n  async bulkBlockDates(): Promise<void> {\n    if (this.selectedCarIds().length === 0) {\n      this.error.set('Debe seleccionar al menos un auto');\n      return;\n    }\n\n    if (!this.startDate() || !this.endDate()) {\n      this.error.set('Debe seleccionar fecha de inicio y fin');\n      return;\n    }\n\n    const start = new Date(this.startDate());\n    const end = new Date(this.endDate());\n\n    if (start > end) {\n      this.error.set('La fecha de inicio debe ser anterior a la fecha de fin');\n      return;\n    }\n\n    this.loading.set(true);\n    this.error.set(null);\n    this.success.set(null);\n    this.result.set(null);\n\n    try {\n      const result = await this.blockingService.bulkBlockDates(\n        this.selectedCarIds(),\n        start,\n        end,\n        this.reason(),\n        this.notes() || undefined,\n      );\n\n      this.result.set(result);\n\n      if (result.success > 0) {\n        this.success.set(\n          `Se bloquearon ${result.success} auto(s) exitosamente. ${result.failed > 0 ? `${result.failed} fallaron.` : ''}`,\n        );\n      }\n\n      if (result.failed > 0 && result.errors.length > 0) {\n        this.error.set(result.errors.join('\\n'));\n      }\n\n      // Reset form if all succeeded\n      if (result.failed === 0) {\n        this.resetForm();\n      }\n    } catch (err) {\n      console.error('Error blocking dates:', err);\n      this.error.set(err instanceof Error ? err.message : 'Error al bloquear fechas');\n    } finally {\n      this.loading.set(false);\n    }\n  }\n\n  resetForm(): void {\n    this.selectedCarIds.set([]);\n    this.startDate.set('');\n    this.endDate.set('');\n    this.reason.set('maintenance');\n    this.notes.set('');\n    this.result.set(null);\n  }\n\n  getReasonLabel(reason: string): string {\n    const labels: Record<string, string> = {\n      maintenance: 'Mantenimiento',\n      personal_use: 'Uso Personal',\n      vacation: 'Vacaciones',\n      other: 'Otro',\n    };\n    return labels[reason] || reason;\n  }\n\n  getCarDisplayName(car: Car): string {\n    return `${car.brand} ${car.model} ${car.year}`;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/features/cars/conversion/cars-conversion.page.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`@core/services/cars/cars.service` import should occur before import of `../../../shared/components/icon/icon.component`","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":8,"endColumn":64,"fix":{"range":[193,428],"text":"import { CarsService } from '@core/services/cars/cars.service';\nimport { IconComponent } from '../../../shared/components/icon/icon.component';\nimport { CarCardComponent } from '../../../shared/components/car-card/car-card.component';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import {Component, inject, signal, OnInit,\n  ChangeDetectionStrategy} from '@angular/core';\nimport { Router, RouterLink } from '@angular/router';\nimport { FormsModule } from '@angular/forms';\n\nimport { IconComponent } from '../../../shared/components/icon/icon.component';\nimport { CarCardComponent } from '../../../shared/components/car-card/car-card.component';\nimport { CarsService } from '@core/services/cars/cars.service';\nimport { Car } from '../../../core/models';\n\n@Component({\n  selector: 'app-cars-conversion',\n  standalone: true,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  imports: [RouterLink, IconComponent, FormsModule, CarCardComponent],\n  templateUrl: './cars-conversion.page.html',\n  styleUrls: ['./cars-conversion.page.css'],\n})\nexport class CarsConversionPage implements OnInit {\n  private readonly router = inject(Router);\n  private readonly carsService = inject(CarsService);\n\n  searchQuery = signal('');\n  readonly featuredCars = signal<Car[]>([]);\n  readonly loading = signal(true);\n\n  async ngOnInit(): Promise<void> {\n    await this.loadFeaturedCars();\n  }\n\n  private async loadFeaturedCars(): Promise<void> {\n    try {\n      const cars = await this.carsService.listActiveCars({});\n      // Ordenar por rating y tomar los 6 mejores\n      const sorted = cars\n        .filter(car => (car.photos?.length || car.car_photos?.length) && (car.price_per_day ?? 0) > 0)\n        .sort((a, b) => (b.rating_avg || 0) - (a.rating_avg || 0))\n        .slice(0, 6);\n      this.featuredCars.set(sorted);\n    } catch (error) {\n      console.error('Error loading featured cars:', error);\n    } finally {\n      this.loading.set(false);\n    }\n  }\n\n  onSearchSubmit(): void {\n    const query = this.searchQuery().trim();\n    if (query) {\n      void this.router.navigate(['/cars/list'], { queryParams: { q: query } });\n    } else {\n      void this.router.navigate(['/cars/list']);\n    }\n  }\n\n  navigateToList(): void {\n    void this.router.navigate(['/cars/list']);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/features/cars/detail/car-detail.page.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`@core/services/verification/risk-calculator.service` import should occur before import of `../../../core/models`","line":40,"column":1,"nodeType":"ImportDeclaration","endLine":40,"endColumn":110,"fix":{"range":[1468,1835],"text":"import { RiskCalculation, RiskCalculatorService } from '@core/services/verification/risk-calculator.service';\nimport { Car, CarPhoto, CarStats, Review } from '../../../core/models';\nimport { calculateCreditSecurityUsd } from '../../../core/models/booking-detail-payment.model';\nimport { BookingPaymentMethod } from '../../../core/models/wallet.model';\n\n// Components\n"}},{"ruleId":"import/order","severity":1,"message":"`@core/services/infrastructure/analytics.service` import should occur before import of `../../../core/models`","line":75,"column":1,"nodeType":"ImportDeclaration","endLine":75,"endColumn":84},{"ruleId":"import/order","severity":1,"message":"`@core/services/infrastructure/notification-manager.service` import should occur before import of `../../../core/models`","line":76,"column":1,"nodeType":"ImportDeclaration","endLine":76,"endColumn":105},{"ruleId":"import/order","severity":1,"message":"`@core/services/infrastructure/tiktok-events.service` import should occur before import of `../../../core/models`","line":77,"column":1,"nodeType":"ImportDeclaration","endLine":77,"endColumn":91},{"ruleId":"import/order","severity":1,"message":"`@core/services/bookings/urgent-rental.service` import should occur before import of `../../../core/models`","line":78,"column":1,"nodeType":"ImportDeclaration","endLine":78,"endColumn":85},{"ruleId":"import/order","severity":1,"message":"`@core/services/bookings/waitlist.service` import should occur before import of `../../../core/models`","line":79,"column":1,"nodeType":"ImportDeclaration","endLine":79,"endColumn":76}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { LoggerService } from '@core/services/infrastructure/logger.service';\nimport { CommonModule } from '@angular/common';\nimport {\n  AfterViewInit,\n  ChangeDetectionStrategy,\n  Component,\n  computed,\n  ElementRef,\n  inject,\n  OnDestroy,\n  OnInit,\n  signal,\n  ViewChild,\n} from '@angular/core';\nimport { toSignal } from '@angular/core/rxjs-interop';\nimport { ActivatedRoute, Router, RouterLink } from '@angular/router';\nimport { TranslateModule } from '@ngx-translate/core';\nimport { combineLatest, from, fromEvent, of, Subject } from 'rxjs';\nimport { catchError, map, switchMap, takeUntil, throttleTime } from 'rxjs/operators';\n\n// Services\nimport { AuthService } from '@core/services/auth/auth.service';\nimport { BookingsService } from '@core/services/bookings/bookings.service';\nimport { CarsService } from '@core/services/cars/cars.service';\nimport { DistanceCalculatorService } from '@core/services/geo/distance-calculator.service';\nimport { DynamicPricingService } from '@core/services/payments/dynamic-pricing.service';\nimport { FxService } from '@core/services/payments/fx.service';\nimport { LocationService } from '@core/services/geo/location.service';\nimport { MetaService } from '@core/services/ui/meta.service';\nimport { ReviewsService } from '@core/services/cars/reviews.service';\nimport { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\nimport { WalletService } from '@core/services/payments/wallet.service';\n\n// Models\nimport { Car, CarPhoto, CarStats, Review } from '../../../core/models';\nimport { calculateCreditSecurityUsd } from '../../../core/models/booking-detail-payment.model';\nimport { BookingPaymentMethod } from '../../../core/models/wallet.model';\n\n// Components\nimport { RiskCalculation, RiskCalculatorService } from '@core/services/verification/risk-calculator.service';\nimport { AiChecklistPanelComponent } from '../../../shared/components/ai-checklist-panel/ai-checklist-panel.component';\nimport { AiLegalPanelComponent } from '../../../shared/components/ai-legal-panel/ai-legal-panel.component';\nimport { AiReputationCardComponent } from '../../../shared/components/ai-reputation-card/ai-reputation-card.component';\nimport { AiTripPanelComponent } from '../../../shared/components/ai-trip-panel/ai-trip-panel.component';\nimport { CarInquiryChatComponent } from '../../../shared/components/car-inquiry-chat/car-inquiry-chat.component';\nimport { CarReviewsSectionComponent } from '../../../shared/components/car-reviews-section/car-reviews-section.component';\nimport {\n  DateRange,\n  DateRangePickerComponent,\n} from '../../../shared/components/date-range-picker/date-range-picker.component';\nimport { IconComponent } from '../../../shared/components/icon/icon.component';\nimport { type PaymentMethod } from '../../../shared/components/payment-method-buttons/payment-method-buttons.component';\nimport { AvailabilityMiniCalendarComponent } from '../../../shared/components/availability-mini-calendar/availability-mini-calendar.component';\nimport { RiskCalculatorViewerComponent } from '../../../shared/components/risk-calculator-viewer/risk-calculator-viewer.component';\nimport { StickyCtaMobileComponent } from '../../../shared/components/sticky-cta-mobile/sticky-cta-mobile.component';\nimport {\n  BookingLocationData,\n} from '../../bookings/components/booking-location-form/booking-location-form.component';\n\n// Temporary interfaces until components are created\nexport interface Photo {\n  id: string;\n  url: string;\n  alt: string;\n  thumbnail?: string;\n}\n\nexport interface BreadcrumbItem {\n  label: string;\n  url?: string;\n  icon?: string;\n}\n\n// Services\nimport { AnalyticsService } from '@core/services/infrastructure/analytics.service';\nimport { NotificationManagerService } from '@core/services/infrastructure/notification-manager.service';\nimport { TikTokEventsService } from '@core/services/infrastructure/tiktok-events.service';\nimport { UrgentRentalService } from '@core/services/bookings/urgent-rental.service';\nimport { WaitlistService } from '@core/services/bookings/waitlist.service';\n\ninterface CarDetailState {\n  car: Car | null;\n  reviews: Review[];\n  stats: CarStats | null;\n  loading: boolean;\n  error: string | null;\n}\n\n@Component({\n  standalone: true,\n  selector: 'app-car-detail-page',\n  imports: [\n    CommonModule,\n    RouterLink,\n    DateRangePickerComponent,\n    CarReviewsSectionComponent,\n    TranslateModule,\n    StickyCtaMobileComponent,\n    IconComponent,\n    RiskCalculatorViewerComponent,\n    AiLegalPanelComponent,\n    AiTripPanelComponent,\n    AiChecklistPanelComponent,\n    AiReputationCardComponent,\n    CarInquiryChatComponent,\n    AvailabilityMiniCalendarComponent,\n  ],\n  templateUrl: './car-detail.page.html',\n  styleUrls: ['./car-detail.page.css'],\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class CarDetailPage implements OnInit, AfterViewInit, OnDestroy {\n  private readonly logger = inject(LoggerService);\n  // ✅ NEW: ViewChild references for scroll behavior\n  @ViewChild('stickyHeader', { read: ElementRef }) stickyHeaderRef?: ElementRef<HTMLDivElement>;\n  @ViewChild('mainHeader', { read: ElementRef }) mainHeaderRef?: ElementRef<HTMLDivElement>;\n  @ViewChild('bookingDatePicker', { read: DateRangePickerComponent })\n  bookingDatePicker?: DateRangePickerComponent;\n  private readonly route = inject(ActivatedRoute);\n  public readonly router = inject(Router);\n  private readonly carsService = inject(CarsService);\n  private readonly reviewsService = inject(ReviewsService);\n  private readonly bookingsService = inject(BookingsService);\n  private readonly walletService = inject(WalletService);\n  private readonly metaService = inject(MetaService);\n  private readonly fxService = inject(FxService);\n  private readonly supabase = injectSupabase();\n  readonly authService = inject(AuthService);\n  readonly pricingService = inject(DynamicPricingService);\n  readonly urgentRentalService = inject(UrgentRentalService);\n  private readonly analytics = inject(AnalyticsService);\n  private readonly distanceCalculator = inject(DistanceCalculatorService);\n  private readonly locationService = inject(LocationService);\n  private readonly waitlistService = inject(WaitlistService);\n  private readonly toastService = inject(NotificationManagerService);\n  private readonly tiktokEvents = inject(TikTokEventsService);\n  private readonly riskCalculatorService = inject(RiskCalculatorService);\n  private readonly usdFormatter = new Intl.NumberFormat('en-US', {\n    style: 'currency',\n    currency: 'USD',\n    minimumFractionDigits: 0,\n    maximumFractionDigits: 0,\n  });\n\n  // P0-006 FIX: Memory leak prevention\n  private readonly destroy$ = new Subject<void>();\n\n  readonly expressMode = signal(false);\n  readonly dateRange = signal<DateRange>({ from: null, to: null });\n  readonly urgentAvailability = signal<{\n    available: boolean;\n    distance?: number;\n    eta?: number;\n  } | null>(null);\n\n  // ✅ NEW: Distance-based pricing\n  readonly userLocation = signal<{ lat: number; lng: number } | null>(null);\n  readonly distanceKm = signal<number | null>(null);\n  readonly deliveryFeeCents = signal<number>(0);\n  readonly distanceTier = signal<'local' | 'regional' | 'long_distance' | null>(null);\n  readonly bookingInProgress = signal(false);\n  readonly bookingError = signal<string | null>(null);\n  readonly termsAccepted = signal(false); // ✅ Checkbox de aceptación de términos\n  readonly validatingAvailability = signal(false); // ✅ NEW: Loading state for re-validation\n  readonly selectedPaymentMethod = signal<BookingPaymentMethod>('credit_card');\n\n  // ✅ NEW: Booking location form state\n  readonly pendingBookingData = signal<{ from: string; to: string } | null>(null);\n\n  // ✅ NEW: Date suggestions and waitlist\n  readonly suggestedDateRanges = signal<\n    Array<{ startDate: string; endDate: string; daysCount: number }>\n  >([]);\n  readonly canWaitlist = signal(false);\n  readonly addingToWaitlist = signal(false);\n  readonly currentPhotoIndex = signal(0);\n  readonly blockedDates = signal<string[]>([]); // DEPRECATED: Usado solo para inline calendar\n  readonly blockedRanges = signal<Array<{ from: string; to: string }>>([]); // ✅ NEW: Rangos bloqueados para date picker\n  readonly imageLoaded = signal(false);\n  readonly specsCollapsed = signal(false);\n\n  private readonly defaultCarPlaceholderUrl = '/assets/placeholder-car.webp';\n\n  // ✅ FIX: Precio dinámico para mostrar en lugar del estático\n  readonly dynamicPrice = signal<number | null>(null);\n  readonly priceLoading = signal(false);\n  readonly hourlyRateLoading = signal(false);\n\n  readonly isCarOwner = signal<boolean>(false);\n\n  // Risk calculation for guarantee display\n  readonly riskCalculation = signal<RiskCalculation | null>(null);\n  readonly showRiskCalculator = signal(false);\n\n  // AI Panels\n  readonly expandedAiPanel = signal<'legal' | 'trip' | 'checklist' | null>(null);\n\n  toggleAiPanel(panel: 'legal' | 'trip' | 'checklist'): void {\n    this.expandedAiPanel.update(current => current === panel ? null : panel);\n  }\n\n  private readonly carId$ = this.route.paramMap.pipe(map((params) => params.get('id')));\n\n  /**\n   * Valida si un string es un UUID válido\n   */\n  private isValidUUID(uuid: string): boolean {\n    // Matches UUID v4 format: 8-4-4-4-12 hexadecimal characters with hyphens\n    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;\n    return uuidRegex.test(uuid);\n  }\n\n  private readonly carData$ = this.carId$.pipe(\n    switchMap((id) => {\n      if (!id) {\n        return of({\n          car: null,\n          reviews: [],\n          stats: null,\n          loading: false,\n          error: 'Auto no encontrado',\n        });\n      }\n      // ✅ FIX: Validar que el ID sea un UUID válido\n      // Previene errores cuando se navega a rutas como /cars/publish\n      this.logger.debug(`CarDetailPage: Validating ID: ${id}`);\n      if (!this.isValidUUID(id)) {\n        this.logger.debug(`CarDetailPage: Invalid UUID: ${id}, redirecting to /cars`);\n        // Redirigir a la lista de autos si el ID no es válido\n        setTimeout(() => this.router.navigate(['/cars']), 100);\n        return of({\n          car: null,\n          reviews: [],\n          stats: null,\n          loading: false,\n          error: 'ID de auto inválido',\n        });\n      }\n      this.logger.debug(`CarDetailPage: Valid UUID: ${id}, fetching data...`);\n      return combineLatest([\n        from(this.carsService.getCarById(id)),\n        from(this.reviewsService.getReviewsForCar(id)).pipe(\n          catchError(() => of([])), // Retornar array vacío si falla\n        ),\n        from(this.reviewsService.getCarStats(id)).pipe(\n          catchError(() => of(null)), // Retornar null si falla\n        ),\n      ]).pipe(\n        map(([car, reviews, stats]) => {\n          if (car) {\n            this.logger.debug('CarDetailPage: Car loaded:', JSON.stringify(car));\n            this.updateMetaTags(car, stats);\n          }\n          return { car, reviews, stats, loading: false, error: car ? null : 'Auto no disponible' };\n        }),\n        catchError((err) => {\n          // Determinar mensaje de error más específico\n          let errorMessage = 'Error al cargar el auto';\n          if (err?.code === 'PGRST116') {\n            errorMessage = 'Auto no encontrado';\n          } else if (err?.code === 'PGRST200') { // Ignore missing relationship error\n            console.warn('Review relationship missing (PGRST200), returning empty reviews');\n            return of({\n              car: null, // This will trigger the overall error state if car is also null\n              reviews: [],\n              stats: null,\n              loading: false,\n              error: null // Allow loading to complete if it was just reviews failing\n            });\n          } else if (err?.message?.includes('permission') || err?.code === '42501') {\n            errorMessage = 'No tienes permiso para ver este auto';\n          } else if (err?.message?.includes('network') || err?.message?.includes('fetch')) {\n            errorMessage = 'Error de conexión. Verifica tu internet';\n          } else if (err?.message) {\n            errorMessage = `Error: ${err.message}`;\n          }\n          return of({\n            car: null,\n            reviews: [],\n            stats: null,\n            loading: false,\n            error: errorMessage,\n          });\n        }),\n      );\n    }),\n  );\n\n  private readonly state = toSignal(this.carData$, {\n    initialValue: {\n      car: null,\n      reviews: [],\n      stats: null,\n      loading: true,\n      error: null,\n    } as CarDetailState,\n  });\n\n  readonly car = computed(() => this.state().car);\n  readonly reviews = computed(() => this.state().reviews);\n  readonly carStats = computed(() => this.state().stats);\n  readonly loading = computed(() => this.state().loading);\n  readonly error = computed(() => this.state().error);\n\n  readonly displayTitle = computed(() => {\n    const car = this.car();\n    if (!car) return 'Próximamente';\n    if (car.title && car.title.trim().length > 0) return car.title.trim();\n\n    const parts = [\n      car.brand || car.brand_name || '',\n      car.model || car.model_name || '',\n      car.year || '',\n    ]\n      .map((p) => String(p).trim())\n      .filter(Boolean);\n\n    const fallback = parts.join(' ').trim();\n    return fallback || 'Próximamente';\n  });\n\n  /**\n   * Returns owner's first name only if it's valid (not corrupted data like 'del', 'de', etc.)\n   */\n  readonly ownerFirstName = computed(() => {\n    const car = this.car();\n    const fullName = car?.owner?.full_name?.trim();\n    if (!fullName || fullName.length < 3) return null;\n\n    const firstName = fullName.split(' ')[0];\n    // Reject common Spanish prepositions/articles that indicate corrupted data\n    const invalidNames = ['de', 'del', 'la', 'el', 'los', 'las', 'un', 'una'];\n    if (!firstName || firstName.length < 2 || invalidNames.includes(firstName.toLowerCase())) {\n      return null;\n    }\n\n    return firstName;\n  });\n\n  /** Signal para toggle de términos expandibles */\n  readonly showTerms = signal(false);\n\n  // Breadcrumbs navigation\n  readonly breadcrumbItems = computed<BreadcrumbItem[]>(() => {\n    return [\n      { label: 'Inicio', url: '/', icon: '🏠' },\n      { label: 'Explorar Autos', url: '/cars/list', icon: '🚗' },\n      { label: this.displayTitle() || 'Cargando...' },\n    ];\n  });\n\n  /**\n   * Obtiene la mejor review de 5 estrellas para mostrar en el sidebar\n   */\n  readonly bestFiveStarReview = computed(() => {\n    const reviews = this.reviews();\n    if (!reviews || reviews.length === 0) return null;\n\n    // Filtrar reviews de 5 estrellas (rating_overall calculado)\n    const fiveStarReviews = reviews.filter((r) => (r.rating_overall ?? 0) >= 5);\n    if (fiveStarReviews.length === 0) return null;\n\n    // Ordenar por más reciente y con comentario más largo\n    return fiveStarReviews.sort((a, b) => {\n      const aLength = a.comment_public?.length ?? 0;\n      const bLength = b.comment_public?.length ?? 0;\n      return bLength - aLength;\n    })[0];\n  });\n\n  /**\n   * Determina si el propietario es \"Superhost\"\n   * Criterios: 50+ alquileres y rating >= 4.8\n   */\n  readonly isSuperhost = computed(() => {\n    const car = this.car();\n    if (!car?.owner) return false;\n\n    return car.owner.rating_count >= 50 && car.owner.rating_avg >= 4.8;\n  });\n\n  /**\n   * Verifica si el usuario actual es el propietario del auto\n   */\n  readonly isOwner = computed(() => this.isCarOwner());\n\n  readonly walletBalance = toSignal(this.walletService.getBalance(), {\n    initialValue: null,\n  });\n  readonly currentFxRate = toSignal(\n    this.fxService.getFxSnapshot('USD', 'ARS').pipe(map((s) => s?.rate ?? null)),\n  );\n\n  readonly allPhotos = computed(() => {\n    const photos = (this.car()?.photos ?? this.car()?.car_photos ?? []) as CarPhoto[];\n    if (!Array.isArray(photos) || photos.length === 0) {\n      return [] as CarPhoto[];\n    }\n\n    const seen = new Set<string>();\n    return photos.filter((photo) => {\n      const key = photo.stored_path || photo.url;\n      if (!key) {\n        return true;\n      }\n      if (seen.has(key)) {\n        return false;\n      }\n      seen.add(key);\n      return true;\n    });\n  });\n\n  // Convert CarPhoto[] to Photo[] for PhotoGalleryComponent\n  readonly galleryPhotos = computed<Photo[]>(() => {\n    const photos = this.allPhotos();\n    const car = this.car();\n\n    return photos.map((photo, index) => ({\n      id: photo.id || `photo-${index}`,\n      url: photo.url,\n      thumbnailUrl: photo.url, // Use same URL, component will handle optimization\n      alt: `${car?.title || 'Auto'} - Foto ${index + 1}`,\n      caption: undefined, // CarPhoto doesn't have description field\n    }));\n  });\n\n  readonly currentPhoto = computed(() => this.allPhotos()[this.currentPhotoIndex()]);\n  readonly hasMultiplePhotos = computed(() => this.allPhotos().length > 1);\n\n  readonly heroPhotoUrls = computed<string[]>(() => {\n    const photos = this.allPhotos();\n    // Always return 5 URLs (with fallback) to avoid broken hero grid\n    return Array.from({ length: 5 }, (_, idx) => {\n      const photo = photos[idx];\n      return this.resolveCarPhotoUrl(photo) ?? this.defaultCarPlaceholderUrl;\n    });\n  });\n\n  private resolveCarPhotoUrl(photo: CarPhoto | undefined): string | null {\n    if (!photo) return null;\n\n    // Prefer an explicit absolute URL\n    const rawUrl = (photo.url ?? '').trim();\n    if (rawUrl) {\n      try {\n        // Validate & normalize (also helps if there are spaces)\n        const url = new URL(rawUrl);\n        return url.toString();\n      } catch {\n        // Fall back to stored_path\n      }\n    }\n\n    // Fall back to storage public URL\n    const rawPath = (photo.stored_path ?? '').trim();\n    if (!rawPath) return null;\n\n    // Defensive: strip bucket prefix if it was accidentally included\n    const normalizedPath = rawPath.replace(/^car-images\\//, '').replace(/^\\/+/, '');\n    const { data } = this.supabase.storage.from('car-images').getPublicUrl(normalizedPath);\n    return data?.publicUrl ?? null;\n  }\n\n  /**\n   * Helper: Obtiene la etiqueta legible para la política de combustible\n   */\n  getFuelPolicyLabel(policy: string | null | undefined): string {\n    const labels: Record<string, string> = {\n      'full_to_full': 'Lleno a lleno',\n      'same_to_same': 'Igual a igual',\n      'prepaid': 'Prepago',\n      'free_tank': 'Tanque incluido',\n    };\n    return labels[policy || ''] || 'Lleno a lleno';\n  }\n\n  /**\n   * Helper: Obtiene la etiqueta legible para la política de cancelación\n   */\n  getCancelPolicyLabel(policy: string | undefined): string {\n    const labels: Record<string, string> = {\n      'flexible': 'Flexible - 100% reembolso hasta 24h antes del inicio',\n      'moderate': 'Moderada - 50% reembolso hasta 48h antes del inicio',\n      'strict': 'Estricta - Sin reembolso en los 7 días previos',\n    };\n    return labels[policy || 'moderate'] || 'Moderada';\n  }\n\n  onImgError(event: Event, fallbackUrl: string = this.defaultCarPlaceholderUrl): void {\n    const el = event.target as HTMLImageElement | null;\n    if (!el) return;\n    if (el.src === fallbackUrl) return;\n    el.src = fallbackUrl;\n  }\n\n  private openDatePicker(): void {\n    try {\n      this.bookingDatePicker?.handleDateInputClick();\n    } catch {\n      // no-op\n    }\n  }\n\n  readonly daysCount = computed(() => {\n    const { from, to } = this.dateRange();\n    if (!from || !to) return 0;\n    const diff = Math.ceil(\n      (new Date(to).getTime() - new Date(from).getTime()) / (1000 * 60 * 60 * 24),\n    );\n    return diff > 0 ? diff : 0;\n  });\n\n  readonly hoursCount = computed(() => {\n    const { from, to } = this.dateRange();\n    if (!from || !to) return 0;\n    const diff = Math.ceil((new Date(to).getTime() - new Date(from).getTime()) / (1000 * 60 * 60));\n    return diff > 0 ? Math.max(diff, 5) : 5; // Mínimo 5 horas\n  });\n\n  readonly isCurrentUserOwner = computed(() => {\n    const car = this.car();\n    const session = this.authService.session$();\n    const currentUserId = session?.user?.id;\n    if (!car || !currentUserId) {\n      return false;\n    }\n    return car.owner_id === currentUserId;\n  });\n\n  readonly canContactOwner = computed(\n    () => this.authService.isAuthenticated() && !this.isCurrentUserOwner(),\n  );\n\n  // ✅ FIX: Precio por hora dinámico (cargado desde el servicio de pricing)\n  readonly dynamicHourlyRate = signal<number | null>(null);\n\n  /**\n   * Precio por hora calculado\n   * ✅ FIX: Usa precio dinámico del sistema de pricing si está disponible,\n   * sino calcula como 75% del precio diario / 24\n   */\n  readonly calculatedHourlyRate = computed(() => {\n    // Prioridad 1: Precio dinámico por hora del sistema de pricing\n    const dynamicHourly = this.dynamicHourlyRate();\n    if (dynamicHourly !== null && dynamicHourly > 0) {\n      return dynamicHourly;\n    }\n\n    // Prioridad 2: Calcular desde precio diario dinámico/estático\n    const car = this.car();\n    if (!car) {\n      return null;\n    }\n\n    const pricePerDay = this.displayPrice();\n    if (!pricePerDay || isNaN(pricePerDay) || pricePerDay <= 0) {\n      return null;\n    }\n\n    // 75% del precio diario / 24 horas\n    const hourlyRate = (pricePerDay * 0.75) / 24;\n    return hourlyRate;\n  });\n\n  /**\n   * Total del alquiler (sin incluir depósito de seguridad)\n   */\n  readonly rentalTotal = computed(() => {\n    const car = this.car();\n    if (!car) return null;\n\n    // Modo express: precio por hora (75% del precio diario / 24)\n    if (this.expressMode()) {\n      const hours = this.hoursCount();\n      const hourlyRate = this.calculatedHourlyRate();\n      if (!hourlyRate) return null;\n\n      return hours * hourlyRate;\n    }\n\n    // Modo normal: precio por día (usar precio dinámico si está disponible)\n    const days = this.daysCount();\n    if (days <= 0) return null;\n\n    // ✅ FIX: Usar precio dinámico si está disponible, sino precio estático\n    const pricePerDay = this.displayPrice();\n    return isNaN(pricePerDay) ? null : days * pricePerDay;\n  });\n\n  /**\n   * Depósito de seguridad en USD (para mostrar)\n   * Retorna siempre US$ 600 según el sistema de garantías\n   */\n  readonly depositAmount = computed(() => {\n    const car = this.car();\n    if (!car) return 0;\n\n    // Usar el sistema de cálculo de garantías (siempre retorna 600 USD)\n    const vehicleValueUsd = car.value_usd ?? 10000;\n    return calculateCreditSecurityUsd(vehicleValueUsd);\n  });\n\n  /**\n   * Depósito de seguridad en ARS (para cálculos)\n   * Convierte el depósito USD a ARS usando la tasa de cambio\n   */\n  readonly depositAmountArs = computed(() => {\n    const depositUsd = this.depositAmount();\n    const fxRate = this.currentFxRate();\n\n    if (!fxRate) return depositUsd; // Fallback a USD si no hay tasa\n    return depositUsd * fxRate;\n  });\n\n  /**\n   * Total a autorizar (alquiler + depósito)\n   * Este es el monto que se pre-autoriza en tarjeta o se bloquea en wallet\n   */\n  readonly authorizationTotal = computed(() => {\n    const rental = this.rentalTotal();\n    const depositArs = this.depositAmountArs();\n\n    if (rental === null) return null;\n    return rental + depositArs;\n  });\n\n  /**\n   * @deprecated Usar rentalTotal() en su lugar\n   * Mantenido por compatibilidad temporal\n   */\n  readonly totalPrice = computed(() => this.rentalTotal());\n\n  readonly canBook = computed(() => {\n    if (this.isCarOwner()) {\n      return false;\n    }\n    if (this.expressMode()) {\n      return !!this.totalPrice() && this.urgentAvailability()?.available;\n    }\n    return !!this.totalPrice();\n  });\n\n  /**\n   * Callback para verificar disponibilidad del auto\n   * Usado por el date-range-picker component\n   */\n  checkAvailability = async (carId: string, from: string, to: string): Promise<boolean> => {\n    try {\n      return await this.carsService.isCarAvailable(carId, from, to);\n    } catch {\n      return false;\n    }\n  };\n\n  suggestNextAvailableRange = async (\n    carId: string,\n    from: string,\n    to: string,\n  ): Promise<DateRange | null> => {\n    try {\n      const suggestions = await this.carsService.getNextAvailableRange(carId, from, to);\n      if (!suggestions || suggestions.length === 0) {\n        return null;\n      }\n\n      // Get the first suggestion\n      const firstSuggestion = suggestions[0];\n      return {\n        from: this.normalizeDateInput(firstSuggestion.startDate),\n        to: this.normalizeDateInput(firstSuggestion.endDate),\n      };\n    } catch {\n      // Silent fail - próxima ventana disponible es opcional\n      return null;\n    }\n  };\n\n  ngOnInit(): void {\n    // Verificar si viene con query param urgent - P0-006 FIX: Added takeUntil\n    this.route.queryParams.pipe(takeUntil(this.destroy$)).subscribe((params) => {\n      if (params['urgent'] === 'true') {\n        this.expressMode.set(true);\n        void this.setupExpressMode();\n      }\n    });\n\n    // Cargar fechas bloqueadas cuando el auto esté disponible - P0-006 FIX: Added takeUntil\n    this.carData$.pipe(takeUntil(this.destroy$)).subscribe((state) => {\n      if (state.car) {\n        void this.loadBlockedDates(state.car.id);\n        // ✅ FIX: Cargar precio dinámico si el auto tiene region_id\n        if (state.car.region_id) {\n          void this.loadDynamicPrice();\n        }\n        // ✅ NEW: Inicializar ubicación y calcular distancia\n        void this.initializeUserLocationAndDistance(state.car);\n\n        // ✅ NEW: Check if current user is the owner\n        void this.checkOwnership(state.car.owner_id);\n\n        // 🎯 TikTok Events: Track ViewContent\n        void this.tiktokEvents.trackViewContent({\n          contentId: state.car.id,\n          contentName: state.car.title,\n          value: state.car.price_per_day,\n          currency: state.car.currency || 'ARS',\n        });\n      }\n    });\n  }\n\n  /**\n   * ✅ NEW: Setup scroll behavior for sticky header (Turo-style)\n   */\n  ngAfterViewInit(): void {\n    // Setup scroll listener for collapsing header\n    if (typeof window !== 'undefined') {\n      const threshold = 200; // Trigger sticky header after 200px scroll\n\n      fromEvent(window, 'scroll')\n        .pipe(\n          throttleTime(100, undefined, { leading: true, trailing: true }),\n          takeUntil(this.destroy$)\n        )\n        .subscribe(() => {\n          const currentScrollY = window.scrollY;\n          const stickyHeader = this.stickyHeaderRef?.nativeElement;\n\n          if (!stickyHeader) return;\n\n          // Show sticky header when scrolling down past threshold\n          if (currentScrollY > threshold) {\n            stickyHeader.classList.remove('sticky-header-hidden');\n            stickyHeader.classList.add('sticky-header-visible');\n          } else {\n            // Hide when scrolling back up to top\n            stickyHeader.classList.remove('sticky-header-visible');\n            stickyHeader.classList.add('sticky-header-hidden');\n          }\n        });\n    }\n  }\n\n  onContactOwner(): void {\n    const car = this.car();\n    if (!car?.owner_id) {\n      return;\n    }\n\n    const session = this.authService.session$();\n    const currentUserId = session?.user?.id;\n\n    if (!currentUserId) {\n      void this.router.navigate(['/auth/login'], {\n        queryParams: { returnUrl: this.router.url },\n      });\n      return;\n    }\n\n    if (currentUserId === car.owner_id) {\n      return;\n    }\n\n    const queryParams = {\n      carId: car.id,\n      userId: car.owner_id,\n      carName: this.getCarChatTitle(car),\n      userName: car.owner?.full_name ?? 'Anfitrión',\n    };\n\n    void this.router.navigate(['/messages/chat'], { queryParams });\n  }\n\n  private getCarChatTitle(car: Car): string {\n    if (car.title?.trim()) {\n      return car.title;\n    }\n\n    const parts = [\n      car.brand ?? car.brand_name ?? car.brand_text_backup,\n      car.model ?? car.model_name ?? car.model_text_backup,\n      car.year ? String(car.year) : '',\n    ]\n      .map((value) => (value ? value.toString().trim() : ''))\n      .filter((value) => !!value);\n\n    return parts.join(' ').trim() || 'Auto';\n  }\n\n  /**\n   * Initialize user location and calculate distance to car\n   */\n  private async initializeUserLocationAndDistance(car: Car): Promise<void> {\n    try {\n      // Get user location\n      const locationData = await this.locationService.getUserLocation();\n      if (locationData) {\n        this.userLocation.set({ lat: locationData.lat, lng: locationData.lng });\n\n        // Calculate distance if car has location\n        if (car.location_lat && car.location_lng) {\n          const distance = this.distanceCalculator.calculateDistance(\n            locationData.lat,\n            locationData.lng,\n            car.location_lat,\n            car.location_lng,\n          );\n\n          this.distanceKm.set(distance);\n\n          // Calculate tier and delivery fee\n          const tier = this.distanceCalculator.getDistanceTier(distance);\n          this.distanceTier.set(tier);\n\n          const deliveryFee = this.distanceCalculator.calculateDeliveryFee(distance);\n          this.deliveryFeeCents.set(deliveryFee);\n        }\n      }\n    } catch {\n      // Silently fail - distance is optional\n    }\n  }\n\n  /**\n   * ✅ FIX: Cargar precio dinámico para el auto (diario y por hora)\n   */\n  private async loadDynamicPrice(): Promise<void> {\n    const car = this.car();\n    if (!car || !car.region_id) {\n      return;\n    }\n\n    this.priceLoading.set(true);\n    try {\n      const {\n        data: { user },\n      } = await this.supabase.auth.getUser();\n      const userId = user?.id || '00000000-0000-0000-0000-000000000000';\n\n      // Cargar precio diario (24 horas)\n      const { data, error } = await this.supabase.rpc('calculate_dynamic_price', {\n        p_region_id: car.region_id,\n        p_user_id: userId,\n        p_rental_start: new Date().toISOString(),\n        p_rental_hours: 24,\n      });\n\n      if (error) {\n        return;\n      }\n\n      if (data && data.total_price) {\n        this.dynamicPrice.set(data.total_price);\n      }\n\n      // ✅ FIX: Cargar precio por hora para modo express (5 horas mínimo)\n      if (this.expressMode()) {\n        this.hourlyRateLoading.set(true);\n        try {\n          const hours = Math.max(this.hoursCount(), 5); // Mínimo 5 horas para cálculo representativo\n          const quote = await this.urgentRentalService.getUrgentQuote(car.id, car.region_id, hours);\n          // Usar el precio por hora del sistema de pricing dinámico\n          this.dynamicHourlyRate.set(quote.hourlyRate);\n        } catch {\n          // Fallback: calcular desde precio diario\n          const pricePerDay = this.displayPrice();\n          if (pricePerDay > 0) {\n            const fallbackHourly = (pricePerDay * 0.75) / 24;\n            this.dynamicHourlyRate.set(fallbackHourly);\n          }\n        } finally {\n          this.hourlyRateLoading.set(false);\n        }\n      }\n    } catch {\n      // Silent fail - will use static price\n    } finally {\n      this.priceLoading.set(false);\n    }\n  }\n\n  /**\n   * ✅ FIX: Precio a mostrar en USD (precio base del auto)\n   * NOTE: Dynamic pricing temporarily disabled during USD migration\n   */\n  readonly displayPrice = computed(() => {\n    const car = this.car();\n    const price = car?.price_per_day ?? 0;\n    return Number.isFinite(price) ? price : 0;\n  });\n\n  readonly hasValidPrice = computed(() => {\n    const price = this.displayPrice();\n    return Number.isFinite(price) && price > 0;\n  });\n\n  readonly formattedPrice = computed(() => {\n    return this.hasValidPrice() ? this.usdFormatter.format(this.displayPrice()) : null;\n  });\n\n  async setupExpressMode(): Promise<void> {\n    const car = this.car();\n    if (!car || !car.region_id) return;\n\n    try {\n      // Obtener ubicación del usuario\n      try {\n        await this.urgentRentalService.getCurrentLocation();\n      } catch {\n        // Silent fail - location is optional\n      }\n\n      // Verificar disponibilidad inmediata\n      const availability = await this.urgentRentalService.checkImmediateAvailability(car.id);\n      this.urgentAvailability.set({\n        available: availability.available,\n        distance: availability.distance,\n        eta: availability.eta,\n      });\n\n      // ✅ FIX: Cargar precio dinámico por hora para modo express (5 horas mínimo)\n      // Siempre intentar cargar, independientemente del precio diario\n      this.hourlyRateLoading.set(true);\n      try {\n        const hours = Math.max(this.hoursCount(), 5); // Mínimo 5 horas para cálculo representativo\n        const quote = await this.urgentRentalService.getUrgentQuote(car.id, car.region_id, hours);\n        // Usar el precio por hora del sistema de pricing dinámico\n        this.dynamicHourlyRate.set(quote.hourlyRate);\n        this.logger.debug(\n          `💰 [CarDetail] Express mode hourly rate: $${quote.hourlyRate}/hora (quote para ${hours} horas)`,\n        );\n      } catch {\n        console.warn('⚠️ [CarDetail] Could not load hourly rate for express mode:');\n        // Fallback: calcular desde precio diario si está disponible\n        const pricePerDay = this.displayPrice();\n        if (pricePerDay > 0) {\n          const fallbackHourly = (pricePerDay * 0.75) / 24;\n          this.dynamicHourlyRate.set(fallbackHourly);\n          this.logger.debug(`💰 [CarDetail] Using fallback hourly rate: $${fallbackHourly}/hora`);\n        }\n      } finally {\n        this.hourlyRateLoading.set(false);\n      }\n\n      // Preseleccionar fechas: ahora + 5 horas (mínimo)\n      const now = new Date();\n      const fiveHoursLater = new Date(now.getTime() + 5 * 60 * 60 * 1000);\n      this.dateRange.set({\n        from: now.toISOString().split('T')[0],\n        to: fiveHoursLater.toISOString().split('T')[0],\n      });\n    } catch (_error) {\n      console.error('Error setting up express mode:', _error);\n    }\n  }\n\n  toggleExpressMode(): void {\n    this.expressMode.set(!this.expressMode());\n    if (this.expressMode()) {\n      // Resetear precio por hora para forzar recarga\n      this.dynamicHourlyRate.set(null);\n      void this.setupExpressMode();\n    } else {\n      // Resetear fechas y precio por hora\n      this.dateRange.set({ from: null, to: null });\n      this.dynamicHourlyRate.set(null);\n    }\n  }\n\n  nextPhoto(): void {\n    this.imageLoaded.set(false);\n    this.currentPhotoIndex.update((index) => (index + 1) % this.allPhotos().length);\n  }\n\n  previousPhoto(): void {\n    this.imageLoaded.set(false);\n    this.currentPhotoIndex.update(\n      (index) => (index - 1 + this.allPhotos().length) % this.allPhotos().length,\n    );\n  }\n\n  goToPhoto(index: number): void {\n    this.imageLoaded.set(false);\n    this.currentPhotoIndex.set(index);\n  }\n\n  onImageLoad(): void {\n    this.imageLoaded.set(true);\n  }\n\n  onRangeChange(range: DateRange): void {\n    this.dateRange.set(range);\n  }\n\n  toggleSpecs(): void {\n    this.specsCollapsed.update((value) => !value);\n  }\n\n  /**\n   * ✅ NEW: Handle payment method selection\n   * Saves the selected method and navigates to payment page\n   */\n  onPaymentMethodSelected(method: PaymentMethod): void {\n    const car = this.car();\n    const { from, to } = this.dateRange();\n\n    if (!car || !from || !to) {\n      this.bookingError.set('Por favor seleccioná las fechas de alquiler');\n      return;\n    }\n\n    // Track: Booking initiated with payment method\n    this.analytics.trackEvent('booking_initiated', {\n      car_id: car.id,\n      payment_method: method,\n      rental_amount: this.rentalTotal() ?? undefined,\n      deposit_amount: this.depositAmount(),\n      total_amount: this.authorizationTotal() ?? undefined,\n    });\n\n    // Save method in sessionStorage for payment page\n    sessionStorage.setItem('payment_method', method);\n\n    // Navigate to payment page with method pre-selected\n    void this.navigateToPaymentPage(method);\n  }\n\n  /**\n   * Navigate to payment page with payment method pre-selected\n   */\n  private async navigateToPaymentPage(paymentMethod?: PaymentMethod): Promise<void> {\n    const car = this.car();\n    const { from, to } = this.dateRange();\n\n    if (!car || !from || !to) return;\n\n    // Check authentication\n    if (!(await this.authService.isAuthenticated())) {\n      this.router.navigate(['/auth/login'], { queryParams: { returnUrl: this.router.url } });\n      return;\n    }\n\n    // Prepare booking data\n    const startDate = new Date(from).toISOString();\n    const endDate = new Date(to).toISOString();\n\n    // Save booking detail input for payment page\n    sessionStorage.setItem(\n      'booking_detail_input',\n      JSON.stringify({\n        carId: car.id,\n        startDate,\n        endDate,\n        bucket: 'standard', // Default bucket, not stored in Car model\n        vehicleValueUsd: car.value_usd ?? 10000,\n        country: car.location_country ?? 'AR',\n      }),\n    );\n\n    // Navigate with payment method if provided\n    const queryParams: Record<string, string> = {\n      carId: car.id,\n      startDate,\n      endDate,\n    };\n\n    if (paymentMethod) {\n      queryParams['paymentMethod'] = paymentMethod;\n    }\n\n    // First create the booking, then navigate to payment page\n    try {\n      // Call booking service to create the booking (using requestBooking RPC)\n      const booking = await this.bookingsService.requestBooking(car.id, startDate, endDate);\n\n      if (booking?.id) {\n        // Navigate to booking request (pre-auth + message)\n        await this.router.navigate(['/bookings', booking.id, 'detail-payment'], {\n          queryParams: paymentMethod ? { paymentMethod } : {},\n        });\n      } else {\n        // Fallback to old flow if booking creation fails\n        await this.router.navigate(['/bookings/detail-payment'], { queryParams });\n      }\n    } catch (error) {\n      console.error('[CarDetail] Error creating booking:', error);\n      // Fallback to old flow on error\n      await this.router.navigate(['/bookings/detail-payment'], { queryParams });\n    }\n  }\n\n  async onBookClick(): Promise<void> {\n    const car = this.car();\n    const { from, to } = this.dateRange();\n    if (!car || !from || !to) {\n      this.bookingError.set('Por favor seleccioná las fechas de alquiler');\n\n      // UX: If the user clicked the CTA without dates, open the date picker.\n      this.openDatePicker();\n      return;\n    }\n\n    // Track: CTA clicked\n    this.analytics.trackEvent('cta_clicked', {\n      car_id: car.id,\n      has_dates: true,\n      express_mode: this.expressMode(),\n      days_count: this.daysCount(),\n      total_price: this.totalPrice() ?? undefined,\n    });\n\n    if (!(await this.authService.isAuthenticated())) {\n      this.router.navigate(['/auth/login'], { queryParams: { returnUrl: this.router.url } });\n      return;\n    }\n\n    // ✅ NEW: Show location form instead of directly booking\n    // Prepare dates in ISO format\n    let startDate: string;\n    let endDate: string;\n\n    if (this.expressMode()) {\n      const now = new Date();\n      const hours = this.hoursCount();\n      const end = new Date(now.getTime() + hours * 60 * 60 * 1000);\n      startDate = now.toISOString();\n      endDate = end.toISOString();\n    } else {\n      startDate = new Date(from).toISOString();\n      endDate = new Date(to).toISOString();\n    }\n\n    // Store booking data and show form\n    this.pendingBookingData.set({ from: startDate, to: endDate });\n    this.bookingError.set(null);\n\n    await this.createBookingFlow(startDate, endDate);\n  }\n\n  /**\n   * ✅ NEW: Handle location form submission\n   */\n  async onLocationFormSubmit(locationData: BookingLocationData): Promise<void> {\n    const pendingData = this.pendingBookingData();\n    if (!pendingData) return;\n\n    await this.createBookingFlow(pendingData.from, pendingData.to, locationData);\n  }\n\n  private async createBookingFlow(\n    startDate: string,\n    endDate: string,\n    locationData?: BookingLocationData,\n  ): Promise<void> {\n    const car = this.car();\n    if (!car) {\n      this.bookingError.set('Datos incompletos. Por favor intentá nuevamente.');\n      return;\n    }\n\n    this.bookingInProgress.set(true);\n    this.bookingError.set(null);\n\n    try {\n      // ✅ NEW: Re-validate availability before booking\n      if (!this.expressMode()) {\n        this.validatingAvailability.set(true);\n        try {\n          const isAvailable = await this.carsService.isCarAvailable(car.id, startDate, endDate);\n          if (!isAvailable) {\n            const conflictInfo = await this.getAvailabilityConflictInfo(car.id, startDate, endDate);\n\n            // Track: Booking failed due to availability\n            this.analytics.trackEvent('booking_failed', {\n              car_id: car.id,\n              error: conflictInfo.hasPendingActive\n                ? 'Fechas no disponibles - reserva temporal (pendiente/pago)'\n                : 'Fechas no disponibles - reserva confirmada/en curso',\n            });\n\n            // Try to suggest alternative dates\n            const suggestions = await this.carsService.getNextAvailableRange(\n              car.id,\n              startDate,\n              endDate,\n              3,\n            );\n\n            if (suggestions && suggestions.length > 0) {\n              this.suggestedDateRanges.set(suggestions);\n              this.bookingError.set(\n                'El auto no está disponible para esas fechas. Te sugerimos las siguientes alternativas:',\n              );\n              // Aun con sugerencias, permitir waitlist para fechas exactas\n              this.canWaitlist.set(true);\n            } else {\n              this.suggestedDateRanges.set([]);\n              if (conflictInfo.hasPendingActive && !conflictInfo.hasConfirmed) {\n                const minutes = conflictInfo.pendingMinutesLeft;\n                this.bookingError.set(\n                  minutes && minutes > 0\n                    ? `El auto está reservado temporalmente (pendiente de pago). Se libera aprox. en ${minutes} min.`\n                    : 'El auto está reservado temporalmente (pendiente de pago). Se libera en breve.',\n                );\n              } else {\n                this.bookingError.set(\n                  'El auto no está disponible para esas fechas. Hay una reserva confirmada en ese período.',\n                );\n              }\n              this.canWaitlist.set(true);\n            }\n\n            await this.loadBlockedDates(car.id);\n            return;\n          }\n        } finally {\n          this.validatingAvailability.set(false);\n        }\n      }\n\n      // Track: Booking initiated\n      this.analytics.trackEvent('booking_initiated', {\n        car_id: car.id,\n        days_count: this.daysCount(),\n        total_amount: this.totalPrice() ?? undefined,\n        express_mode: this.expressMode(),\n        has_delivery: locationData?.deliveryRequired ?? false,\n        delivery_distance_km: locationData?.distanceKm ?? null,\n      });\n\n      // ✅ NEW: Create booking with location data\n      const result = await this.bookingsService.createBookingWithValidation(\n        car.id,\n        startDate,\n        endDate,\n        locationData,\n      );\n\n      if (!result.success || !result.booking) {\n        // Track: Booking failed\n        this.analytics.trackEvent('booking_failed', {\n          car_id: car.id,\n          error: result.error ?? 'Unknown error',\n        });\n\n        this.bookingError.set(result.error || 'No pudimos crear la reserva.');\n        this.canWaitlist.set(Boolean(result.canWaitlist));\n        return;\n      }\n\n      // Track: Booking completed (navigation to payment)\n      this.analytics.trackEvent('booking_completed', {\n        car_id: car.id,\n        booking_id: result.booking.id,\n        total_amount: this.totalPrice() ?? undefined,\n        days_count: this.daysCount(),\n      });\n\n      // Close form and navigate\n      this.pendingBookingData.set(null);\n\n      // After creating a booking, take the user to the booking request step (pre-auth + message)\n      this.router.navigate(['/bookings', result.booking.id, 'detail-payment']);\n    } catch (err: unknown) {\n      // Track: Booking failed (exception)\n      this.analytics.trackEvent('booking_failed', {\n        car_id: car.id,\n        error: err instanceof Error ? err.message : 'Exception during booking',\n      });\n\n      let userMessage = err instanceof Error ? err.message : 'Error al crear la reserva';\n\n      // Handle OVERLAP error specifically\n      if (userMessage.includes('OVERLAP') || (err as { code?: string })?.code === 'P0001') {\n        userMessage = 'El auto ya está reservado para estas fechas. Por favor seleccioná otras.';\n\n        // Load blocked dates to refresh calendar\n        void this.loadBlockedDates(car.id);\n\n        // Show waitlist option\n        this.canWaitlist.set(true);\n      }\n\n      this.bookingError.set(userMessage);\n    } finally {\n      this.bookingInProgress.set(false);\n    }\n  }\n\n  private async getAvailabilityConflictInfo(\n    carId: string,\n    startDate: string,\n    endDate: string,\n  ): Promise<{\n    hasPendingActive: boolean;\n    pendingMinutesLeft: number | null;\n    hasConfirmed: boolean;\n  }> {\n    try {\n      const { data } = await this.supabase\n        .from('bookings')\n        .select('status, expires_at')\n        .eq('car_id', carId)\n        .in('status', ['pending', 'pending_payment', 'confirmed', 'in_progress'])\n        .lt('start_at', endDate)\n        .gt('end_at', startDate);\n\n      const rows = (data ?? []) as Array<{ status: string; expires_at: string | null }>;\n      const nowMs = Date.now();\n\n      const pendingRows = rows.filter((r) => r.status === 'pending' || r.status === 'pending_payment');\n      const confirmedRows = rows.filter((r) => r.status === 'confirmed' || r.status === 'in_progress');\n\n      const activePending = pendingRows.filter((r) => {\n        if (!r.expires_at) return true;\n        return new Date(r.expires_at).getTime() > nowMs;\n      });\n\n      let pendingMinutesLeft: number | null = null;\n      const pendingExpiries = activePending\n        .map((r) => (r.expires_at ? new Date(r.expires_at).getTime() : null))\n        .filter((t): t is number => typeof t === 'number' && t > nowMs);\n\n      if (pendingExpiries.length) {\n        const earliest = Math.min(...pendingExpiries);\n        pendingMinutesLeft = Math.max(1, Math.ceil((earliest - nowMs) / (1000 * 60)));\n      }\n\n      return {\n        hasPendingActive: activePending.length > 0,\n        pendingMinutesLeft,\n        hasConfirmed: confirmedRows.length > 0,\n      };\n    } catch {\n      return { hasPendingActive: false, pendingMinutesLeft: null, hasConfirmed: false };\n    }\n  }\n\n  /**\n   * ✅ NEW: Handle location form cancellation\n   */\n  onLocationFormCancelled(): void {\n    this.pendingBookingData.set(null);\n    this.bookingError.set(null);\n  }\n\n  private updateMetaTags(car: Car, stats: CarStats | null): void {\n    const mainPhoto = (car.photos?.[0] ?? car.car_photos?.[0])?.url;\n    const description =\n      car.description ||\n      `${car.brand} ${car.model} ${car.year} - Alquiler de auto en ${car.location_city}`;\n    this.metaService.updateCarDetailMeta({\n      title: car.title,\n      description,\n      main_photo_url: mainPhoto,\n      price_per_day: car.price_per_day,\n      currency: car.currency || 'ARS',\n      id: car.id,\n    });\n    this.metaService.addCarProductData({\n      title: car.title,\n      description,\n      main_photo_url: mainPhoto,\n      price_per_day: car.price_per_day,\n      currency: car.currency || 'ARS',\n      id: car.id,\n      rating_avg: stats?.rating_avg,\n      rating_count: stats?.reviews_count || 0,\n    });\n  }\n\n  /**\n   * ✅ UPDATED: Carga los rangos de fechas bloqueadas del auto\n   * Usa el nuevo método del servicio que incluye TODOS los estados de reserva bloqueantes:\n   * pending, pending_payment, confirmed, in_progress\n   */\n  private async loadBlockedDates(carId: string): Promise<void> {\n    try {\n      const ranges = await this.carsService.getBlockedDateRanges(carId);\n      this.blockedRanges.set(ranges);\n\n      // DEPRECATED: Mantener blockedDates para compatibilidad con inline calendar\n      // TODO: Migrar inline calendar a usar blockedRanges también\n      const blocked = new Set<string>();\n      ranges.forEach((range: { from: string; to: string }) => {\n        const start = this.parseToLocalDate(range.from);\n        const end = this.parseToLocalDate(range.to);\n        start.setHours(0, 0, 0, 0);\n        end.setHours(0, 0, 0, 0);\n        const currentDate = new Date(start);\n        while (currentDate <= end) {\n          blocked.add(this.toLocalDateString(currentDate));\n          currentDate.setDate(currentDate.getDate() + 1);\n        }\n      });\n      this.blockedDates.set(Array.from(blocked));\n    } catch (error) {\n      console.error('Error in loadBlockedDates:', error);\n    }\n  }\n\n  /**\n   * Check if the current user is the owner of the car\n   */\n  private async checkOwnership(ownerId: string): Promise<void> {\n    try {\n      const { data } = await this.supabase.auth.getSession();\n      this.isCarOwner.set(data.session?.user?.id === ownerId);\n    } catch (error) {\n      console.error('Error checking ownership:', error);\n      this.isCarOwner.set(false);\n    }\n  }\n\n  private normalizeDateInput(value: string): string {\n    const parsed = this.parseToLocalDate(value);\n    return isNaN(parsed.getTime()) ? value : this.toLocalDateString(parsed);\n  }\n\n  private toLocalDateString(value: Date): string {\n    const year = value.getFullYear();\n    const month = String(value.getMonth() + 1).padStart(2, '0');\n    const day = String(value.getDate()).padStart(2, '0');\n    return `${year}-${month}-${day}`;\n  }\n\n  private parseToLocalDate(value: string): Date {\n    if (/^\\d{4}-\\d{2}-\\d{2}$/.test(value)) {\n      const [year, month, day] = value.split('-').map(Number);\n      return new Date(year, month - 1, day);\n    }\n    const parsed = new Date(value);\n    return Number.isNaN(parsed.getTime()) ? new Date() : parsed;\n  }\n\n  /**\n   * ✅ NEW: Aplica una sugerencia de fecha clickeada por el usuario\n   */\n  applySuggestedDates(suggestion: { startDate: string; endDate: string; daysCount: number }): void {\n    // Convertir fechas de YYYY-MM-DD a DateRange format\n    this.dateRange.set({\n      from: suggestion.startDate,\n      to: suggestion.endDate,\n    });\n\n    // Clear errors and suggestions\n    this.bookingError.set(null);\n    this.suggestedDateRanges.set([]);\n    this.canWaitlist.set(false);\n\n    // Show success toast\n    this.toastService.success(\n      'Fechas actualizadas',\n      `Seleccionaste ${suggestion.daysCount} día${suggestion.daysCount !== 1 ? 's' : ''} disponibles`,\n    );\n\n    // Track: Date suggestion applied\n    this.analytics.trackEvent('date_range_selected', {\n      car_id: this.car()?.id,\n      days_count: suggestion.daysCount,\n      source: 'suggestion_chip',\n    });\n  }\n\n  /**\n   * ✅ NEW: Agrega el usuario a la lista de espera\n   */\n  async addToWaitlist(): Promise<void> {\n    const car = this.car();\n    const { from, to } = this.dateRange();\n\n    if (!car || !from || !to) {\n      this.toastService.error('Error', 'Por favor seleccioná las fechas primero');\n      return;\n    }\n\n    this.addingToWaitlist.set(true);\n    try {\n      const result = await this.waitlistService.addToWaitlist(car.id, from, to);\n\n      if (result.success) {\n        this.bookingError.set(null);\n        this.canWaitlist.set(false);\n        this.suggestedDateRanges.set([]);\n\n        this.toastService.success(\n          'Agregado a lista de espera',\n          'Te notificaremos cuando el auto esté disponible para esas fechas',\n        );\n\n        // Track: Waitlist joined\n        this.analytics.trackEvent('date_range_selected', {\n          car_id: car.id,\n          source: 'waitlist_added',\n        });\n      } else {\n        this.toastService.error(\n          'Error',\n          result.error || 'No pudimos agregarte a la lista de espera',\n        );\n      }\n    } catch (error) {\n      console.error('Error adding to waitlist:', error);\n      this.toastService.error(\n        'Error',\n        'No pudimos agregarte a la lista de espera. Intentá nuevamente',\n      );\n    } finally {\n      this.addingToWaitlist.set(false);\n    }\n  }\n\n  /**\n   * ✅ NEW: Formatea una fecha para mostrar en los chips de sugerencias\n   */\n  formatSuggestionDate(dateStr: string): string {\n    const date = new Date(dateStr);\n    return new Intl.DateTimeFormat('es-AR', {\n      weekday: 'short',\n      day: '2-digit',\n      month: 'short',\n    }).format(date);\n  }\n\n  /**\n   * Handle photo share from gallery\n   */\n  onPhotoShare(photo: Photo): void {\n    const car = this.car();\n    if (!car) return;\n\n    // Track: Photo shared - using generic 'cta_clicked' event\n    this.analytics.trackEvent('cta_clicked', {\n      car_id: car.id,\n      cta_type: 'photo_share',\n      photo_id: photo.id,\n      photo_index: this.galleryPhotos().findIndex((p) => p.id === photo.id),\n    });\n\n    // Share API if available\n    if (navigator.share) {\n      void navigator.share({\n        title: car.title,\n        text: `Mirá este ${car.title} disponible para alquilar`,\n        url: window.location.href,\n      });\n    }\n  }\n\n  /**\n   * Handle photo change from gallery\n   */\n  onPhotoChange(event: { photo: Photo; index: number }): void {\n    const car = this.car();\n    if (!car) return;\n\n    // Track: Photo viewed - using 'cta_clicked' event with photo context\n    this.analytics.trackEvent('cta_clicked', {\n      car_id: car.id,\n      source: 'photo_gallery_navigation',\n      // Additional context stored in source field\n    });\n\n    // Update current photo index for any other components that might need it\n    this.currentPhotoIndex.set(event.index);\n  }\n\n  ngOnDestroy(): void {\n    // P0-006 FIX: Clean up subscriptions\n    this.destroy$.next();\n    this.destroy$.complete();\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/features/cars/list/cars-list.page.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`../../../core/models` import should occur after import of `@core/services/bookings/urgent-rental.service`","line":19,"column":1,"nodeType":"ImportDeclaration","endLine":19,"endColumn":44,"fix":{"range":[444,1181],"text":"import { BreakpointService } from '@core/services/ui/breakpoint.service';\nimport { CarsCompareService } from '@core/services/cars/cars-compare.service';\nimport { CarsService } from '@core/services/cars/cars.service';\nimport { DistanceCalculatorService } from '@core/services/geo/distance-calculator.service';\nimport { LocationService } from '@core/services/geo/location.service';\nimport { LoggerService } from '@core/services/infrastructure/logger.service';\nimport { MetaService } from '@core/services/ui/meta.service';\nimport { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\nimport { UrgentRentalService } from '@core/services/bookings/urgent-rental.service';\nimport { Car } from '../../../core/models';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { CommonModule, isPlatformBrowser, NgOptimizedImage } from '@angular/common';\nimport {\n  ChangeDetectionStrategy,\n  Component,\n  computed,\n  effect,\n  ElementRef,\n  inject,\n  isDevMode,\n  OnDestroy,\n  OnInit,\n  PLATFORM_ID,\n  signal,\n  ViewChild,\n} from '@angular/core';\nimport { Router, RouterLink } from '@angular/router';\nimport { TranslateModule } from '@ngx-translate/core';\nimport { RealtimeChannel } from '@supabase/supabase-js';\nimport { Car } from '../../../core/models';\nimport { BreakpointService } from '@core/services/ui/breakpoint.service';\nimport { CarsCompareService } from '@core/services/cars/cars-compare.service';\nimport { CarsService } from '@core/services/cars/cars.service';\nimport { DistanceCalculatorService } from '@core/services/geo/distance-calculator.service';\nimport { LocationService } from '@core/services/geo/location.service';\nimport { LoggerService } from '@core/services/infrastructure/logger.service';\nimport { MetaService } from '@core/services/ui/meta.service';\nimport { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\nimport { UrgentRentalService } from '@core/services/bookings/urgent-rental.service';\nimport { CarsMapComponent } from '../../../shared/components/cars-map/cars-map.component';\nimport { DateRange, DateRangePickerComponent } from '../../../shared/components/date-range-picker/date-range-picker.component';\nimport { PullToRefreshComponent } from '../../../shared/components/pull-to-refresh/pull-to-refresh.component';\nimport { PwaTitlebarComponent } from '../../../shared/components/pwa-titlebar/pwa-titlebar.component';\nimport { StickyCtaMobileComponent } from '../../../shared/components/sticky-cta-mobile/sticky-cta-mobile.component';\nimport { UrgentRentalBannerComponent } from '../../../shared/components/urgent-rental-banner/urgent-rental-banner.component';\n// import { CarCardV3Component } from '../../../shared/components/marketplace/car-card-v3/car-card-v3.component';\n// import { FiltersDrawerComponent } from '../../../shared/components/marketplace/filters-drawer/filters-drawer.component';\n// import { BreadcrumbsComponent, BreadcrumbItem } from '../../../shared/components/breadcrumbs/breadcrumbs.component';\nimport { getErrorMessage } from '../../../core/utils/type-guards';\nimport { AiCarRecommendationComponent } from '../../../shared/components/ai-car-recommendation/ai-car-recommendation.component';\nimport { IconComponent } from '../../../shared/components/icon/icon.component';\n\n// Temporary BreadcrumbItem interface\ninterface BreadcrumbItem {\n  label: string;\n  url?: string;\n  icon?: string;\n}\n\n// Interface para auto con distancia\nexport interface CarWithDistance extends Car {\n  distance?: number;\n  distanceText?: string;\n  body_type?: string | null;\n  image_url?: string;\n}\n\nconst SORT_STORAGE_KEY = 'autorenta:list-sort';\nconst ANALYTICS_EVENT = 'autorenta:analytics';\nconst ECONOMY_RADIUS_KM = 50;\nconst LOCATION_OVERRIDE_KEY = 'autorenta:location_override';\nconst PREMIUM_SCORE_PRICE_WEIGHT = 0.7;\nconst PREMIUM_SCORE_RATING_WEIGHT = 0.3;\nconst PAGE_SIZE = 12;\n\n@Component({\n  standalone: true,\n  selector: 'app-cars-list-page',\n  imports: [\n    CommonModule,\n    NgOptimizedImage,\n    RouterLink,\n    CarsMapComponent,\n    StickyCtaMobileComponent,\n    UrgentRentalBannerComponent,\n    PwaTitlebarComponent,\n    TranslateModule,\n    IconComponent,\n    DateRangePickerComponent,\n    AiCarRecommendationComponent,\n  ],\n  templateUrl: './cars-list.page.html',\n  styleUrls: ['./cars-list.page.css'],\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class CarsListPage implements OnInit, OnDestroy {\n  @ViewChild(CarsMapComponent) carsMapComponent!: CarsMapComponent;\n  @ViewChild('unifiedCarousel', { read: ElementRef }) unifiedCarousel?: ElementRef<HTMLDivElement>;\n  @ViewChild(PullToRefreshComponent) pullToRefresh!: PullToRefreshComponent;\n\n  // Exponer parseFloat para el template\n  readonly parseFloat = parseFloat;\n\n  getCarImageSrcset(imageUrl: string | null | undefined): string | null {\n    if (!imageUrl) return null;\n    if (!imageUrl.includes('unsplash.com') && !imageUrl.includes('images.unsplash.com')) return null;\n\n    const widths = [320, 480, 640, 960, 1280];\n    const parts: string[] = [];\n\n    for (const w of widths) {\n      const url = this.withQueryParam(imageUrl, 'w', String(w));\n      if (!url) return null;\n      parts.push(`${url} ${w}w`);\n    }\n\n    return parts.join(', ');\n  }\n\n  private withQueryParam(rawUrl: string, key: string, value: string): string | null {\n    try {\n      const url = new URL(rawUrl);\n      url.searchParams.set(key, value);\n      return url.toString();\n    } catch {\n      return null;\n    }\n  }\n\n  private readonly router = inject(Router);\n  private readonly carsService = inject(CarsService);\n  private readonly compareService = inject(CarsCompareService);\n  private readonly metaService = inject(MetaService);\n  private readonly logger = inject(LoggerService);\n  private readonly supabase = injectSupabase();\n  private readonly platformId = inject(PLATFORM_ID);\n  private readonly isBrowser = isPlatformBrowser(this.platformId);\n  private readonly distanceCalculator = inject(DistanceCalculatorService);\n  private readonly locationService = inject(LocationService);\n  private readonly urgentRentalService = inject(UrgentRentalService);\n  private readonly breakpoint = inject(BreakpointService);\n  private readonly economyRadiusKm = ECONOMY_RADIUS_KM;\n  private sortInitialized = false;\n  private locationOverrideApplied = false;\n  private analyticsLastKey: string | null = null;\n  private realtimeChannel?: RealtimeChannel;\n  private carouselAutoScrollInterval?: ReturnType<typeof setInterval>;\n  private autoScrollKickoffTimeout?: ReturnType<typeof setTimeout>;\n  private carouselAutoScrollTimeout?: ReturnType<typeof setTimeout>;\n  private carouselAutoScrollResumeTimeout?: ReturnType<typeof setTimeout>;\n\n  readonly city = signal<string | null>(null);\n  readonly dateRange = signal<DateRange>({ from: null, to: null });\n  readonly loading = signal(false);\n  readonly loadError = signal<string | null>(null);\n  readonly cars = signal<Car[]>([]);\n  readonly page = signal(1); // Client-side pagination\n\n  readonly carMapLocations = computed(() =>\n    this.cars().map((car) => {\n      const gallery = this.extractPhotoGallery(car);\n      return {\n        carId: car['id'],\n        title: `${car.brand_text_backup || ''} ${car.model_text_backup || ''}`.trim(),\n        pricePerDay: car['price_per_day'],\n        currency: car['currency'] || 'ARS',\n        lat: car['location_lat'] || 0,\n        lng: car['location_lng'] || 0,\n        updatedAt: car['updated_at'] || new Date().toISOString(),\n        city: car['location_city'],\n        state: car['location_state'],\n        country: car['location_country'],\n        locationLabel: car['location_city'] || 'Sin ubicación',\n        photoUrl: gallery[0] ?? null,\n        photoGallery: gallery,\n        description: car['description'],\n      };\n    }),\n  );\n  readonly userLocation = signal<{ lat: number; lng: number } | null>(null);\n  readonly hasFilters = computed(\n    () =>\n      !!this['city']() ||\n      !!this.dateRange().from ||\n      !!this.searchQuery() ||\n      this.maxDistance() !== null ||\n      this.minPrice() !== null ||\n      this.maxPrice() !== null ||\n      this.minRating() !== null,\n  );\n  readonly selectedCarId = signal<string | null>(null);\n  readonly hoveredCarId = signal<string | null>(null); // For card ↔ map hover sync\n  readonly searchExpanded = signal(false);\n  readonly inventoryReady = signal(false);\n  readonly drawerOpen = signal(false);\n  readonly urgentAvailability = signal<{\n    available: boolean;\n    distance?: number;\n    eta?: number;\n  } | null>(null);\n\n  // Active car for map highlight (hover takes priority over selection)\n  readonly activeMapCarId = computed(() => this.hoveredCarId() ?? this.selectedCarId());\n\n  // Airbnb-style favorites (stored in localStorage)\n  readonly favoriteCars = signal<Set<string>>(new Set());\n  readonly expressModeSignal = signal(true);\n  readonly isMobile = this.breakpoint.isMobile;\n  readonly isDesktop = this.breakpoint.isDesktop;\n\n  // View Mode (grid, list, map)\n  readonly viewMode = signal<'grid' | 'list' | 'map'>('map');\n\n  // Filtros y ordenamiento\n  readonly sortBy = signal<'distance' | 'price_asc' | 'price_desc' | 'rating' | 'newest'>('rating');\n  readonly sortLabel = computed(() => this.getSortLabel(this.sortBy()));\n\n  // Filtros de búsqueda\n  readonly maxDistance = signal<number | null>(null); // km\n  readonly minPrice = signal<number | null>(null);\n  readonly maxPrice = signal<number | null>(null);\n  readonly minRating = signal<number | null>(null); // 0-5\n  readonly searchQuery = signal<string>(''); // Búsqueda por texto\n  readonly searchSuggestions = signal<string[]>([]); // Sugerencias de autocompletado\n  private allBrandsAndModels: { brand: string; model: string }[] = [];\n  private carCities: string[] = [];\n\n  // Efecto para cargar marcas y modelos de autos para el autocompletado\n  private readonly loadBrandsAndModelsEffect = effect(\n    () => {\n      if (this.isBrowser) {\n        // Cargar marcas\n        void this.carsService.getCarBrands().then((brands) => {\n          this.allBrandsAndModels = brands.map((b) => ({ brand: b.name, model: '' }));\n        });\n        // Cargar modelos\n        void this.carsService.getAllCarModels().then((models) => {\n          models.forEach((m) => {\n            // Find brand name by brand_id or use an empty string if not found\n            // For simplicity and to avoid another API call here, we might need a mapping in CarsService\n            // For now, let's just add model names.\n            this.allBrandsAndModels.push({ brand: '', model: m.name });\n          });\n        });\n      }\n    },\n    { allowSignalWrites: true },\n  );\n\n  // Efecto para reaccionar a los cambios en searchQuery y actualizar las sugerencias\n  private readonly searchEffect = effect(\n    () => {\n      const query = this.searchQuery();\n      if (query.length > 2) {\n        this.updateSearchSuggestions(query);\n      } else {\n        this.searchSuggestions.set([]);\n      }\n    },\n    { allowSignalWrites: true },\n  );\n\n  // Efecto para resetear la página al cambiar filtros\n  private readonly resetPageEffect = effect(() => {\n    // Dependencias que deben resetear la paginación\n    this.sortBy();\n    this.searchQuery();\n    this.minPrice();\n    this.maxPrice();\n    this.minRating();\n    this.maxDistance();\n    this.dateRange();\n\n    // Resetear a página 1 (allowSignalWrites true es necesario en effects)\n    this.page.set(1);\n  }, { allowSignalWrites: true });\n\n\n  // Contadores para badge de resultados\n  readonly totalCount = computed(() => this.cars().length);\n\n  // Breadcrumbs navigation\n  readonly breadcrumbItems = computed<BreadcrumbItem[]>(() => [\n    { label: 'Inicio', url: '/', icon: '🏠' },\n    { label: 'Explorar Autos', url: '/cars', icon: '🚗' },\n    { label: `${this.premiumCars().length} Autos Disponibles` },\n  ]);\n\n  private readonly persistSortEffect = effect(() => {\n    if (!this.isBrowser || !this.sortInitialized) {\n      return;\n    }\n    const sort = this.sortBy();\n    localStorage.setItem(SORT_STORAGE_KEY, sort);\n  });\n\n  private readonly analyticsEffect = effect(() => {\n    if (!this.isBrowser) {\n      return;\n    }\n    const premiumCount = this.premiumCars().length;\n    const recommendedCount = this.recommendedCars().length;\n    const sort = this.sortBy();\n    const key = `${premiumCount}:${recommendedCount}:${sort}`;\n    if (key === this.analyticsLastKey) {\n      return;\n    }\n    this.analyticsLastKey = key;\n    this.trackAnalytics('inventory_segments_updated', {\n      premiumCount,\n      recommendedCount,\n      sort,\n    });\n  });\n\n  // 🚀 PERF: Single-pass processing pipeline\n  // Before: 5 cascaded computed signals = 5 full recalculations per change\n  // After: 1 unified computed = 1 calculation per change (-60% computation)\n  //\n  // Merged: filteredCarsWithDistance + premiumSegmentation + sortedFilteredCars\n  private readonly sortedFilteredCars = computed<CarWithDistance[]>(() => {\n    const carsList = this.cars();\n    const userLoc = this.userLocation();\n    const maxDist = this.maxDistance();\n    const minP = this.minPrice();\n    const maxP = this.maxPrice();\n    const minR = this.minRating();\n    const query = this.searchQuery().toLowerCase().trim();\n    const currentSortBy = this.sortBy();\n\n    if (!carsList.length) {\n      return [];\n    }\n\n    // ============================================\n    // STEP 1: Calculate distances + apply filters (single pass)\n    // ============================================\n    const filteredCars: CarWithDistance[] = [];\n\n    for (const car of carsList) {\n      // Calculate distance if user location available\n      let distance: number | undefined;\n      let distanceText: string | undefined;\n\n      if (userLoc && car['location_lat'] && car['location_lng']) {\n        distance = this.distanceCalculator.calculateDistance(\n          userLoc.lat,\n          userLoc.lng,\n          car['location_lat'],\n          car['location_lng'],\n        );\n\n        // Format distance text\n        if (distance < 1) {\n          distanceText = `${Math.round(distance * 10) * 100}m`;\n        } else if (distance < 10) {\n          distanceText = `${distance.toFixed(1)}km`;\n        } else {\n          distanceText = `${Math.round(distance)}km`;\n        }\n\n        // Filter by max distance\n        if (maxDist !== null && distance > maxDist) {\n          continue;\n        }\n      }\n\n      // Filter by price range\n      if (minP !== null && car['price_per_day'] < minP) {\n        continue;\n      }\n      if (maxP !== null && car['price_per_day'] > maxP) {\n        continue;\n      }\n\n      // Filter by minimum rating\n      if (minR !== null) {\n        const rating = car.owner?.rating_avg ?? 0;\n        if (rating < minR) {\n          continue;\n        }\n      }\n\n      // Filter by search query\n      if (query) {\n        const brand = (car.brand_text_backup || car['brand'] || '').toLowerCase();\n        const model = (car.model_text_backup || car['model'] || '').toLowerCase();\n        const city = (car['location_city'] || '').toLowerCase();\n        const title = (car['title'] || '').toLowerCase();\n\n        if (!brand.includes(query) && !model.includes(query) &&\n          !city.includes(query) && !title.includes(query)) {\n          continue;\n        }\n      }\n\n      filteredCars.push({\n        ...car,\n        distance,\n        distanceText,\n        image_url: this.extractPhotoGallery(car)[0] || undefined,\n      });\n    }\n\n    if (!filteredCars.length) {\n      return [];\n    }\n\n    // ============================================\n    // STEP 2: Calculate premium segmentation (inline)\n    // ============================================\n    const prices = filteredCars\n      .map((car) => car['price_per_day'])\n      .filter((price) => typeof price === 'number' && !Number.isNaN(price));\n\n    let premiumCars = filteredCars;\n\n    if (prices.length > 0) {\n      const minPrice = Math.min(...prices);\n      const maxPrice = Math.max(...prices);\n      const priceRange = Math.max(maxPrice - minPrice, 1);\n\n      // Calculate scores inline\n      const carScores = new Map<string, number>();\n      for (const car of filteredCars) {\n        const priceNormalized = (car['price_per_day'] - minPrice) / priceRange;\n        const ratingNormalized = Math.min((car.owner?.rating_avg ?? 0) / 5, 1);\n        const score = priceNormalized * PREMIUM_SCORE_PRICE_WEIGHT +\n          ratingNormalized * PREMIUM_SCORE_RATING_WEIGHT;\n        carScores.set(car['id'], score);\n      }\n\n      // Calculate threshold\n      const sortedScores = Array.from(carScores.values()).sort((a, b) => a - b);\n      const thresholdIndex = Math.max(0, Math.floor(sortedScores.length * 0.6));\n      const threshold = sortedScores[Math.min(thresholdIndex, sortedScores.length - 1)];\n\n      // Filter by premium threshold\n      premiumCars = filteredCars.filter((car) => {\n        const score = carScores.get(car['id']) ?? 0;\n        return score >= threshold;\n      });\n    }\n\n    // ============================================\n    // STEP 3: Sort (inline)\n    // ============================================\n    const sorted = premiumCars.slice();\n\n    switch (currentSortBy) {\n      case 'price_asc':\n        sorted.sort((a, b) => {\n          if (a['price_per_day'] !== b['price_per_day']) {\n            return a['price_per_day'] - b['price_per_day'];\n          }\n          const ratingA = a.owner?.rating_avg ?? 0;\n          const ratingB = b.owner?.rating_avg ?? 0;\n          if (ratingB !== ratingA) {\n            return ratingB - ratingA;\n          }\n          const distanceA = a.distance ?? Number.POSITIVE_INFINITY;\n          const distanceB = b.distance ?? Number.POSITIVE_INFINITY;\n          return distanceA - distanceB;\n        });\n        break;\n\n      case 'price_desc':\n        sorted.sort((a, b) => {\n          if (b['price_per_day'] !== a['price_per_day']) {\n            return b['price_per_day'] - a['price_per_day'];\n          }\n          const ratingA = a.owner?.rating_avg ?? 0;\n          const ratingB = b.owner?.rating_avg ?? 0;\n          return ratingB - ratingA;\n        });\n        break;\n\n      case 'rating':\n        sorted.sort((a, b) => {\n          const ratingA = a.owner?.rating_avg ?? 0;\n          const ratingB = b.owner?.rating_avg ?? 0;\n          if (ratingB !== ratingA) {\n            return ratingB - ratingA;\n          }\n          const distanceA = a.distance ?? Number.POSITIVE_INFINITY;\n          const distanceB = b.distance ?? Number.POSITIVE_INFINITY;\n          if (distanceA !== distanceB) {\n            return distanceA - distanceB;\n          }\n          if (a['price_per_day'] !== b['price_per_day']) {\n            return a['price_per_day'] - b['price_per_day'];\n          }\n          const dateA = new Date(a['created_at'] || 0).getTime();\n          const dateB = new Date(b['created_at'] || 0).getTime();\n          return dateB - dateA;\n        });\n        break;\n\n      case 'newest':\n        sorted.sort((a, b) => {\n          const dateA = new Date(a['created_at'] || 0).getTime();\n          const dateB = new Date(b['created_at'] || 0).getTime();\n          if (dateB !== dateA) {\n            return dateB - dateA;\n          }\n          const ratingA = a.owner?.rating_avg ?? 0;\n          const ratingB = b.owner?.rating_avg ?? 0;\n          if (ratingB !== ratingA) {\n            return ratingB - ratingA;\n          }\n          return a['price_per_day'] - b['price_per_day'];\n        });\n        break;\n\n      case 'distance':\n      default:\n        sorted.sort((a, b) => {\n          const distanceA = a.distance ?? Number.POSITIVE_INFINITY;\n          const distanceB = b.distance ?? Number.POSITIVE_INFINITY;\n          if (distanceA !== distanceB) {\n            return distanceA - distanceB;\n          }\n          const ratingA = a.owner?.rating_avg ?? 0;\n          const ratingB = b.owner?.rating_avg ?? 0;\n          if (ratingB !== ratingA) {\n            return ratingB - ratingA;\n          }\n          return a['price_per_day'] - b['price_per_day'];\n        });\n        break;\n    }\n\n    return sorted;\n  });\n\n  // 🚀 PERF: Filtered cars with distance - computed from unified pipeline\n  // Kept for backwards compatibility with recommendedCars\n  private readonly filteredCarsWithDistance = computed<CarWithDistance[]>(() => {\n    // Re-use the filtered data from sortedFilteredCars but without premium filter\n    const carsList = this.cars();\n    const userLoc = this.userLocation();\n    const maxDist = this.maxDistance();\n    const minP = this.minPrice();\n    const maxP = this.maxPrice();\n    const minR = this.minRating();\n    const query = this.searchQuery().toLowerCase().trim();\n\n    if (!carsList.length) {\n      return [];\n    }\n\n    const result: CarWithDistance[] = [];\n\n    for (const car of carsList) {\n      let distance: number | undefined;\n      let distanceText: string | undefined;\n\n      if (userLoc && car['location_lat'] && car['location_lng']) {\n        distance = this.distanceCalculator.calculateDistance(\n          userLoc.lat,\n          userLoc.lng,\n          car['location_lat'],\n          car['location_lng'],\n        );\n\n        if (distance < 1) {\n          distanceText = `${Math.round(distance * 10) * 100}m`;\n        } else if (distance < 10) {\n          distanceText = `${distance.toFixed(1)}km`;\n        } else {\n          distanceText = `${Math.round(distance)}km`;\n        }\n\n        if (maxDist !== null && distance > maxDist) {\n          continue;\n        }\n      }\n\n      if (minP !== null && car['price_per_day'] < minP) continue;\n      if (maxP !== null && car['price_per_day'] > maxP) continue;\n\n      if (minR !== null) {\n        const rating = car.owner?.rating_avg ?? 0;\n        if (rating < minR) continue;\n      }\n\n      if (query) {\n        const brand = (car.brand_text_backup || car['brand'] || '').toLowerCase();\n        const model = (car.model_text_backup || car['model'] || '').toLowerCase();\n        const city = (car['location_city'] || '').toLowerCase();\n        const title = (car['title'] || '').toLowerCase();\n\n        if (!brand.includes(query) && !model.includes(query) &&\n          !city.includes(query) && !title.includes(query)) {\n          continue;\n        }\n      }\n\n      result.push({\n        ...car,\n        distance,\n        distanceText,\n        image_url: this.extractPhotoGallery(car)[0] || undefined,\n      });\n    }\n\n    return result;\n  });\n\n  // Lista PAGINADA para mostrar en la vista\n  readonly premiumCars = computed<CarWithDistance[]>(() => {\n    return this.sortedFilteredCars().slice(0, this.page() * PAGE_SIZE);\n  });\n\n  // Computed para saber si hay más autos para cargar\n  readonly hasMoreCars = computed(() => {\n    return this.premiumCars().length < this.sortedFilteredCars().length;\n  });\n\n  // 🚀 PERF: Pre-computed badges para evitar llamadas de función en @for loops\n  // Antes: 48+ function calls/render (isTopRated + hasInstantBooking × 24 cars)\n  // Después: 0 function calls (Map lookup O(1))\n  readonly carBadges = computed(() => {\n    const badges = new Map<string, { topRated: boolean; popular: boolean; instantBooking: boolean }>();\n    for (const car of this.premiumCars()) {\n      const ratingAvg = car.rating_avg || 0;\n      const ratingCount = car.rating_count || 0;\n      badges.set(car['id'], {\n        topRated: ratingAvg >= 4.5 && ratingCount >= 5,\n        popular: ratingCount >= 10,\n        instantBooking: ratingAvg >= 4.0 && ratingCount >= 3,\n      });\n    }\n    return badges;\n  });\n\n  // Método para cargar más autos\n  loadMore(): void {\n    this.page.update(p => p + 1);\n  }\n\n  readonly recommendedCars = computed<CarWithDistance[]>(() => {\n    const cars = this.filteredCarsWithDistance();\n    if (!cars.length) {\n      return [];\n    }\n\n    // Filtrar solo autos activos con al menos una reseña (o rating_avg > 0)\n    const eligibleCars = cars.filter(\n      (car) => car['status'] === 'active' && (car.rating_avg > 0 || car.rating_count > 0),\n    );\n\n    if (!eligibleCars.length) {\n      // Si no hay autos con reseñas, mostrar todos los activos\n      return cars\n        .filter((car) => car['status'] === 'active')\n        .sort((a, b) => {\n          // Primero por distancia (si hay ubicación del usuario)\n          const distanceA = a.distance ?? Number.POSITIVE_INFINITY;\n          const distanceB = b.distance ?? Number.POSITIVE_INFINITY;\n\n          if (distanceA !== distanceB) {\n            return distanceA - distanceB;\n          }\n\n          // Luego por precio (más barato primero)\n          if (a['price_per_day'] !== b['price_per_day']) {\n            return a['price_per_day'] - b['price_per_day'];\n          }\n\n          // Finalmente por nombre\n          return (a['title'] || '').localeCompare(b['title'] || '');\n        })\n        .slice(0, 15);\n    }\n\n    // Ordenar por rating primero, luego distancia\n    return eligibleCars\n      .sort((a, b) => {\n        // Primero: Rating promedio (mayor mejor)\n        const ratingA = a.rating_avg || 0;\n        const ratingB = b.rating_avg || 0;\n\n        if (ratingA !== ratingB) {\n          return ratingB - ratingA; // Mayor rating primero\n        }\n\n        // Segundo: Cantidad de reseñas (más reseñas = más confiable)\n        const reviewsA = a.rating_count || 0;\n        const reviewsB = b.rating_count || 0;\n\n        if (reviewsA !== reviewsB) {\n          return reviewsB - reviewsA; // Más reseñas primero\n        }\n\n        // Tercero: Distancia (más cerca mejor, si hay ubicación)\n        const distanceA = a.distance ?? Number.POSITIVE_INFINITY;\n        const distanceB = b.distance ?? Number.POSITIVE_INFINITY;\n\n        if (distanceA !== distanceB) {\n          return distanceA - distanceB;\n        }\n\n        // Cuarto: Precio (más barato primero)\n        if (a['price_per_day'] !== b['price_per_day']) {\n          return a['price_per_day'] - b['price_per_day'];\n        }\n\n        // Finalmente: Nombre alfabético\n        return (a['title'] || '').localeCompare(b['title'] || '');\n      })\n      .slice(0, 15);\n  });\n\n  readonly showRecommendedCarousel = computed(() => {\n    const recommended = this.recommendedCars();\n    if (!recommended.length) {\n      return false;\n    }\n\n    // Mostrar siempre si hay autos recomendados\n    // Esto asegura que el carousel aparezca cuando haya autos con reseñas\n    return recommended.length >= 3; // Mostrar mínimo 3 autos\n  });\n\n  // Effect para extraer ciudades únicas de los autos\n  private readonly extractCarCitiesEffect = effect(() => {\n    const cars = this.cars();\n    const uniqueCities = new Set<string>();\n    cars.forEach(car => {\n      if (car['location_city']) {\n        uniqueCities.add(car['location_city']);\n      }\n    });\n    this.carCities = Array.from(uniqueCities);\n  });\n\n  private updateSearchSuggestions(query: string): void {\n    const lowerQuery = query.toLowerCase();\n    const suggestions: Set<string> = new Set();\n\n    // Sugerencias de marcas\n    this.allBrandsAndModels\n      .filter((item) => item['brand'] && item['brand'].toLowerCase().includes(lowerQuery))\n      .map((item) => item['brand'])\n      .forEach((brand) => suggestions.add(brand));\n\n    // Sugerencias de modelos\n    this.allBrandsAndModels\n      .filter((item) => item['model'] && item['model'].toLowerCase().includes(lowerQuery))\n      .map((item) => item['model'])\n      .forEach((model) => suggestions.add(model));\n\n    // Sugerencias de ciudades\n    this.carCities\n      .filter((city) => city.toLowerCase().includes(lowerQuery))\n      .forEach((city) => suggestions.add(city));\n\n    this.searchSuggestions.set(Array.from(suggestions).slice(0, 5)); // Limitar a 5 sugerencias\n  }\n\n  // Helper para determinar si un auto es \"Top Rated\" (Superanfitrión)\n  isTopRated(car: CarWithDistance): boolean {\n    return (car.rating_avg || 0) >= 4.5 && (car.rating_count || 0) >= 5;\n  }\n\n  // Helper para determinar si un auto es \"Popular\" (muchas reservas)\n  isPopular(car: CarWithDistance): boolean {\n    return (car.rating_count || 0) >= 10;\n  }\n\n  // Helper para \"Reserva inmediata\" - basado en datos reales cuando existan\n  // Por ahora usa umbral de rating como proxy (autos bien valorados = confianza)\n  hasInstantBooking(car: CarWithDistance): boolean {\n    // TODO: Usar car.instant_booking_enabled cuando se agregue a la DB\n    return (car.rating_avg || 0) >= 4.0 && (car.rating_count || 0) >= 3;\n  }\n\n  // Comparación\n  readonly compareCount = this.compareService.count;\n  readonly maxCompareReached = computed(() => this.compareCount() >= 3);\n\n  ngOnInit(): void {\n    if (this.isBrowser) {\n      const storedSort = localStorage.getItem(SORT_STORAGE_KEY);\n      if (storedSort && this.isValidSort(storedSort)) {\n        this.sortBy.set(storedSort);\n      }\n\n      // Load saved favorites from localStorage\n      const storedFavorites = localStorage.getItem('autorenta:favorites');\n      if (storedFavorites) {\n        try {\n          const parsed = JSON.parse(storedFavorites) as string[];\n          this.favoriteCars.set(new Set(parsed));\n        } catch {\n          // Invalid JSON, ignore\n        }\n      }\n\n      // Apply query param overrides (sort, distance, location) if present\n      this.applyQueryOverrides();\n\n      // 📱 Default to grid view (Tinder-style) on mobile for better engagement\n      // Previously defaulted to map, but the new swipe UI is superior\n      // if (this.isMobile()) {\n      //   this.viewMode.set('map');\n      // }\n    }\n\n    this.sortInitialized = true;\n    if (this.isBrowser) {\n      localStorage.setItem(SORT_STORAGE_KEY, this.sortBy());\n    }\n\n    // Update SEO meta tags\n    this.metaService.updateCarsListMeta({\n      city: this['city']() || undefined,\n    });\n\n    // Initialize user location for distance-based pricing\n    void this.initializeUserLocation();\n\n    void this.loadCars();\n    // Effects se ejecutan automáticamente, no necesitan ser llamados\n  }\n\n  /**\n   * Initialize user location from profile or GPS\n   */\n  private async initializeUserLocation(): Promise<void> {\n    try {\n      if (this.userLocation()) {\n        return;\n      }\n      if (this.locationOverrideApplied) {\n        return;\n      }\n      const locationData = await this.locationService.getUserLocation();\n      if (locationData) {\n        this.userLocation.set({\n          lat: locationData.lat,\n          lng: locationData.lng,\n        });\n      }\n    } catch (_error) {\n      // Silently fail - user location is optional\n      console.warn('Could not get user location:', _error);\n    }\n  }\n\n  onUserLocationChange(location: { lat: number; lng: number }): void {\n    this.userLocation.set(location);\n    // Open drawer when user location is set and there are cars\n    if (this.cars().length > 0 && !this.drawerOpen()) {\n      this.drawerOpen.set(true);\n    }\n  }\n\n  private applyQueryOverrides(): void {\n    if (!this.isBrowser) return;\n    const params = new URLSearchParams(window.location.search);\n\n    const sortParam = params.get('sort');\n    if (sortParam && this.isValidSort(sortParam)) {\n      this.sortBy.set(sortParam);\n      localStorage.setItem(SORT_STORAGE_KEY, sortParam);\n    }\n\n    const maxDistanceParam = params.get('maxDistance');\n    if (maxDistanceParam) {\n      const parsed = Number.parseFloat(maxDistanceParam);\n      if (Number.isFinite(parsed) && parsed > 0) {\n        this.maxDistance.set(parsed);\n      }\n    }\n\n    const cityParam = params.get('city');\n    if (cityParam) {\n      this['city'].set(cityParam);\n    }\n\n    const latParam = params.get('lat');\n    const lngParam = params.get('lng');\n    if (latParam && lngParam) {\n      const lat = Number.parseFloat(latParam);\n      const lng = Number.parseFloat(lngParam);\n      if (this.locationService.validateCoordinates(lat, lng)) {\n        this.userLocation.set({ lat, lng });\n        this.locationOverrideApplied = true;\n        return;\n      }\n    }\n\n    this.loadLocationOverrideFromStorage();\n  }\n\n  private loadLocationOverrideFromStorage(): void {\n    if (!this.isBrowser) return;\n    const raw = sessionStorage.getItem(LOCATION_OVERRIDE_KEY);\n    if (!raw) return;\n    try {\n      const parsed = JSON.parse(raw) as { lat?: number; lng?: number };\n      if (\n        typeof parsed?.lat === 'number' &&\n        typeof parsed?.lng === 'number' &&\n        this.locationService.validateCoordinates(parsed.lat, parsed.lng)\n      ) {\n        this.userLocation.set({ lat: parsed.lat, lng: parsed.lng });\n        this.locationOverrideApplied = true;\n      }\n    } catch {\n      // Ignore parse errors\n    }\n  }\n\n  centerOnUserLocation(): void {\n    if (navigator.geolocation) {\n      navigator.geolocation.getCurrentPosition(\n        (position) => {\n          this.userLocation.set({\n            lat: position.coords.latitude,\n            lng: position.coords.longitude,\n          });\n        },\n        (error) => {\n          console.warn('Error getting user location:', error);\n        },\n      );\n    }\n  }\n\n  async loadCars(): Promise<void> {\n    this.loading.set(true);\n    this.loadError.set(null);\n    try {\n      if (this.isBrowser && isDevMode()) {\n        const params = new URLSearchParams(window.location.search);\n        if (params.get('e2eFailCars') === '1') {\n          throw new Error('E2E forced car load failure');\n        }\n      }\n\n      const dateRange = this.dateRange();\n\n      // ✅ SPRINT 2 INTEGRATION: Usar getAvailableCars si hay fechas seleccionadas\n      if (dateRange.from && dateRange.to) {\n        const items = await this.carsService.getAvailableCars(dateRange.from, dateRange.to, {\n          city: this['city']() ?? undefined,\n          limit: 100,\n        });\n        this.cars.set(items);\n      } else {\n        // Si no hay fechas, usar método tradicional\n        const items = await this.carsService.listActiveCars({\n          city: this['city']() ?? undefined,\n          from: dateRange.from ?? undefined,\n          to: dateRange.to ?? undefined,\n        });\n        this.cars.set(items);\n      }\n\n      // Collapse search form on mobile after search\n      this.searchExpanded.set(false);\n      this.searchSuggestions.set([]); // Limpiar sugerencias después de la búsqueda\n\n      // Notificar que el inventario está listo\n      if (this.isBrowser && !this.inventoryReady()) {\n        this.inventoryReady.set(true);\n      }\n\n      // Setup real-time subscription on first load\n      if (this.isBrowser && !this.realtimeChannel) {\n        this.setupRealtimeSubscription();\n      }\n    } catch (err) {\n      this.loadError.set(this.getCarsLoadErrorMessage(err));\n      this.logger['error'](\n        'Error loading cars',\n        'CarsListPage',\n        err instanceof Error ? err : new Error(getErrorMessage(err)),\n      );\n      // Mostrar mensaje al usuario en caso de error crítico\n      if (err instanceof Error) {\n        console['error']('Error al cargar autos:', err['message']);\n      }\n    } finally {\n      this.loading.set(false);\n\n      // Iniciar auto-scroll del carousel después de cargar los autos\n      if (this.autoScrollKickoffTimeout) {\n        clearTimeout(this.autoScrollKickoffTimeout);\n        this.autoScrollKickoffTimeout = undefined;\n      }\n\n      if (this.recommendedCars().length >= 3) {\n        this.autoScrollKickoffTimeout = setTimeout(() => this.startCarouselAutoScroll(), 1000);\n      } else {\n        this.stopCarouselAutoScroll();\n      }\n    }\n  }\n\n  private getCarsLoadErrorMessage(err: unknown): string {\n    const raw = getErrorMessage(err);\n\n    if (/network|failed to fetch|fetch|timeout|timed out|connection|offline/i.test(raw)) {\n      return 'Error de conexión. Verifica tu internet e intenta nuevamente.';\n    }\n\n    if (/unauthorized|forbidden|401|403|invalid token|expired/i.test(raw)) {\n      return 'Tu sesión expiró o no tienes permisos. Inicia sesión nuevamente e intenta otra vez.';\n    }\n\n    return 'No pudimos cargar los vehículos. Intenta nuevamente.';\n  }\n\n  /**\n   * 🔄 Handle pull-to-refresh\n   * Método para actualizar la lista de autos\n   */\n  async handleRefresh(): Promise<void> {\n    try {\n      await this.loadCars();\n\n      // Completar el refresh\n      if (this.pullToRefresh) {\n        this.pullToRefresh.completeRefresh();\n      }\n    } catch (_error) {\n      this.logger['error'](\n        'Error al refrescar autos',\n        'CarsListPage',\n        _error instanceof Error ? _error : new Error(getErrorMessage(_error)),\n      );\n      if (this.pullToRefresh) {\n        this.pullToRefresh.completeRefresh();\n      }\n    }\n  }\n\n  // 🚀 PERF: Debounce timeout for batching realtime updates\n  private realtimeDebounceTimeout?: ReturnType<typeof setTimeout>;\n  private pendingRealtimeRefresh = false;\n\n  private setupRealtimeSubscription(): void {\n    // 🚀 PERF: Only listen to INSERT and DELETE events\n    // UPDATEs are frequent and rarely need immediate UI refresh\n    // This reduces unnecessary re-renders by ~80%\n    this.realtimeChannel = this.supabase\n      .channel('cars-realtime')\n      .on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'cars' }, (payload) => {\n        this.handleRealtimeInsert(payload);\n      })\n      .on('postgres_changes', { event: 'DELETE', schema: 'public', table: 'cars' }, () => {\n        this.handleRealtimeDelete();\n      })\n      .subscribe((status) => {\n        if (status === 'SUBSCRIBED') {\n          console.debug('[CarsList] Realtime subscription active');\n        }\n      });\n  }\n\n  // Handle new car insertion - show toast only (user can manually refresh)\n  private async handleRealtimeInsert(_payload: unknown): Promise<void> {\n    await this.showNewCarToast();\n  }\n\n  // Handle car deletion - debounced refresh to batch multiple deletions\n  private handleRealtimeDelete(): void {\n    // Mark that a refresh is needed\n    this.pendingRealtimeRefresh = true;\n\n    // Clear existing timeout if any\n    if (this.realtimeDebounceTimeout) {\n      clearTimeout(this.realtimeDebounceTimeout);\n    }\n\n    // Debounce: wait 2 seconds before refreshing to batch multiple changes\n    this.realtimeDebounceTimeout = setTimeout(() => {\n      if (this.pendingRealtimeRefresh) {\n        this.pendingRealtimeRefresh = false;\n        void this.loadCars();\n      }\n    }, 2000);\n  }\n\n  private async showNewCarToast(): Promise<void> {\n    if (typeof window === 'undefined') return;\n\n    // Show simple notification banner (usando createElement para evitar XSS)\n    const banner = document.createElement('div');\n    banner.className =\n      'fixed top-4 left-1/2 -translate-x-1/2 z-50 bg-success-light text-text-primary px-6 py-3 rounded-lg shadow-lg flex items-center gap-3 animate-slide-down';\n\n    // Crear elementos de forma segura (sin innerHTML)\n    const messageSpan = document.createElement('span');\n    messageSpan.textContent = '¡Nuevos vehículos disponibles!';\n\n    const refreshButton = document.createElement('button');\n    refreshButton.className = 'underline font-medium';\n    refreshButton.textContent = 'Ver ahora';\n    refreshButton.addEventListener('click', () => {\n      void this.loadCars();\n      banner.remove();\n    });\n\n    const closeButton = document.createElement('button');\n    closeButton.className = 'ml-2';\n    closeButton.textContent = '✕';\n    closeButton.setAttribute('aria-label', 'Cerrar');\n    closeButton.addEventListener('click', () => {\n      banner.remove();\n    });\n\n    banner.appendChild(messageSpan);\n    banner.appendChild(refreshButton);\n    banner.appendChild(closeButton);\n\n    document.body.appendChild(banner);\n\n    // Auto-remove after 5 seconds\n    setTimeout(() => banner.remove(), 5000);\n  }\n\n  ngOnDestroy(): void {\n    if (this.realtimeChannel) {\n      this.supabase.removeChannel(this.realtimeChannel);\n    }\n    if (this.autoScrollKickoffTimeout) {\n      clearTimeout(this.autoScrollKickoffTimeout);\n      this.autoScrollKickoffTimeout = undefined;\n    }\n    // 🚀 PERF: Clean up realtime debounce timeout\n    if (this.realtimeDebounceTimeout) {\n      clearTimeout(this.realtimeDebounceTimeout);\n      this.realtimeDebounceTimeout = undefined;\n    }\n    this.stopCarouselAutoScroll();\n  }\n\n  /**\n   * Inicia el auto-scroll del carousel\n   * Se mueve automáticamente cada 3 segundos\n   */\n  startCarouselAutoScroll(): void {\n    if (!this.isBrowser) return;\n\n    // Limpiar interval existente\n    this.stopCarouselAutoScroll();\n\n    // Iniciar auto-scroll después de 2 segundos (dar tiempo a que cargue)\n    if (this.carouselAutoScrollTimeout) {\n      clearTimeout(this.carouselAutoScrollTimeout);\n    }\n\n    this.carouselAutoScrollTimeout = setTimeout(() => {\n      this.carouselAutoScrollInterval = setInterval(() => {\n        this.scrollCarouselNext();\n      }, 3000); // Cada 3 segundos\n    }, 2000);\n  }\n\n  /**\n   * Detiene el auto-scroll del carousel\n   */\n  stopCarouselAutoScroll(): void {\n    if (this.carouselAutoScrollTimeout) {\n      clearTimeout(this.carouselAutoScrollTimeout);\n      this.carouselAutoScrollTimeout = undefined;\n    }\n    if (this.carouselAutoScrollInterval) {\n      clearInterval(this.carouselAutoScrollInterval);\n      this.carouselAutoScrollInterval = undefined;\n    }\n    // Limpiar también el timeout de reanudación si existe\n    if (this.carouselAutoScrollResumeTimeout) {\n      clearTimeout(this.carouselAutoScrollResumeTimeout);\n      this.carouselAutoScrollResumeTimeout = undefined;\n    }\n  }\n\n  /**\n   * Scroll al siguiente item del carousel\n   */\n  private scrollCarouselNext(): void {\n    const carousel = this.unifiedCarousel?.nativeElement;\n    if (!carousel) return;\n\n    const cardWidth = 340 + 12; // min-width + gap\n    const currentScroll = carousel.scrollLeft;\n    const maxScroll = carousel.scrollWidth - carousel.clientWidth;\n\n    // Si llegó al final, volver al inicio\n    if (currentScroll >= maxScroll - 10) {\n      carousel.scrollTo({ left: 0, behavior: 'smooth' });\n    } else {\n      // Scroll al siguiente item\n      carousel.scrollBy({ left: cardWidth, behavior: 'smooth' });\n    }\n  }\n\n  /**\n   * Pausar auto-scroll cuando el usuario interactúa\n   */\n  onCarouselMouseEnter(): void {\n    this.stopCarouselAutoScroll();\n  }\n\n  /**\n   * Reanudar auto-scroll cuando el usuario deja de interactuar\n   */\n  onCarouselMouseLeave(): void {\n    // Si hay un timeout de reanudación programado, cancelarlo\n    // porque el usuario está interactuando activamente\n    if (this.carouselAutoScrollResumeTimeout) {\n      clearTimeout(this.carouselAutoScrollResumeTimeout);\n      this.carouselAutoScrollResumeTimeout = undefined;\n    }\n    // Reanudar inmediatamente\n    this.startCarouselAutoScroll();\n  }\n\n  toggleSearch(): void {\n    this.searchExpanded.update((expanded) => !expanded);\n  }\n\n  onCityChange(value: string): void {\n    this['city'].set(value || null);\n    void this.loadCars();\n  }\n\n  onRangeChange(range: DateRange): void {\n    this.dateRange.set(range);\n    void this.loadCars();\n  }\n\n  /**\n   * Limpiar todos los filtros\n   */\n  clearFilters(): void {\n    this.maxDistance.set(null);\n    this.minPrice.set(null);\n    this.maxPrice.set(null);\n    this.minRating.set(null);\n    this.searchQuery.set('');\n  }\n\n  /**\n   * Manejar input de búsqueda\n   */\n  onSearchInput(event: Event): void {\n    const value = (event.target as HTMLInputElement).value;\n    this.searchQuery.set(value);\n  }\n\n  /**\n   * Ejecutar búsqueda (on Enter)\n   */\n  onSearchSubmit(): void {\n    // La búsqueda ya se aplica reactivamente via searchQuery signal\n    // Este método puede usarse para analytics o acciones adicionales\n    this.searchSuggestions.set([]); // Limpiar sugerencias al presionar Enter\n  }\n\n  /**\n   * Limpiar búsqueda\n   */\n  clearSearch(): void {\n    this.searchQuery.set('');\n    this.searchSuggestions.set([]); // Limpiar sugerencias al limpiar búsqueda\n  }\n\n  onSuggestionClick(suggestion: string): void {\n    this.searchQuery.set(suggestion);\n    this.searchSuggestions.set([]); // Limpiar sugerencias\n    // Podríamos disparar una búsqueda inmediata aquí si queremos\n    // void this.loadCars();\n  }\n\n  // Card ↔ Map hover synchronization\n  onCardMouseEnter(carId: string): void {\n    this.hoveredCarId.set(carId);\n    // Smooth fly to car location on hover (desktop only)\n    if (this.isDesktop() && this.carsMapComponent) {\n      this.carsMapComponent.flyToCarLocation(carId);\n    }\n  }\n\n  onCardMouseLeave(): void {\n    this.hoveredCarId.set(null);\n  }\n\n  /**\n   * Social proof: Get simulated viewing count for a car\n   * In production, this would come from WebSocket/real-time analytics\n   */\n  getViewingCount(carId: string): number {\n    // Simulate viewing count based on car ID hash\n    // Shows 0-5 viewers, with ~30% of cars having viewers\n    const hash = carId.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);\n    const seed = hash % 100;\n    if (seed < 30) return 0; // 30% have no viewers\n    if (seed < 50) return 1;\n    if (seed < 70) return 2;\n    if (seed < 85) return 3;\n    if (seed < 95) return 4;\n    return 5;\n  }\n\n  onCarSelected(carId: string): void {\n    const previousCarId = this.selectedCarId();\n    this.selectedCarId.set(carId);\n\n    // Open drawer when car is selected\n    if (!this.drawerOpen()) {\n      this.drawerOpen.set(true);\n    }\n\n    // Pausar auto-scroll del carousel por 8 segundos\n    this.stopCarouselAutoScroll();\n\n    // Programar reanudación después de 8 segundos\n    this.carouselAutoScrollResumeTimeout = setTimeout(() => {\n      if (this.recommendedCars().length >= 3) {\n        this.startCarouselAutoScroll();\n      }\n      this.carouselAutoScrollResumeTimeout = undefined;\n    }, 8000);\n\n    // Si es el mismo auto (doble click), navegar al detalle\n    if (previousCarId === carId) {\n      this.router.navigate(['/cars', carId]);\n      return;\n    }\n\n    // Primera selección: fly to location en el mapa\n    if (this.carsMapComponent) {\n      this.carsMapComponent.flyToCarLocation(carId);\n    }\n\n    // Check urgent availability for selected car\n    void this.checkUrgentAvailability(carId);\n  }\n\n  /**\n   * Handle drawer close\n   */\n  onDrawerClose(): void {\n    this.drawerOpen.set(false);\n  }\n\n  /**\n   * Handle reserve click from drawer\n   */\n  onReserveClick(carId: string): void {\n    // Navigate to car detail page or open booking modal\n    this.router.navigate(['/cars', carId]);\n  }\n\n  /**\n   * Get selected car for CTA\n   */\n  readonly selectedCar = computed(() => {\n    const carId = this.selectedCarId();\n    if (!carId) return null;\n    return this.cars().find((c) => c['id'] === carId) || null;\n  });\n\n  /**\n   * Get selected car price for CTA\n   */\n  readonly selectedCarPrice = computed(() => {\n    const car = this.selectedCar();\n    return car?.['price_per_day'] ?? null;\n  });\n\n  /**\n   * Check urgent availability for a car\n   */\n  private async checkUrgentAvailability(carId: string): Promise<void> {\n    const car = this.cars().find((c) => c['id'] === carId);\n    if (!car || !car.region_id) return;\n\n    try {\n      const availability = await this.urgentRentalService.checkImmediateAvailability(carId);\n      this.urgentAvailability.set({\n        available: availability.available,\n        distance: availability.distance,\n        eta: availability.eta,\n      });\n    } catch (_error) {\n      console.warn('Could not check urgent availability:', _error);\n    }\n  }\n\n  onMapCarSelected(carId: string): void {\n    const previousCarId = this.selectedCarId();\n    this.selectedCarId.set(carId);\n\n    // Pausar auto-scroll del carousel por 8 segundos\n    this.stopCarouselAutoScroll();\n\n    // Programar reanudación después de 8 segundos\n    this.carouselAutoScrollResumeTimeout = setTimeout(() => {\n      if (this.recommendedCars().length >= 3) {\n        this.startCarouselAutoScroll();\n      }\n      this.carouselAutoScrollResumeTimeout = undefined;\n    }, 8000);\n\n    // Si es el mismo auto, navegar al detalle\n    if (previousCarId === carId) {\n      this.router.navigate(['/cars', carId]);\n      return;\n    }\n\n    // Scroll al auto en la lista (o carrusel si es móvil)\n    if (this.isMobile() && this.viewMode() === 'map') {\n      this.scrollToCarInCarousel(carId);\n    } else {\n      this.scrollToCarCard(carId);\n    }\n  }\n\n  isCarSelected(carId: string): boolean {\n    return this.selectedCarId() === carId;\n  }\n\n  // Comparación\n  isCarComparing(carId: string): boolean {\n    return this.compareService.isComparing(carId);\n  }\n\n  onCompareToggle(carId: string): void {\n    if (this.compareService.isComparing(carId)) {\n      this.compareService.removeCar(carId);\n    } else {\n      const added = this.compareService.addCar(carId);\n      if (!added) {\n        // Máximo alcanzado, se podría mostrar un mensaje\n        // TODO: surface feedback to user (toast/snackbar)\n      }\n    }\n  }\n\n  // Filters drawer management (mobile)\n  openFiltersDrawer(): void {\n    this.drawerOpen.set(true);\n  }\n\n  closeFiltersDrawer(): void {\n    this.drawerOpen.set(false);\n  }\n\n  toggleFiltersDrawer(): void {\n    this.drawerOpen.update((open) => !open);\n  }\n\n  // Cálculo de distancia usando DistanceCalculatorService\n  private calculateDistance(lat1: number, lon1: number, lat2: number, lon2: number): number {\n    return this.distanceCalculator.calculateDistance(lat1, lon1, lat2, lon2);\n  }\n\n  onSortChange(sortBy: 'distance' | 'price_asc' | 'price_desc' | 'rating' | 'newest'): void {\n    this.sortBy.set(sortBy);\n  }\n\n  trackByCarId(_index: number, car: CarWithDistance): string {\n    return car['id'];\n  }\n\n  /**\n   * TrackBy function for ngFor with proper naming\n   * Returns unique identifier for each car in the list\n   */\n  trackByCar(_index: number, car: CarWithDistance): string {\n    return car['id'];\n  }\n\n  /**\n   * Airbnb-style favorite toggle\n   * Stores favorites in localStorage for persistence\n   */\n  toggleFavorite(event: Event, carId: string): void {\n    event.preventDefault();\n    event.stopPropagation();\n\n    const favorites = new Set(this.favoriteCars());\n    if (favorites.has(carId)) {\n      favorites.delete(carId);\n    } else {\n      favorites.add(carId);\n    }\n    this.favoriteCars.set(favorites);\n\n    // Persist to localStorage\n    if (this.isBrowser) {\n      localStorage.setItem('autorenta:favorites', JSON.stringify([...favorites]));\n    }\n  }\n\n  /**\n   * Check if a car is in favorites\n   */\n  isFavorite(carId: string): boolean {\n    return this.favoriteCars().has(carId);\n  }\n\n  /**\n   * Convierte CarWithDistance al formato esperado por CarCardV3Component\n   * Mapea los campos del modelo Car al formato simplificado de la card\n   */\n  carToCardFormat(car: CarWithDistance): {\n    id: string;\n    title: string;\n    brand: string;\n    model: string;\n    images: string[];\n    pricePerDay: number;\n    rating: number;\n    ratingCount: number;\n    location: string;\n    distanceKm?: number;\n    instantBook?: boolean;\n  } {\n    // Extraer brand y model del title si no están disponibles\n    const titleParts = car['title'].split(' ');\n    const brand = titleParts[0] || '';\n    const model = titleParts.slice(1).join(' ') || '';\n\n    return {\n      id: car['id'],\n      title: car['title'],\n      brand,\n      model,\n      images: car.photos?.map((photo) => photo['url']) || [],\n      pricePerDay: car['price_per_day'],\n      rating: car.rating_avg || 0,\n      ratingCount: car.rating_count || 0,\n      location: `${car['location_city']}, ${car['location_state']}`,\n      distanceKm: car.distance,\n      instantBook: false, // FIXME: Add instant_booking field to Car model and database\n    };\n  }\n\n  /**\n   * Extract feature tags from car features object\n   * Converts feature flags to display-friendly strings\n   * @param features Feature flags object (e.g., { ac: true, gps: true })\n   * @returns Array of feature tag strings\n   */\n  getFeatureTags(features: Record<string, boolean> | undefined): string[] {\n    if (!features || typeof features !== 'object') {\n      return [];\n    }\n\n    // Map feature keys to display labels\n    const featureLabels: Record<string, string> = {\n      ac: '❄️ AC',\n      air_conditioning: '❄️ AC',\n      gps: '🗺️ GPS',\n      navigation: '🗺️ GPS',\n      bluetooth: '🔵 Bluetooth',\n      leather_seats: '🪑 Cuero',\n      sunroof: '☀️ Techo',\n      roof: '☀️ Techo',\n      backup_camera: '📷 Cámara',\n      camera: '📷 Cámara',\n      usb_charging: '🔌 USB',\n      usb: '🔌 USB',\n      apple_carplay: '🍎 CarPlay',\n      android_auto: '🤖 Android',\n      cruise_control: '⚙️ Cruise',\n      automatic_transmission: '⚙️ Automático',\n      transmission: '⚙️ Automático',\n      wifi: '📡 WiFi',\n      heated_seats: '🔥 Calefacción',\n      parking_sensors: '📡 Sensores',\n      sensors: '📡 Sensores',\n      all_wheel_drive: '🏔️ AWD',\n      four_wheel_drive: '🏔️ 4WD',\n      traction_control: '🛡️ Control',\n      lane_departure: '⚠️ LDW',\n      adaptive_cruise: '🎯 Adaptive',\n    };\n\n    return Object.entries(features)\n      .filter(([, value]) => value === true)\n      .map(([key]) => featureLabels[key.toLowerCase()] || key)\n      .filter((label, index, array) => array.indexOf(label) === index); // Remove duplicates\n  }\n\n  private getSortLabel(\n    sort: 'distance' | 'price_asc' | 'price_desc' | 'rating' | 'newest',\n  ): string {\n    switch (sort) {\n      case 'distance':\n        return 'distancia';\n      case 'price_asc':\n        return 'precio ascendente';\n      case 'price_desc':\n        return 'precio descendente';\n      case 'rating':\n        return 'mejor valoración';\n      case 'newest':\n        return 'más nuevos';\n      default:\n        return 'distancia';\n    }\n  }\n\n  private scrollToCarCard(carId: string): void {\n    if (typeof window === 'undefined') {\n      return;\n    }\n\n    const card = document.getElementById(`car-card-${carId}`);\n    if (card) {\n      card.scrollIntoView({ behavior: 'smooth', block: 'start' });\n    }\n  }\n\n  private scrollToCarInCarousel(carId: string): void {\n    if (!this.isBrowser || !this.unifiedCarousel) {\n      return;\n    }\n\n    const carousel = this.unifiedCarousel.nativeElement;\n    const card = carousel.querySelector(`[data-car-id=\"${carId}\"]`) as HTMLElement;\n\n    if (!card) {\n      this.logger.warn(`Car card not found in carousel: ${carId}`, 'CarsListPage');\n      return;\n    }\n\n    // Scroll horizontal suave al card\n    const cardLeft = card.offsetLeft;\n    const cardWidth = card.offsetWidth;\n    const carouselWidth = carousel.offsetWidth;\n    const scrollPosition = cardLeft - carouselWidth / 2 + cardWidth / 2;\n\n    carousel.scrollTo({\n      left: Math.max(0, scrollPosition),\n      behavior: 'smooth',\n    });\n\n    // Highlight temporal\n    card.classList.add('pulse-highlight');\n    setTimeout(() => {\n      card.classList.remove('pulse-highlight');\n    }, 1500);\n  }\n\n  private extractPhotoGallery(car: Car): string[] {\n    const rawPhotos = car.photos ?? car.car_photos ?? [];\n    if (!Array.isArray(rawPhotos)) {\n      return [];\n    }\n    return rawPhotos\n      .map((photo) => (typeof photo === 'string' ? photo : (photo?.['url'] ?? null)))\n      .filter((url): url is string => typeof url === 'string' && url.length > 0);\n  }\n\n  private isValidSort(\n    value: string,\n  ): value is 'distance' | 'price_asc' | 'price_desc' | 'rating' | 'newest' {\n    return ['distance', 'price_asc', 'price_desc', 'rating', 'newest'].includes(value);\n  }\n\n  private trackAnalytics(event: string, payload: Record<string, unknown>): void {\n    if (!this.isBrowser) {\n      return;\n    }\n\n    window.dispatchEvent(\n      new CustomEvent(ANALYTICS_EVENT, {\n        detail: {\n          event,\n          timestamp: Date.now(),\n          source: 'cars-list-page',\n          ...payload,\n        },\n      }),\n    );\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/features/cars/my-cars/my-cars.page.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`../../../core/models` import should occur after import of `@core/services/cars/cars.service`","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":55,"fix":{"range":[300,559],"text":"import { AuthService } from '@core/services/auth/auth.service';\nimport { BookingsService } from '@core/services/bookings/bookings.service';\nimport { CarsService } from '@core/services/cars/cars.service';\nimport { Car, CarStatus } from '../../../core/models';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { CommonModule } from '@angular/common';\nimport { ChangeDetectionStrategy, Component, computed, inject, signal } from '@angular/core';\nimport { Router } from '@angular/router';\nimport { ModalController } from '@ionic/angular/standalone';\nimport { TranslateModule } from '@ngx-translate/core';\nimport { Car, CarStatus } from '../../../core/models';\nimport { AuthService } from '@core/services/auth/auth.service';\nimport { BookingsService } from '@core/services/bookings/bookings.service';\nimport { CarsService } from '@core/services/cars/cars.service';\nimport { CarCardComponent } from '../../../shared/components/car-card/car-card.component';\nimport { MpOnboardingModalComponent } from '../../../shared/components/mp-onboarding-modal/mp-onboarding-modal.component';\n\nimport { BonusProgress } from '../../../core/models/organization.model';\nimport { OrganizationService, Organization } from '../../organizations/services/organization.service';\n\n@Component({\n  standalone: true,\n  selector: 'app-my-cars-page',\n  imports: [CommonModule, CarCardComponent, TranslateModule],\n  templateUrl: './my-cars.page.html',\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class MyCarsPage {\n  private readonly carsService = inject(CarsService);\n  private readonly orgService = inject(OrganizationService);\n  private readonly bookingsService = inject(BookingsService);\n  private readonly authService = inject(AuthService);\n  private readonly modalCtrl = inject(ModalController);\n  private readonly router = inject(Router);\n\n  readonly cars = signal<Car[]>([]);\n  readonly organizations = signal<Organization[]>([]);\n  readonly bonuses = signal<BonusProgress[]>([]);\n  readonly loading = signal(false);\n\n  // Owner penalties\n  readonly ownerPenalties = signal<{\n    visibilityPenaltyUntil: string | null;\n    visibilityFactor: number;\n    cancellationCount90d: number;\n    isSuspended: boolean;\n  } | null>(null);\n\n  readonly hasPenalty = computed(() => {\n    const penalties = this.ownerPenalties();\n    return penalties && (penalties.visibilityFactor < 1 || penalties.isSuspended);\n  });\n\n  readonly penaltyMessage = computed(() => {\n    const penalties = this.ownerPenalties();\n    if (!penalties) return null;\n\n    if (penalties.isSuspended) {\n      return 'Tu cuenta está suspendida temporalmente por cancelaciones frecuentes.';\n    }\n\n    if (penalties.visibilityFactor < 1) {\n      const reduction = Math.round((1 - penalties.visibilityFactor) * 100);\n      const until = penalties.visibilityPenaltyUntil\n        ? new Date(penalties.visibilityPenaltyUntil).toLocaleDateString('es-AR')\n        : 'próximamente';\n      return `Visibilidad reducida ${reduction}% hasta ${until} por cancelaciones recientes.`;\n    }\n\n    return null;\n  });\n\n  constructor() {\n    this.loading.set(true);\n    Promise.all([\n      this.carsService.listMyCars(),\n      this.orgService.getMyOrganizations(),\n      this.bookingsService.getOwnerPenalties(),\n    ]).then(async ([cars, orgs, penalties]) => {\n      this.cars.set(cars);\n      this.organizations.set(orgs);\n      this.ownerPenalties.set(penalties);\n\n      // Fetch bonuses if org exists\n      if (orgs.length > 0) {\n        const bonuses = await this.orgService.getBonusesProgress(orgs[0].id);\n        this.bonuses.set(bonuses);\n      }\n\n      this.loading.set(false);\n    });\n  }\n\n  readonly countActive = computed(\n    () => this.cars().filter((car) => car.status === 'active').length,\n  );\n  readonly countDraft = computed(() => this.cars().filter((car) => car.status === 'draft').length);\n\n  async openPublishModal(carId?: string): Promise<void> {\n    const queryParams = carId ? { edit: carId } : {};\n    await this.router.navigate(['/cars/publish'], { queryParams });\n  }\n\n  async onEditCar(carId: string): Promise<void> {\n    await this.router.navigate(['/cars/publish'], { queryParams: { edit: carId } });\n  }\n\n  async onDeleteCar(carId: string): Promise<void> {\n    this.loading.set(true);\n    try {\n      const hasBookings = await this.carsService.hasActiveBookings(carId);\n      if (hasBookings.hasActive) {\n        return;\n      }\n\n      await this.carsService.deleteCar(carId);\n      this.cars.set(this.cars().filter((car) => car.id !== carId));\n    } catch {\n      // Handle error\n    } finally {\n      this.loading.set(false);\n    }\n  }\n\n  async onToggleAvailability(carId: string, currentStatus: string): Promise<void> {\n    this.loading.set(true);\n    try {\n      const newStatus: CarStatus = currentStatus === 'active' ? 'suspended' : 'active';\n      await this.carsService.updateCarStatus(carId, newStatus);\n      this.cars.update((cars) =>\n        cars.map((car) => (car.id === carId ? { ...car, status: newStatus } : car)),\n      );\n    } catch {\n      // Handle error\n    } finally {\n      this.loading.set(false);\n    }\n  }\n\n  async openOnboardingModal(): Promise<void> {\n    const user = await this.authService.getCurrentUser();\n    if (!user) {\n      alert('No pudimos identificar tu cuenta. Volvé a iniciar sesión e intentá nuevamente.');\n      return;\n    }\n\n    const modal = await this.modalCtrl.create({\n      component: MpOnboardingModalComponent,\n      backdropDismiss: true,\n    });\n\n    await modal.present();\n    await modal.onWillDismiss();\n\n    // Recargar lista de autos para actualizar estados\n    this.loading.set(true);\n    this.carsService.listMyCars().then((cars) => {\n      this.cars.set(cars);\n      this.loading.set(false);\n    });\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/features/cars/publish/publish-car-v2.page.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`@core/services/cars/car-owner-notifications.service` import should occur before import of `../../../shared/components/ai-photo-generator/ai-photo-generator.component`","line":21,"column":1,"nodeType":"ImportDeclaration","endLine":21,"endColumn":100,"fix":{"range":[825,1456],"text":"import { CarOwnerNotificationsService } from '@core/services/cars/car-owner-notifications.service';\nimport { AiPhotoGeneratorComponent } from '../../../shared/components/ai-photo-generator/ai-photo-generator.component';\nimport { FipeAutocompleteComponent } from '../../../shared/components/fipe-autocomplete/fipe-autocomplete.component';\nimport { HostSupportInfoPanelComponent } from '../../../shared/components/host-support-info-panel/host-support-info-panel.component';\nimport { StockPhotosSelectorComponent } from '../../../shared/components/stock-photos-selector/stock-photos-selector.component';\n\n// ✅ NEW: Extracted services\n"}},{"ruleId":"import/order","severity":1,"message":"`@core/services/verification/vehicle-documents.service` import should occur before import of `../../../shared/components/ai-photo-generator/ai-photo-generator.component`","line":22,"column":1,"nodeType":"ImportDeclaration","endLine":22,"endColumn":97,"fix":{"range":[825,1553],"text":"import { VehicleDocumentsService } from '@core/services/verification/vehicle-documents.service';\nimport { AiPhotoGeneratorComponent } from '../../../shared/components/ai-photo-generator/ai-photo-generator.component';\nimport { FipeAutocompleteComponent } from '../../../shared/components/fipe-autocomplete/fipe-autocomplete.component';\nimport { HostSupportInfoPanelComponent } from '../../../shared/components/host-support-info-panel/host-support-info-panel.component';\nimport { StockPhotosSelectorComponent } from '../../../shared/components/stock-photos-selector/stock-photos-selector.component';\n\n// ✅ NEW: Extracted services\nimport { CarOwnerNotificationsService } from '@core/services/cars/car-owner-notifications.service';\n"}}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1201,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1201,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[42831,42834],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[42831,42834],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import { LoggerService } from '@core/services/infrastructure/logger.service';\nimport { CommonModule } from '@angular/common';\nimport {\n  ChangeDetectionStrategy,\n  Component, computed, inject, OnInit, signal, DestroyRef\n} from '@angular/core';\nimport { takeUntilDestroyed } from '@angular/core/rxjs-interop';\nimport { FormGroup, ReactiveFormsModule } from '@angular/forms';\nimport { ActivatedRoute, Router } from '@angular/router';\nimport { TranslateModule } from '@ngx-translate/core';\nimport { CarsService } from '@core/services/cars/cars.service';\nimport { NotificationManagerService } from '@core/services/infrastructure/notification-manager.service';\nimport { PricingService } from '@core/services/payments/pricing.service';\nimport { SupabaseClientService } from '@core/services/infrastructure/supabase-client.service';\nimport { AiPhotoGeneratorComponent } from '../../../shared/components/ai-photo-generator/ai-photo-generator.component';\nimport { FipeAutocompleteComponent } from '../../../shared/components/fipe-autocomplete/fipe-autocomplete.component';\nimport { HostSupportInfoPanelComponent } from '../../../shared/components/host-support-info-panel/host-support-info-panel.component';\nimport { StockPhotosSelectorComponent } from '../../../shared/components/stock-photos-selector/stock-photos-selector.component';\n\n// ✅ NEW: Extracted services\nimport { CarOwnerNotificationsService } from '@core/services/cars/car-owner-notifications.service';\nimport { VehicleDocumentsService } from '@core/services/verification/vehicle-documents.service';\nimport { PublishCarFormService } from './services/publish-car-form.service';\nimport { PublishCarLocationService } from './services/publish-car-location.service';\nimport { PublishCarMpOnboardingService } from './services/publish-car-mp-onboarding.service';\nimport { PublishCarPhotoService } from './services/publish-car-photo.service';\n\n/**\n * Publish Car V2 Component (REFACTORED)\n *\n * This component orchestrates the car publishing flow by delegating\n * all business logic to specialized services.\n *\n * Responsibilities:\n * - Coordinate service interactions\n * - Handle form submission\n * - Navigate user through the flow\n * - Display UI state\n *\n * Before refactor: 1,747 lines (template + logic)\n * After refactor: ~300 lines (orchestration only)\n */\n@Component({\n  selector: 'app-publish-car-v2',\n  standalone: true,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  imports: [\n    CommonModule,\n    ReactiveFormsModule,\n    TranslateModule,\n    StockPhotosSelectorComponent,\n    AiPhotoGeneratorComponent,\n    FipeAutocompleteComponent,\n    HostSupportInfoPanelComponent,\n  ],\n  templateUrl: './publish-car-v2.page.html',\n  styleUrls: ['./publish-car-v2.page.scss'],\n  providers: [\n    PublishCarFormService,\n    PublishCarPhotoService,\n    PublishCarLocationService,\n    PublishCarMpOnboardingService,\n  ],\n})\nexport class PublishCarV2Page implements OnInit {\n  private readonly logger = inject(LoggerService);\n  // Core services\n  private readonly router = inject(Router);\n  private readonly route = inject(ActivatedRoute);\n  private readonly carsService = inject(CarsService);\n  private readonly pricingService = inject(PricingService);\n  private readonly notificationManager = inject(NotificationManagerService);\n\n  // Feature services\n  private readonly formService = inject(PublishCarFormService);\n  private readonly photoService = inject(PublishCarPhotoService);\n  private readonly locationService = inject(PublishCarLocationService);\n  private readonly mpService = inject(PublishCarMpOnboardingService);\n  private readonly documentsService = inject(VehicleDocumentsService);\n  private readonly carOwnerNotifications = inject(CarOwnerNotificationsService);\n  private readonly supabase = inject(SupabaseClientService).getClient();\n  private readonly destroyRef = inject(DestroyRef);\n\n  // Component state\n  readonly isSubmitting = signal(false);\n  readonly editMode = signal(false);\n  readonly showStockPhotosModal = signal(false);\n  readonly showAIPhotosModal = signal(false);\n  private carId: string | null = null;\n\n  // Form reference\n  publishForm!: FormGroup;\n\n  // Expose service state to template\n  readonly brands = this.formService.brands;\n  readonly models = this.formService.models;\n  readonly filteredModels = this.formService.filteredModels;\n  readonly uploadedPhotos = this.photoService.uploadedPhotos;\n  readonly isProcessingPhotos = this.photoService.isProcessingPhotos;\n  readonly isGeneratingAIPhotos = this.photoService.isGeneratingAIPhotos;\n  readonly manualCoordinates = this.locationService.manualCoordinates;\n  readonly autofilledFromLast = this.formService.autofilledFromLast;\n\n  // MP onboarding state\n  readonly mpStatus = this.mpService.mpStatus;\n  readonly mpStatusLoading = this.mpService.mpStatusLoading;\n  readonly mpStatusError = this.mpService.mpStatusError;\n  readonly mpReady = this.mpService.mpReady;\n  readonly showMpBanner = this.mpService.showMpBanner;\n\n  // Min/max year for validation\n  readonly minYear = 1980;\n  readonly maxYear = new Date().getFullYear(); // ✅ Changed: removed +1 to avoid showing future years\n\n  // ✅ Feature flag: FIPE validation is optional (false = optional, true = required)\n  readonly REQUIRE_FIPE_VALIDATION = false;\n\n  // Computed\n  readonly selectedModelInfo = computed(() => {\n    const modelId = this.publishForm?.get('model_id')?.value;\n    if (!modelId) return null;\n    return this.formService.getSelectedModelInfo(modelId);\n  });\n\n  // Expose dynamic pricing signal from service\n  readonly isDynamicPricingSignal = this.formService.isDynamicPricingSignal();\n\n  // FIPE value signals (for UI state)\n  readonly valueAutoCalculated = signal(false);\n  readonly isFetchingFIPEValue = signal(false);\n  readonly fipeError = signal<string | null>(null);\n  readonly fipeErrorCode = signal<string | null>(null); // ✅ NEW: Machine-readable error code\n  readonly fipeSuggestions = signal<string[]>([]); // ✅ NEW: Actionable suggestions\n  readonly allowManualValueEdit = signal(true);\n  readonly fipeMultiCurrencyValues = signal<Record<string, unknown> | null>(null);\n  readonly selectedFIPEBrand = signal<{ code: string; name: string } | null>(null);\n  readonly selectedFIPEModel = signal<{ code: string; name: string } | null>(null);\n  readonly suggestedPrice = signal<number | null>(null);\n  readonly selectedCategoryName = signal<string>('');\n  readonly isCalculatingSuggestedPrice = signal(false);\n  readonly pricingOverrides = signal<{ day: string; price_per_day: number }[]>([]);\n\n  // ✅ NEW: Control submit button availability - Requiere marca, modelo, año, 3 fotos y ubicación\n  // Verifica tanto valores del formulario (brand_id/model_id o brand_text_backup/model_text_backup) como signals FIPE\n  readonly canSubmit = computed(() => {\n    // Verificar valores del formulario tradicional (UUIDs)\n    const brandId = this.publishForm?.get('brand_id')?.value;\n    const modelId = this.publishForm?.get('model_id')?.value;\n\n    // Verificar valores de texto backup (para FIPE)\n    const brandTextBackup = this.publishForm?.get('brand_text_backup')?.value;\n    const modelTextBackup = this.publishForm?.get('model_text_backup')?.value;\n\n    // Verificar valores FIPE (nuevo sistema)\n    const fipeBrand = this.selectedFIPEBrand();\n    const fipeModel = this.selectedFIPEModel();\n\n    // Aceptar cualquiera de los sistemas: UUIDs, texto backup, o FIPE signals\n    const hasBrand = !!(brandId || brandTextBackup || (fipeBrand && fipeBrand.name));\n    const hasModel = !!(modelId || modelTextBackup || (fipeModel && fipeModel.name));\n\n    const year = this.publishForm?.get('year')?.value;\n    const hasPhotos = this.photoService.hasMinimumPhotos();\n    const description = this.publishForm?.get('description')?.value;\n    const availabilityStart = this.publishForm?.get('availability_start_date')?.value;\n    const availabilityEnd = this.publishForm?.get('availability_end_date')?.value;\n\n    // ✅ CRITICAL: Ubicación es obligatoria para aparecer en búsquedas\n    const hasLocation = this.hasValidLocation();\n\n    const hasDescription = !!(description && description.trim().length >= 40);\n    const hasAvailability =\n      !!availabilityStart &&\n      !!availabilityEnd &&\n      new Date(availabilityStart) <= new Date(availabilityEnd);\n\n    // Bloquear si falta alguno de los requisitos\n    return !!(\n      hasBrand &&\n      hasModel &&\n      year &&\n      hasPhotos &&\n      hasLocation &&\n      hasDescription &&\n      hasAvailability\n    );\n  });\n\n  // ✅ NEW: Draft saving capability (Minimal requirements: Brand + Model)\n  readonly canSaveDraft = computed(() => {\n    const brandId = this.publishForm?.get('brand_id')?.value;\n    const modelId = this.publishForm?.get('model_id')?.value;\n    const brandTextBackup = this.publishForm?.get('brand_text_backup')?.value;\n    const modelTextBackup = this.publishForm?.get('model_text_backup')?.value;\n    const fipeBrand = this.selectedFIPEBrand();\n    const fipeModel = this.selectedFIPEModel();\n\n    const hasBrand = !!(brandId || brandTextBackup || (fipeBrand && fipeBrand.name));\n    const hasModel = !!(modelId || modelTextBackup || (fipeModel && fipeModel.name));\n\n    return hasBrand && hasModel;\n  });\n\n  // ✅ NEW: Check if we have valid location coordinates\n  readonly hasValidLocation = computed(() => {\n    const coordinates = this.locationService.getCoordinates();\n    return !!(coordinates?.latitude && coordinates?.longitude);\n  });\n\n  // ✅ NEW: Show explicit pending requirements in UI\n  readonly missingRequirements = computed(() => {\n    const missing: string[] = [];\n\n    const brandId = this.publishForm?.get('brand_id')?.value;\n    const modelId = this.publishForm?.get('model_id')?.value;\n    const brandTextBackup = this.publishForm?.get('brand_text_backup')?.value;\n    const modelTextBackup = this.publishForm?.get('model_text_backup')?.value;\n    const fipeBrand = this.selectedFIPEBrand();\n    const fipeModel = this.selectedFIPEModel();\n    const year = this.publishForm?.get('year')?.value;\n\n    const hasBrand = !!(brandId || brandTextBackup || (fipeBrand && fipeBrand.name));\n    const hasModel = !!(modelId || modelTextBackup || (fipeModel && fipeModel.name));\n    const description = this.publishForm?.get('description')?.value;\n    const availabilityStart = this.publishForm?.get('availability_start_date')?.value;\n    const availabilityEnd = this.publishForm?.get('availability_end_date')?.value;\n\n    if (!hasBrand) missing.push('Marca');\n    if (!hasModel) missing.push('Modelo');\n    if (!year) missing.push('Año');\n    if (!this.photoService.hasMinimumPhotos()) missing.push('Mínimo 3 fotos');\n    if (!this.hasValidLocation()) missing.push('Ubicación en el mapa');\n    if (!description || description.trim().length < 40)\n      missing.push('Descripción (min. 40 caracteres)');\n    if (!availabilityStart || !availabilityEnd) {\n      missing.push('Rango de disponibilidad');\n    } else if (!this.isAvailabilityRangeValid()) {\n      missing.push('Fechas de disponibilidad válidas');\n    }\n\n    return missing;\n  });\n\n  // Submit habilitado con datos mínimos; MP recomendado pero no bloquea\n  readonly canSubmitWithPayments = computed(() => this.canSubmit());\n  readonly publishBlockerMessage = computed(() => {\n    if (this.mpStatusLoading()) return null;\n    if (!this.mpReady()) {\n      return 'Conecta Mercado Pago para cobrar (puedes publicar igual).';\n    }\n    return null;\n  });\n\n  // FIPE autocomplete signals\n  readonly fipeBrands = signal<{ code: string; name: string }[]>([]);\n  readonly fipeModels = signal<{ code: string; name: string }[]>([]);\n  readonly isLoadingFIPEBrands = signal(false);\n  readonly isLoadingFIPEModels = signal(false);\n\n  // Year options (2013-2025)\n  // ✅ Generate years dynamically from current year back 12 years\n  readonly yearOptions = Array.from({ length: 13 }, (_, i) => new Date().getFullYear() - i);\n\n  // Helper to validate disponibilidad\n  readonly isAvailabilityRangeValid = computed(() => {\n    const start = this.publishForm?.get('availability_start_date')?.value;\n    const end = this.publishForm?.get('availability_end_date')?.value;\n\n    if (!start || !end) return false;\n\n    const startDate = new Date(start);\n    const endDate = new Date(end);\n    return startDate <= endDate;\n  });\n\n  async ngOnInit(): Promise<void> {\n    // Initialize form\n    this.publishForm = this.formService.initForm();\n\n    // ✅ NEW: Listen to category_id changes to update selectedCategoryName\n    this.publishForm.get('category_id')?.valueChanges.pipe(\n      takeUntilDestroyed(this.destroyRef)\n    ).subscribe(async (categoryId) => {\n      if (categoryId) {\n        await this.updateCategoryName(categoryId);\n      } else {\n        this.selectedCategoryName.set('');\n      }\n    });\n\n    // Check if editing\n    this['carId'] = this.route.snapshot.paramMap.get('id');\n    if (this['carId']) {\n      this.editMode.set(true);\n    }\n\n    // Load brands and models\n    await this.formService.loadBrandsAndModels();\n\n    // ✅ CRITICAL: Load FIPE brands for autocomplete\n    await this.loadFIPEBrands();\n\n    // Load car data if editing\n    if (this['carId']) {\n      const loaded = await this.formService.loadCarForEditing(this['carId']);\n      if (!loaded) {\n        alert('No se pudo cargar el auto');\n        await this.router.navigate(['/cars/my-cars']);\n        return;\n      }\n      await this.photoService.loadExistingPhotos(this['carId']);\n      await this.loadPricingOverrides(this['carId']);\n    } else {\n      // Auto-fill from last car\n      await this.formService.autoFillFromLastCar();\n    }\n  }\n\n  /**\n   * ✅ NEW: Update selectedCategoryName when category_id changes\n   */\n  private async updateCategoryName(categoryId: string): Promise<void> {\n    try {\n      this.logger.debug('[PublishCarV2] updateCategoryName called with categoryId:', categoryId);\n      const categories = await this.pricingService.getVehicleCategories();\n      this.logger.debug('[PublishCarV2] Loaded categories:', categories.length);\n      const category = categories.find((c) => c['id'] === categoryId);\n      if (category) {\n        const categoryName = (category as { name_es?: string; name: string }).name_es || category.name;\n        this.logger.debug('[PublishCarV2] ✅ Category name updated:', categoryName);\n        this.selectedCategoryName.set(categoryName);\n      } else {\n        console.warn('[PublishCarV2] ⚠️ Category not found for ID:', categoryId);\n      }\n    } catch (error) {\n      console.error('[PublishCarV2] ❌ Error updating category name:', error);\n    }\n  }\n\n  private async loadPricingOverrides(carId: string): Promise<void> {\n    try {\n      const { data, error } = await this.supabase\n        .from('pricing_overrides')\n        .select('day, price_per_day')\n        .eq('car_id', carId)\n        .order('day', { ascending: true });\n      if (error) throw error;\n      this.pricingOverrides.set((data as { day: string; price_per_day: number }[]) || []);\n    } catch (err) {\n      console.warn('pricing-overrides-load', err);\n    }\n  }\n\n  /**\n   * Handle brand selection change\n   */\n  onBrandChange(): void {\n    const brandId = this.publishForm.get('brand_id')?.value;\n    this.formService.filterModelsByBrand(brandId);\n    // Reset model selection\n    this.publishForm.get('model_id')?.setValue('');\n  }\n\n  /**\n   * Handle model selection change\n   */\n  onModelChange(): void {\n    // Model info computed automatically via selectedModelInfo\n  }\n\n  /**\n   * Set pricing strategy (dynamic vs custom)\n   */\n  setPricingStrategy(mode: 'dynamic' | 'custom'): void {\n    this.formService.setPricingStrategy(mode);\n  }\n\n  /**\n   * Check if dynamic pricing is enabled (legacy method)\n   */\n  isDynamicPricing(): boolean {\n    return this.formService.isDynamicPricing();\n  }\n\n  /**\n   * Enable manual editing of value_usd field\n   */\n  enableManualValueEdit(): void {\n    this.allowManualValueEdit.set(true);\n  }\n\n  /**\n   * ✅ NEW: Load FIPE brands from API\n   */\n  async loadFIPEBrands(): Promise<void> {\n    this.isLoadingFIPEBrands.set(true);\n    try {\n      const brands = await this.pricingService.getFipeBrands();\n      this.logger.debug('[PublishCarV2] Loaded FIPE brands:', brands.length);\n\n      // Convert to FIPEAutocompleteOption format\n      const formattedBrands = brands.map((brand) => ({\n        code: brand.code,\n        name: brand.name,\n      }));\n\n      this.fipeBrands.set(formattedBrands);\n      this.logger.debug('[PublishCarV2] Formatted brands:', formattedBrands.slice(0, 5));\n    } catch (error) {\n      console.error('[PublishCarV2] Error loading FIPE brands:', error);\n      this.fipeBrands.set([]);\n    } finally {\n      this.isLoadingFIPEBrands.set(false);\n    }\n  }\n\n  /**\n   * Handle FIPE brand selection\n   */\n  async onFIPEBrandSelected(brand: { code: string; name: string } | null): Promise<void> {\n    this.logger.debug('[PublishCarV2] Brand selected:', brand);\n    this.selectedFIPEBrand.set(brand);\n    this.selectedFIPEModel.set(null);\n    this.fipeModels.set([]);\n\n    // ✅ CRITICAL: brand_id y model_id son UUIDs, NO códigos FIPE\n    // Los códigos FIPE se guardan en fipe_code y los nombres en brand_text_backup/model_text_backup\n    // Por ahora, dejamos brand_id/model_id como null y usamos los campos de texto\n    this.publishForm?.get('brand_id')?.setValue(null);\n    this.publishForm?.get('model_id')?.setValue(null);\n\n    // Guardar nombre de marca en brand_text_backup (para backward compatibility)\n    if (brand && brand.name) {\n      this.publishForm?.patchValue({\n        brand_text_backup: brand.name,\n      });\n    }\n\n    // Load models for selected brand\n    if (brand && brand.code) {\n      this.isLoadingFIPEModels.set(true);\n      try {\n        const models = await this.pricingService.getFipeModels(brand.code);\n        this.logger.debug('[PublishCarV2] Loaded models for brand:', models.length);\n\n        // Convert to FIPEAutocompleteOption format\n        const formattedModels = models.map((model) => ({\n          code: model.code,\n          name: model.name,\n        }));\n\n        this.fipeModels.set(formattedModels);\n      } catch (error) {\n        console.error('[PublishCarV2] Error loading FIPE models:', error);\n        this.fipeModels.set([]);\n      } finally {\n        this.isLoadingFIPEModels.set(false);\n      }\n    }\n  }\n\n  /**\n   * Handle FIPE model selection\n   */\n  async onFIPEModelSelected(model: { code: string; name: string } | null): Promise<void> {\n    this.logger.debug('[PublishCarV2] Model selected:', model);\n    this.selectedFIPEModel.set(model);\n\n    // ✅ CRITICAL: model_id es UUID, NO código FIPE\n    // Guardar nombre de modelo en model_text_backup (para backward compatibility)\n    this.publishForm?.get('model_id')?.setValue(null);\n\n    if (model && model.name) {\n      this.publishForm?.patchValue({\n        model_text_backup: model.name,\n      });\n    }\n\n    // Fetch vehicle value from FIPE API when we have brand, model, and year\n    await this.fetchFIPEValue();\n  }\n\n  /**\n   * Handle year change (trigger FIPE value fetch)\n   */\n  async onYearChange(): Promise<void> {\n    const year = this.publishForm?.get('year')?.value;\n    this.logger.debug('[PublishCarV2] Year changed to:', year);\n\n    // Re-fetch FIPE value if we have all required data\n    if (year && this.selectedFIPEBrand() && this.selectedFIPEModel()) {\n      await this.fetchFIPEValue();\n    }\n  }\n\n  /**\n   * ✅ NEW: Fetch FIPE value when brand, model, and year are available\n   */\n  async fetchFIPEValue(): Promise<void> {\n    const brand = this.selectedFIPEBrand();\n    const model = this.selectedFIPEModel();\n    const year = this.publishForm?.get('year')?.value;\n\n    // Need all three to fetch value\n    if (!brand || !model || !year) {\n      this.logger.debug('[PublishCarV2] Cannot fetch FIPE value - missing data:', {\n        brand: !!brand,\n        model: !!model,\n        year: !!year,\n      });\n      return;\n    }\n\n    this.logger.debug('[PublishCarV2] Fetching FIPE value for:', {\n      brand: brand.name,\n      model: model.name,\n      year,\n    });\n\n    this.isFetchingFIPEValue.set(true);\n    this.fipeError.set(null);\n    this.fipeErrorCode.set(null);\n    this.fipeSuggestions.set([]);\n\n    try {\n      const result = await this.pricingService.getFipeValueRealtime({\n        brand: brand.name,\n        model: model.name,\n        year: year,\n        country: 'AR',\n      });\n\n      this.logger.debug('[PublishCarV2] FIPE value result:', result);\n\n      if (result && result.success && result.data) {\n        // Store multi-currency values\n        this.fipeMultiCurrencyValues.set({\n          value_brl: result.data.value_brl,\n          value_usd: result.data.value_usd,\n          value_ars: result.data.value_ars,\n          fipe_code: result.data.fipe_code,\n          reference_month: result.data.reference_month,\n        });\n\n        // Ensure value_usd is a number\n        const valueUsd = Number(result.data.value_usd);\n        if (isNaN(valueUsd) || valueUsd <= 0) {\n          console.error(\n            '[PublishCarV2] Invalid value_usd from pricing API:',\n            result.data.value_usd,\n          );\n          this.fipeError.set(\n            'No se pudo calcular el valor automáticamente. Podés ingresarlo manualmente.',\n          );\n\n          // ✅ REMOVED: No longer blocking submit - FIPE is optional\n          return;\n        }\n\n        // Auto-fill the value_usd field\n        this.publishForm.get('value_usd')?.setValue(valueUsd, {\n          emitEvent: true, // ✅ FIX: Trigger valueChanges to recalculate price\n        });\n\n        // ✅ NEW: Auto-categorize vehicle based on value USD\n        this.logger.debug('[PublishCarV2] Calling autoCategorizeVehicle with:', {\n          valueUsd,\n          brand: brand.name,\n          model: model.name,\n          year,\n        });\n        await this.autoCategorizeVehicle(valueUsd, brand.name, model.name, year);\n\n        // Mark as auto-calculated\n        this.valueAutoCalculated.set(true);\n        this.allowManualValueEdit.set(false);\n        this.fipeError.set(null);\n        this.fipeErrorCode.set(null);\n        this.fipeSuggestions.set([]);\n\n        // ✅ CRITICAL: Force price calculation after setting value_usd\n        if (this.isDynamicPricing()) {\n          setTimeout(async () => {\n            await this.calculateSuggestedRate();\n          }, 100);\n        }\n      } else {\n        // ✅ NEW: Enhanced error handling with error codes and suggestions\n        const errorMsg = result?.['error'] || 'No se pudo obtener el valor del vehículo';\n        const errorCode = result?.errorCode || 'UNKNOWN';\n        const suggestions = result?.suggestions || [];\n\n        console.warn('[PublishCarV2] FIPE lookup failed:', {\n          errorMsg,\n          errorCode,\n          suggestions,\n          availableOptions: result?.availableOptions,\n        });\n\n        this.fipeError.set(errorMsg);\n        this.fipeErrorCode.set(errorCode);\n        this.fipeSuggestions.set(suggestions);\n        this.valueAutoCalculated.set(false);\n\n        // ✅ FIPE es opcional - permitir input manual\n        this.allowManualValueEdit.set(true);\n        this.logger.debug('[PublishCarV2] ⚠️ FIPE failed but manual input allowed');\n      }\n    } catch (err) {\n      console.error('[PublishCarV2] Error fetching FIPE value:', err);\n      this.isFetchingFIPEValue.set(false);\n      this.fipeError.set('Error al consultar el valor. Intentá nuevamente en unos momentos.');\n      this.fipeErrorCode.set('NETWORK_ERROR');\n      this.fipeSuggestions.set([\n        'Verifica tu conexión a internet',\n        'Reintenta en unos momentos',\n        'Si el problema persiste, contacta a soporte',\n      ]);\n\n      // ✅ FIPE es opcional - permitir input manual\n      this.valueAutoCalculated.set(false);\n      this.allowManualValueEdit.set(true);\n    } finally {\n      this.isFetchingFIPEValue.set(false);\n    }\n  }\n\n  /**\n   * ✅ NEW: Auto-categorize vehicle based on value USD or brand/model/year\n   * Uses two methods:\n   * 1. Try estimateVehicleValue() for precise category from pricing_models\n   * 2. Fallback to value-based classification if not found\n   */\n  private async autoCategorizeVehicle(\n    valueUsd: number,\n    brand: string,\n    model: string,\n    year: number,\n  ): Promise<void> {\n    this.logger.debug('[PublishCarV2] Auto-categorizing vehicle:', { valueUsd, brand, model, year });\n\n    // Validate inputs\n    if (!valueUsd || valueUsd <= 0) {\n      console.warn('[PublishCarV2] Invalid value_usd for categorization:', valueUsd);\n      return;\n    }\n\n    // Method 1: Try to get category from pricing_models (most accurate)\n    try {\n      const estimate = await this.pricingService.estimateVehicleValue({\n        brand,\n        model,\n        year,\n        country: 'AR',\n      });\n\n      if (estimate && estimate.category_id) {\n        this.logger.debug(\n          '[PublishCarV2] ✅ Category from pricing_models:',\n          estimate.category_name,\n          `(${valueUsd} USD)`,\n          'category_id:',\n          estimate.category_id,\n        );\n        const categoryControl = this.publishForm.get('category_id');\n        if (categoryControl) {\n          categoryControl.setValue(estimate.category_id, { emitEvent: true });\n          categoryControl.markAsTouched();\n          categoryControl.updateValueAndValidity();\n          this.logger.debug(\n            '[PublishCarV2] Category control updated, value:',\n            categoryControl.value,\n            'valid:',\n            categoryControl.valid,\n            'form valid:',\n            this.publishForm.valid,\n          );\n        } else {\n          console.error('[PublishCarV2] ❌ category_id control not found in form!');\n        }\n        // Update name immediately\n        this.selectedCategoryName.set(estimate.category_name || '');\n        return;\n      }\n    } catch (error) {\n      console.warn('[PublishCarV2] Could not get category from pricing_models:', error);\n    }\n\n    // Method 2: Classify by value USD (fallback)\n    // Load categories to get IDs\n    let categories;\n    try {\n      categories = await this.pricingService.getVehicleCategories();\n      if (!categories || categories.length === 0) {\n        console.warn('[PublishCarV2] No categories available for auto-classification');\n        return;\n      }\n    } catch (error) {\n      console.error('[PublishCarV2] Error loading categories:', error);\n      return;\n    }\n\n    let categoryCode: string;\n    // ✅ UPDATED: New category thresholds\n    // Economy: < $13,000\n    // Standard: $13,000 - $25,000\n    // Premium: $25,000 - $40,000\n    // Luxury: >= $40,000\n    if (valueUsd < 13000) {\n      categoryCode = 'economy';\n    } else if (valueUsd < 25000) {\n      categoryCode = 'standard';\n    } else if (valueUsd < 40000) {\n      categoryCode = 'premium';\n    } else {\n      categoryCode = 'luxury';\n    }\n\n    this.logger.debug('[PublishCarV2] Value-based classification:', { valueUsd, categoryCode });\n\n    const category = categories.find((c) => c.code === categoryCode);\n    if (category) {\n      const categoryName = (category as { name_es?: string; name: string }).name_es || category.name;\n      this.logger.debug(\n        '[PublishCarV2] ✅ Category from value USD:',\n        categoryName,\n        `(${valueUsd} USD)`,\n        'category_id:',\n        category['id'],\n      );\n      const categoryControl = this.publishForm.get('category_id');\n      if (categoryControl) {\n        categoryControl.setValue(category['id'], { emitEvent: true });\n        categoryControl.markAsTouched();\n        categoryControl.updateValueAndValidity();\n        this.logger.debug(\n          '[PublishCarV2] Category control updated, value:',\n          categoryControl.value,\n          'valid:',\n          categoryControl.valid,\n          'form valid:',\n          this.publishForm.valid,\n        );\n      } else {\n        console.error('[PublishCarV2] ❌ category_id control not found in form!');\n      }\n      // Update name immediately\n      this.selectedCategoryName.set(categoryName);\n    } else {\n      console.error(\n        '[PublishCarV2] ❌ Category not found for code:',\n        categoryCode,\n        'Available codes:',\n        categories.map((c) => c.code),\n      );\n    }\n  }\n\n  /**\n   * ✅ NEW: Calculate suggested rate based on vehicle value and category\n   * Called when: vehicle value changes, category changes, or dynamic pricing toggled on\n   */\n  private async calculateSuggestedRate(): Promise<void> {\n    const valueUsd = this.publishForm?.get('value_usd')?.value;\n    const categoryId = this.publishForm?.get('category_id')?.value;\n    const isDynamic = this.isDynamicPricing();\n\n    this.logger.debug('[PublishCarV2] calculateSuggestedRate called:', {\n      valueUsd,\n      categoryId,\n      isDynamic,\n    });\n\n    // Only calculate if dynamic pricing is enabled\n    if (!isDynamic) {\n      this.logger.debug('[PublishCarV2] Dynamic pricing not enabled, skipping calculation');\n      this.suggestedPrice.set(0);\n      return;\n    }\n\n    // Need vehicle value and category\n    if (!valueUsd) {\n      console.warn('[PublishCarV2] No value_usd, cannot calculate price');\n      this.suggestedPrice.set(0);\n      return;\n    }\n\n    if (!categoryId) {\n      console.warn(\n        '[PublishCarV2] No category_id selected. Price calculation requires a category.',\n      );\n      this.suggestedPrice.set(0);\n      return;\n    }\n\n    this.isCalculatingSuggestedPrice.set(true);\n\n    try {\n      // Call pricing service to get suggested daily rate\n      const suggestedRate = await this.pricingService.calculateSuggestedRate({\n        categoryId: categoryId,\n        estimatedValueUsd: valueUsd,\n      });\n\n      if (suggestedRate && suggestedRate > 0) {\n        // Round to nearest integer\n        const roundedPrice = Math.round(suggestedRate);\n        this.suggestedPrice.set(roundedPrice);\n\n        // ✅ CRITICAL: Also update the form field directly to ensure it's set\n        if (this.publishForm && this.isDynamicPricing()) {\n          const currentPrice = this.publishForm.get('price_per_day')?.value;\n          this.logger.debug('[PublishCarV2] Updating price_per_day:', {\n            currentPrice,\n            suggestedPrice: roundedPrice,\n            willUpdate: !currentPrice || currentPrice !== roundedPrice,\n          });\n\n          // Always update when in dynamic mode\n          this.publishForm.get('price_per_day')?.setValue(roundedPrice, { emitEvent: false });\n        }\n      }\n    } catch (error) {\n      console.error('[PublishCarV2] Error calculating suggested rate:', error);\n      this.suggestedPrice.set(0);\n    } finally {\n      this.isCalculatingSuggestedPrice.set(false);\n    }\n  }\n\n  /**\n   * Get placeholder text for model selection\n   */\n  getModelPlaceholder(): string {\n    const selectedBrand = this.selectedFIPEBrand();\n    if (!selectedBrand) {\n      return 'Primero selecciona una marca';\n    }\n    return `Buscar modelo de ${selectedBrand.name}...`;\n  }\n\n  /**\n   * Get helper text for model selection\n   */\n  getModelHelperText(): string {\n    const selectedBrand = this.selectedFIPEBrand();\n    if (!selectedBrand) {\n      return 'Primero selecciona una marca';\n    }\n    return `Selecciona el modelo de ${selectedBrand.name}`;\n  }\n\n  /**\n   * Handle photo selection\n   */\n  async onPhotoSelected(event: Event): Promise<void> {\n    await this.photoService.selectPhotos(event);\n  }\n\n  /**\n   * Handle stock photos selection\n   */\n  async onStockPhotosSelected(photos: File[]): Promise<void> {\n    await this.photoService.addStockPhotosFiles(photos);\n    this.showStockPhotosModal.set(false);\n  }\n\n  /**\n   * Handle AI photos generation\n   */\n  async onAIPhotosGenerated(photos: File[]): Promise<void> {\n    await this.photoService.addAIPhotosFiles(photos);\n    this.showAIPhotosModal.set(false);\n  }\n\n  /**\n   * Get current brand name\n   * ✅ Updated to support FIPE autocomplete\n   */\n  getCurrentBrand(): string {\n    // Try FIPE signal first\n    const fipeBrand = this.selectedFIPEBrand();\n    if (fipeBrand && fipeBrand.code) {\n      return fipeBrand.name;\n    }\n\n    // Try text backup (for FIPE)\n    const brandTextBackup = this.publishForm?.get('brand_text_backup')?.value;\n    if (brandTextBackup) {\n      return brandTextBackup;\n    }\n\n    // Fallback to traditional brand_id (UUID)\n    const brandId = this.publishForm?.get('brand_id')?.value;\n    if (!brandId) return '';\n    const brand = this.brands().find((b) => b['id'] === brandId);\n    return brand?.name || '';\n  }\n\n  /**\n   * Get current model name\n   * ✅ Updated to support FIPE autocomplete\n   */\n  getCurrentModel(): string {\n    // Try FIPE signal first\n    const fipeModel = this.selectedFIPEModel();\n    if (fipeModel && fipeModel.name) {\n      return fipeModel.name;\n    }\n\n    // Try text backup (for FIPE)\n    const modelTextBackup = this.publishForm?.get('model_text_backup')?.value;\n    if (modelTextBackup) {\n      return modelTextBackup;\n    }\n\n    // Fallback to traditional model_id (UUID)\n    const modelId = this.publishForm?.get('model_id')?.value;\n    if (!modelId) return '';\n    const model = this.models().find((m) => m['id'] === modelId);\n    return model?.name || '';\n  }\n\n  /**\n   * Get current year\n   */\n  getCurrentYear(): number {\n    return this.publishForm?.get('year')?.value || new Date().getFullYear();\n  }\n\n  /**\n   * Generate AI photos\n   */\n  async generateAIPhotos(): Promise<void> {\n    const brandId = this.publishForm.get('brand_id')?.value;\n    const modelId = this.publishForm.get('model_id')?.value;\n    const year = this.publishForm.get('year')?.value;\n    const color = this.publishForm.get('color')?.value;\n\n    if (!brandId || !modelId || !year) {\n      alert('Debes seleccionar marca, modelo y año primero');\n      return;\n    }\n\n    const brand = this.brands().find((b) => b['id'] === brandId);\n    const model = this.models().find((m) => m['id'] === modelId);\n\n    if (!brand || !model) {\n      alert('No se pudo obtener información del vehículo');\n      return;\n    }\n\n    await this.photoService.generateAIPhotos(brand.name, model.name, year, { color: color || undefined });\n  }\n\n  /**\n   * Remove photo at index\n   */\n  removePhoto(index: number): void {\n    this.photoService.removePhoto(index);\n  }\n\n  /**\n   * Use current GPS location\n   */\n  async useCurrentLocation(): Promise<void> {\n    const location = await this.locationService.useCurrentLocation();\n\n    if (location) {\n      // Reverse geocode to get address\n      const address = await this.locationService.reverseGeocode(\n        location.latitude,\n        location.longitude,\n      );\n\n      if (address) {\n        // Fill address fields - combine street + number for display\n        const streetWithNumber = address.streetNumber\n          ? `${address.street} ${address.streetNumber}`\n          : address.street;\n\n        this.publishForm.patchValue({\n          location_street: streetWithNumber,\n          location_street_number: address.streetNumber,\n          location_city: address['city'],\n          location_state: address.state,\n          location_country: address['country'],\n        });\n        this.notificationManager.success(\n          'Ubicación actualizada',\n          'Se completó la dirección automáticamente.',\n        );\n      } else {\n        this.notificationManager.warning(\n          'Ubicación detectada',\n          'Tenemos tus coordenadas, pero no pudimos encontrar la dirección exacta. Por favor completa los campos manualmente.',\n        );\n      }\n    }\n  }\n\n  /**\n   * Open MercadoPago onboarding modal\n   */\n  async openOnboardingModal(): Promise<void> {\n    await this.mpService.openOnboardingModal();\n  }\n\n  /**\n   * Dismiss onboarding reminder\n   */\n  dismissOnboardingReminder(): void {\n    this.mpService.dismissOnboardingReminder();\n  }\n\n  /**\n   * Submit form\n   */\n  async onSubmit(): Promise<void> {\n    // ✅ NUEVO: Solo validar campos mínimos (marca, modelo, año, fotos)\n    // Verificar tanto valores del formulario como signals FIPE\n    const brandId = this.publishForm.get('brand_id')?.value;\n    const modelId = this.publishForm.get('model_id')?.value;\n    const brandTextBackup = this.publishForm.get('brand_text_backup')?.value;\n    const modelTextBackup = this.publishForm.get('model_text_backup')?.value;\n    const fipeBrand = this.selectedFIPEBrand();\n    const fipeModel = this.selectedFIPEModel();\n\n    const hasBrand = !!(brandId || brandTextBackup || (fipeBrand && fipeBrand.name));\n    const hasModel = !!(modelId || modelTextBackup || (fipeModel && fipeModel.name));\n    const year = this.publishForm.get('year')?.value;\n\n    if (!hasBrand || !hasModel || !year) {\n      alert('Por favor completa: Marca, Modelo y Año');\n      return;\n    }\n\n    if (!this.photoService.hasMinimumPhotos()) {\n      this.notificationManager['error'](\n        'Fotos requeridas',\n        'Debes subir al menos 3 fotos para publicar tu auto.',\n      );\n      return;\n    }\n\n    const description = this.publishForm.get('description')?.value as string | undefined;\n    if (!description || description.trim().length < 40) {\n      this.notificationManager['error'](\n        'Descripción incompleta',\n        'Agrega una descripción clara (mínimo 40 caracteres) para que los viajeros conozcan tu auto.',\n      );\n      return;\n    }\n\n    if (\n      !this.publishForm.get('availability_start_date')?.value ||\n      !this.publishForm.get('availability_end_date')?.value\n    ) {\n      this.notificationManager['error'](\n        'Disponibilidad faltante',\n        'Indicá desde cuándo y hasta cuándo está disponible el auto.',\n      );\n      return;\n    }\n\n    if (!this.isAvailabilityRangeValid()) {\n      this.notificationManager['error'](\n        'Fechas inválidas',\n        'La fecha de fin debe ser posterior o igual a la fecha de inicio.',\n      );\n      return;\n    }\n\n    // ✅ CRITICAL: Validar ubicación antes de publicar\n    if (!this.hasValidLocation()) {\n      this.notificationManager['error'](\n        'Ubicación requerida',\n        'Debes seleccionar una ubicación en el mapa o usar tu ubicación actual para que tu auto aparezca en las búsquedas.',\n      );\n      return;\n    }\n\n    const mpReady = this.mpReady();\n\n    if (!mpReady) {\n      this.notificationManager.warning(\n        'Conectá Mercado Pago',\n        'Vinculá tu cuenta para recibir pagos. Podés seguir y publicaremos el auto igual.',\n      );\n\n      // No bloqueamos la publicación: abrimos el flujo de onboarding en background\n      void this.openOnboardingModal();\n    }\n\n    // ✅ IMPORTANTE: NO bloqueamos la publicación por documentos faltantes\n    // El usuario puede publicar su auto sin documentos, pero le notificaremos\n    // después de la publicación que faltan documentos (DNI, Cédula, Seguro, etc.)\n\n    this.isSubmitting.set(true);\n\n    try {\n      // Get form data\n      const formData = this.formService.getFormData();\n\n      this.logger.debug('📝 Form data before processing:', {\n        brand_id: formData['brand_id'],\n        model_id: formData['model_id'],\n        year: formData['year'],\n        price_per_day: formData['price_per_day'],\n        pricing_strategy: formData['pricing_strategy'],\n      });\n\n      // ✅ NUEVO: Establecer valores por defecto para campos opcionales\n      // ✅ CRITICAL: price_per_day siempre debe ser > 0 para pasar validación\n      const pricePerDay = formData['price_per_day']\n        ? Number(formData['price_per_day'])\n        : formData['pricing_strategy'] === 'dynamic'\n          ? 50\n          : 100; // Default: 50 si dinámico, 100 si custom\n\n      this.logger.debug('💰 Calculated price_per_day:', pricePerDay);\n\n      const carData: Record<string, unknown> = {\n        ...formData,\n        // Campos opcionales con valores por defecto\n        color: formData['color'] || 'No especificado',\n        mileage: formData['mileage'] || 0,\n        transmission: (formData['transmission'] || 'manual') as string,\n        fuel: (formData['fuel'] || 'nafta') as string,\n        price_per_day: pricePerDay, // ✅ Siempre un número válido > 0\n        value_usd: formData['value_usd'] || 10000, // Valor por defecto si no se especifica\n        category_id: formData['category_id'] || null, // Se puede auto-categorizar después\n        min_rental_days: formData['min_rental_days'] || 1,\n        max_rental_days: formData['max_rental_days'] || null,\n        deposit_required: formData['deposit_required'] ?? true,\n        deposit_amount: formData['deposit_amount'] || 200,\n        insurance_included: formData['insurance_included'] ?? false,\n        auto_approval: formData['auto_approval'] ?? true,\n        // Location opcional\n        location_street: formData['location_street'] || '',\n        location_street_number: formData['location_street_number'] || '',\n        location_city: formData['location_city'] || '',\n        location_state: formData['location_state'] || '',\n        location_country: formData['location_country'] || '', // ✅ CHANGED: Removed hardcoded 'AR' default\n      };\n\n      // Get coordinates (manual or from address)\n      let coordinates = this.locationService.getCoordinates();\n      if (!coordinates && carData['location_street'] && carData['location_city']) {\n        // Geocode address si está disponible\n        const address = {\n          street: carData['location_street'] as string,\n          streetNumber: carData['location_street_number'] as string,\n          city: carData['location_city'] as string,\n          state: carData['location_state'] as string,\n          country: carData['location_country'] as string,\n        };\n        coordinates = await this.locationService.geocodeAddress(address);\n      }\n\n      // Agregar coordenadas (solo si existen)\n      // ✅ CRITICAL: Solo incluir location_lat/location_lng si tienen valores válidos\n      // Esto evita errores de schema cache si las columnas no están disponibles\n      if (coordinates?.latitude && coordinates?.longitude) {\n        carData['location_lat'] = coordinates.latitude;\n        carData['location_lng'] = coordinates.longitude;\n      } else {\n        // No incluir las propiedades si no hay coordenadas\n        // El backend puede manejar autos sin coordenadas\n        delete carData['location_lat'];\n        delete carData['location_lng'];\n      }\n\n      carData['status'] = 'active' as const; // Car is active inmediatamente y aparecerá en el mapa\n\n      this.logger.debug('🚗 Final car data to submit:', {\n        ...carData,\n        // Redact sensitive data\n        owner_id: carData['owner_id'] ? '***' : undefined,\n      });\n\n      await this.performSubmission(carData);\n    } catch (error) {\n      this.handleSubmissionError(error);\n    } finally {\n      this.isSubmitting.set(false);\n    }\n  }\n\n  /**\n   * Save car as draft (Minimal validation)\n   */\n  async saveDraft(): Promise<void> {\n    if (!this.canSaveDraft()) return;\n\n    this.isSubmitting.set(true);\n    try {\n      const formData = this.formService.getFormData();\n\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const carData: any = {\n        ...formData,\n        status: 'draft', // ✅ Explicitly set as draft\n        // Defaults for draft to avoid DB constraints if any\n        price_per_day: formData['price_per_day'] || 0,\n        year: formData['year'] || new Date().getFullYear(),\n        mileage: formData['mileage'] || 0,\n        transmission: formData['transmission'] || 'manual',\n        fuel: formData['fuel'] || 'nafta',\n      };\n\n      await this.performSubmission(carData);\n\n      this.notificationManager.success(\n        'Borrador guardado',\n        'Tu progreso ha sido guardado. Puedes continuar editando más tarde.'\n      );\n    } catch (error) {\n      this.handleSubmissionError(error);\n    } finally {\n      this.isSubmitting.set(false);\n    }\n  }\n\n  private async performSubmission(carData: Record<string, unknown>): Promise<void> {\n    let carId: string;\n\n    if (this.editMode() && this['carId']) {\n      // Update existing car\n      await this.carsService.updateCar(this['carId'], carData);\n      carId = this['carId'];\n\n      if (carData['status'] === 'active') {\n        this.notificationManager.success(\n          '✅ Auto actualizado exitosamente',\n          'Los cambios se han guardado correctamente.',\n          6000,\n        );\n      }\n    } else {\n      // Create new car\n      const newCar = await this.carsService.createCar(carData);\n      carId = newCar['id'];\n\n      if (carData['status'] === 'active') {\n        this.notificationManager.success(\n          '🎉 ¡Auto publicado exitosamente!',\n          'Tu auto ya está visible en el marketplace.',\n          8000,\n        );\n      }\n    }\n\n    // Upload photos (if new or changed)\n    if (this.photoService.getPhotoCount() > 0) {\n      await this.photoService.uploadPhotos(carId);\n    }\n\n    // Check docs only if active\n    if (carData['status'] === 'active' && !this.editMode()) {\n      setTimeout(() => {\n        this.checkMissingDocuments(carId).catch(() => { });\n      }, 2000);\n    }\n\n    await this.router.navigate(['/cars/my-cars']);\n  }\n\n  private handleSubmissionError(error: unknown): void {\n    console.error('❌ Failed to publish car:', error);\n\n    // Log detailed error information\n    if (error instanceof Error) {\n      console.error('Error message:', error['message']);\n    }\n\n    // Show user-friendly error message\n    let errorTitle = 'Error al guardar';\n    let errorMessage = 'Por favor intenta nuevamente.';\n\n    if (error instanceof Error) {\n      if (error['message'].includes('Marca y modelo son requeridos')) {\n        errorTitle = 'Información incompleta';\n        errorMessage = 'Por favor completa la marca y el modelo del vehículo.';\n      } else if (error['message']) {\n        errorMessage = error['message'];\n      }\n    }\n\n    this.notificationManager['error'](errorTitle, errorMessage);\n  }\n\n  /**\n   * Go back to previous page\n   */\n  async goBack(): Promise<void> {\n    await this.router.navigate(['/cars/my-cars']);\n  }\n\n  /**\n   * Verifica documentos faltantes y notifica al usuario\n   */\n  private async checkMissingDocuments(carId: string): Promise<void> {\n    try {\n      const missingDocs = await this.documentsService.getMissingDocuments(carId);\n\n      if (missingDocs.length > 0) {\n        const car = await this.carsService.getCarById(carId);\n        if (!car) return;\n\n        const carName = car['title'] || `${car['brand'] || ''} ${car['model'] || ''}`.trim() || 'tu auto';\n        const documentsUrl = `/cars/${carId}/documents`;\n\n        // Notificar sobre cada documento faltante\n        for (const docKind of missingDocs) {\n          const documentType = this.documentsService.getDocumentKindLabel(docKind);\n          this.carOwnerNotifications.notifyMissingDocument(documentType, carName, documentsUrl);\n          // Pequeña pausa entre notificaciones\n          await new Promise((resolve) => setTimeout(resolve, 1000));\n        }\n      }\n    } catch {\n      // Silently fail\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/features/cars/publish/services/publish-car-form.service.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`@core/services/infrastructure/supabase-client.service` import should occur before import of `../../../../core/models`","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":88,"fix":{"range":[216,383],"text":"import { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\nimport { CarBrand, CarModel, VehicleCategory } from '../../../../core/models';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { Injectable, inject, signal, computed, type Signal } from '@angular/core';\nimport { FormBuilder, FormGroup, Validators } from '@angular/forms';\nimport { CarsService } from '@core/services/cars/cars.service';\nimport { CarBrand, CarModel, VehicleCategory } from '../../../../core/models';\nimport { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\n\n/**\n * Service for managing the publish car form\n *\n * Responsibilities:\n * - Form initialization and validation\n * - Brand and model filtering\n * - Auto-fill from last car\n * - Dynamic vs custom pricing logic\n */\n@Injectable()\nexport class PublishCarFormService {\n  private readonly fb = inject(FormBuilder);\n  private readonly carsService = inject(CarsService);\n  private readonly supabase = injectSupabase();\n\n  private readonly minYear = 1980;\n  private readonly maxYear = new Date().getFullYear(); // ✅ Changed: removed +1 to avoid future years\n\n  // State\n  readonly brands = signal<CarBrand[]>([]);\n  readonly models = signal<CarModel[]>([]);\n  readonly filteredModels = signal<CarModel[]>([]);\n  readonly autofilledFromLast = signal(false);\n  private readonly pricingStrategySignal = signal<'dynamic' | 'custom'>('dynamic');\n  readonly categories = signal<VehicleCategory[]>([]);\n\n  // Form instance\n  private formInstance: FormGroup | null = null;\n\n  /**\n   * Initialize form with default values and validators\n   */\n  initForm(): FormGroup {\n    this.formInstance = this.fb.group({\n      // Vehicle - SOLO ESTOS SON REQUERIDOS\n      brand_id: [null], // UUID - puede ser null si usamos FIPE\n      model_id: [null], // UUID - puede ser null si usamos FIPE\n      brand_text_backup: ['', Validators.required], // Texto backup para FIPE\n      model_text_backup: ['', Validators.required], // Texto backup para FIPE\n      year: [\n        new Date().getFullYear(),\n        [Validators.required, Validators.min(this.minYear), Validators.max(this.maxYear)],\n      ],\n      // Campos opcionales\n      color: ['', Validators.required],\n      mileage: [null, [Validators.required, Validators.min(0)]],\n      transmission: ['', Validators.required],\n      fuel: ['', Validators.required],\n\n      // Descripción y disponibilidad\n      description: ['', [Validators.required, Validators.minLength(40), Validators.maxLength(800)]],\n      availability_start_date: [this.todayISO(), [Validators.required]],\n      availability_end_date: [this.nextMonthISO(), [Validators.required]],\n      \n      // Reglas de Alquiler (Owner Preferences)\n      mileage_limit: [200, [Validators.min(0)]], // 0 = Ilimitado\n      extra_km_price: [5, [Validators.min(0)]],\n      fuel_policy: ['full_to_full', Validators.required],\n      allow_second_driver: [true],\n      second_driver_cost: [10, [Validators.min(0)]],\n      max_anticipation_days: [90, [Validators.min(1), Validators.max(365)]],\n\n      // Pricing - Opcional (se calcula automáticamente si es dinámico)\n      pricing_strategy: ['dynamic'],\n      price_per_day: [null, [Validators.required, Validators.min(1)]], // Opcional si es dinámico\n      currency: ['USD', Validators.required],\n      value_usd: [null, [Validators.required, Validators.min(5000), Validators.max(500000)]], // Opcional\n      category_id: [null], // Opcional (se auto-categoriza)\n      min_rental_days: [1, [Validators.required, Validators.min(1)]],\n      max_rental_days: [30], // Opcional\n      deposit_required: [true],\n      deposit_amount: [200, [Validators.min(0)]], // Requerido condicionalmente, se maneja en el componente\n      insurance_included: [false],\n      auto_approval: [true],\n\n      // Location - Opcional\n      location_street: ['', Validators.required],\n      location_street_number: ['', Validators.required],\n      location_city: ['', Validators.required],\n      location_state: ['', Validators.required],\n      location_country: ['AR', Validators.required],\n    });\n\n    return this.formInstance;\n  }\n\n  /**\n   * Get form instance\n   */\n  getForm(): FormGroup {\n    if (!this.formInstance) {\n      throw new Error('Form not initialized. Call initForm() first.');\n    }\n    return this.formInstance;\n  }\n\n  /**\n   * Load brands and models from API\n   */\n  async loadBrandsAndModels(): Promise<void> {\n    const [brandsData, modelsData] = await Promise.all([\n      this.carsService.getCarBrands(),\n      this.carsService.getAllCarModels(),\n    ]);\n\n    this.brands.set(brandsData as CarBrand[]);\n    this.models.set(modelsData as CarModel[]);\n  }\n\n  /**\n   * Filter models by selected brand\n   */\n  filterModelsByBrand(brandId: string): CarModel[] {\n    if (!brandId) {\n      this.filteredModels.set([]);\n      return [];\n    }\n\n    const filtered = this.models().filter((m) => m.brand_id === brandId);\n    this.filteredModels.set(filtered);\n    return filtered;\n  }\n\n  /**\n   * Get selected model info\n   */\n  getSelectedModelInfo(modelId: string): CarModel | null {\n    if (!modelId) return null;\n    return this.filteredModels().find((m) => m.id === modelId) || null;\n  }\n\n  /**\n   * Auto-fill form from last published car\n   */\n  async autoFillFromLastCar(): Promise<void> {\n    if (!this.formInstance) {\n      throw new Error('Form not initialized');\n    }\n\n    try {\n      const lastCar = await this.carsService.getUserLastCar();\n\n      if (lastCar) {\n        // Convert uses_dynamic_pricing (DB field) to pricing_strategy (UI field)\n        const pricing_strategy = lastCar.uses_dynamic_pricing ? 'dynamic' : 'custom';\n\n        this.formInstance.patchValue({\n          transmission: lastCar.transmission,\n          fuel: lastCar.fuel,\n          color: lastCar.color,\n          currency: lastCar.currency,\n          pricing_strategy,\n          min_rental_days: lastCar.min_rental_days,\n          max_rental_days: lastCar.max_rental_days,\n          deposit_required: lastCar.deposit_required,\n          deposit_amount: lastCar.deposit_amount,\n          insurance_included: lastCar.insurance_included,\n          auto_approval: lastCar.auto_approval ?? true,\n          location_street: lastCar.location_street,\n          location_street_number: lastCar.location_street_number,\n          location_city: lastCar.location_city,\n          location_state: lastCar.location_state,\n          location_country: lastCar.location_country,\n          \n          // Reglas\n          mileage_limit: lastCar.mileage_limit ?? 200,\n          extra_km_price: lastCar.extra_km_price ?? 5,\n          fuel_policy: lastCar.fuel_policy ?? 'full_to_full',\n          allow_second_driver: lastCar.allow_second_driver ?? true,\n          second_driver_cost: lastCar.second_driver_cost ?? 10,\n          max_anticipation_days: lastCar.max_anticipation_days ?? 90,\n        });\n\n        // Update signal for reactive UI\n        this.pricingStrategySignal.set(pricing_strategy);\n\n        this.autofilledFromLast.set(true);\n      }\n    } catch {\n      // Silently fail - not critical\n    }\n  }\n\n  /**\n   * Load car data for editing\n   */\n  async loadCarForEditing(carId: string): Promise<boolean> {\n    if (!this.formInstance) {\n      throw new Error('Form not initialized');\n    }\n\n    try {\n      const car = await this.carsService.getCarById(carId);\n      if (!car) {\n        return false;\n      }\n\n      // Convert uses_dynamic_pricing (DB field) to pricing_strategy (UI field)\n      const pricing_strategy = car.uses_dynamic_pricing ? 'dynamic' : 'custom';\n\n      this.formInstance.patchValue({\n        brand_id: car.brand_id,\n        model_id: car.model_id,\n        pricing_strategy,\n        year: car.year,\n        color: car.color,\n        mileage: car.mileage,\n        transmission: car.transmission,\n        fuel: car.fuel,\n        price_per_day: car.price_per_day,\n        currency: car.currency,\n        value_usd: car.value_usd || null,\n        min_rental_days: car.min_rental_days,\n        max_rental_days: car.max_rental_days,\n        deposit_required: car.deposit_required,\n        deposit_amount: car.deposit_amount,\n        insurance_included: car.insurance_included,\n        auto_approval: car.auto_approval ?? true,\n        location_street: car.location_street,\n        location_street_number: car.location_street_number,\n        location_city: car.location_city,\n        location_state: car.location_state,\n        location_country: car.location_country,\n\n        // Reglas\n        mileage_limit: car.mileage_limit ?? 200,\n        extra_km_price: car.extra_km_price ?? 5,\n        fuel_policy: car.fuel_policy ?? 'full_to_full',\n        allow_second_driver: car.allow_second_driver ?? true,\n        second_driver_cost: car.second_driver_cost ?? 10,\n        max_anticipation_days: car.max_anticipation_days ?? 90,\n      });\n\n      // Update signal for reactive UI\n      this.pricingStrategySignal.set(pricing_strategy);\n\n      // Trigger brand change to load models\n      if (car.brand_id) {\n        this.filterModelsByBrand(car.brand_id);\n      }\n\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Check if dynamic pricing is enabled (legacy method for compatibility)\n   */\n  isDynamicPricing(): boolean {\n    if (!this.formInstance) return false;\n    const value = this.formInstance.get('pricing_strategy')?.value;\n    return value === 'dynamic';\n  }\n\n  /**\n   * Get dynamic pricing state as signal (reactive)\n   */\n  isDynamicPricingSignal(): Signal<boolean> {\n    return computed(() => this.pricingStrategySignal() === 'dynamic');\n  }\n\n  /**\n   * Set pricing strategy\n   */\n  setPricingStrategy(mode: 'dynamic' | 'custom'): void {\n    if (!this.formInstance) return;\n    this.formInstance.get('pricing_strategy')?.setValue(mode);\n    this.pricingStrategySignal.set(mode); // Update signal for reactive UI\n  }\n\n  /**\n   * Generate car title from form data\n   */\n  generateTitle(): string {\n    if (!this.formInstance) return '';\n\n    const brandId = this.formInstance.get('brand_id')?.value;\n    const modelId = this.formInstance.get('model_id')?.value;\n    const year = this.formInstance.get('year')?.value;\n\n    if (!brandId || !modelId || !year) return '';\n\n    const brand = this.brands().find((b) => b.id === brandId);\n    const model = this.models().find((m) => m.id === modelId);\n\n    if (!brand || !model) return '';\n\n    return `${brand.name} ${model.name} ${year}`;\n  }\n\n  /**\n   * Get form data ready for submission\n   */\n  getFormData(): Record<string, unknown> {\n    if (!this.formInstance) {\n      throw new Error('Form not initialized');\n    }\n\n    const rawValue = this.formInstance.getRawValue();\n\n    // Extract fields from form (pricing_strategy is UI-only, converted to uses_dynamic_pricing)\n    const {\n      brand_id,\n      model_id,\n      brand_text_backup,\n      model_text_backup,\n      year,\n      color,\n      mileage,\n      transmission,\n      fuel,\n      pricing_strategy,\n      price_per_day,\n      currency,\n      value_usd,\n      min_rental_days,\n      max_rental_days,\n      deposit_required,\n      deposit_amount,\n      insurance_included,\n      auto_approval,\n\n      // Descripción y disponibilidad\n      description,\n      availability_start_date,\n      availability_end_date,\n      location_street,\n      location_street_number,\n      location_city,\n      location_state,\n      location_country,\n      \n      // Reglas de Alquiler\n      mileage_limit,\n      extra_km_price,\n      fuel_policy,\n      allow_second_driver,\n      second_driver_cost,\n      max_anticipation_days,\n    } = rawValue;\n\n    // Get brand and model info (solo si tenemos UUIDs)\n    const brand = brand_id ? this.brands().find((b) => b.id === brand_id) : null;\n    const model = model_id ? this.models().find((m) => m.id === model_id) : null;\n\n    // Convert pricing_strategy (UI field) to uses_dynamic_pricing (DB field)\n    const uses_dynamic_pricing = pricing_strategy === 'dynamic';\n\n    // Return clean data for database\n    return {\n      // Vehicle fields\n      // ✅ CRITICAL: brand_id y model_id son UUIDs, pueden ser null si usamos FIPE\n      brand_id: brand_id || null,\n      model_id: model_id || null,\n      // ✅ CRITICAL: brand_text_backup y model_text_backup para FIPE\n      brand_text_backup: brand_text_backup || brand?.name || '',\n      model_text_backup: model_text_backup || model?.name || '',\n      year,\n      color,\n      mileage,\n      transmission,\n      fuel,\n\n      // Reglas de Alquiler\n      mileage_limit: mileage_limit ?? 200,\n      extra_km_price: extra_km_price ?? 5,\n      fuel_policy: fuel_policy || 'full_to_full',\n      allow_second_driver: allow_second_driver ?? true,\n      second_driver_cost: second_driver_cost ?? 10,\n      max_anticipation_days: max_anticipation_days ?? 90,\n\n      // Pricing fields\n      price_per_day,\n      currency,\n      value_usd,\n      uses_dynamic_pricing, // ✅ NEW: Dynamic pricing opt-in\n      min_rental_days,\n      max_rental_days,\n      deposit_required,\n      deposit_amount,\n      insurance_included,\n      auto_approval,\n\n      // Location fields\n      location_street,\n      location_street_number,\n      location_city,\n      location_state,\n      location_country,\n\n      // Generated/computed fields\n      title: this.generateTitle() || 'Auto sin título',\n      description,\n      seats: model?.seats || 5,\n      doors: model?.doors || 4,\n      features: {},\n      fuel_type: fuel,\n      location_province: location_state,\n      rating_avg: 0,\n      rating_count: 0,\n      availability_start_date: availability_start_date || this.todayISO(),\n      availability_end_date: availability_end_date || null,\n    };\n  }\n\n  /**\n   * Validate form\n   */\n  isValid(): boolean {\n    return this.formInstance?.valid ?? false;\n  }\n\n  /**\n   * Get form errors\n   */\n  getErrors(): Record<string, unknown> | null {\n    return this.formInstance?.errors ?? null;\n  }\n\n  /**\n   * Obtener fecha de hoy en formato ISO (yyyy-MM-dd)\n   */\n  private todayISO(): string {\n    return new Date().toISOString().slice(0, 10);\n  }\n\n  /**\n   * Obtener fecha dentro de un mes para prellenar disponibilidad\n   */\n  private nextMonthISO(): string {\n    const date = new Date();\n    date.setMonth(date.getMonth() + 1);\n    return date.toISOString().slice(0, 10);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/features/cars/publish/services/publish-car-photo.service.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`../../../../../environments/environment` import should occur after import of `@core/services/infrastructure/notification-manager.service`","line":2,"column":1,"nodeType":"ImportDeclaration","endLine":2,"endColumn":71,"fix":{"range":[60,300],"text":"import { CarsService } from '@core/services/cars/cars.service';\nimport { NotificationManagerService } from '@core/services/infrastructure/notification-manager.service';\nimport { environment } from '../../../../../environments/environment';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { Injectable, inject, signal } from '@angular/core';\nimport { environment } from '../../../../../environments/environment';\nimport { CarsService } from '@core/services/cars/cars.service';\nimport { NotificationManagerService } from '@core/services/infrastructure/notification-manager.service';\n\nexport interface PhotoPreview {\n  file: File;\n  preview: string;\n}\n\nexport interface GenerateAIPhotosOptions {\n  color?: string;\n  body_type?:\n  | 'sedan'\n  | 'hatchback'\n  | 'suv'\n  | 'crossover'\n  | 'pickup'\n  | 'coupe'\n  | 'wagon'\n  | 'minivan';\n  trim_level?: 'base' | 'lx' | 'ex' | 'sport' | 'touring' | 'limited' | 'type-r';\n  /** Same set id for the 3 photos so context/color stays consistent. */\n  setId?: string;\n}\n\n/**\n * Service for managing car photos\n *\n * Responsibilities:\n * - Photo selection and validation\n * - AI photo generation\n * - Photo upload to storage\n * - Photo removal\n */\n@Injectable()\nexport class PublishCarPhotoService {\n  private readonly carsService = inject(CarsService);\n  private readonly notifications = inject(NotificationManagerService);\n\n  // State\n  readonly uploadedPhotos = signal<PhotoPreview[]>([]);\n  readonly isProcessingPhotos = signal(false);\n  readonly isGeneratingAIPhotos = signal(false);\n\n  private readonly MAX_PHOTOS = 10;\n  private readonly MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB\n  private readonly ALLOWED_TYPES = ['image/jpeg', 'image/jpg', 'image/png', 'image/webp'];\n\n  /**\n   * Handle photo selection from file input\n   */\n  async selectPhotos(event: Event): Promise<void> {\n    const input = event.target as HTMLInputElement;\n    if (!input.files || input.files.length === 0) return;\n\n    this.isProcessingPhotos.set(true);\n\n    try {\n      const files = Array.from(input.files);\n      const currentPhotos = this.uploadedPhotos();\n\n      // Check max limit\n      if (currentPhotos.length + files.length > this.MAX_PHOTOS) {\n        throw new Error(`Máximo ${this.MAX_PHOTOS} fotos permitidas`);\n      }\n\n      // Validate and create previews\n      const newPhotos: PhotoPreview[] = [];\n\n      for (const file of files) {\n        this.validatePhoto(file);\n        const preview = await this.createPreview(file);\n        newPhotos.push({ file, preview });\n      }\n\n      // Update state\n      this.uploadedPhotos.set([...currentPhotos, ...newPhotos]);\n    } catch (error) {\n      if (error instanceof Error) {\n        alert(error.message);\n      }\n    } finally {\n      this.isProcessingPhotos.set(false);\n      // Reset input\n      input.value = '';\n    }\n  }\n\n  /**\n   * Validate photo file\n   */\n  private validatePhoto(file: File): void {\n    // Check file type\n    if (!this.ALLOWED_TYPES.includes(file.type)) {\n      throw new Error(`Tipo de archivo no válido: ${file.type}. Usa JPG, PNG o WebP.`);\n    }\n\n    // Check file size\n    if (file.size > this.MAX_FILE_SIZE) {\n      throw new Error(\n        `Archivo muy pesado: ${(file.size / 1024 / 1024).toFixed(1)}MB. Máximo 10MB.`,\n      );\n    }\n  }\n\n  /**\n   * Create preview URL for photo\n   */\n  private createPreview(file: File): Promise<string> {\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader();\n      reader.onload = () => resolve(reader.result as string);\n      reader.onerror = () => reject(new Error('Error al leer archivo'));\n      reader.readAsDataURL(file);\n    });\n  }\n\n  /**\n   * Generate AI photos for a car\n   */\n  async generateAIPhotos(\n    brand: string,\n    model: string,\n    year: number,\n    options: GenerateAIPhotosOptions = {},\n  ): Promise<void> {\n    if (!brand || !model || !year) {\n      alert('Debes seleccionar marca, modelo y año para generar fotos con IA.');\n      return;\n    }\n\n    const currentPhotos = this.uploadedPhotos();\n    // Solo generaremos hasta 3 imágenes nuevas (front, rear, interior) respetando el máximo total de fotos\n    let remainingSlots = Math.min(this.MAX_PHOTOS - currentPhotos.length, 3);\n\n    if (remainingSlots <= 0) {\n      alert('Ya alcanzaste el máximo de fotos permitidas.');\n      return;\n    }\n\n    this.isGeneratingAIPhotos.set(true);\n\n    try {\n      // Generación de imágenes se hace vía Worker (server-side) para no exponer keys en el navegador.\n      const workerEnabled = Boolean(environment.cloudflareWorkerUrl);\n      if (!workerEnabled) {\n        alert('Falta configurar NG_APP_CLOUDFLARE_WORKER_URL (worker de Gemini para imágenes).');\n        return;\n      }\n\n      const generatedPhotos: PhotoPreview[] = [];\n      const errors: string[] = [];\n\n      const setId =\n        options.setId ||\n        (globalThis.crypto && 'randomUUID' in globalThis.crypto\n          ? (globalThis.crypto as Crypto).randomUUID()\n          : `${Date.now()}-${Math.random().toString(16).slice(2)}`);\n\n      // Generar hasta 3 imágenes: 3/4 frontal, lateral, interior (estilo marketplace)\n      const angles: Array<'3/4-front' | 'side' | 'interior'> = ['3/4-front', 'side', 'interior'];\n      for (const [index, angle] of angles.entries()) {\n        if (remainingSlots <= 0) break;\n\n        try {\n          const workerResponse = await fetch(`${environment.cloudflareWorkerUrl}`, {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify({\n              brand,\n              model,\n              year,\n              color: options.color,\n              body_type: options.body_type,\n              trim_level: options.trim_level,\n              angle,\n              // Marketplace-style photos (avoid studio/showroom look)\n              style: 'marketplace_latam_border_town',\n              set_id: setId,\n            }),\n          });\n\n          const workerResult = await workerResponse.json().catch(() => ({}));\n\n          const modelUsed = workerResult?.metadata?.model;\n          if (modelUsed) {\n            console.info('[AI Photos] Worker model:', modelUsed);\n          }\n\n          if (!workerResponse.ok || !workerResult.success || !workerResult.image) {\n            const message = workerResult?.error || workerResponse.statusText;\n            throw new Error(message || 'Error al generar foto con IA');\n          }\n\n          const workerFile = await this.base64ToFile(\n            workerResult.image,\n            `ai-${brand}-${model}-${Date.now()}-${index}.png`,\n          );\n          const workerPreview = await this.createPreview(workerFile);\n          generatedPhotos.push({ file: workerFile, preview: workerPreview });\n          remainingSlots--;\n        } catch (error) {\n          console.error(`Error generando foto ${index + 1} con worker:`, error);\n          errors.push(`IA #${index + 1}: ${error instanceof Error ? error.message : 'falló'}`);\n        }\n      }\n\n      if (generatedPhotos.length > 0) {\n        this.uploadedPhotos.set([...currentPhotos, ...generatedPhotos]);\n        const errorMsg = errors.length ? ` (algunas fallaron: ${errors.join('; ')})` : '';\n        alert(`✨ Se generaron ${generatedPhotos.length} foto(s) con IA${errorMsg}. Revisa consola para ver el modelo usado.`);\n      } else {\n        const msg = errors.length\n          ? `No se generaron fotos. Errores: ${errors.join('; ')}`\n          : 'No se pudo generar ninguna foto con IA. Verifica NG_APP_CLOUDFLARE_WORKER_URL.';\n        alert(msg);\n      }\n    } catch (error) {\n      console.error('Error general durante la generación de fotos con IA:', error);\n      alert('Ocurrió un error inesperado al generar fotos con IA. Intenta nuevamente.');\n    } finally {\n      this.isGeneratingAIPhotos.set(false);\n    }\n  }\n\n  // Helper function to convert base64 to File object\n  private async base64ToFile(\n    base64String: string,\n    filename: string,\n    mimeType = 'image/png',\n    maxBytes = 900_000,\n    maxDimension = 1600,\n  ): Promise<File> {\n    const dataUrl = base64String.startsWith('data:')\n      ? base64String\n      : `data:${mimeType};base64,${base64String}`;\n\n    // Cargar la imagen en un elemento <img>\n    const image = await new Promise<HTMLImageElement>((resolve, reject) => {\n      const img = new Image();\n      img.onload = () => resolve(img);\n      img.onerror = () => reject(new Error('No se pudo cargar la imagen generada'));\n      img.src = dataUrl;\n    });\n\n    // Ajustar dimensiones si excede el máximo permitido\n    const { width, height } = image;\n    const scale = Math.min(1, maxDimension / Math.max(width, height));\n    const targetWidth = Math.round(width * scale);\n    const targetHeight = Math.round(height * scale);\n\n    const canvas = document.createElement('canvas');\n    canvas.width = targetWidth;\n    canvas.height = targetHeight;\n    const ctx = canvas.getContext('2d');\n    if (!ctx) {\n      throw new Error('No se pudo crear el contexto de canvas');\n    }\n    ctx.drawImage(image, 0, 0, targetWidth, targetHeight);\n\n    // Comprimir iterativamente hasta quedar debajo de maxBytes o calidad mínima\n    let quality = 0.85;\n    let compressedDataUrl = canvas.toDataURL('image/jpeg', quality);\n    while (compressedDataUrl.length > maxBytes * 1.37 && quality > 0.5) {\n      // dataURL pesa ~1.37x el binario base64\n      quality -= 0.05;\n      compressedDataUrl = canvas.toDataURL('image/jpeg', quality);\n    }\n\n    // Convertir dataURL a Blob\n    const compressedBlob = await (await fetch(compressedDataUrl)).blob();\n    const finalMime = compressedBlob.type || 'image/jpeg';\n    return new File([compressedBlob], filename.replace(/\\.[^.]+$/, '.jpg'), { type: finalMime });\n  }\n\n  /**\n   * Remove photo at index\n   */\n  removePhoto(index: number): void {\n    const photos = this.uploadedPhotos();\n    const newPhotos = photos.filter((_, i) => i !== index);\n    this.uploadedPhotos.set(newPhotos);\n  }\n\n  /**\n   * Upload photos to storage for a car\n   */\n  async uploadPhotos(carId: string): Promise<void> {\n    const photos = this.uploadedPhotos();\n    if (photos.length === 0) return;\n\n    for (let i = 0; i < photos.length; i++) {\n      const photo = photos[i];\n      await this.carsService.uploadPhoto(photo.file, carId, i);\n    }\n  }\n\n  /**\n   * Clear all photos\n   */\n  clearPhotos(): void {\n    this.uploadedPhotos.set([]);\n  }\n\n  /**\n   * Get photo count\n   */\n  getPhotoCount(): number {\n    return this.uploadedPhotos().length;\n  }\n\n  /**\n   * Check if minimum photos requirement is met\n   */\n  hasMinimumPhotos(): boolean {\n    return this.uploadedPhotos().length >= 3;\n  }\n\n  /**\n   * Add stock photos (Files) to the photo list\n   */\n  async addStockPhotosFiles(files: File[]): Promise<void> {\n    const currentPhotos = this.uploadedPhotos();\n    const remainingSlots = this.MAX_PHOTOS - currentPhotos.length;\n\n    if (files.length > remainingSlots) {\n      alert(`Solo puedes agregar ${remainingSlots} foto(s) más. Máximo ${this.MAX_PHOTOS} fotos.`);\n      return;\n    }\n\n    this.isProcessingPhotos.set(true);\n\n    try {\n      const newPhotos: PhotoPreview[] = [];\n\n      for (const file of files) {\n        this.validatePhoto(file);\n        const preview = await this.createPreview(file);\n        newPhotos.push({ file, preview });\n      }\n\n      this.uploadedPhotos.set([...currentPhotos, ...newPhotos]);\n    } catch (error) {\n      if (error instanceof Error) {\n        alert(error.message);\n      }\n    } finally {\n      this.isProcessingPhotos.set(false);\n    }\n  }\n\n  /**\n   * Add stock photos (URLs) to the photo list\n   */\n  async addStockPhotos(photoUrls: string[]): Promise<void> {\n    const currentPhotos = this.uploadedPhotos();\n    const remainingSlots = this.MAX_PHOTOS - currentPhotos.length;\n\n    if (photoUrls.length > remainingSlots) {\n      alert(`Solo puedes agregar ${remainingSlots} foto(s) más. Máximo ${this.MAX_PHOTOS} fotos.`);\n      return;\n    }\n\n    this.isProcessingPhotos.set(true);\n\n    try {\n      const newPhotos: PhotoPreview[] = [];\n\n      for (const url of photoUrls) {\n        // Fetch image and convert to File\n        const response = await fetch(url);\n        const blob = await response.blob();\n        const file = new File([blob], `stock-${Date.now()}.jpg`, {\n          type: blob.type || 'image/jpeg',\n        });\n\n        this.validatePhoto(file);\n        const preview = await this.createPreview(file);\n        newPhotos.push({ file, preview });\n      }\n\n      this.uploadedPhotos.set([...currentPhotos, ...newPhotos]);\n    } catch (error) {\n      if (error instanceof Error) {\n        alert(error.message);\n      }\n    } finally {\n      this.isProcessingPhotos.set(false);\n    }\n  }\n\n  /**\n   * Add AI generated photos (Files) to the photo list\n   */\n  async addAIPhotosFiles(files: File[]): Promise<void> {\n    const currentPhotos = this.uploadedPhotos();\n    const remainingSlots = this.MAX_PHOTOS - currentPhotos.length;\n\n    if (files.length > remainingSlots) {\n      alert(`Solo puedes agregar ${remainingSlots} foto(s) más. Máximo ${this.MAX_PHOTOS} fotos.`);\n      return;\n    }\n\n    this.isProcessingPhotos.set(true);\n\n    try {\n      const newPhotos: PhotoPreview[] = [];\n\n      for (const file of files) {\n        this.validatePhoto(file);\n        const preview = await this.createPreview(file);\n        newPhotos.push({ file, preview });\n      }\n\n      this.uploadedPhotos.set([...currentPhotos, ...newPhotos]);\n    } catch (error) {\n      if (error instanceof Error) {\n        alert(error.message);\n      }\n    } finally {\n      this.isProcessingPhotos.set(false);\n    }\n  }\n\n  /**\n   * Add AI generated photos (URLs) to the photo list\n   */\n  async addAIPhotos(photoUrls: string[]): Promise<void> {\n    const currentPhotos = this.uploadedPhotos();\n    const remainingSlots = this.MAX_PHOTOS - currentPhotos.length;\n\n    if (photoUrls.length > remainingSlots) {\n      alert(`Solo puedes agregar ${remainingSlots} foto(s) más. Máximo ${this.MAX_PHOTOS} fotos.`);\n      return;\n    }\n\n    this.isProcessingPhotos.set(true);\n\n    try {\n      const newPhotos: PhotoPreview[] = [];\n\n      for (const url of photoUrls) {\n        // Fetch image and convert to File\n        const response = await fetch(url);\n        const blob = await response.blob();\n        const file = new File([blob], `ai-${Date.now()}.png`, { type: blob.type || 'image/png' });\n\n        this.validatePhoto(file);\n        const preview = await this.createPreview(file);\n        newPhotos.push({ file, preview });\n      }\n\n      this.uploadedPhotos.set([...currentPhotos, ...newPhotos]);\n    } catch (error) {\n      if (error instanceof Error) {\n        alert(error.message);\n      }\n    } finally {\n      this.isProcessingPhotos.set(false);\n    }\n  }\n\n  // Genera prompts variados para evitar imágenes repetidas\n  private buildGeminiPrompts(brand: string, model: string, year: number): string[] {\n    const pick = <T>(list: T[]): T => list[Math.floor(Math.random() * list.length)];\n\n    const weather = pick([\n      'bright sunny day with soft shadows',\n      'slightly overcast day with diffused light',\n      'after-rain damp ground and cloudy sky',\n      'golden hour warm light with long shadows',\n      'early morning cool light with a bit of mist',\n    ]);\n\n    const terrain = pick([\n      'on a dirt road with light tire marks',\n      'on a gravel turnout near trees',\n      'on a rural roadside with dry grass',\n      'on a damp compacted earth surface',\n      'on a light muddy patch with puddles nearby',\n    ]);\n\n    const background = pick([\n      'trees and bushes behind the car',\n      'a distant hill line',\n      'light forest edge',\n      'open countryside',\n      'sparse shrubs and a cloudy horizon',\n    ]);\n\n    const camera = pick([\n      'handheld smartphone at eye level',\n      'handheld smartphone slightly low angle',\n      'handheld smartphone slightly high angle',\n    ]);\n\n    const interiorLight = pick([\n      'natural daylight entering through windows',\n      'soft overcast light through windshield',\n      'late afternoon warm light through side windows',\n    ]);\n\n    const interiorWeather = pick([\n      'windows slightly dusty',\n      'light reflections from cloudy sky',\n      'subtle streaks on glass from recent rain',\n    ]);\n\n    const exteriorPrompt = `Generate a realistic photo (not render, not showroom) of a ${year} ${brand} ${model} car parked ${terrain}, ${weather}, background of ${background}. Angle: 3/4 front. Style: ${camera}, natural shadows, slight imperfections, realistic reflections, no studio lighting, no advertising vibe. Vary the scene subtly each time so photos are not identical.`;\n\n    const interiorPrompt = `Generate a realistic interior photo (not render) of a ${year} ${brand} ${model} car. Show front seats, dashboard and steering wheel from driver's door perspective. Lighting: ${interiorLight}, ${interiorWeather}. Style: handheld smartphone photo, slight imperfections, realistic textures, no studio lighting, no advertising vibe. Vary small details so photos are not identical.`;\n\n    const rearPrompt = `Generate a realistic photo (not render) of a ${year} ${brand} ${model} car parked ${terrain}, ${weather}, background of ${background}. Angle: 3/4 rear view showing trunk and tail lights. Style: ${camera}, natural shadows, slight imperfections, realistic reflections, no studio lighting, no advertising vibe.`;\n\n    return [exteriorPrompt, interiorPrompt, rearPrompt];\n  }\n\n  /**\n   * Load existing photos for editing\n   */\n  async loadExistingPhotos(carId: string): Promise<void> {\n    try {\n      const photos = await this.carsService.getCarPhotos(carId);\n\n      const previews: PhotoPreview[] = await Promise.all(\n        photos.map(async (photo) => {\n          const response = await fetch(photo.url);\n          if (!response.ok) throw new Error('No se pudo descargar la foto existente');\n          const blob = await response.blob();\n          const file = new File([blob], `photo-${photo.position || 0}.jpg`, {\n            type: blob.type || 'image/jpeg',\n          });\n          return { file, preview: photo.url };\n        }),\n      );\n\n      this.uploadedPhotos.set(previews);\n    } catch (error) {\n      console.error('Failed to load existing photos:', error);\n      this.notifications.warning('Fotos', 'No pudimos cargar las fotos existentes.');\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/features/cars/quick-book/quick-book.page.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`@core/services/infrastructure/analytics.service` import should occur before import of `../../../shared/components/date-range-picker/date-range-picker.component`","line":16,"column":1,"nodeType":"ImportDeclaration","endLine":16,"endColumn":84,"fix":{"range":[223,737],"text":"import { AnalyticsService } from '@core/services/infrastructure/analytics.service';\nimport { DateRangePickerComponent } from '../../../shared/components/date-range-picker/date-range-picker.component';\nimport {\n  PaymentMethodButtonsComponent,\n  type PaymentMethod,\n} from '../../../shared/components/payment-method-buttons/payment-method-buttons.component';\nimport { MoneyPipe } from '../../../shared/pipes/money.pipe';\nimport { CarChatComponent } from '../../messages/components/car-chat.component';\n\n// Services\n"}},{"ruleId":"import/order","severity":1,"message":"`@core/services/auth/auth.service` import should occur before import of `../../../shared/components/date-range-picker/date-range-picker.component`","line":17,"column":1,"nodeType":"ImportDeclaration","endLine":17,"endColumn":64,"fix":{"range":[223,801],"text":"import { AuthService } from '@core/services/auth/auth.service';\nimport { DateRangePickerComponent } from '../../../shared/components/date-range-picker/date-range-picker.component';\nimport {\n  PaymentMethodButtonsComponent,\n  type PaymentMethod,\n} from '../../../shared/components/payment-method-buttons/payment-method-buttons.component';\nimport { MoneyPipe } from '../../../shared/pipes/money.pipe';\nimport { CarChatComponent } from '../../messages/components/car-chat.component';\n\n// Services\nimport { AnalyticsService } from '@core/services/infrastructure/analytics.service';\n"}},{"ruleId":"import/order","severity":1,"message":"`@core/services/bookings/booking-initiation.service` import should occur before import of `../../../shared/components/date-range-picker/date-range-picker.component`","line":18,"column":1,"nodeType":"ImportDeclaration","endLine":18,"endColumn":95,"fix":{"range":[223,896],"text":"import { BookingInitiationService } from '@core/services/bookings/booking-initiation.service';\nimport { DateRangePickerComponent } from '../../../shared/components/date-range-picker/date-range-picker.component';\nimport {\n  PaymentMethodButtonsComponent,\n  type PaymentMethod,\n} from '../../../shared/components/payment-method-buttons/payment-method-buttons.component';\nimport { MoneyPipe } from '../../../shared/pipes/money.pipe';\nimport { CarChatComponent } from '../../messages/components/car-chat.component';\n\n// Services\nimport { AnalyticsService } from '@core/services/infrastructure/analytics.service';\nimport { AuthService } from '@core/services/auth/auth.service';\n"}},{"ruleId":"import/order","severity":1,"message":"`@core/services/cars/cars.service` import should occur before import of `../../../shared/components/date-range-picker/date-range-picker.component`","line":19,"column":1,"nodeType":"ImportDeclaration","endLine":19,"endColumn":64,"fix":{"range":[223,960],"text":"import { CarsService } from '@core/services/cars/cars.service';\nimport { DateRangePickerComponent } from '../../../shared/components/date-range-picker/date-range-picker.component';\nimport {\n  PaymentMethodButtonsComponent,\n  type PaymentMethod,\n} from '../../../shared/components/payment-method-buttons/payment-method-buttons.component';\nimport { MoneyPipe } from '../../../shared/pipes/money.pipe';\nimport { CarChatComponent } from '../../messages/components/car-chat.component';\n\n// Services\nimport { AnalyticsService } from '@core/services/infrastructure/analytics.service';\nimport { AuthService } from '@core/services/auth/auth.service';\nimport { BookingInitiationService } from '@core/services/bookings/booking-initiation.service';\n"}}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":44,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":44,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1735,1738],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1735,1738],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":151,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":151,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4941,4944],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4941,4944],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":4,"source":"\nimport { ChangeDetectionStrategy, Component, computed, inject, signal } from '@angular/core';\nimport { ActivatedRoute, Router } from '@angular/router';\nimport { TranslateModule } from '@ngx-translate/core';\n\n// Components\nimport { DateRangePickerComponent } from '../../../shared/components/date-range-picker/date-range-picker.component';\nimport {\n  PaymentMethodButtonsComponent,\n  type PaymentMethod,\n} from '../../../shared/components/payment-method-buttons/payment-method-buttons.component';\nimport { MoneyPipe } from '../../../shared/pipes/money.pipe';\nimport { CarChatComponent } from '../../messages/components/car-chat.component';\n\n// Services\nimport { AnalyticsService } from '@core/services/infrastructure/analytics.service';\nimport { AuthService } from '@core/services/auth/auth.service';\nimport { BookingInitiationService } from '@core/services/bookings/booking-initiation.service';\nimport { CarsService } from '@core/services/cars/cars.service';\n\n@Component({\n  standalone: true,\n  selector: 'app-quick-book-page',\n  imports: [\n    DateRangePickerComponent,\n    CarChatComponent,\n    PaymentMethodButtonsComponent,\n    TranslateModule,\n    MoneyPipe\n],\n  templateUrl: './quick-book.page.html',\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class QuickBookPage {\n  private route = inject(ActivatedRoute);\n  private router = inject(Router);\n  private carsService = inject(CarsService);\n  private bookingInitiation = inject(BookingInitiationService);\n  private authService = inject(AuthService);\n  private analytics = inject(AnalyticsService);\n\n  readonly carId = computed(() => this.route.snapshot.paramMap.get('id'));\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  readonly car = signal<any | null>(null);\n\n  readonly dateRange = signal<{ from: string | null; to: string | null }>({ from: null, to: null });\n  readonly selectedPaymentMethod = signal<PaymentMethod>('credit_card');\n  readonly loading = signal(false);\n  readonly error = signal<string | null>(null);\n\n  constructor() {\n    const id = this.carId();\n    if (id) {\n      void this.loadCar(id);\n    }\n  }\n\n  private async loadCar(id: string): Promise<void> {\n    try {\n      const car = await this.carsService.getCarById(id);\n      this.car.set(car);\n    } catch (err) {\n      console.error('Error loading car for quick-book:', err);\n      this.error.set('No se pudo cargar el auto');\n    }\n  }\n\n  onRangeChange(range: { from: string | null; to: string | null }): void {\n    this.dateRange.set(range);\n  }\n\n  onContactOwner(): void {\n    const car = this.car();\n    if (!car) return;\n    const session = this.authService.session$();\n    if (!session?.user) {\n      void this.router.navigate(['/auth/login'], { queryParams: { returnUrl: this.router.url } });\n      return;\n    }\n\n    void this.router.navigate(['/messages/chat'], {\n      queryParams: {\n        carId: car.id,\n        userId: car.owner_id,\n        carName: car.title ?? `${car.brand} ${car.model}`,\n        userName: car.owner?.full_name ?? 'Anfitrión',\n      },\n    });\n  }\n\n  onPaymentMethodSelected(method: PaymentMethod): void {\n    this.selectedPaymentMethod.set(method);\n  }\n\n  async onBookNow(): Promise<void> {\n    const car = this.car();\n    const { from, to } = this.dateRange();\n    if (!car || !from || !to) {\n      this.error.set('Seleccioná las fechas antes de continuar');\n      return;\n    }\n\n    this.loading.set(true);\n    this.error.set(null);\n    try {\n      const startIso = new Date(from).toISOString();\n      const endIso = new Date(to).toISOString();\n\n      const result = await this.bookingInitiation.startFromCar(car.id, startIso, endIso);\n\n      if (!result.success) {\n        if (result.error === 'not_authenticated') {\n          // login flow handled by service\n          return;\n        }\n        this.error.set(result.error || 'No pudimos crear la reserva');\n        return;\n      }\n\n      const bookingId = result.booking?.id ?? null;\n      if (!bookingId) {\n        this.error.set('No se obtuvo bookingId');\n        return;\n      }\n\n      // Track conversion\n      this.analytics.trackEvent('booking_completed', {\n        car_id: car.id,\n        booking_id: bookingId,\n        payment_method: this.selectedPaymentMethod(),\n      });\n\n      // Navigate to payment page and pre-select payment method\n      await this.router.navigate(['/bookings/detail-payment'], {\n        queryParams: { bookingId, paymentMethod: this.selectedPaymentMethod() },\n      });\n    } catch (err) {\n      console.error('QuickBook error:', err);\n      this.error.set(err instanceof Error ? err.message : 'Error desconocido');\n    } finally {\n      this.loading.set(false);\n    }\n  }\n\n  // Helper: obtiene URL de la primera foto o placeholder\n  getCarPhotoUrl(): string {\n    const car = this.car();\n    if (!car) return '/assets/placeholder-car.jpg';\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const photos = car.photos || (car as any).car_photos;\n    if (photos && photos.length > 0 && photos[0].url) {\n      return photos[0].url;\n    }\n\n    return '/assets/placeholder-car.jpg';\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/features/dashboard/components/multi-car-calendar/multi-car-calendar.component.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`../../../../core/models` import should occur after import of `@core/services/infrastructure/supabase-client.service`","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":8,"endColumn":47,"fix":{"range":[367,935],"text":"import { AuthService } from '@core/services/auth/auth.service';\nimport {\n  CarAvailabilityService,\n  DetailedBlockedRange,\n} from '@core/services/cars/car-availability.service';\nimport { CarBlockingService } from '@core/services/cars/car-blocking.service';\nimport { CarsService } from '@core/services/cars/cars.service';\nimport { NotificationManagerService } from '@core/services/infrastructure/notification-manager.service';\nimport { SupabaseClientService } from '@core/services/infrastructure/supabase-client.service';\nimport { Car } from '../../../../core/models';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { CommonModule } from '@angular/common';\nimport {Component, computed, inject, OnInit, signal,\n  ChangeDetectionStrategy} from '@angular/core';\nimport { FormsModule } from '@angular/forms';\nimport { Router } from '@angular/router';\nimport { addMonths, eachDayOfInterval, endOfMonth, format, startOfMonth } from 'date-fns';\nimport { es } from 'date-fns/locale';\nimport { Car } from '../../../../core/models';\nimport { AuthService } from '@core/services/auth/auth.service';\nimport {\n  CarAvailabilityService,\n  DetailedBlockedRange,\n} from '@core/services/cars/car-availability.service';\nimport { CarBlockingService } from '@core/services/cars/car-blocking.service';\nimport { CarsService } from '@core/services/cars/cars.service';\nimport { NotificationManagerService } from '@core/services/infrastructure/notification-manager.service';\nimport { SupabaseClientService } from '@core/services/infrastructure/supabase-client.service';\nimport {\n  BlockDateModalComponent,\n  BlockDateRequest,\n} from '../../../../shared/components/block-date-modal/block-date-modal.component';\n\ninterface CarCalendarData {\n  carId: string;\n  carTitle: string;\n  imageUrl?: string;\n  blockedRanges: DetailedBlockedRange[];\n  selected: boolean;\n  loading: boolean;\n}\n\n@Component({\n  selector: 'app-multi-car-calendar',\n  standalone: true,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  imports: [CommonModule, FormsModule, BlockDateModalComponent],\n  templateUrl: './multi-car-calendar.component.html',\n  styleUrls: ['./multi-car-calendar.component.css'],\n})\nexport class MultiCarCalendarComponent implements OnInit {\n  private readonly router = inject(Router);\n  private readonly carsService = inject(CarsService);\n  private readonly availabilityService = inject(CarAvailabilityService);\n  private readonly blockingService = inject(CarBlockingService);\n  private readonly toastService = inject(NotificationManagerService);\n  private readonly authService = inject(AuthService);\n  private readonly supabase = inject(SupabaseClientService).getClient();\n\n  readonly cars = signal<CarCalendarData[]>([]);\n  readonly loading = signal(true);\n  readonly currentMonth = signal(new Date());\n  readonly showBlockModal = signal(false);\n\n  readonly monthDays = computed(() => {\n    const month = this.currentMonth();\n    return eachDayOfInterval({\n      start: startOfMonth(month),\n      end: endOfMonth(month),\n    });\n  });\n\n  readonly monthName = computed(() => {\n    return format(this.currentMonth(), 'MMMM yyyy', { locale: es });\n  });\n\n  readonly selectedCars = computed(() => {\n    return this.cars().filter((car) => car.selected);\n  });\n\n  readonly stats = computed(() => {\n    const allCars = this.cars();\n    const total = allCars.length;\n    const withBookings = allCars.filter((car) =>\n      car.blockedRanges.some((r) => r.type === 'booking'),\n    ).length;\n    const withBlocks = allCars.filter((car) =>\n      car.blockedRanges.some((r) => r.type === 'manual_block'),\n    ).length;\n\n    return {\n      total,\n      withBookings,\n      withBlocks,\n      fullyAvailable: total - withBookings - withBlocks,\n    };\n  });\n\n  async ngOnInit(): Promise<void> {\n    await this.loadOwnerCars();\n  }\n\n  private async loadOwnerCars(): Promise<void> {\n    this.loading.set(true);\n\n    try {\n      // Get owner's active cars\n      const user = await this.authService.getCurrentUser();\n      if (!user) {\n        throw new Error('Usuario no autenticado');\n      }\n      const ownerCars = await this.carsService.getCarsByOwner(user.id);\n      const activeCars = ownerCars.filter((car: Car) => car.status === 'active');\n\n      if (activeCars.length === 0) {\n        this.toastService.info('Sin autos', 'No tienes autos activos para mostrar');\n        this.loading.set(false);\n        return;\n      }\n\n      // Initialize car calendar data\n      const carData: CarCalendarData[] = activeCars.map((car: Car) => {\n        // ✅ FIX: Use photos array instead of thumbnail_url/image_urls\n        const firstPhoto = car.photos?.[0] || car.car_photos?.[0];\n        const imageUrl = firstPhoto?.url || null;\n\n        return {\n          carId: car.id,\n          carTitle:\n            `${car.brand_text_backup || car.brand || ''} ${car.model_text_backup || car.model || ''} (${car.year})`.trim(),\n          imageUrl: imageUrl ?? undefined,\n          blockedRanges: [],\n          selected: false,\n          loading: true,\n        };\n      });\n\n      this.cars.set(carData);\n\n      // Load blocked dates for each car\n      await this.loadAllCalendarData();\n    } catch (error) {\n      console.error('Error loading owner cars:', error);\n      this.toastService.error('Error', 'No se pudieron cargar tus autos');\n    } finally {\n      this.loading.set(false);\n    }\n  }\n\n  private async loadAllCalendarData(): Promise<void> {\n    const cars = this.cars();\n    const startDate = format(startOfMonth(this.currentMonth()), 'yyyy-MM-dd');\n    const endDate = format(endOfMonth(addMonths(this.currentMonth(), 2)), 'yyyy-MM-dd');\n\n    // Load in parallel\n    await Promise.all(\n      cars.map(async (car) => {\n        try {\n          const ranges = await this.availabilityService.getBlockedRangesWithDetails(\n            car.carId,\n            startDate,\n            endDate,\n          );\n\n          this.updateCarData(car.carId, { blockedRanges: ranges, loading: false });\n        } catch (error) {\n          console.error(`Error loading calendar for car ${car.carId}:`, error);\n          this.updateCarData(car.carId, { loading: false });\n        }\n      }),\n    );\n  }\n\n  private updateCarData(carId: string, updates: Partial<CarCalendarData>): void {\n    const currentCars = this.cars();\n    const updatedCars = currentCars.map((car) =>\n      car.carId === carId ? { ...car, ...updates } : car,\n    );\n\n    this.cars.set(updatedCars);\n  }\n\n  toggleCarSelection(carId: string): void {\n    const currentCars = this.cars();\n    const updatedCars = currentCars.map((car) =>\n      car.carId === carId ? { ...car, selected: !car.selected } : car,\n    );\n\n    this.cars.set(updatedCars);\n  }\n\n  selectAllCars(): void {\n    const updatedCars = this.cars().map((car) => ({ ...car, selected: true }));\n    this.cars.set(updatedCars);\n  }\n\n  deselectAllCars(): void {\n    const updatedCars = this.cars().map((car) => ({ ...car, selected: false }));\n    this.cars.set(updatedCars);\n  }\n\n  async handleBulkBlockDates(request: BlockDateRequest): Promise<void> {\n    const selectedCars = this.selectedCars();\n\n    if (selectedCars.length === 0) {\n      this.toastService.error('Error', 'Selecciona al menos un auto');\n      return;\n    }\n\n    this.showBlockModal.set(false);\n    this.loading.set(true);\n\n    try {\n      const carIds = selectedCars.map((car) => car.carId);\n\n      const result = await this.blockingService.bulkBlockDates(\n        carIds,\n        request.startDate,\n        request.endDate,\n        request.reason,\n        request.notes,\n      );\n\n      if (result.success > 0) {\n        this.toastService.success(\n          'Éxito',\n          `Fechas bloqueadas en ${result.success} auto(s)${result.failed > 0 ? `, ${result.failed} falló(s)` : ''}`,\n        );\n        await this.loadAllCalendarData();\n      } else {\n        this.toastService.error(\n          'Error',\n          `No se pudieron bloquear las fechas: ${result.errors.join(', ')}`,\n        );\n      }\n    } catch (error) {\n      console.error('Error bulk blocking dates:', error);\n      this.toastService.error('Error', 'Ocurrió un error al bloquear las fechas');\n    } finally {\n      this.loading.set(false);\n    }\n  }\n\n  previousMonth(): void {\n    this.currentMonth.set(\n      new Date(this.currentMonth().getFullYear(), this.currentMonth().getMonth() - 1, 1),\n    );\n    void this.loadAllCalendarData();\n  }\n\n  nextMonth(): void {\n    this.currentMonth.set(\n      new Date(this.currentMonth().getFullYear(), this.currentMonth().getMonth() + 1, 1),\n    );\n    void this.loadAllCalendarData();\n  }\n\n  goToToday(): void {\n    this.currentMonth.set(new Date());\n    void this.loadAllCalendarData();\n  }\n\n  getDayStatus(car: CarCalendarData, day: Date): 'available' | 'booked' | 'blocked' | 'past' {\n    const today = new Date();\n    today.setHours(0, 0, 0, 0);\n\n    if (day < today) {\n      return 'past';\n    }\n\n    const dayStr = format(day, 'yyyy-MM-dd');\n\n    const hasBooking = car.blockedRanges.some(\n      (range) => range.type === 'booking' && dayStr >= range.from && dayStr <= range.to,\n    );\n\n    if (hasBooking) {\n      return 'booked';\n    }\n\n    const hasBlock = car.blockedRanges.some(\n      (range) => range.type === 'manual_block' && dayStr >= range.from && dayStr <= range.to,\n    );\n\n    if (hasBlock) {\n      return 'blocked';\n    }\n\n    return 'available';\n  }\n\n  // Helper methods for template\n  getBookingsCount(car: CarCalendarData): number {\n    return car.blockedRanges.filter((r) => r.type === 'booking').length;\n  }\n\n  getManualBlocksCount(car: CarCalendarData): number {\n    return car.blockedRanges.filter((r) => r.type === 'manual_block').length;\n  }\n\n  goToCarCalendar(carId: string): void {\n    void this.router.navigate(['/cars', carId, 'availability']);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/features/dashboard/earnings/earnings.page.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`../../../core/models` type import should occur after import of `@core/services/infrastructure/supabase-client.service`","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":49,"fix":{"range":[283,727],"text":"import type { DashboardStats } from '../../../core/models/dashboard.model';\nimport { CarsService } from '@core/services/cars/cars.service';\nimport { DashboardService } from '@core/services/admin/dashboard.service';\nimport { ExchangeRateService } from '@core/services/payments/exchange-rate.service';\nimport { SupabaseClientService } from '@core/services/infrastructure/supabase-client.service';\nimport type { Car } from '../../../core/models';\n"}},{"ruleId":"import/order","severity":1,"message":"`../../../core/models/dashboard.model` type import should occur after import of `@core/services/infrastructure/supabase-client.service`","line":7,"column":1,"nodeType":"ImportDeclaration","endLine":7,"endColumn":76,"fix":{"range":[332,727],"text":"import { CarsService } from '@core/services/cars/cars.service';\nimport { DashboardService } from '@core/services/admin/dashboard.service';\nimport { ExchangeRateService } from '@core/services/payments/exchange-rate.service';\nimport { SupabaseClientService } from '@core/services/infrastructure/supabase-client.service';\nimport type { DashboardStats } from '../../../core/models/dashboard.model';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import { CommonModule, DatePipe } from '@angular/common';\nimport {Component, computed, inject, OnInit, signal,\n  ChangeDetectionStrategy, DestroyRef} from '@angular/core';\nimport { takeUntilDestroyed } from '@angular/core/rxjs-interop';\nimport { RouterLink } from '@angular/router';\nimport type { Car } from '../../../core/models';\nimport type { DashboardStats } from '../../../core/models/dashboard.model';\nimport { CarsService } from '@core/services/cars/cars.service';\nimport { DashboardService } from '@core/services/admin/dashboard.service';\nimport { ExchangeRateService } from '@core/services/payments/exchange-rate.service';\nimport { SupabaseClientService } from '@core/services/infrastructure/supabase-client.service';\nimport { IconComponent } from '../../../shared/components/icon/icon.component';\nimport { MoneyPipe } from '../../../shared/pipes/money.pipe';\n\n@Component({\n  selector: 'app-earnings-page',\n  standalone: true,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  imports: [CommonModule, RouterLink, MoneyPipe, DatePipe, IconComponent],\n  templateUrl: './earnings.page.html',\n  styleUrls: ['./earnings.page.css'],\n})\nexport class EarningsPage implements OnInit {\n  private readonly dashboardService = inject(DashboardService);\n  private readonly carsService = inject(CarsService);\n  private readonly exchangeRateService = inject(ExchangeRateService);\n  private readonly supabaseService = inject(SupabaseClientService);\n  private readonly destroyRef = inject(DestroyRef);\n\n  readonly loading = signal(true);\n  readonly error = signal<string | null>(null);\n  readonly stats = signal<DashboardStats | null>(null);\n  readonly cars = signal<Car[]>([]);\n  readonly exchangeRate = signal<number>(1000); // Default ARS/USD rate\n  readonly carCategories = signal<Map<string, { depreciation_rate_annual: number }>>(new Map());\n\n  // Computed signals\n  readonly availableBalance = computed(() => this.stats()?.wallet.availableBalance ?? 0);\n  readonly pendingBalance = computed(() => this.stats()?.wallet.lockedBalance ?? 0);\n  readonly totalEarnings = computed(() => this.stats()?.earnings.total ?? 0);\n  readonly thisMonthEarnings = computed(() => this.stats()?.earnings.thisMonth ?? 0);\n  readonly lastMonthEarnings = computed(() => this.stats()?.earnings.lastMonth ?? 0);\n\n  readonly growthPercentage = computed(() => {\n    const current = this.thisMonthEarnings();\n    const previous = this.lastMonthEarnings();\n    if (previous === 0) return current > 0 ? 100 : 0;\n    return Math.round(((current - previous) / previous) * 100);\n  });\n\n  readonly isGrowthPositive = computed(() => this.growthPercentage() >= 0);\n\n  // Depreciation and breakeven calculations\n  readonly totalAnnualDepreciation = computed(() => {\n    const userCars = this.cars();\n\n    let total = 0;\n\n    for (const car of userCars) {\n      const valueUsd = car.value_usd || 0;\n      if (valueUsd > 0) {\n        // Obtener tasa de depreciación de la categoría o usar default\n        let depreciationRate = 0.15; // 15% anual (default)\n        // Note: category_id is not part of Car interface, using default depreciation rate\n        const annualDepreciation = valueUsd * depreciationRate;\n        total += annualDepreciation * this.exchangeRate(); // Convert to ARS\n      }\n    }\n\n    return total;\n  });\n\n  readonly totalAnnualIncome = computed(() => {\n    // Estimación basada en ganancias mensuales * 12\n    const monthlyEarnings = this.thisMonthEarnings();\n    return monthlyEarnings * 12;\n  });\n\n  readonly breakevenDays = computed(() => {\n    const annualDepreciation = this.totalAnnualDepreciation();\n    const userCars = this.cars();\n\n    if (annualDepreciation === 0 || userCars.length === 0) return 0;\n\n    // Calcular ingreso diario promedio por auto\n    let totalDailyIncome = 0;\n    for (const car of userCars) {\n      // Owner recibe 85% del precio diario (split payment)\n      const dailyIncome = (car.price_per_day || 0) * 0.85;\n      totalDailyIncome += dailyIncome;\n    }\n\n    if (totalDailyIncome === 0) return 0;\n\n    // Días necesarios para cubrir depreciación anual\n    return Math.ceil(annualDepreciation / totalDailyIncome);\n  });\n\n  readonly profitStartDate = computed(() => {\n    const days = this.breakevenDays();\n    if (days === 0) return null;\n\n    const startDate = new Date();\n    startDate.setDate(startDate.getDate() + days);\n    return startDate;\n  });\n\n  // Chart data for CSS bar charts\n  readonly months = ['Ene', 'Feb', 'Mar', 'Abr', 'May', 'Jun', 'Jul', 'Ago', 'Sep', 'Oct', 'Nov', 'Dic'];\n\n  // CSS chart data signals\n  readonly depreciationChartData = signal<{ month: string; value: number; percentage: number }[]>([]);\n  readonly incomeChartData = signal<{ month: string; value: number; percentage: number }[]>([]);\n\n  async ngOnInit(): Promise<void> {\n    await Promise.all([this.loadData(), this.loadCars(), this.loadExchangeRate()]);\n  }\n\n  async loadData(): Promise<void> {\n    this.loading.set(true);\n    this.error.set(null);\n\n    this.dashboardService.getDashboardStats(false).pipe(\n      takeUntilDestroyed(this.destroyRef)\n    ).subscribe({\n      next: (stats) => {\n        this.stats.set(stats);\n        this.updateCharts();\n        this.loading.set(false);\n      },\n      error: (_err) => {\n        this.error.set('No pudimos cargar las ganancias. Intentá de nuevo.');\n        this.loading.set(false);\n      },\n    });\n  }\n\n  async loadCars(): Promise<void> {\n    try {\n      const cars = await this.carsService.listMyCars();\n      this.cars.set(cars);\n      this.updateCharts();\n    } catch (error) {\n      console.error('Error loading cars:', error);\n    }\n  }\n\n  async loadExchangeRate(): Promise<void> {\n    try {\n      const rate = await this.exchangeRateService.getPlatformRate();\n      this.exchangeRate.set(rate);\n    } catch (error) {\n      console.error('Error loading exchange rate:', error);\n      this.exchangeRate.set(1000); // Fallback\n    }\n  }\n\n  private updateCharts(): void {\n    const annualDepreciation = this.totalAnnualDepreciation();\n    const monthlyDepreciation = annualDepreciation / 12;\n    const monthlyIncome = this.thisMonthEarnings();\n    const fallbackMonthly =\n      monthlyIncome ||\n      (this.totalEarnings() > 0 ? this.totalEarnings() / 12 : 0) ||\n      (this.availableBalance() + this.pendingBalance()) / 6 ||\n      500; // baseline estimate if no data\n\n    // Generate cumulative data for each month\n    const depreciationData: { month: string; value: number; percentage: number }[] = [];\n    const incomeData: { month: string; value: number; percentage: number }[] = [];\n\n    const maxDepreciation = annualDepreciation;\n    const baseIncome = monthlyIncome || fallbackMonthly;\n    const maxIncome = baseIncome * 12;\n\n    for (let i = 0; i < 12; i++) {\n      const depValue = Math.round(monthlyDepreciation * (i + 1));\n      const incValue = Math.round(baseIncome * (i + 1));\n\n      depreciationData.push({\n        month: this.months[i],\n        value: depValue,\n        percentage: maxDepreciation > 0 ? (depValue / maxDepreciation) * 100 : 0,\n      });\n\n      incomeData.push({\n        month: this.months[i],\n        value: incValue,\n        percentage: maxIncome > 0 ? (incValue / maxIncome) * 100 : 0,\n      });\n    }\n\n    this.depreciationChartData.set(depreciationData);\n    this.incomeChartData.set(incomeData);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/features/dashboard/owner-dashboard.page.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`../../core/models/dashboard.model` type import should occur after import of `@core/services/infrastructure/user-notifications.service`","line":7,"column":1,"nodeType":"ImportDeclaration","endLine":7,"endColumn":73,"fix":{"range":[305,550],"text":"import { DashboardService } from '@core/services/admin/dashboard.service';\nimport { NotificationsService } from '@core/services/infrastructure/user-notifications.service';\nimport type { DashboardStats } from '../../core/models/dashboard.model';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { CommonModule } from '@angular/common';\nimport {Component, computed, inject, OnDestroy, OnInit, signal,\n  ChangeDetectionStrategy} from '@angular/core';\nimport { RouterLink } from '@angular/router';\nimport { TranslateModule } from '@ngx-translate/core';\nimport { Subject, takeUntil } from 'rxjs';\nimport type { DashboardStats } from '../../core/models/dashboard.model';\nimport { DashboardService } from '@core/services/admin/dashboard.service';\nimport { NotificationsService } from '@core/services/infrastructure/user-notifications.service';\nimport { MissingDocumentsWidgetComponent } from '../../shared/components/missing-documents-widget/missing-documents-widget.component';\nimport { MoneyPipe } from '../../shared/pipes/money.pipe';\nimport { MultiCarCalendarComponent } from './components/multi-car-calendar/multi-car-calendar.component';\nimport { PayoutsHistoryComponent } from './components/payouts-history/payouts-history.component';\n\n@Component({\n  standalone: true,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  selector: 'app-owner-dashboard',\n  imports: [\n    CommonModule,\n    RouterLink,\n    MoneyPipe,\n    TranslateModule,\n    MultiCarCalendarComponent,\n    MissingDocumentsWidgetComponent,\n    PayoutsHistoryComponent,\n  ],\n  templateUrl: './owner-dashboard.page.html',\n  styleUrls: ['./owner-dashboard.page.css'],\n})\nexport class OwnerDashboardPage implements OnInit, OnDestroy {\n  private readonly dashboardService = inject(DashboardService);\n  private readonly notificationsService = inject(NotificationsService);\n\n  // P0-006 FIX: Memory leak prevention\n  private readonly destroy$ = new Subject<void>();\n\n  readonly loading = signal(true);\n  readonly error = signal<string | null>(null);\n  readonly showCalendar = signal(false);\n\n  // Dashboard stats from Edge Function\n  readonly stats = signal<DashboardStats | null>(null);\n\n  // Wallet computed signals\n  readonly availableBalance = computed(() => this.stats()?.wallet.availableBalance ?? 0);\n  readonly pendingBalance = computed(() => this.stats()?.wallet.lockedBalance ?? 0);\n  readonly totalBalance = computed(() => this.stats()?.wallet.totalBalance ?? 0);\n  readonly withdrawableBalance = computed(() => this.stats()?.wallet.withdrawableBalance ?? 0);\n\n  // Cars computed signals\n  readonly totalCars = computed(() => this.stats()?.cars.total ?? 0);\n  readonly activeCars = computed(() => this.stats()?.cars.active ?? 0);\n  readonly pendingCars = computed(() => this.stats()?.cars.pending ?? 0);\n  readonly suspendedCars = computed(() => this.stats()?.cars.suspended ?? 0);\n\n  // Bookings computed signals\n  readonly upcomingBookings = computed(() => this.stats()?.bookings.upcoming ?? 0);\n  readonly activeBookings = computed(() => this.stats()?.bookings.active ?? 0);\n  readonly completedBookings = computed(() => this.stats()?.bookings.completed ?? 0);\n  readonly totalBookings = computed(() => this.stats()?.bookings.total ?? 0);\n\n  // Earnings computed signals\n  readonly thisMonthEarnings = computed(() => this.stats()?.earnings.thisMonth ?? 0);\n  readonly lastMonthEarnings = computed(() => this.stats()?.earnings.lastMonth ?? 0);\n  readonly totalEarnings = computed(() => this.stats()?.earnings.total ?? 0);\n\n  // Growth percentage calculation\n  readonly growthPercentage = computed(() => {\n    const current = this.thisMonthEarnings();\n    const previous = this.lastMonthEarnings();\n    if (previous === 0) return current > 0 ? 100 : 0;\n    return Math.round(((current - previous) / previous) * 100);\n  });\n\n  readonly isGrowthPositive = computed(() => this.growthPercentage() >= 0);\n\n  // Notifications computed signals\n  readonly notifications = this.notificationsService.notifications;\n  readonly unreadCount = this.notificationsService.unreadCount;\n  readonly recentNotifications = computed(\n    () => this.notifications().slice(0, 5), // Last 5 notifications\n  );\n\n  async ngOnInit() {\n    await this.loadDashboardData();\n    // Notifications are loaded automatically by the service\n  }\n\n  getRetryAction() {\n    return {\n      label: 'Reintentar',\n      handler: () => this.loadDashboardData(),\n      variant: 'primary' as const,\n    };\n  }\n\n  async loadDashboardData(forceRefresh: boolean = false) {\n    this.loading.set(true);\n    this.error.set(null);\n\n    // P0-006 FIX: Prevent memory leak with takeUntil\n    this.dashboardService\n      .getDashboardStats(forceRefresh)\n      .pipe(takeUntil(this.destroy$))\n      .subscribe({\n        next: (stats) => {\n          this.stats.set(stats);\n          this.loading.set(false);\n        },\n        error: (_err) => {\n          this.error.set('No pudimos cargar las estadísticas. Intentá de nuevo.');\n          this.loading.set(false);\n        },\n      });\n  }\n\n  /**\n   * Refresh dashboard data manually\n   * Clears cache and fetches fresh data\n   */\n  refreshDashboard(): void {\n    this.dashboardService.clearCache();\n    this.loadDashboardData(true);\n  }\n\n  toggleCalendar(): void {\n    this.showCalendar.set(!this.showCalendar());\n  }\n\n  ngOnDestroy(): void {\n    // P0-006 FIX: Clean up subscriptions\n    this.destroy$.next();\n    this.destroy$.complete();\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/features/disputes/components/dispute-detail/dispute-detail.component.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`../evidence-uploader/evidence-uploader.component` import should occur after import of `@core/services/auth/profile.service`","line":9,"column":1,"nodeType":"ImportDeclaration","endLine":9,"endColumn":94,"fix":{"range":[536,772],"text":"import { WalletService } from '@core/services/payments/wallet.service';\nimport { ProfileService } from '@core/services/auth/profile.service';\nimport { EvidenceUploaderComponent } from '../evidence-uploader/evidence-uploader.component';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import {Component, OnInit, inject, input, output, signal, computed,\n  ChangeDetectionStrategy} from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { FormsModule } from '@angular/forms';\nimport { Router } from '@angular/router';\nimport { DisputesService, Dispute, DisputeEvidence, DisputeStatus } from '@core/services/admin/disputes.service';\nimport { AuthService } from '@core/services/auth/auth.service';\nimport { NotificationManagerService } from '@core/services/infrastructure/notification-manager.service';\nimport { EvidenceUploaderComponent } from '../evidence-uploader/evidence-uploader.component';\nimport { WalletService } from '@core/services/payments/wallet.service';\nimport { ProfileService } from '@core/services/auth/profile.service';\n\n@Component({\n  selector: 'app-dispute-detail',\n  standalone: true,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  imports: [CommonModule, FormsModule, EvidenceUploaderComponent],\n  templateUrl: './dispute-detail.component.html',\n  styleUrls: ['./dispute-detail.component.css']\n})\nexport class DisputeDetailComponent implements OnInit {\n  private readonly disputesService = inject(DisputesService);\n  private readonly authService = inject(AuthService);\n  private readonly toastService = inject(NotificationManagerService);\n  private readonly router = inject(Router);\n  private readonly walletService = inject(WalletService);\n  private readonly profileService = inject(ProfileService);\n\n  readonly disputeId = input.required<string>();\n  readonly closeDetail = output<void>();\n\n  readonly dispute = signal<Dispute | null>(null);\n  readonly evidence = signal<DisputeEvidence[]>([]);\n  readonly loading = signal(true);\n  readonly sendingMessage = signal(false);\n  readonly currentUserId = signal<string | null>(null);\n  readonly isAdmin = signal(false);\n\n  // Mensaje de respuesta\n  newMessage = '';\n\n  // Admin Resolution Form\n  adminResolutionAmount: number | null = null;\n  adminResolutionParty: 'renter' | 'owner' | '' = '';\n\n  readonly canAcceptResolution = computed(() => {\n    const dispute = this.dispute();\n    if (!dispute || dispute.status !== 'in_review') return false;\n    return dispute.responsible_party_id === this.currentUserId();\n  });\n\n  async ngOnInit(): Promise<void> {\n    const user = await this.authService.getCurrentUser();\n    this.currentUserId.set(user?.id || null);\n    \n    if (user) {\n      try {\n        const profile = await this.profileService.getProfileById(user.id);\n        this.isAdmin.set(!!profile?.is_admin);\n      } catch (e) {\n        console.warn('Error checking admin status', e);\n      }\n    }\n\n    await this.loadDisputeDetails();\n  }\n\n  async loadDisputeDetails(): Promise<void> {\n    this.loading.set(true);\n    try {\n      const disputeData = await this.disputesService.getDisputeById(this.disputeId());\n      this.dispute.set(disputeData || null);\n\n      const evidenceData = await this.disputesService.listEvidence(this.disputeId());\n      this.evidence.set(evidenceData);\n    } catch (error) {\n      console.error('Error loading dispute details:', error);\n      this.toastService.error('Error al cargar la disputa', 'Por favor intenta nuevamente.');\n      this.closeDetail.emit();\n    } finally {\n      this.loading.set(false);\n    }\n  }\n\n  // Enviar mensaje o respuesta a la disputa\n  async sendMessage(): Promise<void> {\n    if (!this.newMessage.trim() || this.sendingMessage()) return;\n\n    this.sendingMessage.set(true);\n    try {\n      await this.disputesService.addEvidence(this.disputeId(), '', this.newMessage);\n      this.newMessage = '';\n      await this.loadDisputeDetails();\n      this.toastService.success('Mensaje enviado', '');\n    } catch (error) {\n      console.error('Error sending message:', error);\n      this.toastService.error('Error al enviar mensaje', '');\n    } finally {\n      this.sendingMessage.set(false);\n    }\n  }\n\n  async acceptResolution(): Promise<void> {\n    const dispute = this.dispute();\n    if (!dispute || !this.canAcceptResolution()) return;\n\n    if (dispute.resolution_amount && dispute.resolution_amount > 0) {\n      this.router.navigate(['/wallet/deposit'], {\n        queryParams: { amount: dispute.resolution_amount, purpose: 'dispute_resolution', disputeId: dispute.id }\n      });\n      this.toastService.info('Redirigiendo para pagar resolución', 'Completa el pago en tu wallet.');\n      this.closeDetail.emit();\n    } else {\n      if (confirm('¿Confirmas que aceptas la resolución de esta disputa?')) {\n        this.loading.set(true);\n        try {\n          await this.disputesService.resolveDispute(dispute.id, 'resolved');\n          this.toastService.success('Resolución aceptada', 'La disputa ha sido marcada como resuelta.');\n          this.closeDetail.emit();\n        } catch (error) {\n          console.error('Error accepting dispute resolution:', error);\n          this.toastService.error('Error al aceptar resolución', 'Por favor intenta nuevamente.');\n        } finally {\n          this.loading.set(false);\n        }\n      }\n    }\n  }\n\n  async resolveAsAdmin(status: DisputeStatus): Promise<void> {\n    if (!this.isAdmin()) return;\n    if (status === 'resolved' && !this.adminResolutionParty) {\n      this.toastService.error('Debes seleccionar la parte responsable', '');\n      return;\n    }\n\n    if (confirm(`¿Confirmas resolver esta disputa como ${status === 'resolved' ? 'Aprobada' : 'Rechazada'}?`)) {\n      this.loading.set(true);\n      try {\n        const dispute = this.dispute();\n        if (!dispute) return;\n\n        // Determinar responsiblePartyId\n        let responsiblePartyId: string | null = null;\n        if (this.adminResolutionParty === 'renter') {\n          // Necesitamos el ID del renter. Lo sacamos de la reserva o asumiendo roles.\n          // Para simplificar, si el creador es owner, el renter es el otro ID en la reserva (no tenemos acceso directo aquí sin cargar la reserva).\n          // Por ahora, asumiremos que disputesService.resolveDispute puede manejar la lógica o necesitamos cargar la reserva.\n          // Mejor: Cargar la reserva para obtener los IDs correctos.\n          // WORKAROUND: Asignar el ID basándonos en quien abrió la disputa.\n          // Si opened_by es renter, y party es renter -> responsible = opened_by\n          // Si opened_by es owner, y party es owner -> responsible = opened_by\n          // Esto es frágil. Lo ideal es obtener la reserva.\n          // Vamos a cargar la reserva en ngOnInit o aquí.\n        }\n        \n        // Simplemente pasamos lo que tenemos, la lógica completa de admin debería ser más robusta\n        // Para este MVP, si el admin elige 'renter', intentaremos inferirlo o dejarlo nulo si no podemos.\n        // Pero necesitamos IDs reales.\n        \n        // REVISIÓN: El backend o el servicio deberían encargarse de esto, o traer la reserva completa.\n        // Asumiremos que el admin conoce los IDs o que el componente carga la reserva.\n        // Vamos a modificar loadDisputeDetails para traer la reserva si es necesario, o hacer un fetch rápido aquí.\n        \n        // Fetch booking to get participants\n        const { data: booking } = await this.disputesService['supabase'].from('bookings').select('owner_id, renter_id').eq('id', dispute.booking_id).single();\n        \n        if (booking) {\n           if (this.adminResolutionParty === 'owner') responsiblePartyId = booking.owner_id;\n           if (this.adminResolutionParty === 'renter') responsiblePartyId = booking.renter_id;\n        }\n\n        await this.disputesService.resolveDispute(\n          dispute.id,\n          status,\n          this.adminResolutionAmount,\n          'USD', // Default currency\n          responsiblePartyId\n        );\n        \n        this.toastService.success('Disputa resuelta por admin', '');\n        this.closeDetail.emit();\n      } catch (error) {\n        console.error('Error resolving as admin:', error);\n        this.toastService.error('Error al resolver', '');\n      } finally {\n        this.loading.set(false);\n      }\n    }\n  }\n\n  getStatusLabel(status: Dispute['status']): string {\n    const labels: Record<Dispute['status'], string> = {\n      open: 'Abierta',\n      in_review: 'En revisión',\n      resolved: 'Resuelta',\n      rejected: 'Rechazada',\n    };\n    return labels[status] || status;\n  }\n\n  getKindLabel(kind: Dispute['kind']): string {\n    const labels: Record<Dispute['kind'], string> = {\n      damage: 'Daños',\n      no_show: 'No se presentó',\n      late_return: 'Devolución tardía',\n      other: 'Otro',\n    };\n    return labels[kind] || kind;\n  }\n\n  isMyMessage(evidence: DisputeEvidence): boolean {\n    return !evidence.path; \n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/features/driver-profile/driver-profile.page.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`@core/services/ui/meta.service` import should occur before import of `../../shared/components/class-benefits-modal/class-benefits-modal.component`","line":9,"column":1,"nodeType":"ImportDeclaration","endLine":9,"endColumn":62,"fix":{"range":[393,578],"text":"import { MetaService } from '@core/services/ui/meta.service';\nimport { ClassBenefitsModalComponent } from '../../shared/components/class-benefits-modal/class-benefits-modal.component';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import {Component, computed, inject, OnInit,\n  ChangeDetectionStrategy} from '@angular/core';\n\nimport { IonicModule, ModalController, AlertController } from '@ionic/angular';\nimport { RouterLink } from '@angular/router';\nimport { DriverProfileService } from '@core/services/auth/driver-profile.service';\nimport { BonusProtectorService } from '@core/services/payments/bonus-protector.service';\nimport { ClassBenefitsModalComponent } from '../../shared/components/class-benefits-modal/class-benefits-modal.component';\nimport { MetaService } from '@core/services/ui/meta.service';\n\n/**\n * DriverProfilePage - Perfil de Conductor Estilo Aseguradora\n *\n * Página dedicada con diseño profesional de seguros que muestra:\n * - Dashboard visual con clase actual y beneficios\n * - Score telemático con gráficos\n * - Historial detallado de siniestros\n * - Sistema Bonus-Malus explicado visualmente\n * - Estado de protecciones activas\n * - Comparativa con otras clases\n */\n\n@Component({\n  standalone: true,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  selector: 'app-driver-profile-page',\n  imports: [IonicModule, RouterLink],\n  template: `\n    <ion-header class=\"header-primary\">\n      <ion-toolbar>\n        <ion-buttons slot=\"start\">\n          <ion-back-button defaultHref=\"/profile\" color=\"light\"></ion-back-button>\n        </ion-buttons>\n        <ion-title>Mi Perfil de Conductor</ion-title>\n        <ion-buttons slot=\"end\">\n          <ion-button fill=\"clear\" color=\"light\" (click)=\"showSystemExplanation()\">\n            <ion-icon slot=\"icon-only\" name=\"help-circle-outline\"></ion-icon>\n          </ion-button>\n        </ion-buttons>\n      </ion-toolbar>\n    </ion-header>\n    \n    <ion-content class=\"profile-content\">\n      <!-- Loading State -->\n      @if (driverService.loading()) {\n        <div class=\"loading-section\">\n          <ion-card>\n            <ion-card-content class=\"loading-content\">\n              <ion-spinner name=\"crescent\" color=\"primary\"></ion-spinner>\n              <p>Cargando tu perfil de conductor...</p>\n            </ion-card-content>\n          </ion-card>\n        </div>\n      }\n    \n      <!-- Profile Loaded -->\n      @if (!driverService.loading() && profile()) {\n        <div>\n          <!-- Hero Section - Class Overview -->\n          <div class=\"hero-section\">\n            <ion-card class=\"hero-card\">\n              <ion-card-content>\n                <div class=\"hero-content\">\n                  <div class=\"class-display\">\n                    <div class=\"class-badge\" [class]=\"getClassStyle()\">\n                      <div class=\"class-number\">{{ driverClass() }}</div>\n                      <div class=\"class-label\">CLASE</div>\n                    </div>\n                    <div class=\"class-info\">\n                      <h1>{{ getClassTitle() }}</h1>\n                      <p class=\"class-description\">{{ classDescription() }}</p>\n                      <div class=\"benefit-highlight\" [class]=\"getBenefitStyle()\">\n                        <ion-icon [name]=\"getBenefitIcon()\"></ion-icon>\n                        <span>{{ getBenefitText() }}</span>\n                      </div>\n                    </div>\n                  </div>\n                  <!-- Status Indicator -->\n                  <div class=\"status-indicator\">\n                    <div class=\"status-dot\" [class]=\"getStatusColor()\"></div>\n                    <span class=\"status-text\">{{ getStatusText() }}</span>\n                  </div>\n                </div>\n              </ion-card-content>\n            </ion-card>\n          </div>\n          <!-- Protection Status -->\n          @if (!bonusProtectorService.loading()) {\n            <div class=\"protection-section\">\n              <ion-card class=\"protection-card\" [class]=\"getProtectionCardStyle()\">\n                <ion-card-content>\n                  <div class=\"protection-header\">\n                    <ion-icon\n                      [name]=\"getProtectionIcon()\"\n                      [color]=\"getProtectionIconColor()\"\n                    ></ion-icon>\n                    <div class=\"protection-info\">\n                      <h3>{{ getProtectionTitle() }}</h3>\n                      <p>{{ getProtectionMessage() }}</p>\n                    </div>\n                    @if (needsProtection()) {\n                      <ion-button\n                        fill=\"solid\"\n                        size=\"small\"\n                        (click)=\"buyProtection()\"\n                        >\n                        Proteger\n                      </ion-button>\n                    }\n                  </div>\n                </ion-card-content>\n              </ion-card>\n            </div>\n          }\n          <!-- Score Telemático -->\n          <div class=\"score-section\">\n            <ion-card>\n              <ion-card-header>\n                <ion-card-title>\n                  <ion-icon name=\"analytics-outline\" color=\"primary\"></ion-icon>\n                  Score Telemático\n                </ion-card-title>\n              </ion-card-header>\n              <ion-card-content>\n                <div class=\"score-display\">\n                  <div class=\"score-gauge\">\n                    <svg viewBox=\"0 0 200 120\" class=\"gauge-svg\">\n                      <!-- Background arc -->\n                      <path\n                        d=\"M 20 100 A 80 80 0 0 1 180 100\"\n                        stroke=\"#e0e0e0\"\n                        stroke-width=\"20\"\n                        fill=\"none\"\n                      ></path>\n                      <!-- Score arc -->\n                      <path\n                        d=\"M 20 100 A 80 80 0 0 1 180 100\"\n                        [attr.stroke]=\"getScoreColor()\"\n                        stroke-width=\"20\"\n                        fill=\"none\"\n                        [attr.stroke-dasharray]=\"getScoreArcLength()\"\n                        [attr.stroke-dashoffset]=\"getScoreArcOffset()\"\n                        class=\"score-arc\"\n                      ></path>\n                    </svg>\n                    <div class=\"score-number\">\n                      <span class=\"score-value\">{{ driverScore() }}</span>\n                      <span class=\"score-max\">/100</span>\n                    </div>\n                  </div>\n                  <div class=\"score-breakdown\">\n                    <div class=\"score-category\">\n                      <div class=\"category-bar\">\n                        <div\n                          class=\"bar-fill\"\n                          [style.width]=\"getSpeedScore() + '%'\"\n                          [style.background]=\"'var(--system-blue-default, #3880ff)'\"\n                        ></div>\n                      </div>\n                      <span>Velocidad: {{ getSpeedScore() }}%</span>\n                    </div>\n                    <div class=\"score-category\">\n                      <div class=\"category-bar\">\n                        <div\n                          class=\"bar-fill\"\n                          [style.width]=\"getBrakingScore() + '%'\"\n                          [style.background]=\"'var(--success-default, #2dd36f)'\"\n                        ></div>\n                      </div>\n                      <span>Frenado: {{ getBrakingScore() }}%</span>\n                    </div>\n                    <div class=\"score-category\">\n                      <div class=\"category-bar\">\n                        <div\n                          class=\"bar-fill\"\n                          [style.width]=\"getAccelerationScore() + '%'\"\n                          [style.background]=\"'var(--warning-default, #ffc409)'\"\n                        ></div>\n                      </div>\n                      <span>Aceleración: {{ getAccelerationScore() }}%</span>\n                    </div>\n                  </div>\n                </div>\n                <p class=\"score-message\">{{ getScoreMessage() }}</p>\n              </ion-card-content>\n            </ion-card>\n          </div>\n          <!-- Benefits Comparison -->\n          <div class=\"benefits-section\">\n            <ion-card>\n              <ion-card-header>\n                <ion-card-title>\n                  <ion-icon name=\"trophy-outline\" color=\"warning\"></ion-icon>\n                  Tus Beneficios Actuales\n                </ion-card-title>\n              </ion-card-header>\n              <ion-card-content>\n                <div class=\"benefits-grid\">\n                  <div class=\"benefit-item\" [class]=\"getFeeStyle()\">\n                    <div class=\"benefit-icon\">\n                      <ion-icon [name]=\"getFeeIcon()\"></ion-icon>\n                    </div>\n                    <div class=\"benefit-content\">\n                      <h4>Tarifa de Servicio</h4>\n                      <p class=\"benefit-value\">{{ getFeeText() }}</p>\n                      <p class=\"benefit-description\">{{ getFeeDescription() }}</p>\n                    </div>\n                  </div>\n                  <div class=\"benefit-item\" [class]=\"getGuaranteeStyle()\">\n                    <div class=\"benefit-icon\">\n                      <ion-icon [name]=\"getGuaranteeIcon()\"></ion-icon>\n                    </div>\n                    <div class=\"benefit-content\">\n                      <h4>Garantía</h4>\n                      <p class=\"benefit-value\">{{ getGuaranteeText() }}</p>\n                      <p class=\"benefit-description\">{{ getGuaranteeDescription() }}</p>\n                    </div>\n                  </div>\n                </div>\n              </ion-card-content>\n            </ion-card>\n          </div>\n          <!-- Claims History -->\n          <div class=\"claims-section\">\n            <ion-card>\n              <ion-card-header>\n                <ion-card-title>\n                  <ion-icon name=\"document-text-outline\" color=\"medium\"></ion-icon>\n                  Historial de Siniestros\n                </ion-card-title>\n              </ion-card-header>\n              <ion-card-content>\n                <div class=\"claims-overview\">\n                  <div class=\"claim-metric\">\n                    <div class=\"metric-number total\">{{ profile()?.total_claims || 0 }}</div>\n                    <p>Total de Siniestros</p>\n                  </div>\n                  <div class=\"claim-metric\">\n                    <div class=\"metric-number fault\">{{ profile()?.claims_with_fault || 0 }}</div>\n                    <p>Con Responsabilidad</p>\n                  </div>\n                  <div class=\"claim-metric\">\n                    <div class=\"metric-number good\">{{ profile()?.good_years || 0 }}</div>\n                    <p>Años Sin Siniestros</p>\n                  </div>\n                </div>\n                @if (profile()?.last_claim_at) {\n                  <div class=\"claims-timeline\">\n                    <div class=\"timeline-item\">\n                      <div class=\"timeline-dot\"></div>\n                      <div class=\"timeline-content\">\n                        <h4>Último Siniestro</h4>\n                        <p>{{ formatDate(profile()?.last_claim_at) }}</p>\n                        <ion-badge [color]=\"profile()?.last_claim_with_fault ? 'danger' : 'medium'\">\n                          {{\n                          profile()?.last_claim_with_fault\n                          ? 'Con responsabilidad'\n                          : 'Sin responsabilidad'\n                          }}\n                        </ion-badge>\n                      </div>\n                    </div>\n                  </div>\n                }\n                @if (!profile()?.total_claims) {\n                  <div class=\"no-claims\">\n                    <ion-icon name=\"checkmark-circle-outline\" color=\"success\"></ion-icon>\n                    <p>¡Excelente! No tienes siniestros registrados</p>\n                  </div>\n                }\n              </ion-card-content>\n            </ion-card>\n          </div>\n          <!-- Class Progression -->\n          <div class=\"progression-section\">\n            <ion-card>\n              <ion-card-header>\n                <ion-card-title>\n                  <ion-icon name=\"trending-up-outline\" color=\"success\"></ion-icon>\n                  Progreso de Clase\n                </ion-card-title>\n              </ion-card-header>\n              <ion-card-content>\n                <div class=\"class-ladder\">\n                  @for (classItem of getClassLadder(); track classItem) {\n                    <div\n                      class=\"ladder-item\"\n                      [class.current]=\"classItem.class === driverClass()\"\n                      [class.better]=\"classItem.class < driverClass()\"\n                      [class.worse]=\"classItem.class > driverClass()\"\n                      >\n                      <div class=\"ladder-class\">{{ classItem.class }}</div>\n                      <div class=\"ladder-info\">\n                        <h4>{{ classItem.title }}</h4>\n                        <p>{{ classItem.benefit }}</p>\n                      </div>\n                      <div class=\"ladder-status\">\n                        @if (classItem.class === driverClass()) {\n                          <ion-icon\n                            name=\"location\"\n                            color=\"primary\"\n                          ></ion-icon>\n                        }\n                        @if (classItem.class < driverClass()) {\n                          <ion-icon\n                            name=\"arrow-up\"\n                            color=\"success\"\n                          ></ion-icon>\n                        }\n                        @if (classItem.class > driverClass()) {\n                          <ion-icon\n                            name=\"arrow-down\"\n                            color=\"danger\"\n                          ></ion-icon>\n                        }\n                      </div>\n                    </div>\n                  }\n                </div>\n                @if (canImprove()) {\n                  <div class=\"progression-message\">\n                    <ion-icon name=\"information-circle-outline\" color=\"primary\"></ion-icon>\n                    <p>\n                      Mantén un historial limpio por\n                      <strong>{{ yearsToImprove() }} año{{ yearsToImprove() > 1 ? 's' : '' }}</strong>\n                      para mejorar a Clase {{ getNextBetterClass() }}\n                    </p>\n                  </div>\n                }\n              </ion-card-content>\n            </ion-card>\n          </div>\n          <!-- Quick Actions -->\n          <div class=\"actions-section\">\n            <ion-grid>\n              <ion-row>\n                <ion-col size=\"6\">\n                  <ion-button expand=\"block\" fill=\"outline\" [routerLink]=\"['/wallet']\">\n                    <ion-icon slot=\"start\" name=\"wallet-outline\"></ion-icon>\n                    Mi Wallet\n                  </ion-button>\n                </ion-col>\n                <ion-col size=\"6\">\n                  <ion-button expand=\"block\" fill=\"outline\" [routerLink]=\"['/protections']\">\n                    <ion-icon slot=\"start\" name=\"shield-checkmark-outline\"></ion-icon>\n                    Proteger\n                  </ion-button>\n                </ion-col>\n              </ion-row>\n            </ion-grid>\n          </div>\n        </div>\n      }\n    \n      <!-- No Profile State -->\n      @if (!driverService.loading() && !profile()) {\n        <div class=\"no-profile-section\">\n          <ion-card>\n            <ion-card-content class=\"no-profile-content\">\n              <ion-icon name=\"person-add-outline\" color=\"medium\"></ion-icon>\n              <h2>Crear Perfil de Conductor</h2>\n              <p>Inicia tu perfil de riesgo para acceder a beneficios y descuentos</p>\n              <ion-button expand=\"block\" (click)=\"initializeProfile()\"> Crear Perfil </ion-button>\n            </ion-card-content>\n          </ion-card>\n        </div>\n      }\n    </ion-content>\n    `,\n  styles: [\n    `\n      /* ===== GLOBAL VARIABLES ===== */\n      :host {\n        --gradient-primary: var(\n          --cta-default,\n          #667eea\n        ); /* Replaced gradient with solid color token */\n        --gradient-success: var(\n          --success-default,\n          #11998e\n        ); /* Replaced gradient with solid color token */\n        --gradient-warning: var(\n          --warning-default,\n          #f093fb\n        ); /* Replaced gradient with solid color token */\n        --gradient-danger: var(\n          --error-default,\n          #fc466b\n        ); /* Replaced gradient with solid color token */\n        --shadow-soft: 0 4px 20px rgba(0, 0, 0, 0.08);\n        --shadow-medium: 0 8px 32px rgba(0, 0, 0, 0.12);\n        --shadow-strong: 0 12px 48px rgba(0, 0, 0, 0.15);\n        --border-radius: 16px;\n        --border-radius-large: 24px;\n        --spacing-xs: 4px;\n        --spacing-sm: 8px;\n        --spacing-md: 16px;\n        --spacing-lg: 24px;\n        --spacing-xl: 32px;\n      }\n\n      /* ===== HEADER ===== */\n      .header-primary {\n        --background: var(--gradient-primary);\n        box-shadow: var(--shadow-soft);\n      }\n\n      .profile-content {\n        --background: var(--surface-base, #f8fafc); /* Replaced gradient with solid color token */\n        --padding-top: 0;\n        --padding-bottom: var(--spacing-lg);\n        --padding-start: 0;\n        --padding-end: 0;\n        position: relative;\n        min-height: 100vh;\n      }\n\n      .profile-content::before {\n        content: '';\n        position: absolute;\n        top: 0;\n        left: 0;\n        right: 0;\n        height: 120px;\n        background: var(--gradient-primary);\n        z-index: -1;\n      }\n\n      /* ===== LOADING & EMPTY STATES ===== */\n      .loading-section,\n      .no-profile-section {\n        padding: var(--spacing-lg);\n        margin-top: 60px;\n      }\n\n      .loading-content,\n      .no-profile-content {\n        text-align: center;\n        padding: var(--spacing-xl) var(--spacing-lg);\n        background: #E3E3E3;\n        backdrop-filter: blur(10px);\n        border-radius: var(--border-radius-large);\n        box-shadow: var(--shadow-medium);\n      }\n\n      .loading-content ion-spinner {\n        margin-bottom: var(--spacing-md);\n        --color: var(--ion-color-primary);\n      }\n\n      .no-profile-content ion-icon {\n        font-size: 4rem;\n        margin-bottom: var(--spacing-lg);\n        color: var(--ion-color-medium);\n      }\n\n      .no-profile-content h2 {\n        color: var(--ion-color-dark);\n        font-weight: 600;\n        margin-bottom: var(--spacing-sm);\n      }\n\n      .no-profile-content p {\n        color: var(--ion-color-medium);\n        margin-bottom: var(--spacing-lg);\n      }\n\n      /* ===== HERO SECTION ===== */\n      .hero-section {\n        padding: var(--spacing-lg) var(--spacing-md) 0;\n        margin-top: 40px;\n      }\n\n      .hero-card {\n        background: #E3E3E3;\n        backdrop-filter: blur(20px);\n        border: 1px solid rgba(255, 255, 255, 0.2);\n        box-shadow: var(--shadow-strong);\n        border-radius: var(--border-radius-large);\n        margin: 0;\n        overflow: hidden;\n        position: relative;\n      }\n\n      .hero-card::before {\n        content: '';\n        position: absolute;\n        top: 0;\n        left: 0;\n        right: 0;\n        height: 4px;\n        background: var(--gradient-primary);\n      }\n\n      .hero-content {\n        display: flex;\n        justify-content: space-between;\n        align-items: flex-start;\n        padding: var(--spacing-lg);\n      }\n\n      .class-display {\n        display: flex;\n        align-items: center;\n        gap: var(--spacing-lg);\n      }\n\n      .class-badge {\n        display: flex;\n        flex-direction: column;\n        align-items: center;\n        justify-content: center;\n        width: 100px;\n        height: 100px;\n        border-radius: 50%;\n        border: 4px solid;\n        position: relative;\n        background: white;\n        box-shadow: var(--shadow-medium);\n        transition: all 0.3s ease;\n      }\n\n      .class-badge::after {\n        content: '';\n        position: absolute;\n        inset: -8px;\n        border-radius: 50%;\n        padding: 4px;\n        background: transparent; /* Removed gradient */\n        mask:\n          linear-gradient(#fff 0 0) content-box,\n          linear-gradient(#fff 0 0);\n        mask-composite: exclude;\n        animation: shimmer 3s linear infinite;\n      }\n\n      @keyframes shimmer {\n        0% {\n          transform: rotate(0deg);\n        }\n        100% {\n          transform: rotate(360deg);\n        }\n      }\n\n      .class-badge.excellent {\n        border-color: #10b981;\n        background: var(\n          --surface-success-light,\n          #ecfdf5\n        ); /* Replaced gradient with solid color token */\n        color: #065f46;\n      }\n      .class-badge.good {\n        border-color: #3b82f6;\n        background: var(\n          --surface-info-light,\n          #eff6ff\n        ); /* Replaced gradient with solid color token */\n        color: #1e40af;\n      }\n      .class-badge.base {\n        border-color: #6b7280;\n        background: var(\n          --surface-light-subtle,\n          #f9fafb\n        ); /* Replaced gradient with solid color token */\n        color: #374151;\n      }\n      .class-badge.risk {\n        border-color: #f59e0b;\n        background: var(\n          --surface-warning-light,\n          #fffbeb\n        ); /* Replaced gradient with solid color token */\n        color: #92400e;\n      }\n      .class-badge.high-risk {\n        border-color: #ef4444;\n        background: var(\n          --surface-error-light,\n          #fef2f2\n        ); /* Replaced gradient with solid color token */\n        color: #991b1b;\n      }\n\n      .class-number {\n        font-size: 2.5rem;\n        font-weight: 900;\n        line-height: 1;\n        text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n      }\n\n      .class-label {\n        font-size: 0.7rem;\n        font-weight: 700;\n        letter-spacing: 0.1em;\n        text-transform: uppercase;\n        opacity: 0.7;\n        margin-top: 2px;\n      }\n\n      .class-info h1 {\n        font-size: 1.75rem;\n        font-weight: 800;\n        margin: 0 0 var(--spacing-sm) 0;\n        background: var(--gradient-primary);\n        -webkit-background-clip: text;\n        -webkit-text-fill-color: transparent;\n        background-clip: text;\n      }\n\n      .class-description {\n        color: var(--ion-color-medium);\n        margin: 0 0 var(--spacing-md) 0;\n        font-size: 1rem;\n        line-height: 1.4;\n      }\n\n      .benefit-highlight {\n        display: inline-flex;\n        align-items: center;\n        gap: var(--spacing-sm);\n        padding: var(--spacing-sm) var(--spacing-md);\n        border-radius: 24px;\n        font-size: 0.875rem;\n        font-weight: 600;\n        backdrop-filter: blur(10px);\n        box-shadow: var(--shadow-soft);\n        transition: all 0.3s ease;\n      }\n\n      .benefit-highlight:hover {\n        transform: translateY(-2px);\n        box-shadow: var(--shadow-medium);\n      }\n\n      .benefit-highlight.discount {\n        background: var(\n          --surface-success-light,\n          rgba(16, 185, 129, 0.15)\n        ); /* Replaced gradient with solid color token */\n        color: #059669;\n        border: 1px solid rgba(16, 185, 129, 0.2);\n      }\n\n      .benefit-highlight.surcharge {\n        background: var(\n          --surface-error-light,\n          rgba(239, 68, 68, 0.15)\n        ); /* Replaced gradient with solid color token */\n        color: #dc2626;\n        border: 1px solid rgba(239, 68, 68, 0.2);\n      }\n\n      .benefit-highlight.neutral {\n        background: var(\n          --surface-light-muted,\n          rgba(107, 114, 128, 0.15)\n        ); /* Replaced gradient with solid color token */\n        color: #4b5563;\n        border: 1px solid rgba(107, 114, 128, 0.2);\n      }\n\n      .status-indicator {\n        display: flex;\n        flex-direction: column;\n        align-items: center;\n        gap: var(--spacing-sm);\n      }\n\n      .status-dot {\n        width: 16px;\n        height: 16px;\n        border-radius: 50%;\n        position: relative;\n        box-shadow: var(--shadow-soft);\n      }\n\n      .status-dot::before {\n        content: '';\n        position: absolute;\n        inset: -4px;\n        border-radius: 50%;\n        background: inherit;\n        opacity: 0.3;\n        animation: pulse-ring 2s cubic-bezier(0.455, 0.03, 0.515, 0.955) infinite;\n      }\n\n      @keyframes pulse-ring {\n        0% {\n          transform: scale(0.8);\n          opacity: 0.3;\n        }\n        50% {\n          transform: scale(1.2);\n          opacity: 0.1;\n        }\n        100% {\n          transform: scale(1.4);\n          opacity: 0;\n        }\n      }\n\n      .status-dot.active {\n        background: #10b981;\n      }\n      .status-dot.warning {\n        background: #f59e0b;\n      }\n      .status-dot.danger {\n        background: #ef4444;\n      }\n\n      .status-text {\n        font-size: 0.75rem;\n        font-weight: 600;\n        color: var(--ion-color-dark);\n        text-transform: uppercase;\n        letter-spacing: 0.05em;\n      }\n\n      /* ===== PROTECTION SECTION ===== */\n      .protection-section {\n        padding: var(--spacing-md);\n      }\n\n      .protection-card {\n        margin: 0;\n        border-radius: var(--border-radius);\n        box-shadow: var(--shadow-soft);\n        overflow: hidden;\n        transition: all 0.3s ease;\n      }\n\n      .protection-card:hover {\n        transform: translateY(-2px);\n        box-shadow: var(--shadow-medium);\n      }\n\n      .protection-card.protected {\n        background: var(\n          --surface-success-light,\n          #ecfdf5\n        ); /* Replaced gradient with solid color token */\n        border: 2px solid #10b981;\n      }\n\n      .protection-card.needs-protection {\n        background: var(\n          --surface-warning-light,\n          #fffbeb\n        ); /* Replaced gradient with solid color token */\n        border: 2px solid #f59e0b;\n      }\n\n      .protection-card.coming-soon {\n        background: var(\n          --surface-light-subtle,\n          #f3f4f6\n        ); /* Replaced gradient with solid color token */\n        border: 2px solid #9ca3af;\n      }\n\n      .protection-header {\n        display: flex;\n        align-items: center;\n        gap: var(--spacing-md);\n        padding: var(--spacing-lg);\n      }\n\n      .protection-header ion-icon {\n        font-size: 2.5rem;\n        flex-shrink: 0;\n        background: white;\n        border-radius: 50%;\n        padding: var(--spacing-sm);\n        box-shadow: var(--shadow-soft);\n      }\n\n      .protection-info {\n        flex: 1;\n      }\n\n      .protection-info h3 {\n        margin: 0 0 var(--spacing-xs) 0;\n        font-size: 1.2rem;\n        font-weight: 700;\n        color: var(--ion-color-dark);\n      }\n\n      .protection-info p {\n        margin: 0;\n        font-size: 0.95rem;\n        color: var(--ion-color-medium);\n        line-height: 1.4;\n      }\n\n      /* ===== SCORE SECTION ===== */\n      .score-section {\n        padding: 0 var(--spacing-md) var(--spacing-md);\n      }\n\n      .score-section ion-card {\n        border-radius: var(--border-radius);\n        box-shadow: var(--shadow-medium);\n        overflow: hidden;\n        background: white;\n      }\n\n      .score-display {\n        display: flex;\n        gap: var(--spacing-xl);\n        align-items: center;\n        padding: var(--spacing-lg);\n      }\n\n      .score-gauge {\n        position: relative;\n        width: 220px;\n        height: 140px;\n        flex-shrink: 0;\n      }\n\n      .gauge-svg {\n        width: 100%;\n        height: 100%;\n        filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.1));\n      }\n\n      .score-arc {\n        transition: stroke-dashoffset 2s cubic-bezier(0.4, 0, 0.2, 1);\n        filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.1));\n      }\n\n      .score-number {\n        position: absolute;\n        bottom: 30px;\n        left: 50%;\n        transform: translateX(-50%);\n        text-align: center;\n      }\n\n      .score-value {\n        font-size: 3rem;\n        font-weight: 900;\n        color: var(--ion-color-dark);\n        text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n        display: block;\n      }\n\n      .score-max {\n        font-size: 1.1rem;\n        color: var(--ion-color-medium);\n        font-weight: 500;\n      }\n\n      .score-breakdown {\n        flex: 1;\n        display: flex;\n        flex-direction: column;\n        gap: var(--spacing-md);\n        min-width: 0;\n      }\n\n      .score-category {\n        display: flex;\n        flex-direction: column;\n        gap: var(--spacing-sm);\n      }\n\n      .score-category span {\n        font-size: 0.9rem;\n        font-weight: 600;\n        color: var(--ion-color-dark);\n      }\n\n      .category-bar {\n        height: 12px;\n        background: var(--surface-light-subtle, #f1f5f9);\n        border-radius: 6px;\n        overflow: hidden;\n        box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.05);\n      }\n\n      .bar-fill {\n        height: 100%;\n        border-radius: 6px;\n        transition: width 2s cubic-bezier(0.4, 0, 0.2, 1);\n        position: relative;\n        overflow: hidden;\n      }\n\n      .bar-fill::after {\n        content: '';\n        position: absolute;\n        top: 0;\n        left: 0;\n        right: 0;\n        height: 50%;\n        background: transparent; /* Removed gradient */\n        border-radius: 6px 6px 0 0;\n      }\n\n      .score-message {\n        text-align: center;\n        margin: var(--spacing-lg) 0 0 0;\n        font-style: italic;\n        color: var(--ion-color-medium);\n        font-size: 1rem;\n        background: #f8fafc;\n        padding: var(--spacing-md);\n        border-radius: var(--spacing-sm);\n        border-left: 4px solid var(--ion-color-primary);\n      }\n\n      /* ===== BENEFITS SECTION ===== */\n      .benefits-section,\n      .claims-section,\n      .progression-section {\n        padding: 0 var(--spacing-md) var(--spacing-md);\n      }\n\n      .benefits-section ion-card,\n      .claims-section ion-card,\n      .progression-section ion-card {\n        border-radius: var(--border-radius);\n        box-shadow: var(--shadow-medium);\n        background: white;\n        overflow: hidden;\n      }\n\n      .benefits-grid {\n        display: grid;\n        grid-template-columns: 1fr 1fr;\n        gap: var(--spacing-lg);\n        padding: var(--spacing-lg);\n      }\n\n      .benefit-item {\n        display: flex;\n        flex-direction: column;\n        align-items: center;\n        text-align: center;\n        padding: var(--spacing-xl) var(--spacing-lg);\n        border-radius: var(--border-radius);\n        border: 2px solid transparent;\n        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);\n        position: relative;\n        overflow: hidden;\n      }\n\n      .benefit-item::before {\n        content: '';\n        position: absolute;\n        top: 0;\n        left: 0;\n        right: 0;\n        height: 4px;\n      }\n\n      .benefit-item:hover {\n        transform: translateY(-4px);\n        box-shadow: var(--shadow-medium);\n      }\n\n      .benefit-item.discount {\n        background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%);\n        border-color: #16a34a;\n      }\n\n      .benefit-item.discount::before {\n        background: linear-gradient(90deg, #16a34a, #22c55e);\n      }\n\n      .benefit-item.surcharge {\n        background: linear-gradient(135deg, #fef2f2 0%, #fecaca 100%);\n        border-color: #dc2626;\n      }\n\n      .benefit-item.surcharge::before {\n        background: linear-gradient(90deg, #dc2626, #ef4444);\n      }\n\n      .benefit-item.neutral {\n        background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);\n        border-color: #64748b;\n      }\n\n      .benefit-item.neutral::before {\n        background: linear-gradient(90deg, #64748b, #94a3b8);\n      }\n\n      .benefit-icon {\n        width: 64px;\n        height: 64px;\n        border-radius: 50%;\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        margin-bottom: var(--spacing-md);\n        background: white;\n        box-shadow: var(--shadow-medium);\n        transition: transform 0.3s ease;\n      }\n\n      .benefit-item:hover .benefit-icon {\n        transform: scale(1.1);\n      }\n\n      .benefit-icon ion-icon {\n        font-size: 1.8rem;\n      }\n\n      .benefit-content h4 {\n        margin: 0 0 var(--spacing-sm) 0;\n        font-size: 1.1rem;\n        font-weight: 700;\n        color: var(--ion-color-dark);\n      }\n\n      .benefit-value {\n        margin: 0 0 var(--spacing-xs) 0;\n        font-size: 1.4rem;\n        font-weight: 800;\n        line-height: 1;\n      }\n\n      .benefit-description {\n        margin: 0;\n        font-size: 0.85rem;\n        color: var(--ion-color-medium);\n        font-weight: 500;\n      }\n\n      /* ===== CLAIMS SECTION ===== */\n      .claims-overview {\n        display: grid;\n        grid-template-columns: repeat(3, 1fr);\n        gap: var(--spacing-lg);\n        margin-bottom: var(--spacing-xl);\n        padding: var(--spacing-lg);\n      }\n\n      .claim-metric {\n        text-align: center;\n        padding: var(--spacing-lg);\n        background: var(\n          --surface-light-subtle,\n          #f8fafc\n        ); /* Replaced gradient with solid color token */\n        border-radius: var(--border-radius);\n        border: 1px solid #e2e8f0;\n        transition: all 0.3s ease;\n        position: relative;\n        overflow: hidden;\n      }\n\n      .claim-metric::before {\n        content: '';\n        position: absolute;\n        top: 0;\n        left: 0;\n        right: 0;\n        height: 3px;\n      }\n\n      .claim-metric:hover {\n        transform: translateY(-2px);\n        box-shadow: var(--shadow-soft);\n      }\n\n      .claim-metric:nth-child(1)::before {\n        background: var(--text-secondary, #64748b);\n      }\n      .claim-metric:nth-child(2)::before {\n        background: var(--error-default, #dc2626);\n      }\n      .claim-metric:nth-child(3)::before {\n        background: var(--success-default, #16a34a);\n      }\n\n      .metric-number {\n        font-size: 2.5rem;\n        font-weight: 900;\n        margin-bottom: var(--spacing-sm);\n        text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n      }\n\n      .metric-number.total {\n        color: var(--text-primary, #475569);\n      }\n      .metric-number.fault {\n        color: var(--error-default, #dc2626);\n      }\n      .metric-number.good {\n        color: var(--success-default, #16a34a);\n      }\n\n      .claim-metric p {\n        margin: 0;\n        font-size: 0.9rem;\n        color: var(--ion-color-medium);\n        font-weight: 600;\n      }\n\n      .claims-timeline {\n        border-left: 3px solid var(--border-default, #e2e8f0);\n        padding-left: var(--spacing-lg);\n        margin-left: var(--spacing-md);\n        margin-bottom: var(--spacing-lg);\n      }\n\n      .timeline-item {\n        position: relative;\n        padding-bottom: var(--spacing-lg);\n      }\n\n      .timeline-dot {\n        position: absolute;\n        left: -30px;\n        top: 6px;\n        width: 16px;\n        height: 16px;\n        border-radius: 50%;\n        background: var(--ion-color-primary);\n        border: 3px solid white;\n        box-shadow: var(--shadow-soft);\n        z-index: 1;\n      }\n\n      .timeline-content {\n        background: #f8fafc;\n        padding: var(--spacing-md);\n        border-radius: var(--spacing-sm);\n        border-left: 4px solid var(--ion-color-primary);\n      }\n\n      .timeline-content h4 {\n        margin: 0 0 var(--spacing-xs) 0;\n        font-size: 1.1rem;\n        font-weight: 700;\n        color: var(--ion-color-dark);\n      }\n\n      .timeline-content p {\n        margin: 0 0 var(--spacing-sm) 0;\n        font-size: 0.95rem;\n        color: var(--ion-color-medium);\n      }\n\n      .no-claims {\n        text-align: center;\n        padding: var(--spacing-xl);\n        background: var(\n          --surface-success-light,\n          #f0fdf4\n        ); /* Replaced gradient with solid color token */\n        border-radius: var(--border-radius);\n        margin: var(--spacing-lg);\n      }\n\n      .no-claims ion-icon {\n        font-size: 3.5rem;\n        margin-bottom: var(--spacing-md);\n        color: var(--success-default, #16a34a);\n      }\n\n      .no-claims p {\n        font-size: 1.1rem;\n        font-weight: 600;\n        color: var(--text-success-dark, #166534);\n        margin: 0;\n      }\n\n      /* ===== CLASS LADDER ===== */\n      .class-ladder {\n        display: flex;\n        flex-direction: column;\n        gap: var(--spacing-sm);\n        padding: var(--spacing-lg);\n      }\n\n      .ladder-item {\n        display: flex;\n        align-items: center;\n        gap: var(--spacing-md);\n        padding: var(--spacing-md);\n        border-radius: var(--spacing-sm);\n        transition: all 0.3s ease;\n        border: 2px solid transparent;\n        position: relative;\n        overflow: hidden;\n      }\n\n      .ladder-item::before {\n        content: '';\n        position: absolute;\n        left: 0;\n        top: 0;\n        bottom: 0;\n        width: 4px;\n        transition: width 0.3s ease;\n      }\n\n      .ladder-item:hover {\n        transform: translateX(4px);\n      }\n\n      .ladder-item.current {\n        background: var(\n          --surface-info-light,\n          #eff6ff\n        ); /* Replaced gradient with solid color token */\n        border-color: var(--system-blue-default, #3b82f6);\n        box-shadow: var(--shadow-soft);\n      }\n\n      .ladder-item.current::before {\n        background: var(--system-blue-default, #3b82f6);\n        width: 8px;\n      }\n\n      .ladder-item.better {\n        background: var(\n          --surface-success-light,\n          #f0fdf4\n        ); /* Replaced gradient with solid color token */\n        opacity: 0.9;\n      }\n\n      .ladder-item.better::before {\n        background: var(--success-default, #16a34a);\n      }\n\n      .ladder-item.worse {\n        background: var(\n          --surface-error-light,\n          #fef2f2\n        ); /* Replaced gradient with solid color token */\n        opacity: 0.5;\n      }\n\n      .ladder-item.worse::before {\n        background: var(--error-default, #dc2626);\n      }\n\n      .ladder-class {\n        width: 48px;\n        height: 48px;\n        border-radius: 50%;\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        font-weight: 900;\n        background: white;\n        box-shadow: var(--shadow-soft);\n        color: var(--ion-color-dark);\n        font-size: 1.2rem;\n        flex-shrink: 0;\n      }\n\n      .ladder-info {\n        flex: 1;\n        min-width: 0;\n      }\n\n      .ladder-info h4 {\n        margin: 0 0 var(--spacing-xs) 0;\n        font-size: 1rem;\n        font-weight: 700;\n        color: var(--ion-color-dark);\n      }\n\n      .ladder-info p {\n        margin: 0;\n        font-size: 0.85rem;\n        color: var(--ion-color-medium);\n        line-height: 1.3;\n      }\n\n      .ladder-status {\n        flex-shrink: 0;\n      }\n\n      .ladder-status ion-icon {\n        font-size: 1.5rem;\n      }\n\n      .progression-message {\n        display: flex;\n        align-items: center;\n        gap: var(--spacing-md);\n        padding: var(--spacing-lg);\n        background: var(\n          --surface-info-light,\n          #eff6ff\n        ); /* Replaced gradient with solid color token */\n        border-radius: var(--border-radius);\n        margin: var(--spacing-lg);\n        border: 1px solid var(--border-info-light, #bfdbfe);\n      }\n\n      .progression-message ion-icon {\n        font-size: 1.5rem;\n        flex-shrink: 0;\n      }\n\n      .progression-message p {\n        margin: 0;\n        font-size: 0.95rem;\n        color: var(--ion-color-dark);\n        line-height: 1.4;\n      }\n\n      /* ===== ACTIONS SECTION ===== */\n      .actions-section {\n        padding: var(--spacing-md);\n      }\n\n      .actions-section ion-button {\n        --border-radius: var(--border-radius);\n        --box-shadow: var(--shadow-soft);\n        font-weight: 600;\n        height: 48px;\n      }\n\n      .actions-section ion-button:hover {\n        --box-shadow: var(--shadow-medium);\n        transform: translateY(-2px);\n      }\n\n      /* ===== RESPONSIVE DESIGN ===== */\n      @media (max-width: 768px) {\n        .hero-content {\n          flex-direction: column;\n          gap: var(--spacing-lg);\n          text-align: center;\n        }\n\n        .class-display {\n          flex-direction: column;\n          gap: var(--spacing-md);\n        }\n\n        .class-badge {\n          width: 120px;\n          height: 120px;\n        }\n\n        .class-number {\n          font-size: 3rem;\n        }\n\n        .score-display {\n          flex-direction: column;\n          gap: var(--spacing-lg);\n        }\n\n        .score-gauge {\n          width: 200px;\n          height: 120px;\n        }\n\n        .benefits-grid {\n          grid-template-columns: 1fr;\n        }\n\n        .claims-overview {\n          grid-template-columns: 1fr;\n        }\n      }\n\n      @media (max-width: 480px) {\n        .class-badge {\n          width: 100px;\n          height: 100px;\n        }\n\n        .class-number {\n          font-size: 2.5rem;\n        }\n\n        .benefit-item {\n          padding: var(--spacing-lg);\n        }\n\n        .claim-metric {\n          padding: var(--spacing-md);\n        }\n\n        .metric-number {\n          font-size: 2rem;\n        }\n      }\n\n      /* ===== ACCESSIBILITY ===== */\n      @media (prefers-reduced-motion: reduce) {\n        *,\n        *::before,\n        *::after {\n          animation-duration: 0.01ms !important;\n          animation-iteration-count: 1 !important;\n          transition-duration: 0.01ms !important;\n        }\n      }\n\n      /* ===== DARK MODE SUPPORT ===== */\n      @media (prefers-color-scheme: dark) {\n        .profile-content {\n          --background: var(\n            --surface-base-dark,\n            #1e293b\n          ); /* Replaced gradient with solid color token */\n        }\n\n        .hero-card {\n          background: rgba(30, 41, 59, 0.95);\n          border-color: rgba(255, 255, 255, 0.1);\n        }\n\n        .benefit-item,\n        .claim-metric,\n        .protection-card {\n          background: rgba(30, 41, 59, 0.8);\n          border-color: rgba(255, 255, 255, 0.1);\n        }\n\n        .timeline-content,\n        .progression-message {\n          background: rgba(30, 41, 59, 0.6);\n        }\n      }\n    `,\n  ],\n})\nexport class DriverProfilePage implements OnInit {\n  protected readonly driverService = inject(DriverProfileService);\n  protected readonly bonusProtectorService = inject(BonusProtectorService);\n  private readonly modalController = inject(ModalController);\n  private readonly alertController = inject(AlertController);\n  private readonly metaService = inject(MetaService);\n\n  // Computed signals from services\n  readonly profile = computed(() => this.driverService.profile());\n  readonly driverClass = computed(() => this.driverService.driverClass());\n  readonly driverScore = computed(() => this.driverService.driverScore());\n  readonly hasDiscount = computed(() => this.driverService.hasDiscount());\n  readonly hasSurcharge = computed(() => this.driverService.hasSurcharge());\n  readonly feeDiscountPct = computed(() => this.driverService.feeDiscountPct());\n  readonly guaranteeDiscountPct = computed(() => this.driverService.guaranteeDiscountPct());\n  readonly classDescription = computed(() => this.driverService.getClassDescription());\n  readonly hasActiveProtector = computed(() => this.bonusProtectorService.hasActiveProtector());\n\n  ngOnInit(): void {\n    this.updateMeta();\n    this.loadData();\n  }\n\n  private async loadData(): Promise<void> {\n    try {\n      await this.driverService.ensureProfile();\n\n      // Intentar cargar protector activo, pero no fallar si no existe\n      try {\n        await this.bonusProtectorService.loadActiveProtector();\n        await this.bonusProtectorService.loadOptions();\n      } catch (protectorError) {\n        console.warn('[DriverProfilePage] Bonus protector service not available:', protectorError);\n        // Continuar sin el servicio de protector\n      }\n    } catch (error) {\n      console.error('[DriverProfilePage] Error loading data:', error);\n    }\n  }\n\n  async initializeProfile(): Promise<void> {\n    try {\n      await this.driverService.initializeProfile();\n    } catch (error) {\n      console.error('[DriverProfilePage] Error initializing profile:', error);\n    }\n  }\n\n  async showSystemExplanation(): Promise<void> {\n    const modal = await this.modalController.create({\n      component: ClassBenefitsModalComponent,\n      componentProps: {\n        currentClass: this.driverClass(),\n      },\n    });\n    await modal.present();\n  }\n\n  buyProtection(): void {\n    // Navigate to protections page\n    window.location.href = '/protections';\n  }\n\n  // Visual helpers\n  getClassStyle(): string {\n    const cls = this.driverClass();\n    if (cls <= 2) return 'excellent';\n    if (cls <= 4) return 'good';\n    if (cls === 5) return 'base';\n    if (cls <= 7) return 'risk';\n    return 'high-risk';\n  }\n\n  getClassTitle(): string {\n    const cls = this.driverClass();\n    if (cls <= 2) return 'Conductor Excelente';\n    if (cls <= 4) return 'Buen Conductor';\n    if (cls === 5) return 'Conductor Base';\n    if (cls <= 7) return 'Conductor de Riesgo';\n    return 'Alto Riesgo';\n  }\n\n  getBenefitStyle(): string {\n    if (this.hasDiscount()) return 'discount';\n    if (this.hasSurcharge()) return 'surcharge';\n    return 'neutral';\n  }\n\n  getBenefitIcon(): string {\n    if (this.hasDiscount()) return 'trending-down';\n    if (this.hasSurcharge()) return 'trending-up';\n    return 'remove';\n  }\n\n  getBenefitText(): string {\n    const fee = this.feeDiscountPct();\n    if (fee > 0) return `${fee}% de descuento`;\n    if (fee < 0) return `${Math.abs(fee)}% de recargo`;\n    return 'Sin ajustes';\n  }\n\n  getStatusColor(): string {\n    if (this.hasActiveProtector()) return 'active';\n    if (this.driverClass() > 5) return 'danger';\n    if (this.driverClass() > 3) return 'warning';\n    return 'active';\n  }\n\n  getStatusText(): string {\n    if (this.hasActiveProtector()) return 'Protegido';\n    if (this.driverClass() > 5) return 'Riesgo Alto';\n    if (this.driverClass() > 3) return 'Atención';\n    return 'Excelente';\n  }\n\n  getProtectionCardStyle(): string {\n    if (this.bonusProtectorService.error()) {\n      return 'coming-soon';\n    }\n    return this.hasActiveProtector() ? 'protected' : 'needs-protection';\n  }\n\n  getProtectionIcon(): string {\n    return this.hasActiveProtector() ? 'shield-checkmark' : 'shield-outline';\n  }\n\n  getProtectionIconColor(): string {\n    return this.hasActiveProtector() ? 'success' : 'warning';\n  }\n\n  getProtectionTitle(): string {\n    if (this.bonusProtectorService.error()) {\n      return 'Protección de Clase';\n    }\n    return this.hasActiveProtector() ? 'Protección Activa' : 'Sin Protección';\n  }\n\n  getProtectionMessage(): string {\n    if (this.bonusProtectorService.error()) {\n      return 'El sistema de protección estará disponible próximamente';\n    }\n    if (this.hasActiveProtector()) {\n      return 'Tu clase está protegida contra siniestros';\n    }\n    return 'Protege tu clase de conductor de siniestros inesperados';\n  }\n\n  needsProtection(): boolean {\n    // Solo mostrar la opción si el servicio de protector está disponible\n    if (this.bonusProtectorService.error()) {\n      return false;\n    }\n    // Permitir protección para cualquier clase (0-10)\n    // Los conductores de alto riesgo también necesitan proteger su clase\n    return !this.hasActiveProtector();\n  }\n\n  // Score helpers\n  getScoreColor(): string {\n    const score = this.driverScore();\n    if (score >= 80) return 'var(--success-default, #2dd36f)';\n    if (score >= 60) return 'var(--system-blue-default, #3880ff)';\n    if (score >= 40) return 'var(--warning-default, #ffc409)';\n    return 'var(--error-default, #eb445a)';\n  }\n\n  getScoreArcLength(): string {\n    const circumference = Math.PI * 80; // radius = 80\n    return `${circumference} ${circumference}`;\n  }\n\n  getScoreArcOffset(): string {\n    const circumference = Math.PI * 80;\n    const score = this.driverScore();\n    const offset = circumference - (score / 100) * circumference;\n    return offset.toString();\n  }\n\n  getScoreMessage(): string {\n    return this.driverService.getScoreMessage();\n  }\n\n  // Mock score breakdown (would come from service in real app)\n  getSpeedScore(): number {\n    return Math.round(Math.min(100, this.driverScore() + Math.random() * 20 - 10));\n  }\n\n  getBrakingScore(): number {\n    return Math.round(Math.min(100, this.driverScore() + Math.random() * 20 - 10));\n  }\n\n  getAccelerationScore(): number {\n    return Math.round(Math.min(100, this.driverScore() + Math.random() * 20 - 10));\n  }\n\n  // Benefit helpers\n  getFeeStyle(): string {\n    return this.getBenefitStyle();\n  }\n\n  getFeeIcon(): string {\n    return this.getBenefitIcon();\n  }\n\n  getFeeText(): string {\n    return this.getBenefitText();\n  }\n\n  getFeeDescription(): string {\n    if (this.hasDiscount()) return 'Pagas menos comisión';\n    if (this.hasSurcharge()) return 'Comisión adicional';\n    return 'Tarifa estándar';\n  }\n\n  getGuaranteeStyle(): string {\n    return this.getBenefitStyle();\n  }\n\n  getGuaranteeIcon(): string {\n    if (this.hasDiscount()) return 'shield-checkmark';\n    if (this.hasSurcharge()) return 'shield';\n    return 'shield-outline';\n  }\n\n  getGuaranteeText(): string {\n    const guarantee = this.guaranteeDiscountPct();\n    if (guarantee > 0) return `${guarantee}% menos garantía`;\n    if (guarantee < 0) return `${Math.abs(guarantee)}% más garantía`;\n    return 'Garantía estándar';\n  }\n\n  getGuaranteeDescription(): string {\n    if (this.hasDiscount()) return 'Menor depósito requerido';\n    if (this.hasSurcharge()) return 'Mayor depósito requerido';\n    return 'Depósito estándar';\n  }\n\n  // Class ladder\n  getClassLadder(): Array<{ class: number; title: string; benefit: string }> {\n    return [\n      { class: 0, title: 'Excelente', benefit: '15% descuento, 25% menos garantía' },\n      { class: 1, title: 'Muy Bueno', benefit: '12% descuento, 20% menos garantía' },\n      { class: 2, title: 'Bueno', benefit: '8% descuento, 15% menos garantía' },\n      { class: 3, title: 'Regular+', benefit: '4% descuento, 5% menos garantía' },\n      { class: 4, title: 'Regular', benefit: '2% descuento' },\n      { class: 5, title: 'Base', benefit: 'Sin ajustes' },\n      { class: 6, title: 'Riesgo Bajo', benefit: '5% recargo, 10% más garantía' },\n      { class: 7, title: 'Riesgo Medio', benefit: '10% recargo, 20% más garantía' },\n      { class: 8, title: 'Riesgo Alto', benefit: '15% recargo, 40% más garantía' },\n      { class: 9, title: 'Riesgo Muy Alto', benefit: '18% recargo, 60% más garantía' },\n      { class: 10, title: 'Riesgo Máximo', benefit: '20% recargo, 80% más garantía' },\n    ];\n  }\n\n  canImprove(): boolean {\n    return this.driverClass() > 0;\n  }\n\n  yearsToImprove(): number {\n    return 1; // Standard: 1 year without fault claims\n  }\n\n  getNextBetterClass(): number {\n    return Math.max(0, this.driverClass() - 1);\n  }\n\n  formatDate(dateString: string | null | undefined): string {\n    if (!dateString) return '';\n    const date = new Date(dateString);\n    const now = new Date();\n    const diffMs = now.getTime() - date.getTime();\n    const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));\n    const diffMonths = Math.floor(diffDays / 30);\n    const diffYears = Math.floor(diffDays / 365);\n\n    let relativeTime = '';\n    if (diffYears >= 1) {\n      relativeTime = `Hace ${diffYears} año${diffYears > 1 ? 's' : ''}`;\n    } else if (diffMonths >= 1) {\n      relativeTime = `Hace ${diffMonths} mes${diffMonths > 1 ? 'es' : ''}`;\n    } else if (diffDays >= 1) {\n      relativeTime = `Hace ${diffDays} día${diffDays > 1 ? 's' : ''}`;\n    } else {\n      relativeTime = 'Hoy';\n    }\n\n    const formattedDate = date.toLocaleDateString('es-AR', {\n      day: 'numeric',\n      month: 'short',\n      year: 'numeric',\n    });\n\n    return `${relativeTime} (${formattedDate})`;\n  }\n\n  private updateMeta(): void {\n    this.metaService.updateMeta({\n      title: 'Mi Perfil de Conductor - AutoRenta',\n      description:\n        'Revisa tu clase de conductor, beneficios y descuentos en el sistema Bonus-Malus.',\n      keywords: 'perfil conductor, bonus malus, descuentos, clase conductor, seguro',\n    });\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/features/explore/explore.page.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`../../core/models` import should occur after import of `@core/services/cars/car-availability.service`","line":29,"column":1,"nodeType":"ImportDeclaration","endLine":29,"endColumn":41,"fix":{"range":[703,1050],"text":"import { BreakpointService } from '@core/services/ui/breakpoint.service';\nimport type { CarMapLocation } from '@core/services/cars/car-locations.service';\nimport { CarsService } from '@core/services/cars/cars.service';\nimport { CarAvailabilityService } from '@core/services/cars/car-availability.service';\nimport { Car } from '../../core/models';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { LoggerService } from '@core/services/infrastructure/logger.service';\nimport { CommonModule } from '@angular/common';\nimport {AfterViewInit,\n  ChangeDetectionStrategy,\n  Component,\n  computed,\n  ElementRef,\n  OnInit,\n  signal,\n  ViewChild, inject} from '@angular/core';\nimport { FormsModule } from '@angular/forms';\nimport { Router } from '@angular/router';\nimport {\n  IonContent,\n  IonHeader,\n  IonIcon,\n  IonToolbar,\n  ToastController,\n} from '@ionic/angular/standalone';\nimport { addIcons } from 'ionicons';\nimport {\n  gridOutline,\n  listOutline,\n  locateOutline,\n  mapOutline,\n  optionsOutline,\n} from 'ionicons/icons';\nimport { LocationService } from '@core/services/geo/location.service';\nimport { Car } from '../../core/models';\nimport { BreakpointService } from '@core/services/ui/breakpoint.service';\nimport type { CarMapLocation } from '@core/services/cars/car-locations.service';\nimport { CarsService } from '@core/services/cars/cars.service';\nimport { CarAvailabilityService } from '@core/services/cars/car-availability.service';\nimport { CarsMapComponent } from '../../shared/components/cars-map/cars-map.component';\nimport { MapDrawerComponent } from '../../shared/components/map-drawer/map-drawer.component';\nimport {\n  FilterState,\n  MapFiltersComponent,\n} from '../../shared/components/map-filters/map-filters.component';\nimport { SORT_OPTIONS, SortOption } from '../../core/models/marketplace.model';\nimport { WazeLiveMapComponent } from '../../shared/components/waze-live-map/waze-live-map.component';\n\n@Component({\n  selector: 'app-explore',\n  templateUrl: './explore.page.html',\n  styleUrls: ['./explore.page.scss'],\n  standalone: true,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  imports: [\n    CommonModule,\n    FormsModule,\n    IonContent,\n    IonHeader,\n    IonToolbar,\n    IonIcon,\n    CarsMapComponent,\n    WazeLiveMapComponent,\n    MapFiltersComponent,\n    MapDrawerComponent,\n  ],\n})\nexport class ExplorePage implements OnInit, AfterViewInit {\n  private readonly logger = inject(LoggerService);\n  @ViewChild('mapContainer') mapContainer?: ElementRef<HTMLDivElement>;\n  @ViewChild('carouselContainer') carouselContainer?: ElementRef<HTMLDivElement>;\n  @ViewChild(CarsMapComponent) carsMap?: CarsMapComponent;\n\n  // Data\n  cars: Car[] = [];\n  filteredCars: Car[] = [];\n  loading = true;\n  searchQuery = '';\n\n  // State signals\n  readonly selectedCarId = signal<string | null>(null);\n  readonly isDrawerOpen = signal(false);\n  readonly isMobileView!: () => boolean;\n  readonly currentFilters = signal<FilterState | null>(null);\n  readonly userLocation = signal<{ lat: number; lng: number } | null>(null);\n  readonly viewMode = signal<'map' | 'grid' | 'list'>('list'); // Mobile-first: lista por defecto\n  readonly mapProvider = signal<'mapbox' | 'waze'>('mapbox'); // Map provider toggle\n\n  readonly sortOptions = SORT_OPTIONS;\n  readonly sortOrder = signal<SortOption>('distance');\n\n  // Computed\n  readonly selectedCar = computed<CarMapLocation | undefined>(() => {\n    const id = this.selectedCarId();\n    return id ? this.carMapLocations().find((c) => c['carId'] === id) : undefined;\n  });\n\n  readonly carMapLocations = computed(() => {\n    return this.filteredCars.map((car) => {\n      const gallery = this.extractPhotoGallery(car);\n      return {\n        carId: car['id'],\n        title: `${car.brand_text_backup || ''} ${car.model_text_backup || ''}`.trim(),\n        pricePerDay: car['price_per_day'],\n        currency: car['currency'] || 'ARS',\n        regionId: car.region_id,\n        lat: car['location_lat'] || 0,\n        lng: car['location_lng'] || 0,\n        updatedAt: car['updated_at'] || new Date().toISOString(),\n        city: car['location_city'],\n        state: car['location_state'],\n        country: car['location_country'],\n        locationLabel: car['location_city'] || 'Sin ubicación',\n        photoUrl: gallery[0] ?? null,\n        photoGallery: gallery,\n        description: car['description'],\n      };\n    });\n  });\n\n  constructor(\n    private carsService: CarsService,\n    private availabilityService: CarAvailabilityService,\n    private router: Router,\n    private breakpoint: BreakpointService,\n    private toastController: ToastController,\n    private locationService: LocationService,\n  ) {\n    addIcons({ optionsOutline, locateOutline, gridOutline, listOutline, mapOutline });\n    // Usar BreakpointService en lugar de window.innerWidth\n    this.isMobileView = this.breakpoint.isMobile;\n\n    // Set default view mode based on device\n    if (!this.isMobileView()) {\n      this.viewMode.set('grid');\n    }\n  }\n\n  ngOnInit(): void {\n    this.loadCars();\n    this.getUserLocation();\n  }\n\n  ngAfterViewInit(): void {\n    if (this.mapContainer?.nativeElement) {\n      // Aquí podría inicializarse lógica adicional de mapa si se requiere.\n    }\n  }\n\n  async loadCars() {\n    this.loading = true;\n    try {\n      const cars = await this.carsService.listActiveCars({});\n      this.cars = cars;\n      await this.applyFiltersAndSort();\n    } catch {\n      /* Silenced */\n    } finally {\n      this.loading = false;\n    }\n  }\n\n  async getUserLocation() {\n    try {\n      const position = await this.locationService.getCurrentPosition();\n      if (position) {\n        this.userLocation.set({\n          lat: position.lat,\n          lng: position.lng,\n        });\n      }\n    } catch (error) {\n      console['error']('Error getting location:', error);\n      const toast = await this.toastController.create({\n        message: 'No pudimos obtener tu ubicación. Por favor verifica los permisos.',\n        duration: 3000,\n        position: 'bottom',\n        color: 'warning',\n        icon: 'location-outline',\n      });\n      await toast.present();\n    }\n  }\n\n  /**\n   * 🎯 Handle map marker click\n   */\n  onMapCarSelected(carId: string) {\n    const previousCarId = this.selectedCarId();\n    this.selectedCarId.set(carId);\n\n    // Si es el mismo auto (doble click), navegar al detalle\n    if (previousCarId === carId) {\n      this.router.navigate(['/cars/detail', carId]);\n      return;\n    }\n\n    // Abrir drawer en desktop/mobile\n    this.isDrawerOpen.set(true);\n\n    // Scroll carousel en desktop si aplica\n    if (!this.isMobileView()) {\n      this.scrollToCarInCarousel(carId);\n    }\n  }\n\n  /**\n   * 🎯 Handle carousel card click\n   */\n  onCarouselCardSelected(carId: string) {\n    const previousCarId = this.selectedCarId();\n    this.selectedCarId.set(carId);\n\n    // Si es el mismo auto (doble click), navegar al detalle\n    if (previousCarId === carId) {\n      this.router.navigate(['/cars/detail', carId]);\n      return;\n    }\n\n    // Fly-to en mapa\n    if (this.carsMap) {\n      this.carsMap.flyToCarLocation(carId);\n    }\n  }\n\n  /**\n   * 🎯 Handle filter change from map-filters\n   */\n  onFilterChange(filters: FilterState) {\n    this.currentFilters.set(filters);\n    void this.applyFiltersAndSort();\n  }\n\n  /**\n   * 🎯 Close drawer\n   */\n  onCloseDrawer() {\n    this.isDrawerOpen.set(false);\n  }\n\n  /**\n   * 🎯 Handle reserve click from drawer\n   */\n  onReserveClick(data: {\n    carId: string;\n    paymentMethod: string;\n    dates?: { start: Date; end: Date };\n  }) {\n    // Navigate to booking checkout with car ID and payment method\n    this.router.navigate(['/bookings/checkout'], {\n      queryParams: {\n        carId: data['carId'],\n        paymentMethod: data.paymentMethod,\n      },\n    });\n  }\n\n  /**\n   * 🎯 Handle chat click from drawer\n   */\n  onChatClick(carId: string) {\n    // TODO: Abrir chat con anfitrión\n    this.logger.debug('Chat requested for car:', carId);\n  }\n\n  /**\n   * 🎯 Handle sticky CTA click on mobile\n   */\n  onStickyCtaClick() {\n    this.isDrawerOpen.set(true);\n  }\n\n  onSortChange(sort: SortOption) {\n    this.sortOrder.set(sort);\n    this.applyFiltersAndSort();\n  }\n\n  onUserLocationChange(location: { lat: number; lng: number }) {\n    this.userLocation.set(location);\n  }\n\n  private scrollToCarInCarousel(carId: string) {\n    if (!this.carouselContainer) {\n      return;\n    }\n\n    const carousel = this.carouselContainer.nativeElement;\n    const scrollContainer = carousel.querySelector('.map-carousel-scroll') as HTMLElement;\n\n    if (!scrollContainer) {\n      return;\n    }\n\n    const card = scrollContainer.querySelector(`[data-car-id=\"${carId}\"]`) as HTMLElement;\n\n    if (!card) {\n      console.warn('⚠️ Car card not found in carousel:', carId);\n      return;\n    }\n\n    // Scroll horizontal suave al card\n    const cardLeft = card.offsetLeft;\n    const cardWidth = card.offsetWidth;\n    const scrollWidth = scrollContainer.offsetWidth;\n    const scrollPosition = cardLeft - scrollWidth / 2 + cardWidth / 2;\n\n    scrollContainer.scrollTo({\n      left: Math.max(0, scrollPosition),\n      behavior: 'smooth',\n    });\n\n    // Highlight temporal\n    card.classList.add('pulse-highlight');\n    setTimeout(() => {\n      card.classList.remove('pulse-highlight');\n    }, 1500);\n  }\n\n  onSearch() {\n    void this.applyFiltersAndSort();\n  }\n\n  centerOnUser() {\n    const loc = this.userLocation();\n    if (!loc) {\n      // Intentar obtener la ubicación nuevamente\n      this.getUserLocation().then(() => {\n        const newLoc = this.userLocation();\n        if (newLoc && this.carsMap) {\n          this.carsMap.flyToLocation(newLoc.lat, newLoc.lng);\n        }\n      });\n      return;\n    }\n\n    if (this.carsMap) {\n      this.carsMap.flyToLocation(loc.lat, loc.lng);\n    }\n  }\n\n  extractPhotoGallery(car: Car): string[] {\n    const rawPhotos = car.photos ?? car.car_photos ?? [];\n    if (!Array.isArray(rawPhotos)) {\n      return [];\n    }\n    return rawPhotos\n      .map((photo) => (typeof photo === 'string' ? photo : (photo?.['url'] ?? null)))\n      .filter((url): url is string => typeof url === 'string' && url.length > 0);\n  }\n\n  private async applyFiltersAndSort() {\n    const filters = this.currentFilters() ?? {\n      dateRange: null,\n      priceRange: null,\n      vehicleTypes: null,\n      immediateOnly: false,\n      transmission: null,\n    };\n\n    const query = this.searchQuery?.toLowerCase().trim();\n\n    let result = [...this.cars];\n\n    // Texto libre\n    if (query) {\n      result = result.filter((car) => {\n        const city = car['location_city']?.toLowerCase() || '';\n        const brand = car['brand']?.toLowerCase() || car.brand_text_backup?.toLowerCase() || '';\n        const model = car['model']?.toLowerCase() || car.model_text_backup?.toLowerCase() || '';\n        return brand.includes(query) || model.includes(query) || city.includes(query);\n      });\n    }\n\n    // Rango de precio\n    if (filters.priceRange) {\n      result = result.filter((car) => {\n        const price = car['price_per_day'] || 0;\n        return price >= filters.priceRange!.min && price <= filters.priceRange!.max;\n      });\n    }\n\n    // Tipo de vehículo\n    if (filters.vehicleTypes && filters.vehicleTypes.length > 0) {\n      result = result.filter((car) =>\n        filters.vehicleTypes!.includes((car.vehicle_type as string | undefined) ?? ''),\n      );\n    }\n\n    // Transmisión\n    if (filters['transmission'] && filters['transmission'].length > 0) {\n      result = result.filter((car) =>\n        filters['transmission']!.includes((car['transmission'] as string | undefined) ?? ''),\n      );\n    }\n\n    // Entrega inmediata (instant booking flag)\n    if (filters.immediateOnly) {\n      result = result.filter((car) => {\n        const instant = (car as { instant_booking?: boolean }).instant_booking;\n        return instant === true;\n      });\n    }\n\n    // Fecha: filtrar por disponibilidad vía RPC (costoso pero necesario para consistencia)\n    if (filters.dateRange) {\n      const from = filters.dateRange.start.toISOString().slice(0, 10);\n      const to = filters.dateRange.end.toISOString().slice(0, 10);\n      const availabilityResults = await Promise.all(\n        result.map(async (car) => {\n          try {\n            const available = await this.availabilityService.checkAvailability(car['id'], from, to);\n            return available ? car : null;\n          } catch {\n            return null;\n          }\n        }),\n      );\n      result = availabilityResults.filter((c): c is Car => Boolean(c));\n    }\n\n    // Ordenamiento\n    const sortOrder = this.sortOrder();\n    result.sort((a, b) => {\n      const priceA = a['price_per_day'] || 0;\n      const priceB = b['price_per_day'] || 0;\n      const ratingA = a.rating_avg || 0;\n      const ratingB = b.rating_avg || 0;\n      switch (sortOrder) {\n        case 'price_asc':\n          return priceA - priceB;\n        case 'price_desc':\n          return priceB - priceA;\n        case 'rating':\n          return ratingB - ratingA;\n        default:\n          return 0; // relevance/distance keep API order\n      }\n    });\n\n    this.filteredCars = result;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/features/marketplace/marketplace-v2.page.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`../../../environments/environment` import should occur after import of `@core/services/ui/theme.service`","line":20,"column":1,"nodeType":"ImportDeclaration","endLine":20,"endColumn":65,"fix":{"range":[559,2705],"text":"import { Car } from '../../core/models';\nimport { CarMapLocation } from '@core/services/cars/car-locations.service';\nimport { CarsService } from '@core/services/cars/cars.service';\nimport { DistanceCalculatorService } from '@core/services/geo/distance-calculator.service';\nimport { GeocodingResult, GeocodingService } from '@core/services/geo/geocoding.service';\nimport { LocationService } from '@core/services/geo/location.service';\nimport { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\nimport { UrgentRentalService } from '@core/services/bookings/urgent-rental.service';\nimport { FilterState } from '../../shared/components/map-filters/map-filters.component';\n\n// QuickFilter interface defined locally (component was removed)\ninterface QuickFilter {\n  id: string;\n  label: string;\n  icon?: string;\n}\n\n// FabAction interface defined locally (component was removed)\ninterface FabAction {\n  id: string;\n  label: string;\n  icon: string;\n  color?: 'primary' | 'secondary';\n}\n\nimport { AnalyticsService } from '@core/services/infrastructure/analytics.service';\nimport { BookingsService } from '@core/services/bookings/bookings.service';\nimport { BreakpointService } from '@core/services/ui/breakpoint.service';\nimport { NotificationManagerService } from '@core/services/infrastructure/notification-manager.service';\nimport { TikTokEventsService } from '@core/services/infrastructure/tiktok-events.service';\n\nimport { HdriBackgroundComponent } from '../../shared/components/hdri-background/hdri-background.component';\nimport {\n  DateRange,\n  DateRangePickerComponent,\n} from '../../shared/components/date-range-picker/date-range-picker.component';\n\nimport { AssetPreloaderService } from '@core/services/ui/asset-preloader.service';\nimport { CarLatestLocation, CarLocationService } from '@core/services/geo/car-location.service';\nimport { MapboxPreloaderService } from '@core/services/geo/mapbox-preloader.service';\nimport { SeoSchemaService } from '@core/services/ui/seo-schema.service';\nimport { ThemeService } from '@core/services/ui/theme.service';\nimport { environment } from '../../../environments/environment';\n"}},{"ruleId":"import/order","severity":1,"message":"`../../core/models` import should occur after import of `@core/services/ui/theme.service`","line":21,"column":1,"nodeType":"ImportDeclaration","endLine":21,"endColumn":41,"fix":{"range":[624,2705],"text":"import { CarMapLocation } from '@core/services/cars/car-locations.service';\nimport { CarsService } from '@core/services/cars/cars.service';\nimport { DistanceCalculatorService } from '@core/services/geo/distance-calculator.service';\nimport { GeocodingResult, GeocodingService } from '@core/services/geo/geocoding.service';\nimport { LocationService } from '@core/services/geo/location.service';\nimport { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\nimport { UrgentRentalService } from '@core/services/bookings/urgent-rental.service';\nimport { FilterState } from '../../shared/components/map-filters/map-filters.component';\n\n// QuickFilter interface defined locally (component was removed)\ninterface QuickFilter {\n  id: string;\n  label: string;\n  icon?: string;\n}\n\n// FabAction interface defined locally (component was removed)\ninterface FabAction {\n  id: string;\n  label: string;\n  icon: string;\n  color?: 'primary' | 'secondary';\n}\n\nimport { AnalyticsService } from '@core/services/infrastructure/analytics.service';\nimport { BookingsService } from '@core/services/bookings/bookings.service';\nimport { BreakpointService } from '@core/services/ui/breakpoint.service';\nimport { NotificationManagerService } from '@core/services/infrastructure/notification-manager.service';\nimport { TikTokEventsService } from '@core/services/infrastructure/tiktok-events.service';\n\nimport { HdriBackgroundComponent } from '../../shared/components/hdri-background/hdri-background.component';\nimport {\n  DateRange,\n  DateRangePickerComponent,\n} from '../../shared/components/date-range-picker/date-range-picker.component';\n\nimport { AssetPreloaderService } from '@core/services/ui/asset-preloader.service';\nimport { CarLatestLocation, CarLocationService } from '@core/services/geo/car-location.service';\nimport { MapboxPreloaderService } from '@core/services/geo/mapbox-preloader.service';\nimport { SeoSchemaService } from '@core/services/ui/seo-schema.service';\nimport { ThemeService } from '@core/services/ui/theme.service';\nimport { Car } from '../../core/models';\n"}},{"ruleId":"import/order","severity":1,"message":"`../../shared/components/map-filters/map-filters.component` import should occur after import of `@core/services/ui/theme.service`","line":29,"column":1,"nodeType":"ImportDeclaration","endLine":29,"endColumn":89},{"ruleId":"import/order","severity":1,"message":"`../../shared/components/hdri-background/hdri-background.component` import should occur after import of `@core/services/ui/theme.service`","line":52,"column":1,"nodeType":"ImportDeclaration","endLine":52,"endColumn":109,"fix":{"range":[2062,2705],"text":"import {\n  DateRange,\n  DateRangePickerComponent,\n} from '../../shared/components/date-range-picker/date-range-picker.component';\n\nimport { AssetPreloaderService } from '@core/services/ui/asset-preloader.service';\nimport { CarLatestLocation, CarLocationService } from '@core/services/geo/car-location.service';\nimport { MapboxPreloaderService } from '@core/services/geo/mapbox-preloader.service';\nimport { SeoSchemaService } from '@core/services/ui/seo-schema.service';\nimport { ThemeService } from '@core/services/ui/theme.service';\nimport { HdriBackgroundComponent } from '../../shared/components/hdri-background/hdri-background.component';\n"}},{"ruleId":"import/order","severity":1,"message":"`../../shared/components/date-range-picker/date-range-picker.component` import should occur after import of `@core/services/ui/theme.service`","line":53,"column":1,"nodeType":"ImportDeclaration","endLine":56,"endColumn":80,"fix":{"range":[2171,2705],"text":"\nimport { AssetPreloaderService } from '@core/services/ui/asset-preloader.service';\nimport { CarLatestLocation, CarLocationService } from '@core/services/geo/car-location.service';\nimport { MapboxPreloaderService } from '@core/services/geo/mapbox-preloader.service';\nimport { SeoSchemaService } from '@core/services/ui/seo-schema.service';\nimport { ThemeService } from '@core/services/ui/theme.service';\nimport {\n  DateRange,\n  DateRangePickerComponent,\n} from '../../shared/components/date-range-picker/date-range-picker.component';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":4,"source":"import { LoggerService } from '@core/services/infrastructure/logger.service';\nimport { CommonModule, isPlatformBrowser, NgOptimizedImage } from '@angular/common';\nimport {\n  ChangeDetectionStrategy,\n  Component,\n  computed,\n  effect,\n  ElementRef,\n  inject,\n  OnDestroy,\n  OnInit,\n  PLATFORM_ID,\n  signal,\n  ViewChild,\n} from '@angular/core';\nimport { FormsModule } from '@angular/forms';\nimport { Meta, Title } from '@angular/platform-browser';\nimport { Router, RouterModule } from '@angular/router';\nimport { RealtimeChannel } from '@supabase/supabase-js';\nimport { environment } from '../../../environments/environment';\nimport { Car } from '../../core/models';\nimport { CarMapLocation } from '@core/services/cars/car-locations.service';\nimport { CarsService } from '@core/services/cars/cars.service';\nimport { DistanceCalculatorService } from '@core/services/geo/distance-calculator.service';\nimport { GeocodingResult, GeocodingService } from '@core/services/geo/geocoding.service';\nimport { LocationService } from '@core/services/geo/location.service';\nimport { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\nimport { UrgentRentalService } from '@core/services/bookings/urgent-rental.service';\nimport { FilterState } from '../../shared/components/map-filters/map-filters.component';\n\n// QuickFilter interface defined locally (component was removed)\ninterface QuickFilter {\n  id: string;\n  label: string;\n  icon?: string;\n}\n\n// FabAction interface defined locally (component was removed)\ninterface FabAction {\n  id: string;\n  label: string;\n  icon: string;\n  color?: 'primary' | 'secondary';\n}\n\nimport { AnalyticsService } from '@core/services/infrastructure/analytics.service';\nimport { BookingsService } from '@core/services/bookings/bookings.service';\nimport { BreakpointService } from '@core/services/ui/breakpoint.service';\nimport { NotificationManagerService } from '@core/services/infrastructure/notification-manager.service';\nimport { TikTokEventsService } from '@core/services/infrastructure/tiktok-events.service';\n\nimport { HdriBackgroundComponent } from '../../shared/components/hdri-background/hdri-background.component';\nimport {\n  DateRange,\n  DateRangePickerComponent,\n} from '../../shared/components/date-range-picker/date-range-picker.component';\n\nimport { AssetPreloaderService } from '@core/services/ui/asset-preloader.service';\nimport { CarLatestLocation, CarLocationService } from '@core/services/geo/car-location.service';\nimport { MapboxPreloaderService } from '@core/services/geo/mapbox-preloader.service';\nimport { SeoSchemaService } from '@core/services/ui/seo-schema.service';\nimport { ThemeService } from '@core/services/ui/theme.service';\n\nexport interface LatLngBoundsLiteral {\n  north: number;\n  south: number;\n  east: number;\n  west: number;\n}\n\nexport interface CarWithDistance extends Car {\n  distance?: number;\n  distanceText?: string;\n  latest_location?: {\n    lat: number;\n    lng: number;\n    recorded_at: string;\n  };\n}\n\n// Type alias for backward compatibility\ntype ToastType = 'success' | 'info' | 'warning' | 'error';\n\nexport interface Stat {\n  label: string;\n  value: string | number;\n  icon: string;\n}\n\n@Component({\n  selector: 'app-marketplace-v2-page',\n  standalone: true,\n  imports: [\n    CommonModule,\n    FormsModule,\n    RouterModule,\n    NgOptimizedImage,\n    DateRangePickerComponent,\n    HdriBackgroundComponent,\n  ],\n  templateUrl: './marketplace-v2.page.html',\n  styleUrls: ['./marketplace-v2.page.css'],\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class MarketplaceV2Page implements OnInit, OnDestroy {\n  private readonly logger = inject(LoggerService);\n  @ViewChild('drawerContent', { read: ElementRef }) drawerContent?: ElementRef<HTMLDivElement>;\n  @ViewChild('hdriViewer') hdriViewer?: HdriBackgroundComponent;\n\n  private readonly router = inject(Router);\n  private readonly carsService = inject(CarsService);\n  private readonly locationService = inject(LocationService);\n  private readonly geocodingService = inject(GeocodingService);\n  private readonly urgentRentalService = inject(UrgentRentalService);\n  private readonly notificationManager = inject(NotificationManagerService);\n  private readonly tiktokEvents = inject(TikTokEventsService);\n  private readonly distanceCalculator = inject(DistanceCalculatorService);\n  private readonly bookingsService = inject(BookingsService);\n  private readonly analyticsService = inject(AnalyticsService);\n  private readonly breakpoint = inject(BreakpointService);\n  private readonly carLocationService = inject(CarLocationService);\n  private readonly supabase = injectSupabase();\n  private readonly platformId = inject(PLATFORM_ID);\n  private readonly isBrowser = isPlatformBrowser(this.platformId);\n  private readonly meta = inject(Meta);\n  private readonly titleService = inject(Title);\n  private readonly seoSchemaService = inject(SeoSchemaService);\n  readonly themeService = inject(ThemeService);\n  private readonly assetPreloader = inject(AssetPreloaderService);\n  private readonly mapboxPreloader = inject(MapboxPreloaderService);\n  private locationSearchTimeout?: ReturnType<typeof setTimeout>;\n\n  // State\n  readonly loading = signal(false);\n  readonly error = signal<string | null>(null);\n  readonly cars = signal<Car[]>([]);\n  readonly selectedCarId = signal<string | null>(null);\n  readonly latestLocations = signal<Record<string, CarLatestLocation>>({});\n  readonly generatedPhotoIds = signal<Set<string>>(new Set()); // Almacena IDs de autos con fotos generadas\n\n  // Calculator State - Business Simulator Logic\n  readonly calculatorCarValue = signal(15000000); // Valor de mercado\n  readonly calculatorDays = signal(12); // Días disponibles (Default: Fines de semana + extras)\n  \n  // New: Financing Logic\n  readonly isFinanced = signal(false); // ¿Paga cuota?\n  readonly monthlyQuota = signal(350000); // Cuota promedio ARS\n\n  // Constants for calculation\n  private readonly CALC_CONSTANTS = {\n    dailyRateFactor: 0.0035,    // 0.35% del valor del auto (Ajustado a inflación)\n    platformFee: 0.15,          // 15% comisión\n    avgWashCost: 8000,          // Costo lavado ARS\n    insuranceAvg: 60000,        // Seguro promedio mensual ARS\n    maxDailyRateArs: 120000     // Tope razonable por día\n  };\n\n  readonly calculatorEstimate = computed(() => {\n    const carValue = this.calculatorCarValue();\n    const days = this.calculatorDays();\n    const isFinanced = this.isFinanced();\n    const quota = this.monthlyQuota();\n\n    // 1. Determinar Tarifa Diaria Estimada\n    let estimatedDailyRate = carValue * this.CALC_CONSTANTS.dailyRateFactor;\n    // Tope de mercado\n    estimatedDailyRate = Math.min(estimatedDailyRate, this.CALC_CONSTANTS.maxDailyRateArs);\n\n    // 2. Calcular Ingresos Brutos\n    const grossIncome = estimatedDailyRate * days;\n\n    // 3. Calcular Costos Operativos Visibles\n    const platformFee = grossIncome * this.CALC_CONSTANTS.platformFee;\n    // Estimamos 1 lavado cada 3 días de alquiler\n    const estimatedWashes = Math.ceil(days / 3) * this.CALC_CONSTANTS.avgWashCost; \n    // Seguro proporcional al uso (o fijo mensual, usamos fijo para ser conservadores/realistas)\n    const insuranceCost = this.CALC_CONSTANTS.insuranceAvg;\n\n    const operationalCost = platformFee + estimatedWashes + insuranceCost;\n\n    // 4. Resultado Neto Operativo (En tu bolsillo)\n    const netResult = Math.max(0, grossIncome - operationalCost);\n\n    // 5. Lógica de Financiación (El \"Hook\")\n    let financingMessage = '';\n    let healthScore = 'neutral'; // green, yellow, red\n\n    if (isFinanced && quota > 0) {\n      const balance = netResult - quota;\n      const coveragePercent = (netResult / quota) * 100;\n\n      if (balance >= 0) {\n        financingMessage = `¡Excelente! Cubres el 100% de tu cuota y te sobran $${balance.toLocaleString('es-AR')}. Tu auto es GRATIS.`;\n        healthScore = 'green';\n      } else {\n        // Cuántos días faltan para cubrir\n        // Profit por día extra = tarifa - comisión - lavado/3\n        const profitPerDay = estimatedDailyRate * (1 - this.CALC_CONSTANTS.platformFee) - (this.CALC_CONSTANTS.avgWashCost / 3);\n        const missing = Math.abs(balance);\n        const missingDays = Math.ceil(missing / profitPerDay);\n        \n        financingMessage = `Cubres el ${Math.round(coveragePercent)}% de la cuota. Alquila ${missingDays} días más para que se pague solo.`;\n        healthScore = 'yellow';\n      }\n    } else {\n      // Mensaje para dueños sin deuda\n      financingMessage = `Generas un ingreso extra de $${netResult.toLocaleString('es-AR')} limpios al mes.`;\n      healthScore = 'green';\n    }\n\n    return {\n      grossIncome,\n      netResult,\n      expenses: operationalCost,\n      financingMessage,\n      healthScore,\n      breakdown: {\n        platformFee,\n        insurance: insuranceCost,\n        washes: estimatedWashes\n      }\n    };\n  });\n\n  // Helper computed for template\n  readonly calculatorEarnings = computed(() => this.calculatorEstimate().netResult);\n\n  readonly testimonials: Array<{\n    avatar: string;\n    name: string;\n    location: string;\n    quote: string;\n    earnings: number;\n  }> = [\n    {\n      avatar: '/assets/images/avatars/avatar-2.jpg', // Martín (Hombre 40s)\n      name: 'Martín',\n      location: 'Buenos Aires',\n      quote: 'Empecé para pagar el seguro y ahora pago la cuota completa del auto. Es increíble que antes perdía plata teniéndolo estacionado.',\n      earnings: 450000,\n    },\n    {\n      avatar: '/assets/images/avatars/avatar-1.jpg', // Sofía (Mujer joven)\n      name: 'Sofía',\n      location: 'Córdoba',\n      quote: 'Lo uso para ir al trabajo y lo alquilo los fines de semana. Con eso cubro el mantenimiento y me sobra para ahorrar.',\n      earnings: 280000,\n    },\n    {\n      avatar: '/assets/images/avatars/avatar-3.jpg', // Carlos (Hombre joven)\n      name: 'Carlos',\n      location: 'Rosario',\n      quote: 'Tengo una camioneta que uso poco. La puse en la plataforma y se convirtió en mi mejor inversión del año.',\n      earnings: 820000,\n    },\n  ];\n\n  // Pagination\n  readonly currentPage = signal(1);\n  readonly pageSize = signal(12);\n  readonly totalCarsCount = signal(0);\n  // User Location Signals\n  readonly userLocation = signal<{ lat: number; lng: number } | null>(null);\n  readonly locationAccuracy = signal<number | null>(null);\n  readonly lastLocationUpdate = signal<Date | null>(null);\n  private locationWatchId: number | null = null;\n\n  // UI State Signals\n\n  readonly drawerOpen = signal(false);\n  readonly filtersVisible = signal(true);\n  readonly dateRange = signal<DateRange>({ from: null, to: null });\n  readonly mapFilters = signal<FilterState>({\n    dateRange: null,\n    priceRange: null,\n    vehicleTypes: null,\n    immediateOnly: false,\n    transmission: null,\n  });\n  readonly urgentAvailability = signal<{\n    available: boolean;\n    distance?: number;\n    eta?: number;\n  } | null>(null);\n  readonly expressMode = signal(true);\n\n  readonly searchValue = signal('');\n  readonly showFilters = signal(false);\n  // ViewMode removed - Grid only now\n  readonly toastMessage = signal('');\n  readonly toastType = signal<ToastType>('info');\n  readonly toastVisible = signal(false);\n  readonly radiusKm = signal(5); // Search radius in kilometers\n  readonly showDatePicker = signal(false); // Modal de selector de fechas\n  readonly showLocationPicker = signal(false); // Modal de selector de ubicación\n  readonly selectedLocation = signal<string>(''); // Ubicación seleccionada\n  readonly locationSuggestions = signal<GeocodingResult[]>([]); // Sugerencias de ubicación\n  readonly showLocationSuggestions = signal(false); // Mostrar dropdown de sugerencias\n  readonly locationSearchLoading = signal(false); // Cargando sugerencias\n  readonly googleCalendarId = signal<string | null>(environment.googleCalendarId || null); // ID del calendario de Google desde environment\n  readonly showPriceTransparencyModal = signal(false); // Modal de transparencia de precios\n  readonly mapBounds = signal<{ north: number; south: number; east: number; west: number } | null>(\n    null,\n  );\n  readonly showSearchAreaButton = signal(false); // Botón \"Buscar en esta zona\"\n\n  // Dynamic greeting based on time of day and context\n  readonly dynamicGreeting = computed(() => {\n    const hour = new Date().getHours();\n    const dayOfWeek = new Date().getDay();\n    const carsAvailable = this.totalCarsCount();\n\n    // Weekend vibes\n    if (dayOfWeek === 5) {\n      return 'El finde arranca. ¿A dónde te escapás?';\n    }\n    if (dayOfWeek === 6 || dayOfWeek === 0) {\n      return '¿Domingo de ruta? Hay autos esperándote.';\n    }\n\n    // Time-based greetings\n    if (hour < 9) {\n      return 'Arrancá el día con ruedas. Elegí tu auto.';\n    }\n    if (hour < 13) {\n      return `${carsAvailable} autos cerca tuyo, ¿cuál te llevás?`;\n    }\n    if (hour < 18) {\n      return 'Todavía llegás a reservar para hoy.';\n    }\n    if (hour < 21) {\n      return 'Reservá ahora, retirá mañana temprano.';\n    }\n\n    // Late night\n    return 'Dejá todo listo para mañana.';\n  });\n\n  // HDRI Background State\n  hdriLoaded = false;\n\n  // Quick Booking State\n  readonly quickBookingCar = signal<Car | null>(null);\n  readonly quickBookingModalOpen = signal(false);\n\n  // Hero 3D Click Hint State\n  readonly showClickHint = signal(false);\n  readonly clickHintFading = signal(false);\n  private clickHintTimeout?: ReturnType<typeof setTimeout>;\n  private clickHintShownSession = false;\n\n  // Splash Screen State\n  readonly showSplash = signal(true);\n\n  // Testimonial State (Mobile)\n  readonly showFullTestimonial = signal(false);\n\n  constructor() {\n    // Hide splash immediately to show skeletons or content\n    this.showSplash.set(false);\n  }\n\n  onHdriLoaded(): void {\n    // Mark HDRI as loaded\n    this.hdriLoaded = true;\n\n    // Show click hint after HDRI loads (only once per session)\n    if (!this.clickHintShownSession && this.isBrowser) {\n      this.clickHintShownSession = true;\n      setTimeout(() => {\n        this.showClickHint.set(true);\n        this.clickHintTimeout = setTimeout(() => {\n          this.hideClickHint();\n        }, 2500);\n      }, 900);\n    }\n\n    // Preload Mapbox map after HDRI loads\n    if (this.isBrowser) {\n      setTimeout(() => {\n        this.mapboxPreloader.preloadMap().then(() => {\n          this.logger.debug('[Marketplace] Mapbox map fully preloaded');\n        });\n      }, 1000);\n    }\n  }\n\n  scrollToHowItWorks(): void {\n    if (this.isBrowser) {\n      const element = document.getElementById('how-it-works');\n      if (element) {\n        element.scrollIntoView({ behavior: 'smooth', block: 'start' });\n      }\n    }\n  }\n\n\n\n\n  // Computed - Ahora usa BreakpointService\n  readonly isMobile = this.breakpoint.isMobile;\n  readonly isTablet = this.breakpoint.isTablet;\n  readonly isDesktop = this.breakpoint.isDesktop;\n\n  readonly selectedCar = computed(() => {\n    const carId = this.selectedCarId();\n    if (!carId) return null;\n    return this.cars().find((c) => c.id === carId) || null;\n  });\n\n  readonly quickFilters: QuickFilter[] = [\n    { id: 'immediate', label: 'Entrega inmediata', icon: 'lightning' },\n    { id: 'verified', label: 'Dueño verificado', icon: 'verified' },\n    { id: 'no-card', label: 'Sin tarjeta', icon: 'credit-card' },\n    { id: 'near-me', label: 'Cerca de mí', icon: 'location' },\n    { id: 'electric', label: 'Eléctrico', icon: 'battery-charging' },\n  ];\n\n  readonly fabActions: FabAction[] = [\n    { id: 'filter', label: 'Filtros', icon: 'filter', color: 'primary' },\n    { id: 'location', label: 'Mi ubicación', icon: 'location', color: 'secondary' },\n  ];\n\n  readonly carsWithDistance = computed<CarWithDistance[]>(() => {\n    const carsList = this.cars();\n    const userLoc = this.userLocation();\n\n    if (!carsList.length || !userLoc) {\n      return carsList.map((car) => ({ ...car }));\n    }\n\n    return carsList.map((car) => {\n      if (!car.location_lat || !car.location_lng) {\n        return { ...car };\n      }\n\n      const distanceKm = this.distanceCalculator.calculateDistance(\n        userLoc.lat,\n        userLoc.lng,\n        car.location_lat,\n        car.location_lng,\n      );\n\n      let distanceText: string;\n      if (distanceKm < 1) {\n        distanceText = `${Math.round(distanceKm * 10) * 100}m`;\n      } else if (distanceKm < 10) {\n        distanceText = `${distanceKm.toFixed(1)}km`;\n      } else {\n        distanceText = `${Math.round(distanceKm)}km`;\n      }\n\n      return {\n        ...car,\n        distance: distanceKm,\n        distanceText,\n      };\n    });\n  });\n\n  readonly carMapLocations = computed(() =>\n    this.carsWithDistance().map((car) => {\n      const gallery = this.extractPhotoGallery(car);\n      return {\n        carId: car.id,\n        title: `${car.brand_text_backup || ''} ${car.model_text_backup || ''}`.trim(),\n        pricePerDay: car.price_per_day,\n        currency: car.currency || 'ARS',\n        lat: car.location_lat || 0,\n        lng: car.location_lng || 0,\n        updatedAt: car.updated_at || new Date().toISOString(),\n        city: car.location_city,\n        state: car.location_state,\n        country: car.location_country,\n        locationLabel: car.location_city || 'Sin ubicación',\n        photoUrl: gallery[0] ?? null,\n        photoGallery: gallery,\n        description: car.description,\n      };\n    }),\n  );\n\n  readonly statsStripData = computed<Stat[]>(() => {\n    const totalCars = this.carsWithDistance().length;\n    const availableNow = this.carsWithDistance().filter((c) => c.distance && c.distance < 5).length;\n    const avgPrice = this.calculateAveragePrice();\n    return [\n      { label: 'Autos disponibles', value: totalCars, icon: 'car' },\n      { label: 'Cerca de ti', value: availableNow, icon: 'location' },\n      { label: 'Desde', value: `$${avgPrice}/día`, icon: 'money' },\n    ];\n  });\n\n  readonly availableNowCount = computed(() => {\n    return this.carsWithDistance().filter((c) => c.distance && c.distance < 5).length;\n  });\n\n  readonly activeQuickFilters = signal<Set<string>>(new Set());\n\n  /**\n   * Visible cars with client-side enhancements.\n   * Note: Most filters are now applied server-side in loadCars().\n   * This computed only handles:\n   * - Distance sorting (requires user location)\n   * - Client-only filters (verified, no-card) that can't be done server-side\n   */\n  readonly visibleCars = computed(() => {\n    let cars = this.carsWithDistance().slice();\n    const quickFilters = this.activeQuickFilters();\n    const generatedIds = this.generatedPhotoIds(); // Obtener el Set de IDs\n\n    // 1. Filtrar solo autos con fotos IA generadas\n    cars = cars.filter(car => generatedIds.has(car.id));\n\n    // Client-only filters (can't be done server-side due to nested relations)\n    if (quickFilters.has('verified')) {\n      cars = cars.filter((c) => c.owner?.email_verified && c.owner?.phone_verified);\n    }\n\n    if (quickFilters.has('no-card')) {\n      cars = cars.filter(\n        (c) =>\n          c.payment_methods?.some((pm) =>\n            ['debit_card', 'cash', 'transfer', 'wallet'].includes(pm),\n          ) || !c.payment_methods?.includes('credit_card'),\n      );\n    }\n\n    // Distance sorting (requires user location - can't be done server-side)\n    const sort = this.sortOrder();\n    if (sort === 'distance') {\n      cars = cars.sort((a, b) => {\n        const distA = a.distance ?? Number.MAX_VALUE;\n        const distB = b.distance ?? Number.MAX_VALUE;\n        return distA - distB;\n      });\n    }\n    // Other sorts are now handled server-side in loadCars()\n\n    return cars;\n  });\n\n  readonly sortOrder = signal<string>('distance');\n\n  /**\n   * Contextual marker variant:\n   * - 'photo' for browsing/exploration (default for marketplace - more visual)\n   * - 'price' when user is actively comparing prices (has filters or date range)\n   */\n  readonly contextualMarkerVariant = computed<'photo' | 'price'>(() => {\n    // Default to 'photo' for marketplace - more visual and marketplace-like\n    // Only switch to 'price' when user is actively filtering/comparing\n    const filters = this.mapFilters();\n    const dateRange = this.dateRange();\n\n    // Switch to 'price' mode ONLY when:\n    // 1. User has active price filters AND date range (serious comparison)\n    const hasPriceFilter = filters.priceRange !== null;\n    const hasDateRange = dateRange.from !== null && dateRange.to !== null;\n\n    // Only use price mode when both price filter AND date range are active\n    if (hasPriceFilter && hasDateRange) {\n      return 'price'; // Price comparison mode\n    }\n\n    // Default to photo mode for better marketplace experience\n    return 'photo'; // Browsing/exploration mode (default - more visual)\n  });\n\n  /**\n   * Static Mapbox image URL for performance optimization\n   * Replaces interactive Mapbox GL JS with static image\n   */\n  readonly staticMapUrl = computed(() => {\n    const center = this.userLocation() || { lng: -58.3816, lat: -34.6037 }; // Buenos Aires default\n    const token = environment.mapboxAccessToken;\n    return `https://api.mapbox.com/styles/v1/mapbox/streets-v12/static/${center.lng},${center.lat},11,0/1200x800@2x?access_token=${token}`;\n  });\n\n  /**\n   * Total pages for pagination\n   */\n  readonly totalPages = computed(() => Math.ceil(this.totalCarsCount() / this.pageSize()));\n\n  // Realtime\n  private realtimeChannel?: RealtimeChannel;\n  private loadingInterval?: ReturnType<typeof setInterval>;\n\n  // Effects\n  private readonly filtersEffect = effect(() => {\n    const filters = this.mapFilters();\n    if (filters.dateRange) {\n      const from = filters.dateRange.start.toISOString().split('T')[0];\n      const to = filters.dateRange.end.toISOString().split('T')[0];\n      this.dateRange.set({ from, to });\n    }\n  });\n\n  private readonly dateRangeEffect = effect(() => {\n    const range = this.dateRange();\n    if (range.from && range.to) {\n      void this.loadCars();\n    }\n  });\n\n  ngOnInit(): void {\n    // SEO Meta Tags\n    this.titleService.setTitle(\n      'Autorentar | Alquiler de Autos entre Personas - Renta Segura',\n    );\n    this.meta.updateTag({\n      name: 'description',\n      content:\n        'Alquila autos verificados directamente de dueños. 100% asegurado, pagos seguros con MercadoPago, entrega express. Sin intermediarios, sin tarjeta de crédito requerida.',\n    });\n    this.meta.updateTag({\n      name: 'keywords',\n      content:\n        'alquiler autos, renta de autos, alquiler sin tarjeta, autos particulares, alquiler entre personas, Argentina',\n    });\n    this.meta.updateTag({ property: 'og:title', content: 'Autorentar - Alquiler de Autos entre Personas' });\n    this.meta.updateTag({\n      property: 'og:description',\n      content: 'Conectamos personas con vehículos verificados. Sin intermediarios, 100% asegurado.',\n    });\n    this.meta.updateTag({ property: 'og:type', content: 'website' });\n    this.meta.updateTag({ name: 'twitter:card', content: 'summary_large_image' });\n\n    // Initialize JSON-LD structured data schemas for SEO\n    if (this.isBrowser) {\n      this.seoSchemaService.setOrganizationSchema();\n      this.seoSchemaService.setLocalBusinessSchema();\n      this.seoSchemaService.setWebSiteSchema();\n    }\n\n    void this.initializeUserLocation();\n    void this.loadGeneratedPhotoManifest(); // Cargar manifest al inicio\n    void this.loadCars();\n    if (this.isBrowser) {\n      this.setupRealtimeSubscription();\n      this.checkPriceTransparencyModal();\n    }\n  }\n\n  ngOnDestroy(): void {\n    // Cleanup location watch\n    if (this.locationWatchId !== null) {\n      this.locationService.clearWatch(this.locationWatchId);\n    }\n    // Cleanup timeouts\n    if (this.clickHintTimeout) {\n      clearTimeout(this.clickHintTimeout);\n    }\n    if (this.locationSearchTimeout) {\n      clearTimeout(this.locationSearchTimeout);\n    }\n    // Cleanup loading interval\n    if (this.loadingInterval) {\n      clearInterval(this.loadingInterval);\n    }\n    // Cleanup realtime channel\n    if (this.realtimeChannel) {\n      this.supabase.removeChannel(this.realtimeChannel);\n    }\n  }\n\n  /**\n   * Carga el manifest de IDs de fotos generadas\n   */\n  private async loadGeneratedPhotoManifest(): Promise<void> {\n    if (!this.isBrowser) return;\n    try {\n      const response = await fetch('/assets/generated_photos_manifest.json');\n      if (!response.ok) {\n        console.warn('No se encontró generated_photos_manifest.json. Posiblemente no se han generado fotos IA.');\n        return;\n      }\n      const ids: string[] = await response.json();\n      this.generatedPhotoIds.set(new Set(ids));\n      this.logger.debug(`✅ Manifest de fotos cargado. ${ids.length} fotos IA disponibles.`);\n    } catch (error) {\n      console.error('Error cargando manifest de fotos:', error);\n    }\n  }\n\n  /**\n   * Initialize user location from profile or GPS\n   */\n  private async initializeUserLocation(): Promise<void> {\n    try {\n      const locationData = await this.locationService.getUserLocation();\n      if (locationData) {\n        this.userLocation.set({\n          lat: locationData.lat,\n          lng: locationData.lng,\n        });\n      }\n    } catch (_error) {\n      console.warn('Could not get user location:', _error);\n    }\n  }\n\n  /**\n   * Load available cars with filters applied server-side\n   */\n  async loadCars(): Promise<void> {\n    this.loading.set(true);\n    this.error.set(null);\n    try {\n      const dateRange = this.dateRange();\n      const filters = this.mapFilters();\n      const quickFilters = this.activeQuickFilters();\n      const page = this.currentPage();\n      const size = this.pageSize();\n      const rangeStart = (page - 1) * size;\n      const rangeEnd = rangeStart + size - 1;\n\n      if (dateRange.from && dateRange.to) {\n        // Use RPC with PostGIS distance scoring when user has location\n        const userLoc = this.userLocation();\n        if (userLoc) {\n          // Server-side distance sorting with RPC\n          const items = await this.carsService.getAvailableCarsWithDistance(\n            dateRange.from,\n            dateRange.to,\n            {\n              lat: userLoc.lat,\n              lng: userLoc.lng,\n              limit: size,\n              offset: rangeStart,\n            },\n          );\n          // Map RPC result to Car format\n          const carsData = items.map((item) => ({\n            id: item.id,\n            owner_id: item.owner_id,\n            brand_text_backup: item.brand,\n            model_text_backup: item.model,\n            year: item.year,\n            plate: item.plate,\n            price_per_day: item.price_per_day / 100, // Ajustar de centavos a unidades\n            currency: item.currency,\n            status: item.status,\n            location_city: item.location?.city || '',\n            location_state: item.location?.state || '',\n            location_lat: item.location?.lat || 0,\n            location_lng: item.location?.lng || 0,\n            photos: item.images?.map((url: string) => ({ url })) || [],\n            car_photos: item.images?.map((url: string) => ({ url })) || [],\n            features: item.features,\n            created_at: item.created_at,\n            updated_at: item.updated_at,\n            rating_avg: item.avg_rating,\n            score: item.score,\n          })) as unknown as Car[];\n          this.cars.set(carsData);\n        } else {\n          // Fallback to availability service without distance\n          const items = await this.carsService.getAvailableCars(dateRange.from, dateRange.to, {\n            limit: size,\n            offset: rangeStart,\n          });\n          this.cars.set(items);\n          await this.loadLatestLocationsFor(items);\n        }\n        // For date-filtered queries, we need a separate count query\n        const { count } = await this.supabase\n          .from('cars')\n          .select('*', { count: 'exact', head: true })\n          .eq('status', 'active');\n        this.totalCarsCount.set(count || 0);\n      } else {\n        // Build query with server-side filters\n        let query = this.supabase\n          .from('cars')\n          .select(\n            `\n            *,\n            car_photos(*),\n            owner:profiles!cars_owner_id_fkey(\n              id,\n              full_name,\n              avatar_url,\n              rating_avg,\n              rating_count,\n              created_at,\n              email_verified,\n              phone_verified\n            )\n          `,\n            { count: 'exact' },\n          )\n          .eq('status', 'active');\n\n        // Apply server-side filters\n        if (filters.priceRange) {\n          query = query\n            .gte('price_per_day', filters.priceRange.min)\n            .lte('price_per_day', filters.priceRange.max);\n        }\n\n        if (filters.transmission && filters.transmission.length > 0) {\n          query = query.in('transmission', filters.transmission);\n        }\n\n        if (filters.immediateOnly) {\n          query = query.eq('auto_approval', true);\n        }\n\n        // Quick filters\n        if (quickFilters.has('electric')) {\n          query = query.or('fuel_type.eq.electric,fuel.eq.electric');\n        }\n\n        // Apply sorting\n        const sort = this.sortOrder();\n        switch (sort) {\n          case 'price_asc':\n            query = query.order('price_per_day', { ascending: true });\n            break;\n          case 'price_desc':\n            query = query.order('price_per_day', { ascending: false });\n            break;\n          case 'rating':\n            query = query.order('rating_avg', { ascending: false, nullsFirst: false });\n            break;\n          default:\n            query = query.order('created_at', { ascending: false });\n        }\n\n        const { data, count, error } = await query.range(rangeStart, rangeEnd);\n\n        if (error) throw error;\n        const carsData = (data as Car[]) || [];\n        \n        // DEBUG: Listar autos para generar fotos correctas\n        this.logger.debug('🚗 AUTOS EN GRID:', carsData.map(c => `${c.id}: ${c.brand_text_backup} ${c.model_text_backup}`));\n\n        this.cars.set(carsData);\n        await this.loadLatestLocationsFor(carsData);\n        this.totalCarsCount.set(count || 0);\n      }\n\n      // Hide search button after loading\n      this.showSearchAreaButton.set(false);\n\n      // Open drawer if there are cars and user location is set\n      if (this.cars().length > 0 && this.userLocation() && !this.drawerOpen()) {\n        this.drawerOpen.set(true);\n      }\n    } catch (err) {\n      console.error('Error loading cars:', err);\n      this.error.set('No se pudieron cargar los autos. Por favor, intenta de nuevo más tarde.');\n      this.showToast('Error al cargar los autos. Por favor intenta de nuevo.', 'error');\n    } finally {\n      this.loading.set(false);\n    }\n  }\n\n  private async loadLatestLocationsFor(cars: Car[]): Promise<void> {\n    if (!cars.length) return;\n\n    try {\n      const ids = cars.map((c) => c.id);\n      const locations = await this.carLocationService.getLatestLocations(ids);\n\n      // Map for quick template lookup\n      const map: Record<string, CarLatestLocation> = {};\n      for (const loc of locations) {\n        map[loc.car_id] = loc;\n      }\n      this.latestLocations.set(map);\n\n      // Also enrich car list so other parts can reuse coords if needed\n      const locationMap = new Map(locations.map((l) => [l.car_id, l]));\n      this.cars.update((currentCars) =>\n        currentCars.map((car) => {\n          const loc = locationMap.get(car.id);\n          if (!loc) return car;\n          return {\n            ...car,\n            latest_location: {\n              lat: loc.lat,\n              lng: loc.lng,\n              recorded_at: loc.recorded_at,\n            },\n            location_lat: loc.lat ?? car.location_lat,\n            location_lng: loc.lng ?? car.location_lng,\n          } as Car;\n        }),\n      );\n    } catch (err) {\n      console.warn('latest-locations-load', err);\n    }\n  }\n\n  /**\n   * Setup realtime subscription for car updates\n   * Only listen to INSERT and DELETE events to avoid excessive reloads\n   */\n  private setupRealtimeSubscription(): void {\n    this.realtimeChannel = this.supabase\n      .channel('marketplace-realtime')\n      .on(\n        'postgres_changes',\n        { event: 'INSERT', schema: 'public', table: 'cars' },\n        () => void this.loadCars(),\n      )\n      .on(\n        'postgres_changes',\n        { event: 'DELETE', schema: 'public', table: 'cars' },\n        () => void this.loadCars(),\n      )\n      .subscribe((status) => {\n        if (status === 'SUBSCRIBED') {\n          console.debug('[Marketplace] Car deletion subscription active');\n        }\n      });\n  }\n\n  /**\n   * Handle logo click - switch to map view and request current location\n   */\n  async onLogoClick(): Promise<void> {\n    // Solicitar ubicación actual del navegador\n    try {\n      const currentPosition = await this.locationService.getCurrentPosition();\n      if (currentPosition) {\n        this.userLocation.set({\n          lat: currentPosition.lat,\n          lng: currentPosition.lng,\n        });\n        // Recargar autos con la nueva ubicación\n        await this.loadCars();\n        this.showToast('Ubicación actualizada', 'success');\n      } else {\n        this.showToast(\n          'No se pudo obtener tu ubicación. Verifica los permisos del navegador.',\n          'warning',\n        );\n      }\n    } catch (error) {\n      console.warn('Error obteniendo ubicación:', error);\n      this.showToast('Error al obtener tu ubicación', 'error');\n    }\n  }\n\n  onCarSelected(carId: string): void {\n    // Navigate to car detail page\n    this.router.navigate(['/cars/detail', carId]);\n\n    // Track analytics event\n    this.analyticsService.trackEvent('car_details_clicked', {\n      car_id: carId,\n      source: 'car_card',\n    });\n  }\n\n  /**\n   * Handle map filters change\n   */\n  onFiltersChange(filters: FilterState): void {\n    this.mapFilters.set(filters);\n\n    // Sync quick filters if needed\n    const quick = new Set(this.activeQuickFilters());\n    if (filters.immediateOnly) quick.add('immediate');\n    else quick.delete('immediate');\n    this.activeQuickFilters.set(quick);\n\n    void this.loadCars();\n    this.showToast('Filtros aplicados', 'success');\n    this.closeFiltersPanel();\n  }\n\n  /**\n   * Handle drawer close\n   */\n  onDrawerClose(): void {\n    this.drawerOpen.set(false);\n  }\n\n  /**\n   * Handle reserve CTA click\n   */\n  onReserveClick(): void {\n    const carId = this.selectedCarId();\n    if (carId) {\n      this.router.navigate(['/cars', carId]);\n    }\n  }\n\n  /**\n   * Handle user location change from map\n   */\n  onUserLocationChange(location: { lat: number; lng: number }): void {\n    this.userLocation.set(location);\n    void this.loadCars();\n    this.showToast('Ubicación actualizada', 'success');\n  }\n\n  /**\n   * Handle map bounds change\n   */\n  onBoundsChange(bounds: LatLngBoundsLiteral): void {\n    // Don't update immediately, just show the button\n    // Only update if bounds are significantly different to avoid jitter\n    this.mapBounds.set(bounds);\n    this.showSearchAreaButton.set(true);\n  }\n\n  /**\n   * Trigger search in current area\n   */\n  searchInArea(): void {\n    void this.loadCars();\n  }\n\n  /**\n   * Toggle fullscreen mode for map\n   */\n  private toggleFullscreen(): void {\n    const elem = document.documentElement;\n    if (!document.fullscreenElement) {\n      elem.requestFullscreen().catch((err) => {\n        console.error(`Error attempting to enable fullscreen: ${err.message}`);\n        this.showToast('No se pudo activar pantalla completa', 'error');\n      });\n    } else {\n      document.exitFullscreen();\n    }\n  }\n\n  /**\n   * Extract photo gallery from car\n   * ENHANCED: Forces local AI-generated assets for all cars to ensure high visual quality and consistency.\n   * Ignores potentially low-quality DB photos for the main grid view.\n   */\n  extractPhotoGallery(car: Car): string[] {\n    // FORCE LOCAL AI PHOTO for consistency\n    // We generated high-quality LATAM context photos for all active cars in the DB based on their ID.\n    // This ensures no low-quality or placeholder images break the professional look.\n    return [`/assets/images/cars/${car.id}-front.jpg`];\n  }\n\n  /**\n   * Track by car ID for ngFor\n   */\n  trackByCarId(_index: number, car: CarWithDistance): string {\n    return car.id;\n  }\n\n  trackBySuggestion(_index: number, suggestion: GeocodingResult): string {\n    return `${suggestion.latitude}-${suggestion.longitude}`;\n  }\n\n  /**\n   * Generate a realistic-looking rating based on car ID\n   * Creates consistent but varied ratings that feel human\n   */\n  getCarRating(carId: string): string {\n    // Use car ID to generate a deterministic but varied rating\n    const hash = carId.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);\n    const baseRating = 4.2 + (hash % 8) / 10; // Range: 4.2 - 4.9\n    return baseRating.toFixed(1);\n  }\n\n  /**\n   * Generate a realistic review count based on car ID\n   */\n  getCarReviewCount(carId: string): number {\n    const hash = carId.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);\n    return 3 + (hash % 47); // Range: 3 - 49 reviews\n  }\n\n  onSearchChange(value: string): void {\n    this.searchValue.set(value);\n  }\n\n  onSearchSubmit(value: string): void {\n    this.searchValue.set(value);\n    this.showToast(`Buscando autos en \"${value}\"...`, 'info');\n\n    // 🎯 TikTok Events: Track Search\n    void this.tiktokEvents.trackSearch({\n      searchString: value,\n    });\n\n    void this.loadCars();\n  }\n\n  onQuickFilterClick(filterId: string): void {\n    const current = new Set(this.activeQuickFilters());\n    let active = false;\n\n    if (current.has(filterId)) {\n      current.delete(filterId);\n      active = false;\n    } else {\n      current.add(filterId);\n      active = true;\n    }\n    this.activeQuickFilters.set(current);\n\n    // Sync specific filters with mapFilters\n    if (filterId === 'immediate') {\n      const filters = this.mapFilters();\n      this.mapFilters.set({ ...filters, immediateOnly: active });\n    }\n\n    if (filterId === 'near-me' && active) {\n      this.sortOrder.set('distance');\n    }\n\n    this.showToast(`Filtro \"${filterId}\" ${active ? 'activado' : 'desactivado'}`, 'info');\n  }\n\n  private openQuickBooking(): void {\n    const selectedCar = this.selectedCar();\n    const carToBook = selectedCar ?? this.cars()[0] ?? null;\n\n    if (!carToBook) {\n      this.showToast('No hay autos disponibles para reservar en este momento.', 'warning');\n      return;\n    }\n\n    this.selectedCarId.set(carToBook.id);\n    this.quickBookingCar.set(carToBook);\n    this.quickBookingModalOpen.set(true);\n\n    this.analyticsService.trackEvent('cta_clicked', {\n      car_id: carToBook.id,\n      source: 'fab_quick_booking',\n    });\n  }\n\n  private async handleLocationAction(): Promise<void> {\n    await this.onLogoClick();\n    this.analyticsService.trackEvent('cta_clicked', {\n      source: 'fab_location',\n    });\n  }\n\n  private openFiltersPanel(): void {\n    this.showFilters.set(true);\n    this.analyticsService.trackEvent('filters_opened', {\n      source: 'fab',\n    });\n  }\n\n  closeFiltersPanel(): void {\n    this.showFilters.set(false);\n  }\n\n  onPublishClick(): void {\n    void this.router.navigate(['/cars/publish']);\n  }\n\n  /**\n   * Abre el selector de fechas\n   */\n  openDatePicker(): void {\n    this.showDatePicker.set(true);\n  }\n\n  /**\n   * Cierra el selector de fechas\n   */\n  closeDatePicker(): void {\n    this.showDatePicker.set(false);\n  }\n\n  /**\n   * Maneja el cambio de rango de fechas\n   */\n  onDateRangeChange(range: DateRange): void {\n    this.dateRange.set(range);\n\n    if (range.from && range.to) {\n      this.showToast(`Fechas: ${range.from} - ${range.to}`, 'success');\n      void this.loadCars();\n      this.closeDatePicker(); // Cerrar el modal al seleccionar fechas\n    }\n  }\n\n  /**\n   * Abre el selector de ubicación\n   */\n  openLocationPicker(): void {\n    this.showLocationPicker.set(true);\n  }\n\n  /**\n   * Cierra el selector de ubicación\n   */\n  closeLocationPicker(): void {\n    this.showLocationPicker.set(false);\n  }\n\n  /**\n   * Maneja la selección de ubicación\n   */\n  onLocationSelect(location: string): void {\n    this.selectedLocation.set(location);\n    this.searchValue.set(location);\n    this.closeLocationPicker();\n    this.showToast(`Ubicación: ${location}`, 'success');\n    void this.loadCars();\n  }\n\n  /**\n   * Maneja el cambio en el input de ubicación - busca sugerencias dinámicamente\n   */\n  onLocationInputChange(event: Event): void {\n    const input = event.target as HTMLInputElement;\n    const query = input.value.trim();\n\n    this.selectedLocation.set(query);\n    this.searchValue.set(query);\n\n    // Limpiar timeout anterior\n    if (this.locationSearchTimeout) {\n      clearTimeout(this.locationSearchTimeout);\n    }\n\n    // Si el query es muy corto, ocultar sugerencias\n    if (query.length < 2) {\n      this.locationSuggestions.set([]);\n      this.showLocationSuggestions.set(false);\n      return;\n    }\n\n    // Mostrar sugerencias\n    this.showLocationSuggestions.set(true);\n    this.locationSearchLoading.set(true);\n\n    // Debounce: esperar 300ms después de que el usuario deje de escribir\n    this.locationSearchTimeout = setTimeout(async () => {\n      try {\n        // Buscar en Argentina, Uruguay y Brasil\n        const suggestions = await this.geocodingService.getLocationSuggestions(\n          query,\n          'AR,UY,BR',\n          8,\n        );\n        this.locationSuggestions.set(suggestions);\n      } catch (error) {\n        console.warn('Error buscando sugerencias:', error);\n        this.locationSuggestions.set([]);\n      } finally {\n        this.locationSearchLoading.set(false);\n      }\n    }, 300);\n  }\n\n  /**\n   * Selecciona una sugerencia de ubicación\n   */\n  onLocationSuggestionSelect(suggestion: GeocodingResult): void {\n    this.selectedLocation.set(suggestion.fullAddress);\n    this.searchValue.set(suggestion.fullAddress);\n    this.showLocationSuggestions.set(false);\n    this.locationSuggestions.set([]);\n\n    // Actualizar ubicación del usuario en el mapa\n    this.userLocation.set({\n      lat: suggestion.latitude,\n      lng: suggestion.longitude,\n    });\n\n    // Recargar autos con la nueva ubicación\n    void this.loadCars();\n    this.showToast(`Ubicación: ${suggestion.placeName}`, 'success');\n  }\n\n  /**\n   * Cierra el dropdown de sugerencias\n   */\n  closeLocationSuggestions(): void {\n    this.showLocationSuggestions.set(false);\n  }\n\n  /**\n   * Maneja el blur del input de ubicación con delay para permitir clicks en sugerencias\n   */\n  onLocationInputBlur(): void {\n    setTimeout(() => {\n      this.closeLocationSuggestions();\n    }, 200);\n  }\n\n  onFabActionClick(actionId: string): void {\n    switch (actionId) {\n      case 'filter':\n        this.openFiltersPanel();\n        break;\n      case 'quick-rent':\n        this.openQuickBooking();\n        break;\n      case 'location':\n        void this.handleLocationAction();\n        break;\n      default:\n        console.warn(`[Marketplace] Unhandled FAB action: ${actionId}`);\n        break;\n    }\n  }\n\n  calculateAveragePrice(): number {\n    const cars = this.carsWithDistance();\n    if (cars.length === 0) return 0;\n    const sum = cars.reduce((acc, car) => acc + car.price_per_day, 0);\n    return Math.round(sum / cars.length);\n  }\n\n  getCarInstantBooking(car: CarWithDistance): boolean {\n    // Check if car has auto_approval enabled (closest equivalent to instant booking)\n    return car.auto_approval === true;\n  }\n\n  /**\n   * Toggle favorite status for a car\n   * @param event - Click event (prevent navigation)\n   * @param carId - Car ID\n   */\n  toggleFavorite(event: Event, carId: string): void {\n    event.stopPropagation();\n    event.preventDefault();\n\n    // Get current favorites from localStorage\n    const favorites = this.getFavorites();\n    const index = favorites.indexOf(carId);\n\n    if (index > -1) {\n      favorites.splice(index, 1);\n      this.showToast('Eliminado de favoritos', 'info');\n    } else {\n      favorites.push(carId);\n      this.showToast('Agregado a favoritos', 'success');\n    }\n\n    // Save to localStorage\n    if (this.isBrowser) {\n      localStorage.setItem('favorites', JSON.stringify(favorites));\n    }\n\n    // Track analytics\n    this.analyticsService.trackEvent('favorite_toggled', {\n      car_id: carId,\n      action: index > -1 ? 'remove' : 'add',\n      source: 'marketplace_card',\n    });\n  }\n\n  /**\n   * Check if a car is favorited\n   * @param carId - Car ID\n   */\n  isFavorite(carId: string): boolean {\n    const favorites = this.getFavorites();\n    return favorites.includes(carId);\n  }\n\n  /**\n   * Get favorites from localStorage\n   */\n  private getFavorites(): string[] {\n    if (!this.isBrowser) return [];\n    try {\n      const stored = localStorage.getItem('favorites');\n      return stored ? JSON.parse(stored) : [];\n    } catch {\n      return [];\n    }\n  }\n\n  showToast(message: string, type: ToastType = 'info'): void {\n    // Using NotificationManagerService instead of inline toast\n    const title =\n      type === 'success'\n        ? 'Éxito'\n        : type === 'error'\n          ? 'Error'\n          : type === 'warning'\n            ? 'Advertencia'\n            : 'Información';\n\n    if (type === 'success') {\n      this.notificationManager.success(title, message);\n    } else if (type === 'error') {\n      this.notificationManager.error(title, message);\n    } else if (type === 'warning') {\n      this.notificationManager.warning(title, message);\n    } else {\n      this.notificationManager.info(title, message);\n    }\n  }\n\n  /**\n   * Handle search radius change from map\n   */\n  onSearchRadiusChange(radiusKm: number): void {\n    this.radiusKm.set(radiusKm);\n    // Reload cars with new radius filter\n    void this.loadCars();\n  }\n\n  /**\n   * Check if user has seen price transparency modal\n   * Show it on first visit with a 1.5s delay\n   */\n  private checkPriceTransparencyModal(): void {\n    if (!this.isBrowser) return;\n\n    const hasSeenModal = localStorage.getItem('hasSeenPriceTransparencyModal');\n\n    if (!hasSeenModal) {\n      // Show modal after 1.5 seconds (after welcome toast)\n      setTimeout(() => {\n        this.showPriceTransparencyModal.set(true);\n      }, 1500);\n    }\n  }\n\n  /**\n   * Handle price transparency modal close\n   */\n  onPriceTransparencyModalClose(): void {\n    this.showPriceTransparencyModal.set(false);\n\n    if (this.isBrowser) {\n      localStorage.setItem('hasSeenPriceTransparencyModal', 'true');\n    }\n\n    // Track analytics event\n    this.analyticsService.trackEvent('price_transparency_modal_viewed', {\n      context: 'marketplace_first_visit',\n      timestamp: new Date().toISOString(),\n    });\n  }\n\n  /**\n   * Handle quick book from hero section\n   */\n  handleHeroQuickBook(): void {\n    const firstCar = this.visibleCars()[0];\n    if (firstCar) {\n      this.openQuickBooking();\n    } else {\n      this.showToast('No hay autos disponibles para reservar', 'warning');\n    }\n  }\n\n  /**\n   * Hide click hint with fade animation\n   */\n  private hideClickHint(): void {\n    if (this.clickHintTimeout) {\n      clearTimeout(this.clickHintTimeout);\n      this.clickHintTimeout = undefined;\n    }\n\n    this.clickHintFading.set(true);\n\n    // Remove from DOM after animation\n    setTimeout(() => {\n      this.showClickHint.set(false);\n      this.clickHintFading.set(false);\n    }, 400);\n  }\n\n  /**\n   * Handle click on hero 3D car - navigate to cars list\n   */\n  onHeroCarClick(): void {\n    // Hide hint immediately if showing\n    if (this.showClickHint()) {\n      this.hideClickHint();\n    }\n\n    // Navigate to cars list\n    void this.router.navigate(['/cars/list']);\n\n    // Track analytics\n    this.analyticsService.trackEvent('hero_car_clicked', {\n      source: '3d_model',\n      destination: '/cars/list',\n    });\n  }\n\n  /**\n   * Check if a quick filter is active\n   */\n  isQuickFilterActive(filterId: string): boolean {\n    return this.activeQuickFilters().has(filterId);\n  }\n\n  /**\n   * Handle sort order change\n   */\n  onSortOrderChange(event: Event): void {\n    const select = event.target as HTMLSelectElement;\n    const value = select.value;\n    this.sortOrder.set(value);\n\n    // Show user-friendly toast message\n    const messages: Record<string, string> = {\n      distance: 'Mostrando autos más cercanos primero',\n      price_asc: 'Ordenado por precio: menor a mayor',\n      price_desc: 'Ordenado por precio: mayor a menor',\n      rating: 'Mostrando mejor valorados primero',\n      score: 'Ordenado por relevancia',\n      relevance: 'Ordenado por relevancia',\n    };\n\n    const message = messages[value] || `Ordenado por: ${value}`;\n    this.showToast(message, 'info');\n  }\n\n  /**\n   * Clear all quick filters\n   */\n  clearQuickFilters(): void {\n    // Reset filters to default\n    this.mapFilters.set({\n      dateRange: null,\n      priceRange: null,\n      vehicleTypes: null,\n      immediateOnly: false,\n      transmission: null,\n    });\n    this.activeQuickFilters.set(new Set());\n    // Reset pagination\n    this.currentPage.set(1);\n    void this.loadCars();\n    this.showToast('Filtros limpiados', 'success');\n  }\n\n  /**\n   * Map filter source locations for the map component\n   */\n  mapFilterSourceLocations(): CarMapLocation[] {\n    return this.carMapLocations();\n  }\n\n  /**\n   * Go to next page of cars\n   */\n  nextPage(): void {\n    if (this.currentPage() < this.totalPages()) {\n      this.currentPage.update((p) => p + 1);\n      void this.loadCars();\n      if (this.isBrowser) {\n        window.scrollTo({ top: 0, behavior: 'smooth' });\n      }\n    }\n  }\n\n  /**\n   * Go to previous page of cars\n   */\n  previousPage(): void {\n    if (this.currentPage() > 1) {\n      this.currentPage.update((p) => p - 1);\n      void this.loadCars();\n      if (this.isBrowser) {\n        window.scrollTo({ top: 0, behavior: 'smooth' });\n      }\n    }\n  }\n}","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/features/messages/inbox.page.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`../../core/repositories/messages.repository` type import should occur after import of `@core/services/bookings/unread-messages.service`","line":7,"column":1,"nodeType":"ImportDeclaration","endLine":7,"endColumn":84,"fix":{"range":[302,950],"text":"import { AuthService } from '@core/services/auth/auth.service';\nimport { Message, MessagesService } from '@core/services/bookings/messages.service';\nimport { NotificationManagerService } from '@core/services/infrastructure/notification-manager.service';\nimport {\n  ConnectionStatus,\n  RealtimeConnectionService,\n} from '@core/services/infrastructure/realtime-connection.service';\nimport { SupabaseClientService } from '@core/services/infrastructure/supabase-client.service';\nimport { UnreadMessagesService } from '@core/services/bookings/unread-messages.service';\nimport type { ConversationDTO } from '../../core/repositories/messages.repository';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { LoggerService } from '@core/services/infrastructure/logger.service';\n\nimport {Component, OnDestroy, OnInit, inject, signal,\n  ChangeDetectionStrategy} from '@angular/core';\nimport { Router } from '@angular/router';\nimport type { RealtimeChannel, SupabaseClient } from '@supabase/supabase-js';\nimport type { ConversationDTO } from '../../core/repositories/messages.repository';\nimport { AuthService } from '@core/services/auth/auth.service';\nimport { Message, MessagesService } from '@core/services/bookings/messages.service';\nimport { NotificationManagerService } from '@core/services/infrastructure/notification-manager.service';\nimport {\n  ConnectionStatus,\n  RealtimeConnectionService,\n} from '@core/services/infrastructure/realtime-connection.service';\nimport { SupabaseClientService } from '@core/services/infrastructure/supabase-client.service';\nimport { UnreadMessagesService } from '@core/services/bookings/unread-messages.service';\n\n/**\n * 📬 Bandeja de entrada de mensajes\n * Muestra todas las conversaciones del usuario\n */\n@Component({\n  selector: 'app-inbox',\n  standalone: true,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  imports: [],\n  styleUrls: ['./inbox-pro.styles.css'],\n  template: `\n    <!-- WhatsApp-style Messages Inbox -->\n    <div class=\"whatsapp-container\">\n      <!-- Header estilo WhatsApp -->\n      <div class=\"whatsapp-header\">\n        <div class=\"header-content\">\n          <h1 class=\"header-title\">Mensajes</h1>\n          <div class=\"header-actions\">\n            <button class=\"icon-btn\" type=\"button\">\n              <svg class=\"icon\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path\n                  stroke-linecap=\"round\"\n                  stroke-linejoin=\"round\"\n                  stroke-width=\"2\"\n                  d=\"M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z\"\n                />\n              </svg>\n            </button>\n            <button class=\"icon-btn\" type=\"button\">\n              <svg class=\"icon\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path\n                  stroke-linecap=\"round\"\n                  stroke-linejoin=\"round\"\n                  stroke-width=\"2\"\n                  d=\"M12 5v.01M12 12v.01M12 19v.01M12 6a1 1 0 110-2 1 1 0 010 2zm0 7a1 1 0 110-2 1 1 0 010 2zm0 7a1 1 0 110-2 1 1 0 010 2z\"\n                />\n              </svg>\n            </button>\n          </div>\n        </div>\n      </div>\n\n      <!-- Conversations List -->\n      <div class=\"conversations-container\">\n        @if (loading()) {\n          <div class=\"loading-state\">\n            <div class=\"spinner\"></div>\n            <p class=\"loading-text\">Cargando conversaciones...</p>\n          </div>\n        } @else if (error()) {\n          <div class=\"error-state\">\n            <p class=\"error-text\">{{ error() }}</p>\n          </div>\n        } @else if (conversations().length === 0) {\n          <div class=\"empty-state\">\n            <img src=\"/assets/images/empty-states/empty-messages.svg\" alt=\"No hay mensajes\" class=\"w-48 h-48 mx-auto mb-4\">\n            <h3 class=\"empty-title\">No hay mensajes</h3>\n            <p class=\"empty-subtitle\">Cuando recibas mensajes aparecerán aquí</p>\n          </div>\n        } @else {\n          <div class=\"conversation-list\">\n            @for (conv of conversations(); track conv['id']) {\n              <button\n                (click)=\"openConversation(conv)\"\n                class=\"conversation-item\"\n                [class.unread]=\"conv.unreadCount > 0\"\n                type=\"button\"\n              >\n                <!-- Avatar -->\n                <div class=\"conversation-avatar\">\n                  @if (conv.otherUserAvatar) {\n                    <img\n                      [src]=\"conv.otherUserAvatar\"\n                      [alt]=\"conv.otherUserName\"\n                      class=\"avatar-img\"\n                    />\n                  } @else {\n                    <div class=\"avatar-placeholder\">\n                      {{ conv.otherUserName.charAt(0).toUpperCase() }}\n                    </div>\n                  }\n                </div>\n\n                <!-- Content -->\n                <div class=\"conversation-content\">\n                  <div class=\"conversation-header\">\n                    <span class=\"conversation-name\">{{ conv.otherUserName }}</span>\n                    <span class=\"conversation-time\">{{ formatDate(conv.lastMessageAt) }}</span>\n                  </div>\n\n                  @if (conv.carBrand) {\n                    <div class=\"conversation-car\">\n                      🚗 {{ conv.carBrand }} {{ conv.carModel }} {{ conv.carYear }}\n                    </div>\n                  }\n\n                  <div class=\"conversation-footer\">\n                    <p class=\"conversation-message\">\n                      {{ conv.lastMessage }}\n                    </p>\n                    @if (conv.unreadCount > 0) {\n                      <span class=\"unread-badge\">\n                        {{ conv.unreadCount > 99 ? '99+' : conv.unreadCount }}\n                      </span>\n                    }\n                  </div>\n                </div>\n              </button>\n            }\n          </div>\n        }\n      </div>\n\n      <!-- Floating Action Button (estilo WhatsApp) -->\n      <div class=\"fab-container\">\n        @if (showAttachMenu()) {\n          <div class=\"attach-menu\" (click)=\"closeAttachMenu($event)\">\n            <button class=\"attach-option\" (click)=\"triggerFileInput('document')\" type=\"button\">\n              <div class=\"attach-icon document\">\n                <svg fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                  <path\n                    stroke-linecap=\"round\"\n                    stroke-linejoin=\"round\"\n                    stroke-width=\"2\"\n                    d=\"M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z\"\n                  />\n                </svg>\n              </div>\n              <span>Documento</span>\n            </button>\n            <button class=\"attach-option\" (click)=\"triggerFileInput('image')\" type=\"button\">\n              <div class=\"attach-icon photo\">\n                <svg fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                  <path\n                    stroke-linecap=\"round\"\n                    stroke-linejoin=\"round\"\n                    stroke-width=\"2\"\n                    d=\"M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z\"\n                  />\n                </svg>\n              </div>\n              <span>Foto/Video</span>\n            </button>\n            <button class=\"attach-option\" (click)=\"triggerFileInput('camera')\" type=\"button\">\n              <div class=\"attach-icon camera\">\n                <svg fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                  <path\n                    stroke-linecap=\"round\"\n                    stroke-linejoin=\"round\"\n                    stroke-width=\"2\"\n                    d=\"M3 9a2 2 0 012-2h.93a2 2 0 001.664-.89l.812-1.22A2 2 0 0110.07 4h3.86a2 2 0 011.664.89l.812 1.22A2 2 0 0018.07 7H19a2 2 0 012 2v9a2 2 0 01-2 2H5a2 2 0 01-2-2V9z\"\n                  />\n                  <path\n                    stroke-linecap=\"round\"\n                    stroke-linejoin=\"round\"\n                    stroke-width=\"2\"\n                    d=\"M15 13a3 3 0 11-6 0 3 3 0 016 0z\"\n                  />\n                </svg>\n              </div>\n              <span>Cámara</span>\n            </button>\n          </div>\n        }\n\n        <button\n          class=\"fab-button\"\n          [class.rotated]=\"showAttachMenu()\"\n          (click)=\"toggleAttachMenu()\"\n          type=\"button\"\n        >\n          <svg class=\"fab-icon\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n            <path\n              stroke-linecap=\"round\"\n              stroke-linejoin=\"round\"\n              stroke-width=\"2\"\n              d=\"M15.172 7l-6.586 6.586a2 2 0 102.828 2.828l6.414-6.586a4 4 0 00-5.656-5.656l-6.415 6.585a6 6 0 108.486 8.486L20.5 13\"\n            />\n          </svg>\n        </button>\n      </div>\n\n      <!-- Hidden file inputs -->\n      <input\n        id=\"documentInput\"\n        type=\"file\"\n        accept=\".pdf,.doc,.docx,.txt,.xls,.xlsx\"\n        (change)=\"handleFileSelect($event, 'document')\"\n        style=\"display: none\"\n      />\n      <input\n        id=\"imageInput\"\n        type=\"file\"\n        accept=\"image/*,video/*\"\n        (change)=\"handleFileSelect($event, 'media')\"\n        style=\"display: none\"\n      />\n      <input\n        id=\"cameraInput\"\n        type=\"file\"\n        accept=\"image/*\"\n        capture=\"environment\"\n        (change)=\"handleFileSelect($event, 'camera')\"\n        style=\"display: none\"\n      />\n    </div>\n  `,\n})\nexport class InboxPage implements OnInit, OnDestroy {\n  private readonly logger = inject(LoggerService);\n  private readonly router = inject(Router);\n  private readonly messagesService = inject(MessagesService);\n  private readonly authService = inject(AuthService);\n  private readonly unreadMessagesService = inject(UnreadMessagesService);\n  private readonly realtimeConnection = inject(RealtimeConnectionService);\n  private readonly supabase: SupabaseClient = inject(SupabaseClientService).getClient();\n  private readonly notifications = inject(NotificationManagerService);\n\n  readonly loading = signal(true);\n  readonly error = signal<string | null>(null);\n  readonly conversations = signal<ConversationDTO[]>([]);\n  readonly connectionStatus = signal<ConnectionStatus>('disconnected');\n  readonly showAttachMenu = signal(false);\n\n  private realtimeChannel?: RealtimeChannel;\n\n  async ngOnInit(): Promise<void> {\n    const session = this.authService.session$();\n    if (!session) {\n      this.router.navigate(['/auth/login']);\n      return;\n    }\n\n    await this.loadConversations();\n    this.subscribeToConversations(session['user']['id']);\n  }\n\n  ngOnDestroy(): void {\n    // Limpiar ambos canales\n    this.realtimeConnection.unsubscribe('inbox-conversations-sender');\n    this.realtimeConnection.unsubscribe('inbox-conversations-recipient');\n  }\n\n  /**\n   * Suscribe a cambios en tiempo real de mensajes\n   * Actualiza solo la conversación afectada en lugar de refetch completo\n   * Usa dos canales separados para sender y recipient porque Supabase Realtime\n   * no soporta OR en filtros directamente\n   */\n  private subscribeToConversations(userId: string): void {\n    // Canal para mensajes donde el usuario es el remitente\n    const senderChannel = this.realtimeConnection.subscribeWithRetry<Message>(\n      'inbox-conversations-sender',\n      {\n        event: '*', // INSERT, UPDATE\n        schema: 'public',\n        table: 'messages',\n        filter: `sender_id=eq.${userId}`,\n      },\n      (payload) => {\n        this.handleMessageChange(payload.new as Message, userId);\n      },\n      (status) => {\n        this.connectionStatus.set(status);\n      },\n    );\n\n    // Canal para mensajes donde el usuario es el destinatario\n    this.realtimeConnection.subscribeWithRetry<Message>(\n      'inbox-conversations-recipient',\n      {\n        event: '*', // INSERT, UPDATE\n        schema: 'public',\n        table: 'messages',\n        filter: `recipient_id=eq.${userId}`,\n      },\n      (payload) => {\n        this.handleMessageChange(payload.new as Message, userId);\n      },\n      (status) => {\n        this.connectionStatus.set(status);\n      },\n    );\n\n    // Guardar referencia al primer canal para cleanup (ambos se limpian igual)\n    this.realtimeChannel = senderChannel;\n  }\n\n  /**\n   * Maneja cambios en mensajes recibidos via realtime\n   * Optimizado: actualiza solo los campos necesarios sin refetch completo\n   */\n  private handleMessageChange(message: Message, userId: string): void {\n    const conversationId = message['car_id'] || message.booking_id;\n    if (!conversationId) return;\n\n    const otherUserId = message.sender_id === userId ? message.recipient_id : message.sender_id;\n    const conversationKey = `${conversationId}_${otherUserId}`;\n\n    // Actualizar solo los campos necesarios sin hacer refetch\n    this.conversations.update((convs) => {\n      const index = convs.findIndex((c) => c['id'] === conversationKey);\n\n      if (index >= 0) {\n        // Actualizar conversación existente\n        const updated = [...convs];\n        const existingConv = updated[index];\n\n        // Update only changed fields\n        updated[index] = {\n          ...existingConv,\n          lastMessage: message.body,\n          lastMessageAt: new Date(message['created_at']),\n          // Increment unread count if message is from other user and not read\n          unreadCount:\n            message.sender_id !== userId ? existingConv.unreadCount + 1 : existingConv.unreadCount,\n        };\n\n        // Reordenar por fecha de último mensaje\n        return updated.sort((a, b) => b.lastMessageAt.getTime() - a.lastMessageAt.getTime());\n      } else {\n        // Nueva conversación - en este caso sí necesitamos hacer fetch\n        // pero lo hacemos en background sin bloquear\n        void this.fetchAndAddNewConversation(conversationKey, message, userId);\n        return convs;\n      }\n    });\n  }\n\n  /**\n   * Fetches and adds a new conversation (called only when a new conversation starts)\n   */\n  private async fetchAndAddNewConversation(\n    conversationKey: string,\n    message: Message,\n    userId: string,\n  ): Promise<void> {\n    try {\n      const updatedConversation = await this.messagesService.listConversations(userId, {\n        limit: 1,\n        offset: 0,\n        carId: message['car_id'] || undefined,\n        bookingId: message.booking_id || undefined,\n      });\n\n      const conv = updatedConversation.conversations.find((c) => c['id'] === conversationKey);\n      if (!conv) return;\n\n      // Add new conversation to the list\n      this.conversations.update((convs) => {\n        // Check if it was already added (race condition)\n        if (convs.some((c) => c['id'] === conversationKey)) return convs;\n        return [conv, ...convs].sort(\n          (a, b) => b.lastMessageAt.getTime() - a.lastMessageAt.getTime(),\n        );\n      });\n    } catch (error) {\n      console.error('Error fetching new conversation:', error);\n    }\n  }\n\n  private async loadConversations(): Promise<void> {\n    try {\n      this.loading.set(true);\n      const userId = this.authService.session$()?.['user']['id'];\n      if (!userId) return;\n\n      // Usar MessagesService que ahora usa MessagesRepository\n      const result = await this.messagesService.listConversations(userId, {\n        limit: 50,\n        offset: 0,\n        archived: false,\n      });\n\n      this.conversations.set(result.conversations);\n    } catch (err) {\n      console.error('Error loading conversations:', err);\n      this['error'].set('Error inesperado');\n    } finally {\n      this.loading.set(false);\n    }\n  }\n\n  openConversation(conv: ConversationDTO): void {\n    const params: Record<string, string> = {\n      userId: conv.otherUserId,\n      userName: conv.otherUserName,\n    };\n\n    if (conv['carId']) {\n      params['carId'] = conv['carId'];\n      params['carName'] = `${conv.carBrand} ${conv.carModel}`;\n\n      // Mark car conversation as read\n      this.unreadMessagesService.markConversationAsRead(conv['carId'], 'car');\n    } else if (conv['bookingId']) {\n      params['bookingId'] = conv['bookingId'];\n\n      // Mark booking conversation as read\n      this.unreadMessagesService.markConversationAsRead(conv['bookingId'], 'booking');\n    }\n\n    this.router.navigate(['/messages/chat'], { queryParams: params });\n  }\n\n  formatDate(date: Date): string {\n    // Usar método del servicio para formateo consistente\n    return this.messagesService.formatRelativeDate(date);\n  }\n\n  toggleAttachMenu(): void {\n    this.showAttachMenu.update((show) => !show);\n\n    // Haptic feedback\n    if ('vibrate' in navigator) {\n      navigator.vibrate(10);\n    }\n  }\n\n  closeAttachMenu(event: Event): void {\n    event.stopPropagation();\n    this.showAttachMenu.set(false);\n  }\n\n  triggerFileInput(type: 'document' | 'image' | 'camera'): void {\n    this.showAttachMenu.set(false);\n\n    // Haptic feedback\n    if ('vibrate' in navigator) {\n      navigator.vibrate([10, 20, 5]);\n    }\n\n    // Trigger the appropriate file input\n    setTimeout(() => {\n      const inputId =\n        type === 'document' ? 'documentInput' : type === 'image' ? 'imageInput' : 'cameraInput';\n      const input = document.querySelector(`input[type=\"file\"]#${inputId}`) as HTMLInputElement;\n      if (input) {\n        input.click();\n      } else {\n        // Fallback: try by accept attribute\n        const inputs = document.querySelectorAll('input[type=\"file\"]');\n        if (type === 'document' && inputs[0]) (inputs[0] as HTMLInputElement).click();\n        if (type === 'image' && inputs[1]) (inputs[1] as HTMLInputElement).click();\n        if (type === 'camera' && inputs[2]) (inputs[2] as HTMLInputElement).click();\n      }\n    }, 100);\n  }\n\n  async handleFileSelect(event: Event, fileType: 'document' | 'media' | 'camera'): Promise<void> {\n    const input = event.target as HTMLInputElement;\n    const file = input.files?.[0];\n\n    if (!file) return;\n\n    // Validar tamaño (máx 10MB)\n    const maxSize = 10 * 1024 * 1024; // 10MB\n    if (file.size > maxSize) {\n      this.notifications.warning(\n        'Archivo muy grande',\n        'El archivo supera el límite de 10MB. Por favor selecciona uno más pequeño.',\n        4000,\n      );\n      input.value = '';\n      return;\n    }\n\n    try {\n      // Mostrar loading\n      this.loading.set(true);\n\n      const session = this.authService.session$();\n      if (!session) {\n        throw new Error('No hay sesión activa');\n      }\n\n      // Subir a Supabase Storage\n      const userId = session['user']['id'];\n      const timestamp = Date.now();\n\n      const sanitizedName = file.name.replace(/[^a-zA-Z0-9.-]/g, '_');\n      const fileName = `${timestamp}_${sanitizedName}`;\n      const filePath = `${userId}/messages/${fileName}`;\n\n      // Determinar el bucket según el tipo\n      const bucket = fileType === 'document' ? 'documents' : 'avatars';\n      const fileSize = (file.size / 1024).toFixed(2);\n\n      this.logger.debug(`📤 Subiendo archivo: ${fileName} (${fileSize}KB) al bucket ${bucket}`);\n\n      // Mostrar notificación de progreso\n      this.notifications.info('Subiendo archivo', `${file.name} (${fileSize}KB)`, 2000);\n\n      // Subir a Supabase Storage\n      const { data, error } = await this.supabase.storage.from(bucket).upload(filePath, file, {\n        cacheControl: '3600',\n        upsert: false,\n        contentType: file.type,\n      });\n\n      if (error) {\n        console.error('❌ Error de Supabase Storage:', error);\n        throw new Error(error['message'] || 'Error al subir archivo');\n      }\n\n      this.logger.debug(`✅ Archivo subido exitosamente:`, data);\n\n      // Obtener URL pública del archivo\n      const { data: urlData } = this.supabase.storage.from(bucket).getPublicUrl(filePath);\n\n      this.logger.debug(`🔗 URL pública: ${urlData.publicUrl}`);\n\n      // Notificación de éxito profesional\n      this.notifications.success(\n        'Archivo subido',\n        `${file.name} se subió correctamente (${fileSize}KB)`,\n        5000,\n      );\n\n      // Limpiar input\n      input.value = '';\n    } catch (error) {\n      console.error('Error subiendo archivo:', error);\n      const errorMessage = error instanceof Error ? error['message'] : 'Error desconocido';\n\n      this.notifications['error']('Error al subir archivo', errorMessage, 5000);\n    } finally {\n      this.loading.set(false);\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/features/messages/messages.page.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`../../shared/components/booking-chat/booking-chat.component` import should occur after import of `@core/services/bookings/bookings.service`","line":7,"column":1,"nodeType":"ImportDeclaration","endLine":7,"endColumn":100,"fix":{"range":[260,500],"text":"import { AuthService } from '@core/services/auth/auth.service';\nimport { BookingsService } from '@core/services/bookings/bookings.service';\nimport { BookingChatComponent } from '../../shared/components/booking-chat/booking-chat.component';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import {Component, OnInit, OnDestroy, inject, signal, computed,\n  ChangeDetectionStrategy} from '@angular/core';\n\nimport { Router, ActivatedRoute, RouterLink } from '@angular/router';\nimport { Subject } from 'rxjs';\nimport { takeUntil } from 'rxjs/operators';\nimport { BookingChatComponent } from '../../shared/components/booking-chat/booking-chat.component';\nimport { AuthService } from '@core/services/auth/auth.service';\nimport { BookingsService } from '@core/services/bookings/bookings.service';\nimport { Booking } from '../../core/models';\nimport { CarChatComponent } from './components/car-chat.component';\n\n/**\n * Página de mensajes standalone\n * Soporta dos modos:\n * 1. Chat de reserva: /messages?bookingId=xxx&userId=xxx&userName=xxx\n * 2. Chat de auto: /messages?carId=xxx&userId=xxx&carName=xxx\n */\n@Component({\n  selector: 'app-messages',\n  standalone: true,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  imports: [RouterLink, BookingChatComponent, CarChatComponent],\n  hostDirectives: [],\n  template: `\n    <div class=\"min-h-screen bg-surface-base dark:bg-surface-raised\">\n      <!-- Header -->\n      <div class=\"sticky top-0 z-10 bg-surface-raised shadow dark:bg-surface-base\">\n        <div class=\"mx-auto max-w-4xl px-4 py-4\">\n          <div class=\"flex items-center gap-4\">\n            <!-- Back button -->\n            <button\n              (click)=\"goBack()\"\n              class=\"flex h-10 w-10 items-center justify-center rounded-full hover:bg-surface-raised dark:hover:bg-gray-700\"\n              type=\"button\"\n            >\n              <svg class=\"h-6 w-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path\n                  stroke-linecap=\"round\"\n                  stroke-linejoin=\"round\"\n                  stroke-width=\"2\"\n                  d=\"M15 19l-7-7 7-7\"\n                />\n              </svg>\n            </button>\n\n            <div>\n              <h1 class=\"text-xl font-semibold text-text-primary dark:text-text-inverse\">\n                Mensajes\n              </h1>\n              <p\n                class=\"text-sm text-text-secondary dark:text-text-secondary dark:text-text-secondary\"\n              >\n                @if (bookingId()) {\n                  Conversación sobre reserva\n                } @else if (carId()) {\n                  Consulta sobre auto\n                } @else {\n                  Chat\n                }\n              </p>\n            </div>\n          </div>\n        </div>\n      </div>\n\n      <!-- Content -->\n      <div class=\"mx-auto max-w-4xl p-4\">\n        <!-- Booking Context Card -->\n        @if (hasBookingContext() && bookingContext()) {\n          <div\n            class=\"mb-4 rounded-lg border border-cta-default/40 bg-cta-default/10 p-4 dark:border-cta-default dark:bg-cta-default/20\"\n          >\n            <div class=\"flex items-start gap-3\">\n              <div class=\"flex-shrink-0\">\n                <svg\n                  class=\"h-6 w-6 text-cta-default dark:text-cta-default\"\n                  fill=\"none\"\n                  stroke=\"currentColor\"\n                  viewBox=\"0 0 24 24\"\n                >\n                  <path\n                    stroke-linecap=\"round\"\n                    stroke-linejoin=\"round\"\n                    stroke-width=\"2\"\n                    d=\"M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z\"\n                  />\n                </svg>\n              </div>\n              <div class=\"flex-1\">\n                <h3 class=\"text-sm font-semibold text-cta-default dark:text-cta-default mb-1\">\n                  Reserva: {{ bookingContext()!.carTitle }}\n                </h3>\n                @if (bookingContext()!.dates) {\n                  <p class=\"text-xs text-cta-default dark:text-cta-default mb-2\">\n                    📅 {{ bookingContext()!.dates }}\n                  </p>\n                }\n                <div class=\"flex items-center gap-2\">\n                  <span\n                    class=\"inline-flex items-center px-2 py-0.5 rounded-full text-xs font-medium\"\n                    [class.bg-cta-default/20]=\"\n                      bookingContext()!.status === 'confirmed' ||\n                      bookingContext()!.status === 'in_progress'\n                    \"\n                    [class.text-cta-default]=\"\n                      bookingContext()!.status === 'confirmed' ||\n                      bookingContext()!.status === 'in_progress'\n                    \"\n                    [class.bg-warning-bg-hover]=\"bookingContext()!.status === 'pending'\"\n                    [class.text-warning-strong]=\"bookingContext()!.status === 'pending'\"\n                    [class.bg-success-light/20]=\"bookingContext()!.status === 'completed'\"\n                    [class.text-success-strong]=\"bookingContext()!.status === 'completed'\"\n                  >\n                    {{ bookingContext()!.statusLabel }}\n                  </span>\n                  <a\n                    [routerLink]=\"['/bookings', bookingId()]\"\n                    class=\"text-xs text-cta-default hover:text-cta-default dark:text-cta-default dark:hover:text-cta-default underline\"\n                  >\n                    Ver detalle\n                  </a>\n                </div>\n              </div>\n            </div>\n          </div>\n        }\n\n        @if (loading()) {\n          <div class=\"flex h-96 items-center justify-center\">\n            <div class=\"text-center\">\n              <div\n                class=\"mb-4 inline-block h-12 w-12 animate-spin rounded-full border-4 border-border-muted border-t-blue-500\"\n              ></div>\n              <p class=\"text-text-secondary dark:text-text-secondary dark:text-text-secondary\">\n                Cargando chat...\n              </p>\n            </div>\n          </div>\n        } @else if (error()) {\n          <div class=\"rounded-lg bg-error-bg p-4 dark:bg-error-900/20\">\n            <p class=\"text-sm text-error-strong\">{{ error() }}</p>\n            <button\n              (click)=\"goBack()\"\n              class=\"mt-2 text-sm text-error-text underline hover:text-error-strong\"\n              type=\"button\"\n            >\n              Volver\n            </button>\n          </div>\n        } @else if (bookingId() && recipientId() && recipientName()) {\n          <!-- Booking chat -->\n          <app-booking-chat\n            [bookingId]=\"bookingId()!\"\n            [recipientId]=\"recipientId()!\"\n            [recipientName]=\"recipientName()!\"\n          />\n        } @else if (carId() && recipientId() && recipientName()) {\n          <!-- Car chat (pre-booking) -->\n          <app-car-chat\n            [carId]=\"carId()!\"\n            [recipientId]=\"recipientId()!\"\n            [recipientName]=\"recipientName()!\"\n          />\n        } @else {\n          <div class=\"rounded-lg bg-warning-bg p-4 dark:bg-warning-900/20\">\n            <p class=\"text-sm text-warning-strong dark:text-warning-200\">\n              ⚠️ Faltan parámetros para iniciar el chat\n            </p>\n            <button\n              (click)=\"goBack()\"\n              class=\"mt-2 text-sm text-warning-text underline hover:text-warning-strong dark:text-warning-400\"\n              type=\"button\"\n            >\n              Volver\n            </button>\n          </div>\n        }\n      </div>\n    </div>\n  `,\n})\nexport class MessagesPage implements OnInit, OnDestroy {\n  private readonly router = inject(Router);\n  private readonly route = inject(ActivatedRoute);\n  private readonly authService = inject(AuthService);\n  private readonly bookingsService = inject(BookingsService);\n\n  // ✅ P0-006 FIX: Destroy subject para limpiar subscriptions\n  private readonly destroy$ = new Subject<void>();\n\n  // Query params\n  readonly bookingId = signal<string | null>(null);\n  readonly carId = signal<string | null>(null);\n  readonly recipientId = signal<string | null>(null);\n  readonly recipientName = signal<string | null>(null);\n\n  // Booking context (when bookingId is available)\n  readonly booking = signal<Booking | null>(null);\n  readonly loadingBooking = signal(false);\n\n  // State\n  readonly loading = signal(true);\n  readonly error = signal<string | null>(null);\n\n  // Computed\n  readonly bookingContext = computed(() => {\n    const booking = this.booking();\n    if (!booking) return null;\n\n    return {\n      carTitle: booking.car_title || `${booking.car_brand} ${booking.car_model}`,\n      dates:\n        booking.start_at && booking.end_at\n          ? `${new Date(booking.start_at).toLocaleDateString('es-AR')} - ${new Date(booking.end_at).toLocaleDateString('es-AR')}`\n          : null,\n      status: booking.status,\n      statusLabel: this.getStatusLabel(booking.status),\n    };\n  });\n\n  readonly hasBookingContext = computed(() => this.booking() !== null);\n\n  async ngOnInit(): Promise<void> {\n    // Verificar autenticación\n    const session = this.authService.session$();\n    if (!session) {\n      this.error.set('Debes iniciar sesión para ver los mensajes');\n      this.loading.set(false);\n      setTimeout(() => {\n        this.router.navigate(['/auth/login'], {\n          queryParams: { returnUrl: this.router.url },\n        });\n      }, 2000);\n      return;\n    }\n\n    // Leer query params\n    this.route.queryParams.pipe(takeUntil(this.destroy$)).subscribe(async (params) => {\n      this.bookingId.set(params['bookingId'] ?? null);\n      this.carId.set(params['carId'] ?? null);\n      this.recipientId.set(params['userId'] ?? null);\n      this.recipientName.set(params['userName'] ?? params['carName'] ?? 'Usuario');\n\n      // Validar que tenemos al menos booking o car ID\n      if (!this.bookingId() && !this.carId()) {\n        this.error.set('Falta información para iniciar el chat (booking o car ID)');\n      }\n\n      // Validar que tenemos recipient\n      if (!this.recipientId()) {\n        this.error.set('Falta información del destinatario');\n      }\n\n      // Cargar información del booking si está disponible\n      if (this.bookingId()) {\n        await this.loadBookingContext(this.bookingId()!);\n      }\n\n      this.loading.set(false);\n    });\n  }\n\n  ngOnDestroy(): void {\n    this.destroy$.next();\n    this.destroy$.complete();\n  }\n\n  /**\n   * Carga información del booking para mostrar contexto\n   */\n  private async loadBookingContext(bookingId: string): Promise<void> {\n    this.loadingBooking.set(true);\n    try {\n      const booking = await this.bookingsService.getBookingById(bookingId);\n      if (booking) {\n        this.booking.set(booking);\n      }\n    } catch (err) {\n      // No fallar si no se puede cargar el booking, solo no mostrar contexto\n      console.error('Error loading booking context:', err);\n    } finally {\n      this.loadingBooking.set(false);\n    }\n  }\n\n  /**\n   * Obtiene la etiqueta del estado del booking\n   */\n  private getStatusLabel(status: string): string {\n    switch (status) {\n      case 'pending':\n        return 'Pendiente de pago';\n      case 'confirmed':\n        return 'Confirmada';\n      case 'in_progress':\n        return 'En curso';\n      case 'completed':\n        return 'Finalizada';\n      case 'cancelled':\n        return 'Cancelada';\n      case 'expired':\n        return 'Vencida';\n      default:\n        return status;\n    }\n  }\n\n  /**\n   * Formatea fecha\n   */\n  formatDateTime(dateStr: string): string {\n    return new Date(dateStr).toLocaleString('es-AR', {\n      day: '2-digit',\n      month: '2-digit',\n      year: 'numeric',\n      hour: '2-digit',\n      minute: '2-digit',\n    });\n  }\n\n  goBack(): void {\n    this.router.navigate(['/']);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/features/profile/profile-expanded.page.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`@core/services/auth/auth.service` import should occur before import of `../../core/stores/profile.store`","line":13,"column":1,"nodeType":"ImportDeclaration","endLine":13,"endColumn":64,"fix":{"range":[305,1271],"text":"import { AuthService } from '@core/services/auth/auth.service';\nimport { ProfileStore } from '../../core/stores/profile.store';\nimport { DocumentUploadModalComponent } from '../../shared/components/document-upload-modal/document-upload-modal.component';\nimport { BonusMalusCardComponent } from '../../shared/components/bonus-malus-card/bonus-malus-card.component';\nimport { RenterLevelProgressComponent } from '../../shared/components/renter-level-progress/renter-level-progress.component';\nimport { AiReputationCardComponent } from '../../shared/components/ai-reputation-card/ai-reputation-card.component';\nimport { AiCarRecommendationComponent } from '../../shared/components/ai-car-recommendation/ai-car-recommendation.component';\nimport { BookingHistoryListComponent } from '../../shared/components/booking-history-list/booking-history-list.component';\nimport { ReferralBannerComponent } from '../../shared/components/referral-banner/referral-banner.component';\n"}},{"ruleId":"import/order","severity":1,"message":"`@core/services/ui/meta.service` import should occur before import of `../../core/stores/profile.store`","line":14,"column":1,"nodeType":"ImportDeclaration","endLine":14,"endColumn":62,"fix":{"range":[305,1333],"text":"import { MetaService } from '@core/services/ui/meta.service';\nimport { ProfileStore } from '../../core/stores/profile.store';\nimport { DocumentUploadModalComponent } from '../../shared/components/document-upload-modal/document-upload-modal.component';\nimport { BonusMalusCardComponent } from '../../shared/components/bonus-malus-card/bonus-malus-card.component';\nimport { RenterLevelProgressComponent } from '../../shared/components/renter-level-progress/renter-level-progress.component';\nimport { AiReputationCardComponent } from '../../shared/components/ai-reputation-card/ai-reputation-card.component';\nimport { AiCarRecommendationComponent } from '../../shared/components/ai-car-recommendation/ai-car-recommendation.component';\nimport { BookingHistoryListComponent } from '../../shared/components/booking-history-list/booking-history-list.component';\nimport { ReferralBannerComponent } from '../../shared/components/referral-banner/referral-banner.component';\nimport { AuthService } from '@core/services/auth/auth.service';\n"}},{"ruleId":"import/order","severity":1,"message":"`@core/services/verification/verification-state.service` import should occur before import of `../../core/stores/profile.store`","line":15,"column":1,"nodeType":"ImportDeclaration","endLine":15,"endColumn":99,"fix":{"range":[305,1432],"text":"import { VerificationStateService } from '@core/services/verification/verification-state.service';\nimport { ProfileStore } from '../../core/stores/profile.store';\nimport { DocumentUploadModalComponent } from '../../shared/components/document-upload-modal/document-upload-modal.component';\nimport { BonusMalusCardComponent } from '../../shared/components/bonus-malus-card/bonus-malus-card.component';\nimport { RenterLevelProgressComponent } from '../../shared/components/renter-level-progress/renter-level-progress.component';\nimport { AiReputationCardComponent } from '../../shared/components/ai-reputation-card/ai-reputation-card.component';\nimport { AiCarRecommendationComponent } from '../../shared/components/ai-car-recommendation/ai-car-recommendation.component';\nimport { BookingHistoryListComponent } from '../../shared/components/booking-history-list/booking-history-list.component';\nimport { ReferralBannerComponent } from '../../shared/components/referral-banner/referral-banner.component';\nimport { AuthService } from '@core/services/auth/auth.service';\nimport { MetaService } from '@core/services/ui/meta.service';\n"}},{"ruleId":"import/order","severity":1,"message":"`@core/services/verification/verification.service` import should occur before import of `../../core/stores/profile.store`","line":16,"column":1,"nodeType":"ImportDeclaration","endLine":16,"endColumn":88,"fix":{"range":[305,1520],"text":"import { VerificationService } from '@core/services/verification/verification.service';\nimport { ProfileStore } from '../../core/stores/profile.store';\nimport { DocumentUploadModalComponent } from '../../shared/components/document-upload-modal/document-upload-modal.component';\nimport { BonusMalusCardComponent } from '../../shared/components/bonus-malus-card/bonus-malus-card.component';\nimport { RenterLevelProgressComponent } from '../../shared/components/renter-level-progress/renter-level-progress.component';\nimport { AiReputationCardComponent } from '../../shared/components/ai-reputation-card/ai-reputation-card.component';\nimport { AiCarRecommendationComponent } from '../../shared/components/ai-car-recommendation/ai-car-recommendation.component';\nimport { BookingHistoryListComponent } from '../../shared/components/booking-history-list/booking-history-list.component';\nimport { ReferralBannerComponent } from '../../shared/components/referral-banner/referral-banner.component';\nimport { AuthService } from '@core/services/auth/auth.service';\nimport { MetaService } from '@core/services/ui/meta.service';\nimport { VerificationStateService } from '@core/services/verification/verification-state.service';\n"}},{"ruleId":"import/order","severity":1,"message":"`@core/services/cars/reviews.service` import should occur before import of `../../core/stores/profile.store`","line":17,"column":1,"nodeType":"ImportDeclaration","endLine":17,"endColumn":70,"fix":{"range":[305,1590],"text":"import { ReviewsService } from '@core/services/cars/reviews.service';\nimport { ProfileStore } from '../../core/stores/profile.store';\nimport { DocumentUploadModalComponent } from '../../shared/components/document-upload-modal/document-upload-modal.component';\nimport { BonusMalusCardComponent } from '../../shared/components/bonus-malus-card/bonus-malus-card.component';\nimport { RenterLevelProgressComponent } from '../../shared/components/renter-level-progress/renter-level-progress.component';\nimport { AiReputationCardComponent } from '../../shared/components/ai-reputation-card/ai-reputation-card.component';\nimport { AiCarRecommendationComponent } from '../../shared/components/ai-car-recommendation/ai-car-recommendation.component';\nimport { BookingHistoryListComponent } from '../../shared/components/booking-history-list/booking-history-list.component';\nimport { ReferralBannerComponent } from '../../shared/components/referral-banner/referral-banner.component';\nimport { AuthService } from '@core/services/auth/auth.service';\nimport { MetaService } from '@core/services/ui/meta.service';\nimport { VerificationStateService } from '@core/services/verification/verification-state.service';\nimport { VerificationService } from '@core/services/verification/verification.service';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":5,"source":"import { ChangeDetectionStrategy, Component, computed, effect, inject, signal, DestroyRef, OnInit } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { ActivatedRoute, Router, RouterLink } from '@angular/router';\nimport { takeUntilDestroyed } from '@angular/core/rxjs-interop';\nimport { ProfileStore } from '../../core/stores/profile.store';\nimport { DocumentUploadModalComponent } from '../../shared/components/document-upload-modal/document-upload-modal.component';\nimport { BonusMalusCardComponent } from '../../shared/components/bonus-malus-card/bonus-malus-card.component';\nimport { RenterLevelProgressComponent } from '../../shared/components/renter-level-progress/renter-level-progress.component';\nimport { AiReputationCardComponent } from '../../shared/components/ai-reputation-card/ai-reputation-card.component';\nimport { AiCarRecommendationComponent } from '../../shared/components/ai-car-recommendation/ai-car-recommendation.component';\nimport { BookingHistoryListComponent } from '../../shared/components/booking-history-list/booking-history-list.component';\nimport { ReferralBannerComponent } from '../../shared/components/referral-banner/referral-banner.component';\nimport { AuthService } from '@core/services/auth/auth.service';\nimport { MetaService } from '@core/services/ui/meta.service';\nimport { VerificationStateService } from '@core/services/verification/verification-state.service';\nimport { VerificationService } from '@core/services/verification/verification.service';\nimport { ReviewsService } from '@core/services/cars/reviews.service';\nimport { KycStatus } from '../../core/models';\n\n/**\n * Profile Expanded Page - Simplified\n *\n * Shows hero section with:\n * - Avatar and basic info\n * - Stats (ratings, bookings, etc.)\n * - Verification status card\n * - Quick actions: Dashboard, Wallet, Publish Car\n *\n * All detailed sections moved to dedicated pages accessible via dropdown menu\n */\n@Component({\n  standalone: true,\n  selector: 'app-profile-expanded-page',\n  imports: [\n    CommonModule,\n    RouterLink,\n    DocumentUploadModalComponent,\n    BonusMalusCardComponent,\n    RenterLevelProgressComponent,\n    AiReputationCardComponent,\n    AiCarRecommendationComponent,\n    BookingHistoryListComponent,\n    ReferralBannerComponent,\n  ],\n  templateUrl: './profile-expanded.page.html',\n  styleUrls: ['./profile-expanded.page.css'],\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class ProfileExpandedPage implements OnInit {\n  private readonly authService = inject(AuthService);\n  private readonly metaService = inject(MetaService);\n  private readonly verificationStateService = inject(VerificationStateService);\n  private readonly verificationService = inject(VerificationService);\n  private readonly route = inject(ActivatedRoute);\n  private readonly router = inject(Router);\n  private readonly destroyRef = inject(DestroyRef);\n  readonly profileStore = inject(ProfileStore);\n  private readonly reviewsService = inject(ReviewsService);\n\n  // Document upload modal state\n  readonly showDocumentModal = signal(false);\n  readonly documentType = signal<string | null>(null);\n\n  // Profile signals from store\n  readonly profile = this.profileStore.profile;\n  readonly loading = this.profileStore.loading;\n  readonly error = this.profileStore.error;\n\n  // User stats\n  readonly userStats = this.reviewsService.userStats;\n\n  // Wallet balance - TODO: needs to be fetched from wallet_balances table\n  readonly walletBalance = computed(() => 0); // Placeholder until wallet integration\n\n  // Verification status from VerificationStateService\n  readonly verificationProgress = this.verificationStateService.verificationProgress;\n\n  // User documents from VerificationService\n  readonly userDocuments = this.verificationService.documents;\n\n  readonly driverLicenseStatus = computed(() => {\n    const docs = this.userDocuments();\n    // Check for license_front and license_back (DB enum values)\n    const frontDoc = docs.find(d => d.kind === 'license_front');\n    const backDoc = docs.find(d => d.kind === 'license_back');\n\n    // Both must be uploaded and verified\n    if (!frontDoc && !backDoc) return 'not_started' as KycStatus;\n\n    const frontStatus = frontDoc?.status;\n    const backStatus = backDoc?.status;\n\n    // If either is verified, show as verified (relaxed check)\n    if (frontStatus === 'verified' || backStatus === 'verified') return 'verified' as KycStatus;\n    // If either is pending, show as pending\n    if (frontStatus === 'pending' || backStatus === 'pending') return 'pending' as KycStatus;\n\n    return 'not_started' as KycStatus;\n  });\n\n  readonly vehicleRegistrationStatus = computed(() => {\n    const docs = this.userDocuments();\n    const vehicleDoc = docs.find(d => d.kind === 'vehicle_registration');\n    if (!vehicleDoc) return 'not_started' as KycStatus;\n    if (vehicleDoc.status === 'verified') return 'verified' as KycStatus;\n    if (vehicleDoc.status === 'pending') return 'pending' as KycStatus;\n    return 'not_started' as KycStatus;\n  });\n\n  readonly kycStatus = computed(() => this.calculateKycStatus());\n\n  // Computed stats from userStats\n  readonly renterRating = computed(() => this.userStats()?.renter_rating_avg || 0);\n  readonly renterReviewsCount = computed(() => this.userStats()?.renter_reviews_count || 0);\n  readonly totalBookingsAsRenter = computed(() => this.userStats()?.total_bookings_as_renter || 0);\n\n  readonly ownerRating = computed(() => this.userStats()?.owner_rating_avg || 0);\n  readonly ownerReviewsCount = computed(() => this.userStats()?.owner_reviews_count || 0);\n  readonly totalBookingsAsOwner = computed(() => this.userStats()?.total_bookings_as_owner || 0);\n\n  readonly badges = computed(() => this.userStats()?.badges || []);\n\n  // Member since date from profile\n  readonly memberSince = computed(() => this.profile()?.created_at);\n\n  // Avatar and user info\n  readonly avatarUrl = computed(() => this.profile()?.avatar_url);\n  readonly userEmail = computed(() => this.authService.session$()?.user?.email ?? this.profile()?.id);\n  readonly govIdLabel = computed(() => {\n    const type = this.profile()?.gov_id_type?.toLowerCase();\n    if (!type) return 'Documento';\n    const labels: Record<string, string> = {\n      dni: 'DNI',\n      cuit: 'CUIT',\n      passport: 'Pasaporte',\n    };\n    return labels[type] ?? type.toUpperCase();\n  });\n\n  // UI state - delegated to ProfileStore\n  readonly uploadingAvatar = this.profileStore.uploadingAvatar;\n  readonly message = signal<string | null>(null);\n\n  constructor() {\n    // Set page metadata\n    this.metaService.updateMeta({\n      title: 'Mi Perfil - AutoRenta',\n      description: 'Gestiona tu perfil, configuración y preferencias en AutoRenta',\n    });\n\n    // Load profile data\n    void this.profileStore.loadProfile();\n\n    // Initialize verification state service\n    void this.verificationStateService.initialize();\n\n    // Load user documents for verification status\n    void this.verificationService.loadDocuments();\n\n    // Load user stats when profile is available\n    effect(() => {\n      const profile = this.profile();\n      if (profile?.id) {\n        void this.reviewsService.loadUserStats(profile.id);\n      }\n    });\n  }\n\n  ngOnInit(): void {\n    // Handle document upload query param\n    this.route.queryParams\n      .pipe(takeUntilDestroyed(this.destroyRef))\n      .subscribe((params) => {\n        const docType = params['doc'];\n        if (docType) {\n          this.documentType.set(docType);\n          this.showDocumentModal.set(true);\n        }\n      });\n  }\n\n  /**\n   * Check if user can publish cars\n   */\n  canPublishCars(): boolean {\n    const role = this.profile()?.role;\n    return role === 'owner' || role === 'both';\n  }\n\n  /**\n   * Get badge visual properties\n   */\n  getBadgeProps(type: string): { color: string; icon: string } {\n    const badgeMap: Record<string, { color: string; icon: string }> = {\n      top_host: { color: 'text-warning-strong', icon: 'star' },\n      super_host: { color: 'text-warning-strong', icon: 'award' },\n      verified_renter: { color: 'text-success-text', icon: 'check-circle' },\n      trusted_driver: { color: 'text-info-text', icon: 'check-circle' },\n    };\n    return badgeMap[type] || { color: 'text-text-muted', icon: 'check-circle' };\n  }\n\n  /**\n   * Check if user can book cars\n   */\n  canBookCars(): boolean {\n    const role = this.profile()?.role;\n    return role === 'renter' || role === 'both';\n  }\n\n  /**\n   * Calculate overall KYC status\n   */\n  private calculateKycStatus(): KycStatus {\n    const dl = this.driverLicenseStatus();\n    const vr = this.vehicleRegistrationStatus();\n\n    if (dl === 'verified' && vr === 'verified') {\n      return 'verified';\n    }\n\n    if (dl === 'rejected' || vr === 'rejected') {\n      return 'rejected';\n    }\n\n    if (dl === 'pending' || vr === 'pending') {\n      return 'pending';\n    }\n\n    return 'not_started';\n  }\n\n  /**\n   * Get CSS class for KYC status\n   */\n  getKycStatusClass(status: KycStatus): string {\n    const classMap: Record<KycStatus, string> = {\n      verified: 'text-success-text dark:text-success-200',\n      pending: 'text-warning-text dark:text-warning-200',\n      rejected: 'text-error-text dark:text-error-200',\n      not_started: 'text-text-muted dark:text-text-secondary/50',\n    };\n\n    return classMap[status] || classMap.not_started;\n  }\n\n  /**\n   * Get label for KYC status\n   */\n  getKycStatusLabel(status: KycStatus): string {\n    const labelMap: Record<KycStatus, string> = {\n      verified: 'Verificado',\n      pending: 'En Revisión',\n      rejected: 'Rechazado',\n      not_started: 'Sin Enviar',\n    };\n\n    return labelMap[status] || labelMap.not_started;\n  }\n\n  /**\n   * Handle avatar change - uploads file to Supabase Storage\n   */\n  async onAvatarChange(event: Event): Promise<void> {\n    const input = event.target as HTMLInputElement;\n    const file = input.files?.[0];\n\n    if (!file) {\n      return;\n    }\n\n    // Validate file type\n    if (!file.type.startsWith('image/')) {\n      this.message.set('Por favor selecciona una imagen válida');\n      setTimeout(() => this.message.set(null), 3000);\n      return;\n    }\n\n    // Validate file size (max 2MB)\n    const maxSize = 2 * 1024 * 1024;\n    if (file.size > maxSize) {\n      this.message.set('La imagen debe ser menor a 2MB');\n      setTimeout(() => this.message.set(null), 3000);\n      return;\n    }\n\n    try {\n      await this.profileStore.uploadAvatar(file);\n      this.message.set('¡Foto de perfil actualizada!');\n      setTimeout(() => this.message.set(null), 3000);\n    } catch (err) {\n      console.error('Error uploading avatar:', err);\n      this.message.set('Error al subir la imagen. Intenta de nuevo.');\n      setTimeout(() => this.message.set(null), 3000);\n    }\n\n    // Clear input value to allow re-selecting same file\n    input.value = '';\n  }\n\n  /**\n   * Close document upload modal and clear query param\n   */\n  closeDocumentModal(): void {\n    this.showDocumentModal.set(false);\n    this.documentType.set(null);\n    // Remove query param from URL without navigation\n    void this.router.navigate([], {\n      relativeTo: this.route,\n      queryParams: {},\n      replaceUrl: true,\n    });\n  }\n\n  /**\n   * Handle document uploaded successfully\n   */\n  onDocumentUploaded(): void {\n    // Reload documents to update status\n    void this.verificationService.loadDocuments();\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/features/profile/security/profile-security.page.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`@core/services/auth/auth.service` import should occur before import of `../../../core/stores/profile.store`","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":8,"endColumn":64,"fix":{"range":[230,361],"text":"import { AuthService } from '@core/services/auth/auth.service';\nimport { ProfileStore } from '../../../core/stores/profile.store';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import {Component, inject, OnInit, signal,\n  ChangeDetectionStrategy} from '@angular/core';\n\nimport { FormBuilder, FormGroup, ReactiveFormsModule, Validators } from '@angular/forms';\nimport { IonicModule } from '@ionic/angular';\n\nimport { ProfileStore } from '../../../core/stores/profile.store';\nimport { AuthService } from '@core/services/auth/auth.service';\n\n/**\n * Profile Security Page\n *\n * Dedicated page for security settings:\n * - Change password\n * - ToS acceptance status\n * - Active sessions (future)\n * - Security activity log (future)\n */\n@Component({\n  selector: 'app-profile-security',\n  standalone: true,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  imports: [IonicModule, ReactiveFormsModule],\n  template: `\n    <ion-header>\n      <ion-toolbar\n        class=\"bg-surface-raised dark:bg-surface-secondary border-b border-border-default\"\n        >\n        <ion-buttons slot=\"start\">\n          <ion-back-button\n            defaultHref=\"/profile\"\n            text=\"Perfil\"\n            class=\"text-text-primary dark:text-text-secondary\"\n          ></ion-back-button>\n        </ion-buttons>\n        <ion-title class=\"text-text-primary dark:text-text-secondary\"> Seguridad </ion-title>\n      </ion-toolbar>\n    </ion-header>\n    \n    <ion-content class=\"bg-surface-base dark:bg-surface-base\">\n      <div class=\"min-h-full py-6 px-4 max-w-4xl mx-auto\">\n        <!-- Header -->\n        <div class=\"mb-6\">\n          <h1 class=\"text-2xl font-bold text-text-primary dark:text-text-primary mb-2\">\n            Configuración de Seguridad\n          </h1>\n          <p class=\"text-sm text-text-secondary dark:text-text-secondary\">\n            Gestiona la seguridad de tu cuenta.\n          </p>\n        </div>\n    \n        <!-- Change Password Section -->\n        <div class=\"card-premium p-6 mb-6\">\n          <h2 class=\"text-lg font-semibold text-text-primary dark:text-text-primary mb-4\">\n            Cambiar Contraseña\n          </h2>\n    \n          <!-- Success Message -->\n          @if (passwordChangeSuccess()) {\n            <div\n              class=\"mb-4 p-3 rounded-lg bg-success-light/10 border border-success-light/40 text-sm text-success-text\"\n              >\n              ✅ Contraseña actualizada correctamente\n            </div>\n          }\n    \n          <!-- Error Message -->\n          @if (passwordError()) {\n            <div\n              class=\"mb-4 p-3 rounded-lg bg-error-bg border border-error-border text-sm text-error-text\"\n              >\n              {{ passwordError() }}\n            </div>\n          }\n    \n          <form [formGroup]=\"passwordForm\" (ngSubmit)=\"onChangePassword()\" class=\"space-y-4\">\n            <!-- Current Password -->\n            <div>\n              <label\n                for=\"currentPassword\"\n                class=\"block text-sm font-medium text-text-primary dark:text-text-primary mb-1\"\n                >\n                Contraseña Actual\n              </label>\n              <input\n                id=\"currentPassword\"\n                type=\"password\"\n                formControlName=\"currentPassword\"\n                class=\"w-full px-3 py-2 rounded-lg border border-border-default dark:border-border-default bg-surface-raised dark:bg-surface-secondary text-text-primary dark:text-text-secondary focus:outline-none focus:ring-2 focus:ring-cta-default\"\n                placeholder=\"Tu contraseña actual\"\n                />\n              @if (\n                passwordForm.get('currentPassword')?.invalid &&\n                passwordForm.get('currentPassword')?.touched\n                ) {\n                <p\n                  class=\"mt-1 text-xs text-error-text\"\n                  >\n                  La contraseña actual es requerida\n                </p>\n              }\n            </div>\n    \n            <!-- New Password -->\n            <div>\n              <label\n                for=\"newPassword\"\n                class=\"block text-sm font-medium text-text-primary dark:text-text-primary mb-1\"\n                >\n                Nueva Contraseña\n              </label>\n              <input\n                id=\"newPassword\"\n                type=\"password\"\n                formControlName=\"newPassword\"\n                class=\"w-full px-3 py-2 rounded-lg border border-border-default dark:border-border-default bg-surface-raised dark:bg-surface-secondary text-text-primary dark:text-text-secondary focus:outline-none focus:ring-2 focus:ring-cta-default\"\n                placeholder=\"Mínimo 8 caracteres\"\n                />\n              @if (\n                passwordForm.get('newPassword')?.invalid &&\n                passwordForm.get('newPassword')?.touched\n                ) {\n                <p\n                  class=\"mt-1 text-xs text-error-text\"\n                  >\n                  La contraseña debe tener al menos 8 caracteres\n                </p>\n              }\n            </div>\n    \n            <!-- Confirm New Password -->\n            <div>\n              <label\n                for=\"confirmPassword\"\n                class=\"block text-sm font-medium text-text-primary dark:text-text-primary mb-1\"\n                >\n                Confirmar Nueva Contraseña\n              </label>\n              <input\n                id=\"confirmPassword\"\n                type=\"password\"\n                formControlName=\"confirmPassword\"\n                class=\"w-full px-3 py-2 rounded-lg border border-border-default dark:border-border-default bg-surface-raised dark:bg-surface-secondary text-text-primary dark:text-text-secondary focus:outline-none focus:ring-2 focus:ring-cta-default\"\n                placeholder=\"Repite la nueva contraseña\"\n                />\n              @if (\n                passwordForm.hasError('passwordMismatch') &&\n                passwordForm.get('confirmPassword')?.touched\n                ) {\n                <p\n                  class=\"mt-1 text-xs text-error-text\"\n                  >\n                  Las contraseñas no coinciden\n                </p>\n              }\n            </div>\n    \n            <!-- Submit Button -->\n            <button\n              type=\"submit\"\n              [disabled]=\"changingPassword() || passwordForm.invalid\"\n              class=\"w-full px-6 py-2.5 rounded-lg font-semibold text-sm transition-all disabled:opacity-50 disabled:cursor-not-allowed bg-cta-default hover:bg-cta-hover text-cta-text shadow-sm hover:shadow-md\"\n              >\n              @if (!changingPassword()) {\n                <span>Cambiar Contraseña</span>\n              }\n              @if (changingPassword()) {\n                <span>Cambiando...</span>\n              }\n            </button>\n          </form>\n        </div>\n    \n        <!-- Terms of Service -->\n        <div class=\"card-premium p-6 mb-6\">\n          <h2 class=\"text-lg font-semibold text-text-primary dark:text-text-primary mb-4\">\n            Términos y Condiciones\n          </h2>\n          <div class=\"flex items-start gap-3\">\n            <svg\n              class=\"h-5 w-5 text-success-text flex-shrink-0 mt-0.5\"\n              fill=\"none\"\n              stroke=\"currentColor\"\n              viewBox=\"0 0 24 24\"\n              >\n              <path\n                stroke-linecap=\"round\"\n                stroke-linejoin=\"round\"\n                stroke-width=\"2\"\n                d=\"M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z\"\n                />\n            </svg>\n            <div>\n              <p class=\"text-sm text-text-primary dark:text-text-primary\">\n                Aceptaste los Términos y Condiciones el\n                <span class=\"font-semibold\">{{ formatDate(profile()?.tos_accepted_at) }}</span>\n              </p>\n              <a\n                href=\"/legal/terms\"\n                target=\"_blank\"\n                class=\"mt-2 inline-block text-xs text-cta-default hover:text-cta-hover underline\"\n                >\n                Ver Términos y Condiciones →\n              </a>\n            </div>\n          </div>\n        </div>\n    \n        <!-- Verification Status -->\n        <div class=\"card-premium p-6\">\n          <h2 class=\"text-lg font-semibold text-text-primary dark:text-text-primary mb-4\">\n            Estado de Verificación\n          </h2>\n          <div class=\"space-y-3\">\n            <!-- Email -->\n            <div class=\"flex items-center justify-between\">\n              <span class=\"text-sm text-text-primary dark:text-text-primary\">Email</span>\n              <span\n                [class]=\"\n                  profile()?.email_verified\n                    ? 'text-success-text font-semibold text-sm'\n                    : 'text-text-muted text-sm'\n                \"\n                >\n                {{ profile()?.email_verified ? '✓ Verificado' : '✗ Sin verificar' }}\n              </span>\n            </div>\n    \n            <!-- Phone -->\n            <div class=\"flex items-center justify-between\">\n              <span class=\"text-sm text-text-primary dark:text-text-primary\">Teléfono</span>\n              <span\n                [class]=\"\n                  profile()?.phone_verified\n                    ? 'text-success-text font-semibold text-sm'\n                    : 'text-text-muted text-sm'\n                \"\n                >\n                {{ profile()?.phone_verified ? '✓ Verificado' : '✗ Sin verificar' }}\n              </span>\n            </div>\n    \n            <!-- Driver License -->\n            <div class=\"flex items-center justify-between\">\n              <span class=\"text-sm text-text-primary dark:text-text-primary\"\n                >Licencia de Conducir</span\n                >\n                <span\n                [class]=\"\n                  profile()?.id_verified\n                    ? 'text-success-text font-semibold text-sm'\n                    : 'text-text-muted text-sm'\n                \"\n                  >\n                  {{ profile()?.id_verified ? '✓ Verificado' : '✗ Sin verificar' }}\n                </span>\n              </div>\n            </div>\n    \n            <a\n              routerLink=\"/profile/verification\"\n              class=\"mt-4 inline-block text-sm text-cta-default hover:text-cta-hover font-semibold\"\n              >\n              Gestionar verificaciones →\n            </a>\n          </div>\n    \n          <!-- Future: Active Sessions -->\n          <!-- <div class=\"card-premium p-6 mt-6\">\n          <h2 class=\"text-lg font-semibold text-text-primary dark:text-text-primary mb-4\">\n            Sesiones Activas\n          </h2>\n          <p class=\"text-sm text-text-secondary\">Próximamente...</p>\n        </div> -->\n      </div>\n    </ion-content>\n    `,\n  styles: [\n    `\n      :host {\n        display: block;\n        height: 100%;\n      }\n\n      ion-content {\n        --padding-bottom: 24px;\n        min-height: 100vh;\n      }\n    `,\n  ],\n})\nexport class ProfileSecurityPage implements OnInit {\n  private readonly fb = inject(FormBuilder);\n  private readonly profileStore = inject(ProfileStore);\n  private readonly authService = inject(AuthService);\n\n  readonly profile = this.profileStore.profile;\n  readonly loading = signal(false);\n  readonly changingPassword = signal(false);\n  readonly passwordError = signal<string | null>(null);\n  readonly passwordChangeSuccess = signal(false);\n\n  readonly passwordForm = this.fb.group(\n    {\n      currentPassword: ['', [Validators.required]],\n      newPassword: ['', [Validators.required, Validators.minLength(8)]],\n      confirmPassword: ['', [Validators.required]],\n    },\n    {\n      validators: this.passwordMatchValidator,\n    },\n  );\n\n  ngOnInit(): void {\n    // Load profile if not already loaded\n    if (!this.profile()) {\n      void this.profileStore.loadProfile();\n    }\n  }\n\n  /**\n   * Custom validator to check if passwords match\n   */\n  private passwordMatchValidator(form: FormGroup): { passwordMismatch: boolean } | null {\n    const newPassword = form.get('newPassword')?.value;\n    const confirmPassword = form.get('confirmPassword')?.value;\n\n    if (newPassword && confirmPassword && newPassword !== confirmPassword) {\n      return { passwordMismatch: true };\n    }\n\n    return null;\n  }\n\n  /**\n   * Change password using Supabase Auth\n   */\n  async onChangePassword(): Promise<void> {\n    if (this.passwordForm.invalid) {\n      this.passwordError.set('Por favor completa todos los campos correctamente');\n      return;\n    }\n\n    this.changingPassword.set(true);\n    this.passwordError.set(null);\n    this.passwordChangeSuccess.set(false);\n\n    try {\n      const newPassword = this.passwordForm.get('newPassword')?.value;\n\n      if (!newPassword) {\n        throw new Error('Nueva contraseña es requerida');\n      }\n\n      // Use Supabase Auth to update password\n      await this.authService.updatePassword(newPassword);\n\n      // Success!\n      this.passwordChangeSuccess.set(true);\n      this.passwordForm.reset();\n\n      // Clear success message after 5 seconds\n      setTimeout(() => {\n        this.passwordChangeSuccess.set(false);\n      }, 5000);\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : '';\n      const message =\n        errorMessage === 'New password should be different from the old password'\n          ? 'La nueva contraseña debe ser diferente a la actual'\n          : errorMessage || 'Error al cambiar la contraseña';\n\n      this.passwordError.set(message);\n      console.error('Error changing password:', err);\n    } finally {\n      this.changingPassword.set(false);\n    }\n  }\n\n  /**\n   * Format date for display\n   */\n  formatDate(dateString: string | null | undefined): string {\n    if (!dateString) return 'Fecha desconocida';\n\n    const date = new Date(dateString);\n    return date.toLocaleDateString('es-AR', {\n      year: 'numeric',\n      month: 'long',\n      day: 'numeric',\n    });\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/features/profile/verification-page/profile-verification.page.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`@core/services/auth/identity-level.service` import should occur before import of `../../../shared/components/verification-progress/verification-progress.component`","line":18,"column":1,"nodeType":"ImportDeclaration","endLine":18,"endColumn":83,"fix":{"range":[211,842],"text":"import { IdentityLevelService } from '@core/services/auth/identity-level.service';\nimport { VerificationProgressComponent } from '../../../shared/components/verification-progress/verification-progress.component';\nimport { EmailVerificationComponent } from '../../../shared/components/email-verification/email-verification.component';\nimport { PhoneVerificationComponent } from '../../../shared/components/phone-verification/phone-verification.component';\nimport { SelfieCaptureComponent } from '../../../shared/components/selfie-capture/selfie-capture.component';\nimport { ProfileStore } from '../../../core/stores/profile.store';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import {\n  Component,\n  inject,\n  OnInit,\n  ChangeDetectionStrategy,\n  signal,\n  computed,\n} from '@angular/core';\n\nimport { RouterModule } from '@angular/router';\nimport { IonicModule } from '@ionic/angular';\n\nimport { VerificationProgressComponent } from '../../../shared/components/verification-progress/verification-progress.component';\nimport { EmailVerificationComponent } from '../../../shared/components/email-verification/email-verification.component';\nimport { PhoneVerificationComponent } from '../../../shared/components/phone-verification/phone-verification.component';\nimport { SelfieCaptureComponent } from '../../../shared/components/selfie-capture/selfie-capture.component';\nimport { ProfileStore } from '../../../core/stores/profile.store';\nimport { IdentityLevelService } from '@core/services/auth/identity-level.service';\nimport { LicenseUploaderComponent } from './components/license-uploader.component';\nimport { DniUploaderComponent } from './components/dni-uploader.component';\n\n@Component({\n  selector: 'app-profile-verification',\n  standalone: true,\n  imports: [\n    RouterModule,\n    IonicModule,\n    VerificationProgressComponent,\n    EmailVerificationComponent,\n    PhoneVerificationComponent,\n    SelfieCaptureComponent,\n    LicenseUploaderComponent,\n    DniUploaderComponent\n],\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  template: `\n    <ion-header></ion-header>\n    \n    <ion-content class=\"bg-surface-base\" fullscreen=\"true\">\n      <div class=\"py-4 px-4 max-w-3xl mx-auto\">\n        <!-- Compact Header -->\n        <div class=\"mb-4 flex items-center justify-between\">\n          <div>\n            <h1 class=\"text-xl font-bold text-text-primary\">Verificación</h1>\n            <p class=\"text-xs text-text-secondary\">Completa los pasos para desbloquear funciones</p>\n          </div>\n          <a routerLink=\"/profile\" class=\"text-sm text-cta-default hover:underline\">← Volver</a>\n        </div>\n    \n        <!-- Progress Component -->\n        <div class=\"mb-4\">\n          <app-verification-progress></app-verification-progress>\n        </div>\n    \n        <!-- Verification Steps -->\n        <div class=\"space-y-3\">\n          <!-- LEVEL 1: Contact -->\n          <div\n            class=\"rounded-xl border overflow-hidden transition-all duration-300\"\n            [class]=\"getStepContainerClass(1)\"\n            >\n            <!-- Header - Clickable -->\n            <button\n              (click)=\"toggleSection(1)\"\n              class=\"w-full p-4 flex items-center justify-between text-left transition-colors\"\n              [class]=\"getStepHeaderClass(1)\"\n              >\n              <div class=\"flex items-center gap-3\">\n                <div\n                  class=\"w-8 h-8 rounded-full flex items-center justify-center text-sm font-bold transition-all\"\n                  [class]=\"getStepBadgeClass(1)\"\n                  >\n                  @if (isLevelComplete(1)) {\n                    <svg\n                      class=\"w-4 h-4\"\n                      fill=\"currentColor\"\n                      viewBox=\"0 0 20 20\"\n                      >\n                      <path\n                        fill-rule=\"evenodd\"\n                        d=\"M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z\"\n                        clip-rule=\"evenodd\"\n                        />\n                    </svg>\n                  }\n                  @if (!isLevelComplete(1)) {\n                    <span>1</span>\n                  }\n                </div>\n                <div>\n                  <h3 class=\"font-semibold text-text-primary\">Contacto Básico</h3>\n                  <p class=\"text-xs text-text-secondary\">Email y teléfono</p>\n                </div>\n              </div>\n              <div class=\"flex items-center gap-2\">\n                <span class=\"text-xs px-2 py-1 rounded-full\" [class]=\"getStatusBadgeClass(1)\">\n                  {{ getStatusLabel(1) }}\n                </span>\n                <svg\n                  class=\"w-5 h-5 text-text-muted transition-transform duration-200\"\n                  [class.rotate-180]=\"expandedSections().has(1)\"\n                  fill=\"none\"\n                  stroke=\"currentColor\"\n                  viewBox=\"0 0 24 24\"\n                  >\n                  <path\n                    stroke-linecap=\"round\"\n                    stroke-linejoin=\"round\"\n                    stroke-width=\"2\"\n                    d=\"M19 9l-7 7-7-7\"\n                    />\n                </svg>\n              </div>\n            </button>\n    \n            <!-- Content - Collapsible -->\n            <div\n              class=\"overflow-hidden transition-all duration-300\"\n              [class]=\"\n                expandedSections().has(1) ? 'max-h-[800px] opacity-100' : 'max-h-0 opacity-0'\n              \"\n              >\n              <div class=\"p-4 pt-0 space-y-4 border-t border-border-default/50\">\n                <app-email-verification></app-email-verification>\n                <app-phone-verification></app-phone-verification>\n              </div>\n            </div>\n          </div>\n    \n          <!-- Connector Line -->\n          <div class=\"flex justify-center\">\n            <div\n              class=\"w-0.5 h-4 rounded-full\"\n              [class]=\"isLevelComplete(1) ? 'bg-success-light' : 'bg-border-default'\"\n            ></div>\n          </div>\n    \n          <!-- LEVEL 2: Documents -->\n          <div\n            class=\"rounded-xl border overflow-hidden transition-all duration-300\"\n            [class]=\"getStepContainerClass(2)\"\n            >\n            <!-- Header -->\n            <button\n              (click)=\"toggleSection(2)\"\n              [disabled]=\"!canAccessLevel(2)\"\n              class=\"w-full p-4 flex items-center justify-between text-left transition-colors disabled:cursor-not-allowed\"\n              [class]=\"getStepHeaderClass(2)\"\n              >\n              <div class=\"flex items-center gap-3\">\n                <div\n                  class=\"w-8 h-8 rounded-full flex items-center justify-center text-sm font-bold transition-all\"\n                  [class]=\"getStepBadgeClass(2)\"\n                  >\n                  @if (isLevelComplete(2)) {\n                    <svg\n                      class=\"w-4 h-4\"\n                      fill=\"currentColor\"\n                      viewBox=\"0 0 20 20\"\n                      >\n                      <path\n                        fill-rule=\"evenodd\"\n                        d=\"M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z\"\n                        clip-rule=\"evenodd\"\n                        />\n                    </svg>\n                  }\n                  @if (!isLevelComplete(2) && !canAccessLevel(2)) {\n                    <svg\n                      class=\"w-4 h-4\"\n                      fill=\"none\"\n                      stroke=\"currentColor\"\n                      viewBox=\"0 0 24 24\"\n                      >\n                      <path\n                        stroke-linecap=\"round\"\n                        stroke-linejoin=\"round\"\n                        stroke-width=\"2\"\n                        d=\"M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z\"\n                        />\n                    </svg>\n                  }\n                  @if (!isLevelComplete(2) && canAccessLevel(2)) {\n                    <span>2</span>\n                  }\n                </div>\n                <div>\n                  <h3\n                    class=\"font-semibold\"\n                    [class]=\"canAccessLevel(2) ? 'text-text-primary' : 'text-text-muted'\"\n                    >\n                    Documentación\n                  </h3>\n                  <p\n                    class=\"text-xs\"\n                    [class]=\"canAccessLevel(2) ? 'text-text-secondary' : 'text-text-muted'\"\n                    >\n                    DNI y licencia de conducir\n                  </p>\n                </div>\n              </div>\n              <div class=\"flex items-center gap-2\">\n                <span class=\"text-xs px-2 py-1 rounded-full\" [class]=\"getStatusBadgeClass(2)\">\n                  {{ getStatusLabel(2) }}\n                </span>\n                @if (canAccessLevel(2)) {\n                  <svg\n                    class=\"w-5 h-5 text-text-muted transition-transform duration-200\"\n                    [class.rotate-180]=\"expandedSections().has(2)\"\n                    fill=\"none\"\n                    stroke=\"currentColor\"\n                    viewBox=\"0 0 24 24\"\n                    >\n                    <path\n                      stroke-linecap=\"round\"\n                      stroke-linejoin=\"round\"\n                      stroke-width=\"2\"\n                      d=\"M19 9l-7 7-7-7\"\n                      />\n                  </svg>\n                }\n              </div>\n            </button>\n    \n            <!-- Content -->\n            <div\n              class=\"overflow-hidden transition-all duration-300\"\n              [class]=\"\n                expandedSections().has(2) && canAccessLevel(2)\n                  ? 'max-h-[1200px] opacity-100'\n                  : 'max-h-0 opacity-0'\n              \"\n              >\n              <div class=\"p-4 pt-0 space-y-4 border-t border-border-default/50\">\n                <!-- DNI Section -->\n                <div class=\"p-4 rounded-lg bg-surface-secondary/50\">\n                  <div class=\"flex items-center justify-between mb-3\">\n                    <div class=\"flex items-center gap-2\">\n                      <span class=\"text-lg\">🪪</span>\n                      <div>\n                        <h4 class=\"text-sm font-semibold text-text-primary\">DNI</h4>\n                        <p class=\"text-xs text-text-secondary\">Frente y dorso</p>\n                      </div>\n                    </div>\n                    <span\n                      class=\"text-xs px-2 py-1 rounded-full\"\n                      [class]=\"\n                        isDniVerified()\n                          ? 'bg-success-light/20 text-success-strong'\n                          : 'bg-surface-hover text-text-muted'\n                      \"\n                      >\n                      {{ isDniVerified() ? '✓ Verificado' : 'Pendiente' }}\n                    </span>\n                  </div>\n    \n                  @if (!isDniVerified()) {\n                    <div>\n                      @if (!showDniUpload()) {\n                        <button\n                          (click)=\"showDniUpload.set(true)\"\n                          class=\"w-full py-3 rounded-lg bg-cta-default hover:bg-cta-hover text-cta-text text-sm font-semibold transition-all flex items-center justify-center gap-2\"\n                          >\n                          <svg class=\"w-4 h-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                            <path\n                              stroke-linecap=\"round\"\n                              stroke-linejoin=\"round\"\n                              stroke-width=\"2\"\n                              d=\"M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12\"\n                              />\n                          </svg>\n                          Subir DNI\n                        </button>\n                      }\n                      @if (showDniUpload()) {\n                        <div class=\"animate-fadeIn\">\n                          <app-dni-uploader></app-dni-uploader>\n                          <button\n                            (click)=\"showDniUpload.set(false)\"\n                            class=\"mt-3 w-full py-2 text-sm text-text-secondary hover:text-text-primary transition-colors\"\n                            >\n                            Cancelar\n                          </button>\n                        </div>\n                      }\n                    </div>\n                  }\n                </div>\n    \n                <!-- License Section -->\n                <div class=\"p-4 rounded-lg bg-surface-secondary/50\">\n                  <div class=\"flex items-center justify-between mb-3\">\n                    <div class=\"flex items-center gap-2\">\n                      <span class=\"text-lg\">🚗</span>\n                      <div>\n                        <h4 class=\"text-sm font-semibold text-text-primary\">\n                          Licencia de Conducir\n                        </h4>\n                        <p class=\"text-xs text-text-secondary\">Frente y dorso</p>\n                      </div>\n                    </div>\n                    <span\n                      class=\"text-xs px-2 py-1 rounded-full\"\n                      [class]=\"\n                        isLicenseVerified()\n                          ? 'bg-success-light/20 text-success-strong'\n                          : 'bg-surface-hover text-text-muted'\n                      \"\n                      >\n                      {{ isLicenseVerified() ? '✓ Verificado' : 'Pendiente' }}\n                    </span>\n                  </div>\n    \n                  @if (!isLicenseVerified()) {\n                    <div>\n                      @if (!showLicenseUpload()) {\n                        <button\n                          (click)=\"showLicenseUpload.set(true)\"\n                          class=\"w-full py-3 rounded-lg bg-cta-default hover:bg-cta-hover text-cta-text text-sm font-semibold transition-all flex items-center justify-center gap-2\"\n                          >\n                          <svg class=\"w-4 h-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                            <path\n                              stroke-linecap=\"round\"\n                              stroke-linejoin=\"round\"\n                              stroke-width=\"2\"\n                              d=\"M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12\"\n                              />\n                          </svg>\n                          Subir Licencia\n                        </button>\n                      }\n                      @if (showLicenseUpload()) {\n                        <div class=\"animate-fadeIn\">\n                          <app-license-uploader></app-license-uploader>\n                          <button\n                            (click)=\"showLicenseUpload.set(false)\"\n                            class=\"mt-3 w-full py-2 text-sm text-text-secondary hover:text-text-primary transition-colors\"\n                            >\n                            Cancelar\n                          </button>\n                        </div>\n                      }\n                    </div>\n                  }\n                </div>\n              </div>\n            </div>\n          </div>\n    \n          <!-- Connector Line -->\n          <div class=\"flex justify-center\">\n            <div\n              class=\"w-0.5 h-4 rounded-full\"\n              [class]=\"isLevelComplete(2) ? 'bg-success-light' : 'bg-border-default'\"\n            ></div>\n          </div>\n    \n          <!-- LEVEL 3: Selfie -->\n          <div\n            class=\"rounded-xl border overflow-hidden transition-all duration-300\"\n            [class]=\"getStepContainerClass(3)\"\n            >\n            <!-- Header -->\n            <button\n              (click)=\"toggleSection(3)\"\n              [disabled]=\"!canAccessLevel(3)\"\n              class=\"w-full p-4 flex items-center justify-between text-left transition-colors disabled:cursor-not-allowed\"\n              [class]=\"getStepHeaderClass(3)\"\n              >\n              <div class=\"flex items-center gap-3\">\n                <div\n                  class=\"w-8 h-8 rounded-full flex items-center justify-center text-sm font-bold transition-all\"\n                  [class]=\"getStepBadgeClass(3)\"\n                  >\n                  @if (isLevelComplete(3)) {\n                    <svg\n                      class=\"w-4 h-4\"\n                      fill=\"currentColor\"\n                      viewBox=\"0 0 20 20\"\n                      >\n                      <path\n                        fill-rule=\"evenodd\"\n                        d=\"M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z\"\n                        clip-rule=\"evenodd\"\n                        />\n                    </svg>\n                  }\n                  @if (!isLevelComplete(3) && !canAccessLevel(3)) {\n                    <svg\n                      class=\"w-4 h-4\"\n                      fill=\"none\"\n                      stroke=\"currentColor\"\n                      viewBox=\"0 0 24 24\"\n                      >\n                      <path\n                        stroke-linecap=\"round\"\n                        stroke-linejoin=\"round\"\n                        stroke-width=\"2\"\n                        d=\"M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z\"\n                        />\n                    </svg>\n                  }\n                  @if (!isLevelComplete(3) && canAccessLevel(3)) {\n                    <span>3</span>\n                  }\n                </div>\n                <div>\n                  <h3\n                    class=\"font-semibold\"\n                    [class]=\"canAccessLevel(3) ? 'text-text-primary' : 'text-text-muted'\"\n                    >\n                    Verificación Facial\n                  </h3>\n                  <p\n                    class=\"text-xs\"\n                    [class]=\"canAccessLevel(3) ? 'text-text-secondary' : 'text-text-muted'\"\n                    >\n                    Selfie para confirmar identidad\n                  </p>\n                </div>\n              </div>\n              <div class=\"flex items-center gap-2\">\n                <span class=\"text-xs px-2 py-1 rounded-full\" [class]=\"getStatusBadgeClass(3)\">\n                  {{ getStatusLabel(3) }}\n                </span>\n                @if (canAccessLevel(3)) {\n                  <svg\n                    class=\"w-5 h-5 text-text-muted transition-transform duration-200\"\n                    [class.rotate-180]=\"expandedSections().has(3)\"\n                    fill=\"none\"\n                    stroke=\"currentColor\"\n                    viewBox=\"0 0 24 24\"\n                    >\n                    <path\n                      stroke-linecap=\"round\"\n                      stroke-linejoin=\"round\"\n                      stroke-width=\"2\"\n                      d=\"M19 9l-7 7-7-7\"\n                      />\n                  </svg>\n                }\n              </div>\n            </button>\n    \n            <!-- Content -->\n            <div\n              class=\"overflow-hidden transition-all duration-300\"\n              [class]=\"\n                expandedSections().has(3) && canAccessLevel(3)\n                  ? 'max-h-[600px] opacity-100'\n                  : 'max-h-0 opacity-0'\n              \"\n              >\n              <div class=\"p-4 pt-0 border-t border-border-default/50\">\n                <app-selfie-capture></app-selfie-capture>\n              </div>\n            </div>\n          </div>\n        </div>\n    \n        <!-- Help Section - Compact -->\n        <details class=\"mt-4 group\">\n          <summary\n            class=\"p-3 rounded-lg bg-info-bg/50 border border-info-border/30 cursor-pointer list-none flex items-center justify-between text-sm text-info-text hover:bg-info-bg transition-colors\"\n            >\n            <span class=\"flex items-center gap-2\">\n              <svg class=\"w-4 h-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path\n                  stroke-linecap=\"round\"\n                  stroke-linejoin=\"round\"\n                  stroke-width=\"2\"\n                  d=\"M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z\"\n                  />\n              </svg>\n              ¿Por qué verificamos tu identidad?\n            </span>\n            <svg\n              class=\"w-4 h-4 transition-transform group-open:rotate-180\"\n              fill=\"none\"\n              stroke=\"currentColor\"\n              viewBox=\"0 0 24 24\"\n              >\n              <path\n                stroke-linecap=\"round\"\n                stroke-linejoin=\"round\"\n                stroke-width=\"2\"\n                d=\"M19 9l-7 7-7-7\"\n                />\n            </svg>\n          </summary>\n          <div class=\"mt-2 p-3 rounded-lg bg-info-bg/30 text-xs text-info-text space-y-1\">\n            <p><strong>Seguridad:</strong> Protegemos a todos los usuarios</p>\n            <p><strong>Confianza:</strong> Usuarios verificados generan más confianza</p>\n            <p><strong>Acceso:</strong> Desbloquea rentar y publicar autos</p>\n            <p><strong>Legal:</strong> Cumplimos regulaciones anti-fraude</p>\n          </div>\n        </details>\n      </div>\n    </ion-content>\n    `,\n  styles: [\n    `\n      :host {\n        display: block;\n        height: 100%;\n      }\n\n      ion-content {\n        --background: var(--color-surface-base);\n      }\n\n      .animate-fadeIn {\n        animation: fadeIn 0.3s ease-out;\n      }\n\n      @keyframes fadeIn {\n        from {\n          opacity: 0;\n          transform: translateY(-8px);\n        }\n        to {\n          opacity: 1;\n          transform: translateY(0);\n        }\n      }\n    `,\n  ],\n})\nexport class ProfileVerificationPage implements OnInit {\n  private readonly profileStore = inject(ProfileStore);\n  private readonly identityService = inject(IdentityLevelService);\n\n  readonly profile = this.profileStore.profile;\n  readonly loading = this.profileStore.loading;\n  readonly showLicenseUpload = signal(false);\n  readonly showDniUpload = signal(false);\n\n  // Track expanded sections\n  readonly expandedSections = signal<Set<number>>(new Set([1])); // Level 1 expanded by default\n\n  // Get verification progress data\n  readonly verificationProgress = this.identityService.verificationProgress;\n  readonly requirements = computed(() => this.verificationProgress()?.requirements);\n\n  async ngOnInit(): Promise<void> {\n    if (!this.profile()) {\n      void this.profileStore.loadProfile();\n    }\n\n    // Load verification progress\n    try {\n      await this.identityService.getVerificationProgress();\n      this.autoExpandCurrentLevel();\n    } catch (e) {\n      console.error('Failed to load verification progress:', e);\n    }\n  }\n\n  private autoExpandCurrentLevel(): void {\n    const sections = new Set<number>();\n\n    // Always show the current active level\n    if (!this.isLevelComplete(1)) {\n      sections.add(1);\n    } else if (!this.isLevelComplete(2) && this.canAccessLevel(2)) {\n      sections.add(2);\n    } else if (!this.isLevelComplete(3) && this.canAccessLevel(3)) {\n      sections.add(3);\n    }\n\n    this.expandedSections.set(sections);\n  }\n\n  toggleSection(level: number): void {\n    if (!this.canAccessLevel(level)) return;\n\n    const sections = new Set(this.expandedSections());\n    if (sections.has(level)) {\n      sections.delete(level);\n    } else {\n      sections.add(level);\n    }\n    this.expandedSections.set(sections);\n  }\n\n  isLevelComplete(level: number): boolean {\n    const req = this.requirements();\n    if (!req) return false;\n\n    switch (level) {\n      case 1:\n        return req.level_1?.completed ?? false;\n      case 2:\n        return req.level_2?.completed ?? false;\n      case 3:\n        return req.level_3?.completed ?? false;\n      default:\n        return false;\n    }\n  }\n\n  canAccessLevel(level: number): boolean {\n    if (level === 1) return true;\n    if (level === 2) return this.verificationProgress()?.can_access_level_2 ?? false;\n    if (level === 3) return this.verificationProgress()?.can_access_level_3 ?? false;\n    return false;\n  }\n\n  isDniVerified(): boolean {\n    return this.requirements()?.level_2?.document_verified ?? false;\n  }\n\n  isLicenseVerified(): boolean {\n    return this.requirements()?.level_2?.driver_license_verified ?? false;\n  }\n\n  getStatusLabel(level: number): string {\n    if (this.isLevelComplete(level)) return 'Completado';\n    if (!this.canAccessLevel(level)) return 'Bloqueado';\n    return 'En progreso';\n  }\n\n  getStepContainerClass(level: number): string {\n    if (this.isLevelComplete(level)) {\n      return 'border-success-light/40 bg-success-light/5';\n    }\n    if (!this.canAccessLevel(level)) {\n      return 'border-border-default bg-surface-base opacity-60';\n    }\n    // Active level\n    return 'border-cta-default/40 bg-cta-default/5 shadow-sm';\n  }\n\n  getStepHeaderClass(level: number): string {\n    if (!this.canAccessLevel(level)) {\n      return 'bg-transparent';\n    }\n    return 'hover:bg-surface-hover/50';\n  }\n\n  getStepBadgeClass(level: number): string {\n    if (this.isLevelComplete(level)) {\n      return 'bg-success-light text-white';\n    }\n    if (!this.canAccessLevel(level)) {\n      return 'bg-surface-hover text-text-muted';\n    }\n    return 'bg-cta-default text-cta-text';\n  }\n\n  getStatusBadgeClass(level: number): string {\n    if (this.isLevelComplete(level)) {\n      return 'bg-success-light/20 text-success-strong';\n    }\n    if (!this.canAccessLevel(level)) {\n      return 'bg-surface-hover text-text-muted';\n    }\n    return 'bg-cta-default/20 text-cta-default';\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/features/protections/protections.page.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`../../shared/components/bonus-protector-purchase/bonus-protector-purchase.component` import should occur after import of `@core/services/payments/wallet.service`","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":135,"fix":{"range":[248,517],"text":"import { MetaService } from '@core/services/ui/meta.service';\nimport { WalletService } from '@core/services/payments/wallet.service';\nimport { BonusProtectorPurchaseComponent } from '../../shared/components/bonus-protector-purchase/bonus-protector-purchase.component';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import {Component, inject, OnInit, computed,\n  ChangeDetectionStrategy} from '@angular/core';\nimport { CommonModule, CurrencyPipe } from '@angular/common';\nimport { IonicModule } from '@ionic/angular';\nimport { RouterLink } from '@angular/router';\nimport { BonusProtectorPurchaseComponent } from '../../shared/components/bonus-protector-purchase/bonus-protector-purchase.component';\nimport { MetaService } from '@core/services/ui/meta.service';\nimport { WalletService } from '@core/services/payments/wallet.service';\n\n/**\n * ProtectionsPage\n *\n * Página dedicada para gestión centralizada de protecciones y seguros.\n *\n * FEATURES:\n * - Bonus Protector (protege clase de conductor)\n * - Información sobre seguros de vehículos\n * - Gestión de protecciones activas\n * - Educación sobre opciones de protección\n */\n\n@Component({\n  standalone: true,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  selector: 'app-protections-page',\n  imports: [CommonModule, IonicModule, RouterLink, BonusProtectorPurchaseComponent, CurrencyPipe],\n  template: `\n    <ion-header>\n      <ion-toolbar>\n        <ion-buttons slot=\"start\">\n          <ion-back-button defaultHref=\"/profile\"></ion-back-button>\n        </ion-buttons>\n        <ion-title>Protecciones</ion-title>\n      </ion-toolbar>\n    </ion-header>\n\n    <ion-content class=\"ion-padding\">\n      <!-- Header Section -->\n      <div class=\"header-section\">\n        <h1>Protecciones y Seguros</h1>\n        <p class=\"subtitle\">\n          Protege tu clase de conductor y tu vehículo con nuestras opciones de cobertura.\n        </p>\n      </div>\n\n      <!-- Wallet Balance Card -->\n      <div class=\"wallet-balance-section\">\n        <ion-card class=\"wallet-card\">\n          <ion-card-content>\n            <div class=\"wallet-info\">\n              <div class=\"wallet-icon\">\n                <ion-icon name=\"wallet-outline\" color=\"primary\"></ion-icon>\n              </div>\n              <div class=\"wallet-details\">\n                <span class=\"wallet-label\">Saldo disponible</span>\n                <span class=\"wallet-amount\">{{ walletBalance() | currency:'USD':'symbol':'1.2-2' }}</span>\n              </div>\n              <ion-button size=\"small\" fill=\"outline\" [routerLink]=\"['/wallet']\">\n                <ion-icon slot=\"start\" name=\"add-outline\"></ion-icon>\n                Depositar\n              </ion-button>\n            </div>\n          </ion-card-content>\n        </ion-card>\n      </div>\n\n      <!-- Bonus Protector Section -->\n      <div class=\"section-container\">\n        <div class=\"section-header\">\n          <h2>\n            <ion-icon name=\"shield-checkmark-outline\" color=\"primary\"></ion-icon>\n            Protector de Bonus\n          </h2>\n          <p class=\"section-description\">\n            Protege tu clase de conductor de subir en caso de siniestros. Ideal para mantener tus\n            descuentos y evitar recargos.\n          </p>\n        </div>\n\n        <!-- Bonus Protector Purchase Component -->\n        <app-bonus-protector-purchase></app-bonus-protector-purchase>\n      </div>\n\n      <!-- Vehicle Insurance Section -->\n      <div class=\"section-container\">\n        <div class=\"section-header\">\n          <h2>\n            <ion-icon name=\"car-outline\" color=\"secondary\"></ion-icon>\n            Seguros de Vehículo\n          </h2>\n          <p class=\"section-description\">\n            Información sobre las coberturas de seguro requeridas para publicar tu vehículo.\n          </p>\n        </div>\n\n        <ion-card class=\"info-card\">\n          <ion-card-content>\n            <h3>Requisitos de Seguro</h3>\n            <ul class=\"requirements-list\">\n              <li>\n                <ion-icon name=\"checkmark-circle-outline\" color=\"success\"></ion-icon>\n                <span>Responsabilidad Civil obligatoria</span>\n              </li>\n              <li>\n                <ion-icon name=\"checkmark-circle-outline\" color=\"success\"></ion-icon>\n                <span>Cobertura contra terceros recomendada</span>\n              </li>\n              <li>\n                <ion-icon name=\"checkmark-circle-outline\" color=\"success\"></ion-icon>\n                <span>Cobertura completa opcional pero sugerida</span>\n              </li>\n            </ul>\n\n            <p class=\"note\">\n              <ion-icon name=\"information-circle-outline\" color=\"primary\"></ion-icon>\n              Como locador, tu seguro debe estar al día para publicar vehículos en la plataforma.\n            </p>\n          </ion-card-content>\n        </ion-card>\n      </div>\n\n      <!-- Quick Links -->\n      <div class=\"quick-links-section\">\n        <h3>Enlaces Rápidos</h3>\n\n        <ion-list lines=\"none\">\n          <ion-item button [routerLink]=\"['/profile/driver-profile']\">\n            <ion-icon slot=\"start\" name=\"person-circle-outline\" color=\"primary\"></ion-icon>\n            <ion-label>\n              <h4>Mi Perfil de Conductor</h4>\n              <p>Ver mi clase y beneficios actuales</p>\n            </ion-label>\n            <ion-icon slot=\"end\" name=\"chevron-forward-outline\"></ion-icon>\n          </ion-item>\n\n          <ion-item button [routerLink]=\"['/wallet']\">\n            <ion-icon slot=\"start\" name=\"wallet-outline\" color=\"secondary\"></ion-icon>\n            <ion-label>\n              <h4>Mi Wallet</h4>\n              <p>Gestionar fondos para protecciones</p>\n            </ion-label>\n            <ion-icon slot=\"end\" name=\"chevron-forward-outline\"></ion-icon>\n          </ion-item>\n\n          <ion-item button [routerLink]=\"['/profile']\" [queryParams]=\"{ tab: 'conductor' }\">\n            <ion-icon slot=\"start\" name=\"settings-outline\" color=\"tertiary\"></ion-icon>\n            <ion-label>\n              <h4>Configuración de Conductor</h4>\n              <p>Ajustes de perfil y preferencias</p>\n            </ion-label>\n            <ion-icon slot=\"end\" name=\"chevron-forward-outline\"></ion-icon>\n          </ion-item>\n        </ion-list>\n      </div>\n\n      <!-- Help Section -->\n      <div class=\"help-section\">\n        <ion-card class=\"help-card\">\n          <ion-card-header>\n            <ion-card-title>\n              <ion-icon name=\"help-circle-outline\" color=\"warning\"></ion-icon>\n              ¿Necesitas ayuda?\n            </ion-card-title>\n          </ion-card-header>\n          <ion-card-content>\n            <p>\n              Si tienes dudas sobre nuestras protecciones o seguros, contacta a nuestro equipo de\n              soporte.\n            </p>\n            <ion-button expand=\"block\" fill=\"outline\" color=\"primary\">\n              <ion-icon slot=\"start\" name=\"mail-outline\"></ion-icon>\n              Contactar Soporte\n            </ion-button>\n          </ion-card-content>\n        </ion-card>\n      </div>\n    </ion-content>\n  `,\n  styles: [\n    `\n      :host {\n        display: block;\n        position: absolute;\n        top: 0;\n        left: 0;\n        right: 0;\n        bottom: 0;\n        contain: layout size style;\n      }\n\n      ion-header ion-toolbar {\n        --background: var(--ion-color-primary);\n        --color: white;\n      }\n\n      ion-back-button {\n        --color: white;\n      }\n\n      ion-content {\n        --background: var(--ion-background-color, #f5f5f5);\n      }\n\n      .header-section {\n        text-align: center;\n        padding: 2rem 1rem 1.5rem;\n      }\n\n      .header-section h1 {\n        font-size: 2rem;\n        font-weight: 700;\n        color: var(--ion-color-dark);\n        margin-bottom: 0.5rem;\n      }\n\n      .subtitle {\n        font-size: 1rem;\n        color: var(--ion-color-medium);\n        line-height: 1.5;\n        max-width: 600px;\n        margin: 0 auto;\n      }\n\n      .wallet-balance-section {\n        padding: 0 1rem;\n        margin-bottom: 1.5rem;\n      }\n\n      .wallet-card {\n        margin: 0;\n        background: linear-gradient(135deg, #e0f2fe 0%, #bae6fd 100%);\n        border: 1px solid #0ea5e9;\n      }\n\n      .wallet-info {\n        display: flex;\n        align-items: center;\n        gap: 1rem;\n      }\n\n      .wallet-icon {\n        width: 48px;\n        height: 48px;\n        background: white;\n        border-radius: 50%;\n        display: flex;\n        align-items: center;\n        justify-content: center;\n      }\n\n      .wallet-icon ion-icon {\n        font-size: 1.5rem;\n      }\n\n      .wallet-details {\n        flex: 1;\n        display: flex;\n        flex-direction: column;\n      }\n\n      .wallet-label {\n        font-size: 0.85rem;\n        color: #0369a1;\n      }\n\n      .wallet-amount {\n        font-size: 1.5rem;\n        font-weight: 700;\n        color: #0c4a6e;\n      }\n\n      .section-container {\n        margin-bottom: 2rem;\n        padding: 0 1rem;\n      }\n\n      .section-header {\n        margin-bottom: 1.5rem;\n      }\n\n      .section-header h2 {\n        display: flex;\n        align-items: center;\n        gap: 0.5rem;\n        font-size: 1.5rem;\n        font-weight: 600;\n        color: var(--ion-color-dark);\n        margin-bottom: 0.5rem;\n      }\n\n      .section-description {\n        font-size: 0.95rem;\n        color: var(--ion-color-medium);\n        line-height: 1.5;\n      }\n\n      .info-card {\n        margin: 1rem 0;\n      }\n\n      .info-card h3 {\n        font-size: 1.125rem;\n        font-weight: 600;\n        color: var(--ion-color-dark);\n        margin-bottom: 1rem;\n      }\n\n      .requirements-list {\n        list-style: none;\n        padding: 0;\n        margin: 0 0 1rem 0;\n      }\n\n      .requirements-list li {\n        display: flex;\n        align-items: center;\n        gap: 0.75rem;\n        padding: 0.5rem 0;\n        font-size: 0.95rem;\n        color: var(--ion-color-dark);\n      }\n\n      .requirements-list ion-icon {\n        font-size: 1.25rem;\n      }\n\n      .note {\n        display: flex;\n        align-items: flex-start;\n        gap: 0.5rem;\n        padding: 1rem;\n        background-color: var(--ion-color-primary-tint);\n        border-radius: 8px;\n        font-size: 0.875rem;\n        color: var(--ion-color-primary-shade);\n        margin: 0;\n      }\n\n      .note ion-icon {\n        font-size: 1.25rem;\n        flex-shrink: 0;\n        margin-top: 2px;\n      }\n\n      .quick-links-section {\n        padding: 0 1rem;\n        margin-bottom: 2rem;\n      }\n\n      .quick-links-section h3 {\n        font-size: 1.25rem;\n        font-weight: 600;\n        color: var(--ion-color-dark);\n        margin-bottom: 1rem;\n      }\n\n      .quick-links-section ion-list {\n        background: transparent;\n      }\n\n      .quick-links-section ion-item {\n        --background: white;\n        --border-radius: 12px;\n        margin-bottom: 0.75rem;\n        --padding-start: 16px;\n        --padding-end: 16px;\n      }\n\n      .quick-links-section ion-label h4 {\n        font-size: 1rem;\n        font-weight: 600;\n        color: var(--ion-color-dark);\n        margin-bottom: 0.25rem;\n      }\n\n      .quick-links-section ion-label p {\n        font-size: 0.85rem;\n        color: var(--ion-color-medium);\n        margin: 0;\n      }\n\n      .help-section {\n        padding: 0 1rem 2rem;\n      }\n\n      .help-card {\n        background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);\n        border: 1px solid #fbbf24;\n      }\n\n      .help-card ion-card-title {\n        display: flex;\n        align-items: center;\n        gap: 0.5rem;\n        font-size: 1.125rem;\n        color: #78350f;\n      }\n\n      .help-card ion-card-content p {\n        color: #78350f;\n        margin-bottom: 1rem;\n      }\n    `,\n  ],\n})\nexport class ProtectionsPage implements OnInit {\n  private readonly metaService = inject(MetaService);\n  private readonly walletService = inject(WalletService);\n\n  readonly walletBalance = computed(() => this.walletService.availableBalance());\n\n  ngOnInit(): void {\n    this.updateMeta();\n    this.loadWalletBalance();\n  }\n\n  private async loadWalletBalance(): Promise<void> {\n    try {\n      await this.walletService.fetchBalance();\n    } catch {\n      // Silently fail - balance will show as 0\n    }\n  }\n\n  private updateMeta(): void {\n    this.metaService.updateMeta({\n      title: 'Protecciones y Seguros - AutoRenta',\n      description:\n        'Protege tu clase de conductor y tu vehículo con nuestras opciones de cobertura.',\n      keywords: 'protecciones, seguros, bonus protector, seguro vehicular',\n    });\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/features/rentarfast/rentarfast.page.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`../../core/models/wallet.model` type import should occur after import of `@core/services/payments/wallet.service`","line":18,"column":1,"nodeType":"ImportDeclaration","endLine":18,"endColumn":69,"fix":{"range":[412,1121],"text":"import { AuthService } from '@core/services/auth/auth.service';\nimport { BookingsService } from '@core/services/bookings/bookings.service';\nimport { CarsService } from '@core/services/cars/cars.service';\nimport { GeocodingService } from '@core/services/geo/geocoding.service';\nimport { LocationData, LocationService } from '@core/services/geo/location.service';\nimport {\n  ChatContext,\n  ChatMessage,\n  RentarfastAgentService,\n} from '@core/services/ai/rentarfast-agent.service';\nimport { VerificationService } from '@core/services/verification/verification.service';\nimport { WalletService } from '@core/services/payments/wallet.service';\nimport type { WalletBalance } from '../../core/models/wallet.model';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { CommonModule, isPlatformBrowser } from '@angular/common';\nimport {\n  AfterViewChecked,\n  ChangeDetectionStrategy,\n  Component,\n  DestroyRef,\n  ElementRef,\n  OnDestroy,\n  PLATFORM_ID,\n  ViewChild,\n  effect,\n  inject,\n  signal,\n} from '@angular/core';\nimport { takeUntilDestroyed } from '@angular/core/rxjs-interop';\nimport { FormsModule } from '@angular/forms';\nimport { Router } from '@angular/router';\nimport type { WalletBalance } from '../../core/models/wallet.model';\nimport { AuthService } from '@core/services/auth/auth.service';\nimport { BookingsService } from '@core/services/bookings/bookings.service';\nimport { CarsService } from '@core/services/cars/cars.service';\nimport { GeocodingService } from '@core/services/geo/geocoding.service';\nimport { LocationData, LocationService } from '@core/services/geo/location.service';\nimport {\n  ChatContext,\n  ChatMessage,\n  RentarfastAgentService,\n} from '@core/services/ai/rentarfast-agent.service';\nimport { VerificationService } from '@core/services/verification/verification.service';\nimport { WalletService } from '@core/services/payments/wallet.service';\nimport { ProfileStore } from '../../core/stores/profile.store';\n\n// Web Speech API types\ninterface SpeechRecognitionEvent extends Event {\n  results: SpeechRecognitionResultList;\n  resultIndex: number;\n}\n\ninterface SpeechRecognitionResultList {\n  length: number;\n  item(index: number): SpeechRecognitionResult;\n  [index: number]: SpeechRecognitionResult;\n}\n\ninterface SpeechRecognitionResult {\n  isFinal: boolean;\n  length: number;\n  item(index: number): SpeechRecognitionAlternative;\n  [index: number]: SpeechRecognitionAlternative;\n}\n\ninterface SpeechRecognitionAlternative {\n  transcript: string;\n  confidence: number;\n}\n\ninterface SpeechRecognition extends EventTarget {\n  continuous: boolean;\n  interimResults: boolean;\n  lang: string;\n  start(): void;\n  stop(): void;\n  abort(): void;\n  onresult: ((event: SpeechRecognitionEvent) => void) | null;\n  onerror: ((event: Event) => void) | null;\n  onend: (() => void) | null;\n  onstart: (() => void) | null;\n}\n\ndeclare global {\n  interface Window {\n    SpeechRecognition: new () => SpeechRecognition;\n    webkitSpeechRecognition: new () => SpeechRecognition;\n  }\n}\n\n@Component({\n  selector: 'app-rentarfast-page',\n  standalone: true,\n  imports: [CommonModule, FormsModule],\n  templateUrl: './rentarfast.page.html',\n  styleUrls: ['./rentarfast.page.css'],\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class RentarfastPage implements AfterViewChecked, OnDestroy {\n  private readonly router = inject(Router);\n  private readonly destroyRef = inject(DestroyRef);\n  readonly agentService = inject(RentarfastAgentService);\n  private readonly locationService = inject(LocationService);\n  private readonly geocodingService = inject(GeocodingService);\n  private readonly profileStore = inject(ProfileStore);\n  private readonly authService = inject(AuthService);\n  private readonly walletService = inject(WalletService);\n  private readonly carsService = inject(CarsService);\n  private readonly verificationService = inject(VerificationService);\n  private readonly bookingsService = inject(BookingsService);\n  private readonly platformId = inject(PLATFORM_ID);\n\n  @ViewChild('messagesContainer') messagesContainer?: ElementRef<HTMLDivElement>;\n  @ViewChild('messageInput') messageInput?: ElementRef<HTMLInputElement>;\n\n  readonly messages = this.agentService.messages;\n  readonly isLoading = this.agentService.isLoading;\n  readonly inputText = signal('');\n  private readonly lastLocation = signal<LocationData | null>(null);\n  private readonly lastMarket = signal<{ country?: string; city?: string } | null>(null);\n  private readonly lastSanitizedMessageId = signal<string | null>(null);\n  private readonly lastUserText = signal<string>('');\n  private readonly lastPickupPreference = signal<\n    'owner_address' | 'office' | 'airport' | 'custom' | null\n  >(null);\n  private readonly lastDropoffPreference = signal<\n    'owner_address' | 'office' | 'airport' | 'custom' | null\n  >(null);\n  private readonly lastAddressHint = signal<string | null>(null);\n  private readonly locationOverrideKey = 'autorenta:location_override';\n\n  // Voice recognition state\n  readonly isListening = signal(false);\n  readonly voiceSupported = signal(false);\n\n  private lastVoiceErrorAt = 0;\n  private voiceStartInFlight = false;\n\n  private recognition: SpeechRecognition | null = null;\n  private shouldScrollToBottom = false;\n\n  constructor() {\n    this.initVoiceRecognition();\n    void this.profileStore.loadProfile();\n\n    effect(() => {\n      const msgs = this.messages();\n      const last = msgs[msgs.length - 1];\n      if (!last || last.role !== 'agent') return;\n      if (this.lastSanitizedMessageId() === last.id) return;\n      if (!this.shouldOverrideEcuadorResponse(last.content)) return;\n\n      const replacement = [\n        'Gracias por la aclaración.',\n        'En esta app operamos en Buenos Aires, Argentina, y voy a continuar con esa ubicación.',\n        '¿Querés que busque autos cerca de vos y para qué fechas?',\n      ].join(' ');\n\n      this.agentService.updateMessageContent(last.id, replacement, [\n        ...(last.toolsUsed ?? []),\n        'local_override',\n      ]);\n      this.lastSanitizedMessageId.set(last.id);\n    });\n\n    effect(() => {\n      const msgs = this.messages();\n      const last = msgs[msgs.length - 1];\n      if (!last || last.role !== 'agent') return;\n      if (this.lastSanitizedMessageId() === last.id) return;\n      if (!this.shouldOverrideConfusedResponse(last.content)) return;\n      if (!this.isWalletQuery(this.lastUserText())) return;\n\n      void this.overrideWithWalletSummary(last.id);\n    });\n\n    effect(() => {\n      const msgs = this.messages();\n      const last = msgs[msgs.length - 1];\n      if (!last || last.role !== 'agent') return;\n      if (this.lastSanitizedMessageId() === last.id) return;\n      if (!this.isWalletQuery(this.lastUserText())) return;\n      if (!this.shouldOverrideWalletLookup(last.content)) return;\n\n      void this.overrideWithWalletSummary(last.id);\n    });\n\n    effect(() => {\n      const msgs = this.messages();\n      const last = msgs[msgs.length - 1];\n      if (!last || last.role !== 'agent') return;\n      if (this.lastSanitizedMessageId() === last.id) return;\n      if (!this.isWalletQuery(this.lastUserText())) return;\n      if (!this.shouldOverrideGreetingResponse(last.content)) return;\n\n      void this.overrideWithWalletSummary(last.id);\n    });\n  }\n\n  private initVoiceRecognition(): void {\n    if (!isPlatformBrowser(this.platformId)) return;\n\n    const SpeechRecognitionAPI = window.SpeechRecognition || window.webkitSpeechRecognition;\n\n    if (SpeechRecognitionAPI) {\n      this.voiceSupported.set(true);\n      this.recognition = new SpeechRecognitionAPI();\n      this.recognition.continuous = false;\n      this.recognition.interimResults = true;\n      this.recognition.lang = 'es-ES';\n\n      this.recognition.onresult = (event: SpeechRecognitionEvent) => {\n        let finalTranscript = '';\n        let interimTranscript = '';\n\n        for (let i = event.resultIndex; i < event.results.length; i++) {\n          const transcript = event.results[i][0].transcript;\n          if (event.results[i].isFinal) {\n            finalTranscript += transcript;\n          } else {\n            interimTranscript += transcript;\n          }\n        }\n\n        if (finalTranscript) {\n          this.inputText.set(finalTranscript);\n          // Auto-send after voice input\n          setTimeout(() => this.sendMessage(), 300);\n        } else if (interimTranscript) {\n          this.inputText.set(interimTranscript);\n        }\n      };\n\n      this.recognition.onerror = (event: Event) => {\n        this.isListening.set(false);\n        this.voiceStartInFlight = false;\n        this.notifyVoiceError(event);\n      };\n\n      this.recognition.onend = () => {\n        this.isListening.set(false);\n        this.voiceStartInFlight = false;\n      };\n\n      this.recognition.onstart = () => {\n        this.isListening.set(true);\n        this.voiceStartInFlight = false;\n      };\n    }\n  }\n\n  ngAfterViewChecked(): void {\n    if (this.shouldScrollToBottom) {\n      this.scrollToBottom();\n      this.shouldScrollToBottom = false;\n    }\n  }\n\n  ngOnDestroy(): void {\n    this.stopListening();\n  }\n\n  goBack(): void {\n    this.stopListening();\n    this.router.navigate(['/']);\n  }\n\n  toggleVoice(): void {\n    if (this.isListening()) {\n      this.stopListening();\n    } else {\n      this.startListening();\n    }\n  }\n\n  startListening(): void {\n    if (this.isLoading()) {\n      this.agentService.addLocalAgentMessage(\n        'Estoy procesando tu último mensaje. Apenas termino, tocá el micrófono y hablá.',\n        ['local_voice'],\n      );\n      return;\n    }\n    if (!this.recognition) {\n      this.agentService.addLocalAgentMessage(\n        'Tu navegador no habilitó el reconocimiento de voz. Podés escribir o probar en Chrome/Edge y aceptar permisos de micrófono.',\n        ['local_voice'],\n      );\n      return;\n    }\n\n    if (this.isListening() || this.voiceStartInFlight) {\n      // Evitar el error: \"recognition has already started\"\n      this.agentService.addLocalAgentMessage('Ya estoy escuchando. Hablame ahora.', [\n        'local_voice',\n      ]);\n      return;\n    }\n\n    try {\n      // Haptic feedback\n      if ('vibrate' in navigator) {\n        navigator.vibrate(50);\n      }\n      this.inputText.set('');\n      this.voiceStartInFlight = true;\n      this.recognition.start();\n    } catch (err) {\n      this.voiceStartInFlight = false;\n      this.notifyVoiceError(err);\n    }\n  }\n\n  stopListening(): void {\n    if (!this.recognition) return;\n\n    try {\n      this.recognition.stop();\n    } catch {\n      // Not listening\n    }\n    this.isListening.set(false);\n    this.voiceStartInFlight = false;\n  }\n\n  async sendMessage(): Promise<void> {\n    const text = this.inputText().trim();\n    if (!text || this.isLoading()) return;\n\n    this.stopListening();\n    this.inputText.set('');\n    this.shouldScrollToBottom = true;\n    this.lastUserText.set(text);\n\n    if (await this.tryHandleLocalIntent(text)) {\n      this.shouldScrollToBottom = true;\n      return;\n    }\n\n    const context = await this.buildChatContext(text);\n\n    // Use WebSocket real-time if connected, otherwise HTTP fallback\n    if (this.agentService.isConnected()) {\n      this.agentService.sendMessageRealtimeWithContext(text, context);\n      this.shouldScrollToBottom = true;\n      return;\n    }\n\n    // Fallback to HTTP\n    this.agentService\n      .sendMessage(text, context)\n      .pipe(takeUntilDestroyed(this.destroyRef))\n      .subscribe({\n        next: () => {\n          this.shouldScrollToBottom = true;\n        },\n        error: (err) => {\n          console.error('Error sending message:', err);\n        },\n      });\n  }\n\n  onKeyDown(event: KeyboardEvent): void {\n    if (event.key === 'Enter' && !event.shiftKey) {\n      event.preventDefault();\n      this.sendMessage();\n    }\n  }\n\n  clearChat(): void {\n    this.agentService.clearHistory();\n  }\n\n  private scrollToBottom(): void {\n    if (this.messagesContainer) {\n      const el = this.messagesContainer.nativeElement;\n      el.scrollTop = el.scrollHeight;\n    }\n  }\n\n  private async tryHandleLocalIntent(text: string): Promise<boolean> {\n    const normalized = this.normalizeInput(text);\n\n    if (\n      /(no me escuch|no me entiende|no estas escuch|no est[aá]s escuch|microfono|micr[oó]fono|voz no funciona|no anda la voz)/.test(\n        normalized,\n      )\n    ) {\n      await this.respondWithVoiceHelp(text);\n      return true;\n    }\n\n    if (/(publicar|publica|subir).*(auto|veh[ií]culo)/.test(normalized)) {\n      this.agentService.addLocalUserMessage(text);\n      this.agentService.addLocalAgentMessage('Listo, te llevo a publicar tu auto.', [\n        'local_navigation',\n      ]);\n      this.router.navigate(['/cars/publish']);\n      return true;\n    }\n\n    if (\n      /(crear|hacer|iniciar).*(reserva|reservar)/.test(normalized) ||\n      /(buscar|alquilar|rentar).*(auto|veh[ií]culo)/.test(normalized)\n    ) {\n      // ✅ Si el usuario ya aportó carId + fechas, crear la reserva con su sesión.\n      const command = this.parseBookingCommand(text);\n      if (command) {\n        await this.createBookingFromCommand(text, command);\n        return true;\n      }\n\n      // Fallback: navegación al flujo estándar (selección de auto + fechas)\n      this.agentService.addLocalUserMessage(text);\n      this.agentService.addLocalAgentMessage(\n        'Te llevo a buscar autos disponibles. Ahí podés elegir fechas y reservar.',\n        ['local_navigation'],\n      );\n      this.router.navigate(['/cars/list']);\n      return true;\n    }\n\n    if (\n      /(mis reservas|mis reservaciones|estado de mis reservas|estado de reservas)/.test(normalized)\n    ) {\n      this.agentService.addLocalUserMessage(text);\n      this.agentService.addLocalAgentMessage('Te llevo a tus reservas.', ['local_navigation']);\n      this.router.navigate(['/bookings']);\n      return true;\n    }\n\n    if (/(mi cuenta|mi perfil|perfil)/.test(normalized)) {\n      this.agentService.addLocalUserMessage(text);\n      this.agentService.addLocalAgentMessage('Abriendo tu perfil.', ['local_navigation']);\n      this.router.navigate(['/profile']);\n      return true;\n    }\n\n    if (\n      /(herramientas|que puedes hacer|qué puedes hacer|que podes hacer|qué podés hacer|capacidades)/.test(\n        normalized,\n      )\n    ) {\n      await this.respondWithToolsSummary(text);\n      return true;\n    }\n\n    if (this.wantsCurrentLocation(normalized)) {\n      this.agentService.addLocalUserMessage(text);\n      const location = await this.locationService.getLocationByChoice('current');\n      if (location) {\n        this.lastLocation.set(location);\n        const coords =\n          typeof location.lat === 'number' && typeof location.lng === 'number'\n            ? ` (lat ${location.lat.toFixed(5)}, lng ${location.lng.toFixed(5)})`\n            : '';\n        this.agentService.addLocalAgentMessage(\n          location.address\n            ? `Tu ubicación es: ${location.address}.${coords}`\n            : `Tomé tu ubicación.${coords}`,\n          ['local_location'],\n        );\n      } else {\n        const home = await this.locationService.getHomeLocation();\n        if (home) {\n          this.lastLocation.set(home);\n          this.agentService.addLocalAgentMessage(\n            home.address\n              ? `No pude leer tu GPS ahora. Uso tu ubicación guardada: ${home.address}.`\n              : 'No pude leer tu GPS ahora. Uso tu ubicación guardada.',\n            ['local_location'],\n          );\n        } else {\n          this.agentService.addLocalAgentMessage(\n            'No pude acceder a tu ubicación. ¿Podés habilitar permisos o decirme una dirección?',\n            ['local_location'],\n          );\n        }\n      }\n      return true;\n    }\n\n    if (this.looksLikeAddress(normalized)) {\n      this.agentService.addLocalUserMessage(text);\n      const location = await this.resolveLocationContext(text);\n      if (location) {\n        this.lastLocation.set(location);\n        this.lastAddressHint.set(location.address ?? text);\n        this.agentService.addLocalAgentMessage(\n          location.address\n            ? `Listo, tomaré esa ubicación: ${location.address}.`\n            : 'Listo, tomaré esa ubicación.',\n          ['local_location'],\n        );\n        return true;\n      }\n    }\n\n    if (/(buenos aires|argentina)/.test(normalized)) {\n      this.agentService.addLocalUserMessage(text);\n      this.lastMarket.set({ country: 'AR', city: 'Buenos Aires' });\n      this.agentService.addLocalAgentMessage(\n        'Perfecto, usaré Buenos Aires, Argentina para las búsquedas.',\n        ['local_location'],\n      );\n      return true;\n    }\n\n    if (\n      /(mi cuenta|mi perfil|quien soy|quién soy|estoy logueado|estoy logueada|mi usuario)/.test(\n        normalized,\n      )\n    ) {\n      await this.respondWithAccountSummary(text);\n      return true;\n    }\n\n    const personalInfo = this.getPersonalInfoQueryKind(normalized);\n    if (personalInfo) {\n      await this.respondWithPersonalInfo(text, personalInfo);\n      return true;\n    }\n\n    if (\n      /(a que no tenes acceso|a que no tienes acceso|que no tenes acceso|que no tienes acceso|no tenes acceso|no tienes acceso|limitaciones|privacidad)/.test(\n        normalized,\n      )\n    ) {\n      await this.respondWithAccessLimitations(text);\n      return true;\n    }\n\n    if (/(mi wallet|mi billetera|saldo|balance|saldo disponible)/.test(normalized)) {\n      await this.respondWithWalletSummary(text);\n      return true;\n    }\n\n    if (/(abrir|ver|ir a).*(wallet|billetera)/.test(normalized)) {\n      this.agentService.addLocalUserMessage(text);\n      this.agentService.addLocalAgentMessage('Abriendo tu wallet.', ['local_navigation']);\n      this.router.navigate(['/wallet']);\n      return true;\n    }\n\n    if (/(mis autos|mis vehículos|mis vehiculos|mis coches)/.test(normalized)) {\n      await this.respondWithMyCarsSummary(text);\n      return true;\n    }\n\n    if (/(abrir|ver|ir a).*(mis autos|autos publicados|mis veh[ií]culos)/.test(normalized)) {\n      this.agentService.addLocalUserMessage(text);\n      this.agentService.addLocalAgentMessage('Abriendo tus autos.', ['local_navigation']);\n      this.router.navigate(['/cars/my']);\n      return true;\n    }\n\n    if (/(mis documentos|documentos|verificaci[oó]n|kyc|mi verificacion)/.test(normalized)) {\n      await this.respondWithDocumentsSummary(text);\n      return true;\n    }\n\n    if (/(autos?).*(cerca|cercanos|cercanas|m[aá]s cercanos|cerca de m[ií])/.test(normalized)) {\n      await this.navigateToNearbyCars(text);\n      return true;\n    }\n\n    if (/(abrir|ver|ir a).*(documentos|verificaci[oó]n)/.test(normalized)) {\n      this.agentService.addLocalUserMessage(text);\n      this.agentService.addLocalAgentMessage('Abriendo verificación.', ['local_navigation']);\n      this.router.navigate(['/profile/verification']);\n      return true;\n    }\n\n    const pickupPref = this.parsePickupPreference(normalized);\n    if (pickupPref) {\n      this.agentService.addLocalUserMessage(text);\n      this.lastPickupPreference.set(pickupPref.pickup);\n      this.lastDropoffPreference.set(pickupPref.dropoff ?? pickupPref.pickup);\n      if (pickupPref.addressHint) {\n        this.lastAddressHint.set(pickupPref.addressHint);\n      }\n\n      const locationText =\n        pickupPref.pickup === 'owner_address'\n          ? 'en la casa del dueño'\n          : pickupPref.pickup === 'airport'\n            ? 'en el aeropuerto'\n            : pickupPref.pickup === 'office'\n              ? 'en la oficina'\n              : 'en la dirección indicada';\n\n      const response = [\n        `Perfecto: retiro y devolución ${locationText}.`,\n        pickupPref.sameLocation\n          ? 'Confirmo que devolvés en el mismo lugar.'\n          : '¿Querés devolver en el mismo lugar?',\n        pickupPref.pickup === 'owner_address'\n          ? 'Si querés, indicame la dirección exacta o confirmo la del anuncio.'\n          : 'Si querés, indicame la dirección exacta.',\n      ].join(' ');\n\n      this.agentService.addLocalAgentMessage(response, ['local_location']);\n      return true;\n    }\n\n    return false;\n  }\n\n  private getPersonalInfoQueryKind(\n    normalized: string,\n  ): 'name' | 'email' | 'dni' | null {\n    if (/(mi nombre|como me llamo|cu[aá]l es mi nombre)/.test(normalized)) return 'name';\n    if (/(mi email|mi correo|mi mail|cu[aá]l es mi correo|cu[aá]l es mi email)/.test(normalized)) {\n      return 'email';\n    }\n    if (/(mi dni|mi documento|n[uú]mero de documento|documento nacional)/.test(normalized)) {\n      return 'dni';\n    }\n    return null;\n  }\n\n  private async respondWithPersonalInfo(\n    originalText: string,\n    kind: 'name' | 'email' | 'dni',\n  ): Promise<void> {\n    this.agentService.addLocalUserMessage(originalText);\n    const auth = await this.getAuthSnapshot();\n    if (!auth) {\n      this.agentService.addLocalAgentMessage(\n        'Para ver tus datos necesito que estés logueado. ¿Querés que abra el login?',\n        ['local_profile'],\n      );\n      return;\n    }\n\n    let profile = this.profileStore.profile();\n    if (!profile) {\n      try {\n        profile = await this.profileStore.loadProfile();\n      } catch {\n        profile = this.profileStore.profile();\n      }\n    }\n\n    if (kind === 'email') {\n      this.agentService.addLocalAgentMessage(\n        auth.email\n          ? `Tu email es: ${auth.email}.`\n          : 'No tengo un email disponible en tu sesión. Podés revisarlo en tu perfil.',\n        ['local_profile'],\n      );\n      return;\n    }\n\n    if (kind === 'name') {\n      const name = profile?.full_name?.trim();\n      this.agentService.addLocalAgentMessage(\n        name\n          ? `Tu nombre (según tu perfil) es: ${name}.`\n          : 'No veo tu nombre cargado en el perfil. Si querés, abrimos tu perfil para completarlo.',\n        ['local_profile'],\n      );\n      return;\n    }\n\n    const dniCandidate =\n      profile?.gov_id_number ??\n      (profile as unknown as { dni?: string | null }).dni ??\n      null;\n\n    if (!dniCandidate) {\n      this.agentService.addLocalAgentMessage(\n        'No tengo un DNI cargado/visible en tu perfil. Podés revisarlo o completarlo desde tu perfil.',\n        ['local_profile'],\n      );\n      return;\n    }\n\n    this.agentService.addLocalAgentMessage(\n      `DNI (enmascarado): ${this.maskSensitiveNumber(dniCandidate)}.`,\n      ['local_profile'],\n    );\n  }\n\n  private maskSensitiveNumber(value: string): string {\n    const raw = String(value).trim();\n    const digits = raw.replace(/\\D/g, '');\n    if (digits.length === 0) return '***';\n    if (digits.length <= 3) return `***${digits}`;\n    const tail = digits.slice(-3);\n    return `***${tail}`;\n  }\n\n  private async respondWithAccessLimitations(originalText: string): Promise<void> {\n    this.agentService.addLocalUserMessage(originalText);\n\n    const auth = await this.getAuthSnapshot();\n    const canReadAccount = Boolean(auth);\n\n    const response = [\n      'Acceso que SÍ tengo dentro de la app:',\n      canReadAccount\n        ? '• Tus datos de sesión (tu ID y tu email si existe en la sesión).'\n        : '• Solo datos generales (si no estás logueado, no puedo ver tu cuenta).',\n      canReadAccount\n        ? '• Tu perfil (por ejemplo nombre si está cargado).'\n        : '• Autos públicos (marketplace) y navegación dentro de la app.',\n      canReadAccount ? '• Tu wallet (saldos) y tus reservas.' : '• Búsqueda de autos y estimaciones sin cuenta.',\n      '• Tu ubicación SOLO si das permiso al navegador o me das una dirección.',\n      '',\n      'Acceso que NO tengo:',\n      '• Contraseñas o códigos de verificación.',\n      '• Datos de pago completos (tarjetas completas, CVV).',\n      '• Información personal de otros usuarios.',\n      '• Datos que no estén cargados en tu perfil o que el backend no exponga al frontend.',\n      '',\n      'Si querés “programarme” para más personalización, la clave es exponer herramientas locales/servicios que lean esos campos del perfil (con RLS) y luego interceptar intents como “mi nombre / mi email / mi DNI”.',\n    ].join('\\n');\n\n    this.agentService.addLocalAgentMessage(response, ['local_info']);\n  }\n\n  private parseBookingCommand(text: string): { carId: string; startDate: string; endDate: string } | null {\n    const uuid = this.extractFirstUuid(text);\n    if (!uuid) return null;\n\n    const dates = this.extractDateCandidates(text);\n    if (dates.length < 2) return null;\n\n    const startDate = this.normalizeToLocalDateString(dates[0]);\n    const endDate = this.normalizeToLocalDateString(dates[1]);\n    if (!this.isIsoDate(startDate) || !this.isIsoDate(endDate)) return null;\n\n    return { carId: uuid, startDate, endDate };\n  }\n\n  private extractFirstUuid(text: string): string | null {\n    const match = text.match(/[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}/);\n    return match?.[0] ?? null;\n  }\n\n  private extractDateCandidates(text: string): string[] {\n    // Acepta formatos comunes:\n    // - YYYY-MM-DD\n    // - DD/MM/YYYY\n    const isoMatches = text.match(/\\b\\d{4}-\\d{2}-\\d{2}\\b/g) ?? [];\n    const dmyMatches = text.match(/\\b\\d{1,2}\\/\\d{1,2}\\/\\d{4}\\b/g) ?? [];\n    return [...isoMatches, ...dmyMatches];\n  }\n\n  private isIsoDate(value: string): boolean {\n    return /^\\d{4}-\\d{2}-\\d{2}$/.test(value);\n  }\n\n  private normalizeToLocalDateString(value: string): string {\n    // YYYY-MM-DD\n    if (/^\\d{4}-\\d{2}-\\d{2}$/.test(value)) {\n      return value;\n    }\n\n    // DD/MM/YYYY\n    if (/^\\d{1,2}\\/\\d{1,2}\\/\\d{4}$/.test(value)) {\n      const [d, m, y] = value.split('/').map((v) => Number(v));\n      if (!y || !m || !d) return value;\n      const year = String(y).padStart(4, '0');\n      const month = String(m).padStart(2, '0');\n      const day = String(d).padStart(2, '0');\n      return `${year}-${month}-${day}`;\n    }\n\n    // Fallback (best effort)\n    try {\n      const parsed = new Date(value);\n      if (Number.isNaN(parsed.getTime())) return value;\n      const year = parsed.getFullYear();\n      const month = String(parsed.getMonth() + 1).padStart(2, '0');\n      const day = String(parsed.getDate()).padStart(2, '0');\n      return `${year}-${month}-${day}`;\n    } catch {\n      return value;\n    }\n  }\n\n  private async createBookingFromCommand(\n    originalText: string,\n    command: { carId: string; startDate: string; endDate: string },\n  ): Promise<void> {\n    this.agentService.addLocalUserMessage(originalText);\n    const msgId = this.agentService.addLocalAgentMessage(\n      `Creando tu reserva para ${command.startDate} → ${command.endDate}...`,\n      ['local_booking'],\n    );\n\n    const auth = await this.getAuthSnapshot();\n    if (!auth) {\n      this.agentService.updateMessageContent(\n        msgId,\n        'Necesitás iniciar sesión para crear una reserva. ¿Querés que abra el login?',\n        ['local_booking'],\n      );\n      return;\n    }\n\n    try {\n      const result = await this.bookingsService.createBookingWithValidation(\n        command.carId,\n        command.startDate,\n        command.endDate,\n      );\n\n      if (!result.success || !result.booking) {\n        this.agentService.updateMessageContent(\n          msgId,\n          result.error || 'No pude crear la reserva. Probá con otro auto o cambiá fechas.',\n          ['local_booking'],\n        );\n        return;\n      }\n\n      this.agentService.updateMessageContent(\n        msgId,\n        `Listo. Creé la reserva en tu cuenta (ID: ${result.booking.id}). Te llevo al pago/detalle.`,\n        ['local_booking'],\n      );\n\n      this.router.navigate(['/bookings', result.booking.id, 'detail-payment']);\n    } catch {\n      this.agentService.updateMessageContent(\n        msgId,\n        'Error al crear la reserva. Si el auto ya está reservado en esas fechas, probá con otras.',\n        ['local_booking'],\n      );\n    }\n  }\n\n  private async buildChatContext(text: string): Promise<ChatContext | undefined> {\n    const profile = this.profileStore.profile();\n    const session = await this.authService.ensureSession();\n    const userId = session?.user?.id ?? profile?.id;\n    const userEmail = session?.user?.email ?? undefined;\n    const locale = typeof navigator !== 'undefined' ? navigator.language : 'es-AR';\n    const timezone =\n      typeof Intl !== 'undefined'\n        ? Intl.DateTimeFormat().resolvedOptions().timeZone\n        : 'America/Argentina/Buenos_Aires';\n\n    const marketOverride = this.lastMarket();\n    const context: ChatContext = {\n      locale,\n      timezone,\n      currency: profile?.currency ?? undefined,\n      market: {\n        country: marketOverride?.country ?? profile?.country ?? 'AR',\n        city: marketOverride?.city ?? profile?.city ?? undefined,\n      },\n      rentalPreferences:\n        this.lastPickupPreference() || this.lastDropoffPreference()\n          ? {\n            pickup: this.lastPickupPreference() ?? undefined,\n            dropoff: this.lastDropoffPreference() ?? undefined,\n            sameLocation:\n              this.lastPickupPreference() !== null &&\n              this.lastPickupPreference() === this.lastDropoffPreference(),\n            addressHint: this.lastAddressHint() ?? undefined,\n          }\n          : undefined,\n      auth: {\n        userId: userId ?? undefined,\n        email: userEmail,\n        isAuthenticated: !!userId,\n      },\n      userProfile: profile\n        ? {\n          id: profile.id,\n          email: userEmail,\n          full_name: profile.full_name,\n          role: profile.role,\n          city: profile.city ?? null,\n          country: profile.country ?? null,\n          kyc: profile.kyc,\n          can_publish_cars: profile.can_publish_cars,\n          can_book_cars: profile.can_book_cars,\n        }\n        : undefined,\n    };\n\n    const location = this.lastLocation() ?? (await this.resolveLocationContext(text));\n    if (location) {\n      this.lastLocation.set(location);\n      context.userLocation = {\n        lat: location.lat,\n        lng: location.lng,\n        address: location.address,\n        source: location.source,\n        accuracy: location.accuracy,\n        city: profile?.city ?? undefined,\n      };\n      if (!context.market?.city && location.address) {\n        context.market = {\n          ...context.market,\n          city: location.address,\n        };\n      }\n    }\n\n    return context;\n  }\n\n  private wantsCurrentLocation(text: string): boolean {\n    const normalized = this.normalizeInput(text);\n\n    // Evita capturar frases de búsqueda de autos (se manejan con otro intent)\n    if (/(auto|autos|vehiculo|vehiculos|coche|coches)/.test(normalized)) return false;\n\n    // Tolerante a typos comunes: \"ubicaicon\" / \"ubication\" etc.\n    const mentionsLocationWord = /(ubic|ubica|ubicac|ubicaic|ubicaicon|ubication)/.test(normalized);\n    const mentionsNow = /(actual|ahora|en este momento)/.test(normalized);\n    const explicit =\n      /ubicacion actual|usar mi ubicacion|usar ubicacion actual|mi ubicacion actual|mi ubicacion|cual es mi ubicacion|donde estoy/.test(\n        normalized,\n      );\n\n    return explicit || (mentionsLocationWord && mentionsNow);\n  }\n\n  private notifyVoiceError(err: unknown): void {\n    const now = Date.now();\n    if (now - this.lastVoiceErrorAt < 1500) return;\n    this.lastVoiceErrorAt = now;\n\n    const message =\n      typeof err === 'string'\n        ? err\n        : err instanceof Error\n          ? err.message\n          : (err as { error?: string })?.error\n            ? String((err as { error?: string }).error)\n            : null;\n\n    if (message?.toLowerCase().includes('recognition has already started')) {\n      // Caso benigno: doble tap o evento duplicado\n      this.agentService.addLocalAgentMessage('Ya estoy escuchando. Hablame ahora.', ['local_voice']);\n      return;\n    }\n\n    const hint =\n      'No pude activar el micrófono. Revisá permisos del navegador y que estés en HTTPS (o localhost).';\n\n    this.agentService.addLocalAgentMessage(\n      message ? `${hint} Detalle: ${message}` : hint,\n      ['local_voice'],\n    );\n  }\n\n  private async respondWithVoiceHelp(originalText: string): Promise<void> {\n    this.agentService.addLocalUserMessage(originalText);\n\n    if (!this.voiceSupported()) {\n      this.agentService.addLocalAgentMessage(\n        [\n          'En este dispositivo/navegador no está disponible el reconocimiento de voz.',\n          'Probá con Chrome/Edge (Android/desktop) y aceptá el permiso de micrófono.',\n          'Mientras tanto, podés escribirme acá mismo.',\n        ].join(' '),\n        ['local_voice'],\n      );\n      return;\n    }\n\n    if (this.isLoading()) {\n      this.agentService.addLocalAgentMessage(\n        'Estoy procesando tu último mensaje. Apenas termino, tocá el micrófono y hablá.',\n        ['local_voice'],\n      );\n      return;\n    }\n\n    this.agentService.addLocalAgentMessage(\n      [\n        'Para hablarme: tocá el botón del micrófono y empezá a hablar.',\n        'Si no arranca, el navegador puede estar bloqueando permisos de micrófono.',\n        'Probá: permitir micrófono en el candadito del navegador y recargar la página.',\n      ].join(' '),\n      ['local_voice'],\n    );\n  }\n\n  private wantsLocationContext(text: string): boolean {\n    return /ubicaci[oó]n|cerca|cercan|aqui|ac[aá]|estoy en|direcci[oó]n/.test(text);\n  }\n\n  private looksLikeAddress(text: string): boolean {\n    const trimmed = text.trim();\n    if (trimmed.length < 8 || trimmed.length > 120) return false;\n    return trimmed.includes(',') || trimmed.includes(' y ') || trimmed.includes(' & ');\n  }\n\n  private normalizeInput(text: string): string {\n    return text\n      .toLowerCase()\n      .normalize('NFD')\n      .replace(/[\\u0300-\\u036f]/g, '')\n      .replace(/[^a-z0-9\\s]/g, ' ')\n      .replace(/\\s+/g, ' ')\n      .trim();\n  }\n\n  private isWalletQuery(text: string): boolean {\n    const normalized = this.normalizeInput(text);\n    return /(wallet|billetera|saldo|balance|saldo disponible)/.test(normalized);\n  }\n\n  private async resolveLocationContext(text: string): Promise<LocationData | null> {\n    const normalized = text.toLowerCase();\n\n    if (this.wantsCurrentLocation(normalized)) {\n      return await this.locationService.getLocationByChoice('current');\n    }\n\n    if (this.looksLikeAddress(normalized)) {\n      try {\n        const profile = this.profileStore.profile();\n        const countryHint = profile?.country ?? 'AR';\n        const result = await this.geocodingService.geocodeAddress(text, countryHint);\n        return {\n          lat: result.latitude,\n          lng: result.longitude,\n          source: 'address',\n          address: result.fullAddress,\n        };\n      } catch {\n        // Ignore geocoding errors and fallback to home/gps\n      }\n    }\n\n    if (this.wantsLocationContext(normalized)) {\n      const home = await this.locationService.getHomeLocation();\n      if (home) return home;\n      return await this.locationService.getCurrentPosition().then((loc) =>\n        loc\n          ? {\n            ...loc,\n            source: 'gps',\n          }\n          : null,\n      );\n    }\n\n    return await this.locationService.getHomeLocation();\n  }\n\n  private async getAuthSnapshot(): Promise<{ id: string; email?: string } | null> {\n    const session = await this.authService.ensureSession();\n    const user = session?.user;\n    if (!user?.id) return null;\n    return { id: user.id, email: user.email ?? undefined };\n  }\n\n  private formatMoney(amount: number, currency = 'USD'): string {\n    const formatter = new Intl.NumberFormat('es-AR', {\n      style: 'currency',\n      currency,\n      maximumFractionDigits: 2,\n    });\n    return formatter.format(amount);\n  }\n\n  private async respondWithToolsSummary(originalText: string): Promise<void> {\n    this.agentService.addLocalUserMessage(originalText);\n    const auth = await this.getAuthSnapshot();\n    let profile = this.profileStore.profile();\n    if (auth && !profile) {\n      try {\n        profile = await this.profileStore.loadProfile();\n      } catch {\n        profile = this.profileStore.profile();\n      }\n    }\n\n    const loggedInfo = auth\n      ? `Estás logueado como ${profile?.full_name ?? 'Usuario'} (${auth.email ?? 'sin email'})`\n      : 'No estás logueado. Si querés, puedo abrir el login.';\n\n    const response = [\n      loggedInfo,\n      '',\n      'Herramientas disponibles en tu cuenta:',\n      '• Perfil: ver y editar datos personales.',\n      '• Autos: ver tus autos publicados o publicar uno nuevo.',\n      '• Wallet: ver saldo, depositar y retirar.',\n      '• Documentos: verificación y estado de tus documentos.',\n      '• Reservas: ver y gestionar tus reservas.',\n      '• Mensajes: abrir tus chats.',\n      '',\n      'Decime “mi perfil”, “mis autos”, “mi wallet” o “mis documentos”.',\n    ].join('\\n');\n\n    this.agentService.addLocalAgentMessage(response, ['local_info']);\n  }\n\n  private async respondWithAccountSummary(originalText: string): Promise<void> {\n    this.agentService.addLocalUserMessage(originalText);\n    const msgId = this.agentService.addLocalAgentMessage(\n      'Estoy revisando tu cuenta...',\n      ['local_profile'],\n    );\n\n    const auth = await this.getAuthSnapshot();\n    if (!auth) {\n      this.agentService.updateMessageContent(\n        msgId,\n        'No estás logueado. ¿Querés que abra la pantalla de login?',\n        ['local_profile'],\n      );\n      return;\n    }\n\n    try {\n      const profile = await this.profileStore.loadProfile();\n      const role = profile?.role ?? 'renter';\n      const kyc = profile?.kyc ?? 'not_started';\n      const permissions = [\n        profile?.can_publish_cars ? 'puede publicar autos' : 'no puede publicar autos',\n        profile?.can_book_cars ? 'puede reservar autos' : 'no puede reservar autos',\n      ];\n\n      const response = [\n        `Estás logueado como ${profile?.full_name ?? 'Usuario'} (${auth.email ?? 'sin email'}).`,\n        `ID de usuario: ${auth.id}`,\n        `Rol: ${role}.`,\n        `Verificación (KYC): ${kyc}.`,\n        `Permisos: ${permissions.join(', ')}.`,\n      ].join(' ');\n\n      this.agentService.updateMessageContent(msgId, response, ['local_profile']);\n    } catch {\n      this.agentService.updateMessageContent(\n        msgId,\n        'No pude cargar tu perfil en este momento. ¿Querés intentarlo de nuevo?',\n        ['local_profile'],\n      );\n    }\n  }\n\n  private async respondWithWalletSummary(originalText: string): Promise<void> {\n    this.agentService.addLocalUserMessage(originalText);\n    const msgId = this.agentService.addLocalAgentMessage(\n      'Consultando tu wallet...',\n      ['local_wallet'],\n    );\n\n    await this.fillWalletSummary(msgId);\n  }\n\n  private async fillWalletSummary(messageId: string): Promise<void> {\n    const auth = await this.getAuthSnapshot();\n    if (!auth) {\n      this.agentService.updateMessageContent(\n        messageId,\n        'Necesitás iniciar sesión para ver tu wallet.',\n        ['local_wallet'],\n      );\n      return;\n    }\n\n    try {\n      const balance: WalletBalance = await this.walletService.fetchBalance(true);\n      const currency = balance.currency || 'USD';\n      const response = [\n        `Saldo disponible: ${this.formatMoney(balance.available_balance, currency)}.`,\n        `Saldo bloqueado: ${this.formatMoney(balance.locked_balance, currency)}.`,\n        `Saldo total: ${this.formatMoney(balance.total_balance, currency)}.`,\n        `Crédito AutoRenta: ${this.formatMoney(balance.autorentar_credit_balance, currency)}.`,\n      ].join(' ');\n      this.agentService.updateMessageContent(messageId, response, ['local_wallet']);\n    } catch {\n      this.agentService.updateMessageContent(\n        messageId,\n        'No pude obtener tu saldo en este momento. ¿Querés abrir la wallet?',\n        ['local_wallet'],\n      );\n    }\n  }\n\n  private async respondWithMyCarsSummary(originalText: string): Promise<void> {\n    this.agentService.addLocalUserMessage(originalText);\n    const msgId = this.agentService.addLocalAgentMessage(\n      'Buscando tus autos...',\n      ['local_cars'],\n    );\n\n    const auth = await this.getAuthSnapshot();\n    if (!auth) {\n      this.agentService.updateMessageContent(\n        msgId,\n        'Necesitás iniciar sesión para ver tus autos.',\n        ['local_cars'],\n      );\n      return;\n    }\n\n    try {\n      const cars = await this.carsService.listMyCars();\n      if (!cars.length) {\n        this.agentService.updateMessageContent(\n          msgId,\n          'No tenés autos publicados todavía. ¿Querés publicar uno ahora?',\n          ['local_cars'],\n        );\n        return;\n      }\n\n      const preview = cars\n        .slice(0, 3)\n        .map((car) => `${car.brand ?? car.brand_name ?? 'Auto'} ${car.model ?? ''}`.trim())\n        .filter(Boolean);\n\n      const response = [\n        `Tenés ${cars.length} auto(s) publicados.`,\n        preview.length ? `Ejemplos: ${preview.join(', ')}.` : '',\n        '¿Querés abrir “Mis autos”?',\n      ]\n        .filter(Boolean)\n        .join(' ');\n\n      this.agentService.updateMessageContent(msgId, response, ['local_cars']);\n    } catch {\n      this.agentService.updateMessageContent(\n        msgId,\n        'No pude cargar tus autos en este momento.',\n        ['local_cars'],\n      );\n    }\n  }\n\n  private async respondWithDocumentsSummary(originalText: string): Promise<void> {\n    this.agentService.addLocalUserMessage(originalText);\n    const msgId = this.agentService.addLocalAgentMessage(\n      'Revisando tus documentos...',\n      ['local_documents'],\n    );\n\n    const auth = await this.getAuthSnapshot();\n    if (!auth) {\n      this.agentService.updateMessageContent(\n        msgId,\n        'Necesitás iniciar sesión para ver tus documentos.',\n        ['local_documents'],\n      );\n      return;\n    }\n\n    try {\n      const docs = await this.verificationService.loadDocuments();\n      if (!docs.length) {\n        this.agentService.updateMessageContent(\n          msgId,\n          'No encuentro documentos cargados aún. ¿Querés ir a verificación?',\n          ['local_documents'],\n        );\n        return;\n      }\n\n      const counts = docs.reduce(\n        (acc, doc) => {\n          acc[doc.status] = (acc[doc.status] || 0) + 1;\n          return acc;\n        },\n        {} as Record<string, number>,\n      );\n\n      const response = [\n        `Documentos: ${docs.length} en total.`,\n        counts['verified'] ? `Verificados: ${counts['verified']}.` : '',\n        counts['pending'] ? `En revisión: ${counts['pending']}.` : '',\n        counts['rejected'] ? `Rechazados: ${counts['rejected']}.` : '',\n        '¿Querés abrir la sección de verificación?',\n      ]\n        .filter(Boolean)\n        .join(' ');\n\n      this.agentService.updateMessageContent(msgId, response, ['local_documents']);\n    } catch {\n      this.agentService.updateMessageContent(\n        msgId,\n        'No pude cargar tus documentos en este momento.',\n        ['local_documents'],\n      );\n    }\n  }\n\n  private async navigateToNearbyCars(originalText: string): Promise<void> {\n    this.agentService.addLocalUserMessage(originalText);\n    const msgId = this.agentService.addLocalAgentMessage(\n      'Buscando autos cercanos a tu ubicación...',\n      ['local_nearby'],\n    );\n\n    try {\n      const location = this.lastLocation() ?? (await this.locationService.getUserLocation());\n      if (!location) {\n        this.agentService.updateMessageContent(\n          msgId,\n          'Necesito tu ubicación para ordenar por distancia. Podés decir “usar ubicación actual” o indicar una dirección.',\n          ['local_nearby'],\n        );\n        return;\n      }\n\n      this.lastLocation.set(location);\n      this.persistLocationOverride(location);\n\n      if (typeof localStorage !== 'undefined') {\n        localStorage.setItem('autorenta:list-sort', 'distance');\n      }\n\n      const params = new URLSearchParams();\n      params.set('sort', 'distance');\n      params.set('nearby', '1');\n      params.set('lat', String(location.lat));\n      params.set('lng', String(location.lng));\n\n      this.agentService.updateMessageContent(\n        msgId,\n        'Listo. Te muestro los autos más cercanos.',\n        ['local_nearby'],\n      );\n      this.router.navigate(['/cars/list'], { queryParams: Object.fromEntries(params.entries()) });\n    } catch {\n      this.agentService.updateMessageContent(\n        msgId,\n        'No pude obtener tu ubicación. ¿Querés usar tu ubicación actual o decirme una dirección?',\n        ['local_nearby'],\n      );\n    }\n  }\n\n  private persistLocationOverride(location: LocationData): void {\n    if (typeof sessionStorage === 'undefined') return;\n    const payload = {\n      lat: location.lat,\n      lng: location.lng,\n      accuracy: location.accuracy ?? null,\n      timestamp: location.timestamp ?? Date.now(),\n      source: location.source,\n      address: location.address ?? null,\n    };\n    try {\n      sessionStorage.setItem(this.locationOverrideKey, JSON.stringify(payload));\n    } catch {\n      // Ignore storage failures\n    }\n  }\n\n  private parsePickupPreference(text: string): {\n    pickup: 'owner_address' | 'office' | 'airport' | 'custom';\n    dropoff?: 'owner_address' | 'office' | 'airport' | 'custom';\n    sameLocation?: boolean;\n    addressHint?: string;\n  } | null {\n    const normalized = text.toLowerCase();\n    const mentionsOwner =\n      /(casa|domicilio).*(due[ñn]o|propietario|anfitri[oó]n)/.test(normalized) ||\n      /(en la casa del due[ñn]o|en el domicilio del due[ñn]o)/.test(normalized);\n    const mentionsSame =\n      /(mismo lugar|misma direcci[oó]n|igual que lo retir(e|e)|igual que lo retiro)/.test(\n        normalized,\n      );\n    const mentionsAirport = /(aeropuerto|airport)/.test(normalized);\n    const mentionsOffice = /(oficina|sucursal|centro)/.test(normalized);\n    const mentionsHome = /(entrega a domicilio|retiro en domicilio|domicilio)/.test(normalized);\n\n    if (mentionsOwner || mentionsHome) {\n      return {\n        pickup: 'owner_address',\n        dropoff: mentionsSame ? 'owner_address' : undefined,\n        sameLocation: mentionsSame,\n        addressHint: undefined,\n      };\n    }\n\n    if (mentionsAirport) {\n      return {\n        pickup: 'airport',\n        dropoff: mentionsSame ? 'airport' : undefined,\n        sameLocation: mentionsSame,\n      };\n    }\n\n    if (mentionsOffice) {\n      return {\n        pickup: 'office',\n        dropoff: mentionsSame ? 'office' : undefined,\n        sameLocation: mentionsSame,\n      };\n    }\n\n    return null;\n  }\n\n  private shouldOverrideEcuadorResponse(message: string): boolean {\n    const lower = message.toLowerCase();\n    const mentionsEcuador = /(ecuador|quito|guayaquil)/.test(lower);\n    if (!mentionsEcuador) return false;\n\n    const market = this.lastMarket();\n    if (market?.country?.toLowerCase() === 'ar') return true;\n    if (market?.city?.toLowerCase().includes('buenos')) return true;\n\n    const profile = this.profileStore.profile();\n    if (profile?.country?.toLowerCase() === 'ar') return true;\n    if (profile?.city?.toLowerCase()?.includes('buenos')) return true;\n\n    const locale = typeof navigator !== 'undefined' ? navigator.language.toLowerCase() : '';\n    const timezone =\n      typeof Intl !== 'undefined'\n        ? Intl.DateTimeFormat().resolvedOptions().timeZone.toLowerCase()\n        : '';\n\n    if (locale.startsWith('es-ar')) return true;\n    if (timezone.includes('argentina') || timezone.includes('buenos_aires')) return true;\n\n    return false;\n  }\n\n  private shouldOverrideConfusedResponse(message: string): boolean {\n    const lower = message.toLowerCase();\n    return (\n      lower.includes('no entiendo') ||\n      lower.includes('no entendi') ||\n      lower.includes('no pude') ||\n      lower.includes('no puedo') ||\n      lower.includes('no tengo la capacidad') ||\n      lower.includes('no tengo acceso') ||\n      lower.includes('no puedo mostrar') ||\n      lower.includes('no puedo ver') ||\n      lower.includes('disculpa') ||\n      lower.includes('necesitas ayuda') ||\n      lower.includes('quizas')\n    );\n  }\n\n  private shouldOverrideWalletLookup(message: string): boolean {\n    const normalized = this.normalizeInput(message);\n    return (\n      normalized.includes('clienteid') ||\n      normalized.includes('numero de documento') ||\n      normalized.includes('numero de telefono') ||\n      normalized.includes('telefono') ||\n      normalized.includes('cedula') ||\n      normalized.includes('pasaporte') ||\n      normalized.includes('buscar tu perfil')\n    );\n  }\n\n  private shouldOverrideGreetingResponse(message: string): boolean {\n    const normalized = this.normalizeInput(message);\n    return (\n      normalized.includes('hola') &&\n      (normalized.includes('bienvenido') ||\n        normalized.includes('asistente') ||\n        normalized.includes('autorentar') ||\n        normalized.includes('dni') ||\n        normalized.includes('licencia') ||\n        normalized.includes('garantia'))\n    );\n  }\n\n  private async overrideWithWalletSummary(messageId: string): Promise<void> {\n    this.lastSanitizedMessageId.set(messageId);\n    this.agentService.updateMessageContent(\n      messageId,\n      'Claro, te muestro tu wallet...',\n      ['local_wallet'],\n    );\n    await this.fillWalletSummary(messageId);\n  }\n\n  trackByMessageId(index: number, message: ChatMessage): string {\n    return message.id;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/features/users/public-profile.page.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`../../core/models` type import should occur after import of `@core/services/cars/reviews.service`","line":9,"column":1,"nodeType":"ImportDeclaration","endLine":9,"endColumn":54,"fix":{"range":[458,716],"text":"import { CarsService } from '@core/services/cars/cars.service';\nimport { ProfileService } from '@core/services/auth/profile.service';\nimport { ReviewsService } from '@core/services/cars/reviews.service';\nimport type { Car, Review } from '../../core/models';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { CommonModule } from '@angular/common';\nimport {Component, computed, inject, signal, DestroyRef, OnInit,\n  ChangeDetectionStrategy} from '@angular/core';\nimport { toSignal, takeUntilDestroyed } from '@angular/core/rxjs-interop';\nimport { ActivatedRoute, Router, RouterModule } from '@angular/router';\nimport { TranslateModule } from '@ngx-translate/core';\nimport { from, of } from 'rxjs';\nimport { catchError, map, switchMap } from 'rxjs/operators';\nimport type { Car, Review } from '../../core/models';\nimport { CarsService } from '@core/services/cars/cars.service';\nimport { ProfileService } from '@core/services/auth/profile.service';\nimport { ReviewsService } from '@core/services/cars/reviews.service';\nimport {\n  ReviewRadarChartComponent,\n  type RadarChartData,\n} from '../../shared/components/review-radar-chart/review-radar-chart.component';\nimport { getCarImageUrl } from '../../shared/utils/car-placeholder.util';\n\n@Component({\n  selector: 'app-public-profile',\n  standalone: true,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  imports: [CommonModule, RouterModule, TranslateModule, ReviewRadarChartComponent],\n  templateUrl: './public-profile.page.html',\n})\nexport class PublicProfilePage implements OnInit {\n  private readonly route = inject(ActivatedRoute);\n  private readonly router = inject(Router);\n  private readonly profileService = inject(ProfileService);\n  private readonly carsService = inject(CarsService);\n  private readonly reviewsService = inject(ReviewsService);\n  private readonly destroyRef = inject(DestroyRef);\n\n  private readonly userId$ = this.route.paramMap.pipe(map((params) => params.get('id')));\n  readonly userId = toSignal(this.userId$, { initialValue: null });\n\n  readonly data$ = this.userId$.pipe(\n    switchMap((userId) => {\n      if (!userId)\n        return of({ profile: null, stats: null, cars: [], ownerReviews: [], renterReviews: [] });\n      return from(this.profileService.getProfileById(userId)).pipe(\n        switchMap((profile) => {\n          if (!profile)\n            return of({\n              profile: null,\n              stats: null,\n              cars: [],\n              ownerReviews: [],\n              renterReviews: [],\n            });\n          return from(this.reviewsService.getUserStats(userId)).pipe(\n            switchMap((stats) => {\n              return from(this.carsService.getCarsByOwner(userId)).pipe(\n                switchMap((cars) => {\n                  return from(this.reviewsService.getReviewsForOwner(userId)).pipe(\n                    switchMap((ownerReviews) => {\n                      return from(this.reviewsService.getReviewsForRenter(userId)).pipe(\n                        map((renterReviews) => ({\n                          profile,\n                          stats,\n                          cars,\n                          ownerReviews,\n                          renterReviews,\n                        })),\n                      );\n                    }),\n                  );\n                }),\n              );\n            }),\n          );\n        }),\n      );\n    }),\n    catchError(() =>\n      of({ profile: null, stats: null, cars: [], ownerReviews: [], renterReviews: [] }),\n    ),\n  );\n\n  readonly data = toSignal(this.data$, {\n    initialValue: { profile: null, stats: null, cars: [], ownerReviews: [], renterReviews: [] },\n  });\n\n  readonly profile = computed(() => this.data().profile);\n  readonly userStats = computed(() => this.data().stats);\n  readonly userCars = computed(() => this.data().cars);\n  readonly reviewsAsOwner = computed(() => this.data().ownerReviews);\n  readonly reviewsAsRenter = computed(() => this.data().renterReviews);\n\n  readonly loading = signal(true);\n  readonly error = signal<string>('');\n\n  activeTab = signal<'cars' | 'reviews-owner' | 'reviews-renter'>('cars');\n\n  hasOwnerReviews = computed(() => this.reviewsAsOwner().length > 0);\n  hasRenterReviews = computed(() => this.reviewsAsRenter().length > 0);\n  hasCars = computed(() => this.userCars().length > 0);\n\n  displayedCars = computed(() => this.userCars().slice(0, 6));\n  displayedReviewsOwner = computed(() => this.reviewsAsOwner().slice(0, 3));\n  displayedReviewsRenter = computed(() => this.reviewsAsRenter().slice(0, 3));\n\n  // Radar chart data\n  ownerRadarData = computed<RadarChartData | null>(() => {\n    const stats = this.userStats();\n    if (!stats || !stats.owner_reviews_count) return null;\n\n    return {\n      cleanliness: stats.owner_rating_cleanliness_avg || 0,\n      communication: stats.owner_rating_communication_avg || 0,\n      accuracy: stats.owner_rating_accuracy_avg || 0,\n      location: stats.owner_rating_location_avg || 0,\n      checkin: stats.owner_rating_checkin_avg || 0,\n      value: stats.owner_rating_value_avg || 0,\n    };\n  });\n\n  renterRadarData = computed<RadarChartData | null>(() => {\n    const stats = this.userStats();\n    if (!stats || !stats.renter_reviews_count) return null;\n\n    return {\n      cleanliness: stats.renter_rating_cleanliness_avg || 0,\n      communication: stats.renter_rating_communication_avg || 0,\n      accuracy: stats.renter_rating_accuracy_avg || 0,\n      location: 0, // Renters don't have location ratings typically\n      checkin: stats.renter_rating_checkin_avg || 0,\n      value: 0, // Renters don't have value ratings typically\n    };\n  });\n\n  averageCarPrice = computed(() => {\n    const cars = this.userCars();\n    if (cars.length === 0) return 0;\n    const total = cars.reduce((sum: number, car: Car) => sum + (car.price_per_day || 0), 0);\n    return Math.round(total / cars.length);\n  });\n\n  constructor() {}\n\n  ngOnInit(): void {\n    this.data$\n      .pipe(takeUntilDestroyed(this.destroyRef))\n      .subscribe(() => this.loading.set(false));\n  }\n\n  setActiveTab(tab: 'cars' | 'reviews-owner' | 'reviews-renter'): void {\n    this.activeTab.set(tab);\n  }\n\n  goBack(): void {\n    this.router.navigate(['/cars']);\n  }\n\n  formatMemberSince(date: string): string {\n    const d = new Date(date);\n    const months = [\n      'enero',\n      'febrero',\n      'marzo',\n      'abril',\n      'mayo',\n      'junio',\n      'julio',\n      'agosto',\n      'septiembre',\n      'octubre',\n      'noviembre',\n      'diciembre',\n    ];\n    return `${months[d.getMonth()]} ${d.getFullYear()}`;\n  }\n\n  getVerificationBadgeClass(): string {\n    if (this.profile()?.email_verified && this.profile()?.phone_verified) {\n      return 'bg-success-light/20 dark:bg-success-light/20 text-success-700 dark:text-success-strong border-success-light/40 dark:border-success-light/40';\n    }\n    return 'bg-ash-gray/20 dark:bg-surface-secondary/40 text-text-secondary dark:text-text-secondary/60 border-ash-gray/30 dark:border-slate-deep/60';\n  }\n\n  getRatingStars(rating: number): string[] {\n    const stars: string[] = [];\n    const fullStars = Math.floor(rating);\n    const hasHalfStar = rating % 1 >= 0.5;\n    for (let i = 0; i < fullStars; i++) stars.push('full');\n    if (hasHalfStar) stars.push('half');\n    while (stars.length < 5) stars.push('empty');\n    return stars;\n  }\n\n  getOverallRating(review: Review): number {\n    const ratings = [\n      review.rating_cleanliness,\n      review.rating_communication,\n      review.rating_accuracy,\n      review.rating_location,\n      review.rating_checkin,\n      review.rating_value,\n    ];\n    const sum = ratings.reduce((acc, r) => acc + r, 0);\n    return Math.round((sum / 6) * 10) / 10;\n  }\n\n  getCarPhotoUrl(car: Car): string {\n    const photos = car.photos || car.car_photos;\n    return getCarImageUrl(photos, {\n      brand: car.brand || car.brand_name,\n      model: car.model || car.model_name,\n      year: car.year,\n      id: car.id,\n    });\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/features/wallet/wallet.page.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`../../core/models/wallet.model` type import should occur after import of `@core/services/payments/withdrawal.service`","line":13,"column":1,"nodeType":"ImportDeclaration","endLine":13,"endColumn":101,"fix":{"range":[295,869],"text":"import { AnalyticsService } from '@core/services/infrastructure/analytics.service';\nimport { MetaService } from '@core/services/ui/meta.service';\nimport { NotificationManagerService } from '@core/services/infrastructure/notification-manager.service';\nimport { ProfileService } from '@core/services/auth/profile.service';\nimport { WalletService } from '@core/services/payments/wallet.service';\nimport { WithdrawalService } from '@core/services/payments/withdrawal.service';\nimport type { AddBankAccountParams, RequestWithdrawalParams } from '../../core/models/wallet.model';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { CommonModule } from '@angular/common';\nimport {AfterViewInit,\n  Component,\n  computed,\n  effect,\n  inject,\n  OnInit,\n  signal,\n  ViewChild,\n  ChangeDetectionStrategy} from '@angular/core';\nimport { Router } from '@angular/router';\nimport { TranslateModule } from '@ngx-translate/core';\nimport type { AddBankAccountParams, RequestWithdrawalParams } from '../../core/models/wallet.model';\nimport { AnalyticsService } from '@core/services/infrastructure/analytics.service';\nimport { MetaService } from '@core/services/ui/meta.service';\nimport { NotificationManagerService } from '@core/services/infrastructure/notification-manager.service';\nimport { ProfileService } from '@core/services/auth/profile.service';\nimport { WalletService } from '@core/services/payments/wallet.service';\nimport { WithdrawalService } from '@core/services/payments/withdrawal.service';\nimport { BankAccountFormComponent } from '../../shared/components/bank-account-form/bank-account-form.component';\nimport { BankAccountsListComponent } from '../../shared/components/bank-accounts-list/bank-accounts-list.component';\n\nimport { TransactionHistoryComponent } from '../../shared/components/transaction-history/transaction-history.component';\nimport { WalletBalanceCardComponent } from '../../shared/components/wallet-balance-card/wallet-balance-card.component';\nimport { WithdrawalHistoryComponent } from '../../shared/components/withdrawal-history/withdrawal-history.component';\nimport { WithdrawalRequestFormComponent } from '../../shared/components/withdrawal-request-form/withdrawal-request-form.component';\n\n/**\n * WalletPage\n *\n * Página principal del wallet del usuario.\n *\n * Integra componentes para:\n * - Balance y depósitos\n * - Cuentas bancarias\n * - Solicitudes de retiro\n * - Historial de transacciones\n *\n * Características:\n * - Layout responsivo con tabs\n * - Control del modal de depósito\n * - Gestión completa de retiros\n * - Info cards con tips de uso\n *\n * Ruta: /wallet\n */\nimport { GuaranteeOptionsInfoComponent } from '../../shared/components/guarantee-options-info/guarantee-options-info.component';\nimport { IconComponent } from '../../shared/components/icon/icon.component';\nimport { WalletAccountNumberCardComponent } from '../../shared/components/wallet-account-number-card/wallet-account-number-card.component';\nimport { WalletFaqComponent } from './components/wallet-faq.component';\nimport { WalletTransfersComponent } from './components/wallet-transfers.component';\n\n@Component({\n  selector: 'app-wallet',\n  standalone: true,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  imports: [\n    CommonModule,\n    WalletBalanceCardComponent,\n    TransactionHistoryComponent,\n    BankAccountFormComponent,\n    BankAccountsListComponent,\n    WithdrawalRequestFormComponent,\n    WithdrawalHistoryComponent,\n    TranslateModule,\n    WalletAccountNumberCardComponent,\n    GuaranteeOptionsInfoComponent,\n    WalletFaqComponent,\n    WalletTransfersComponent,\n    IconComponent,\n  ],\n  templateUrl: './wallet.page.html',\n  styleUrls: ['./wallet.page.css'],\n})\nexport class WalletPage implements AfterViewInit, OnInit {\n  /**\n   * Referencia al componente de balance card\n   */\n  @ViewChild('balanceCard') balanceCard?: WalletBalanceCardComponent;\n\n  /**\n   * Tab activa (transactions | withdrawals)\n   */\n  /**\n   * Tab activa (transactions | withdrawals)\n   */\n  activeTab = signal<'transactions' | 'withdrawals' | 'transfers'>('transactions');\n\n  /**\n   * Tabs definition for the view\n   */\n  readonly tabs = [\n    { id: 'transactions', label: 'Transacciones' },\n    { id: 'withdrawals', label: 'Retiros' },\n  ];\n\n  /**\n   * Modo de retiro (form | accounts)\n   */\n  withdrawalMode = signal<'form' | 'accounts'>('form');\n\n  /**\n   * Estado de carga\n   */\n  loading = computed(() => this.withdrawalService.loading());\n\n  /**\n   * Control de visibilidad del banner de onboarding\n   */\n  readonly onboardingBannerDismissed = signal(false);\n\n  /**\n   * Controla si ya se trackeó la vista del banner\n   */\n  private bannerViewTracked = false;\n\n  /**\n   * Control de expansión de la sección de beneficios\n   */\n  readonly benefitsSectionExpanded = signal(false);\n\n  private readonly walletService = inject(WalletService);\n  private readonly router = inject(Router);\n  private readonly profileService = inject(ProfileService);\n  private readonly toastService = inject(NotificationManagerService);\n  private readonly analyticsService = inject(AnalyticsService);\n\n  /**\n   * Wallet Account Number del usuario actual\n   */\n  readonly walletAccountNumber = signal<string | null>(null);\n\n  /**\n   * Estado de copiado del WAN\n   */\n  readonly copied = signal(false);\n\n  /**\n   * Error from wallet service (if any)\n   */\n  readonly walletError = computed(() => this.walletService.error());\n\n  /**\n   * Target de crédito protegido (USD 300 = 30000 centavos)\n   */\n  readonly protectedCreditTarget = 30000;\n\n  /**\n   * Balance disponible en el wallet\n   */\n  readonly availableBalanceSummary = this.walletService.availableBalance;\n\n  /**\n   * Fondos transferibles dentro de la app o a otros usuarios\n   */\n  readonly transferableBalance = this.walletService.transferableBalance;\n\n  /**\n   * Fondos retirables a cuenta bancaria externa (off-ramp)\n   */\n  readonly withdrawableBalance = this.walletService.withdrawableBalance;\n\n  /**\n   * Crédito Autorentar (meta inicial USD 300, no retirable)\n   */\n  readonly protectedCreditBalance = this.walletService.protectedCreditBalance;\n\n  /**\n   * Depósitos pendientes\n   */\n  readonly pendingDepositsCount = this.walletService.pendingDepositsCount;\n\n  /**\n   * Estado del crédito protegido (pending | partial | active)\n   */\n  readonly protectedCreditStatus = computed<'pending' | 'partial' | 'active'>(() => {\n    const protectedAmount = this.protectedCreditBalance();\n    if (protectedAmount >= this.protectedCreditTarget) {\n      return 'active';\n    }\n    if (protectedAmount > 0) {\n      return 'partial';\n    }\n    return 'pending';\n  });\n\n  /**\n   * Porcentaje de progreso hacia el crédito objetivo\n   */\n  readonly protectedCreditProgress = computed(() => {\n    const progress = (this.protectedCreditBalance() / this.protectedCreditTarget) * 100;\n    return Math.min(progress, 100);\n  });\n\n  /**\n   * Texto dinámico para el CTA principal de depósito\n   */\n  readonly primaryDepositCTAText = computed(() => {\n    const status = this.protectedCreditStatus();\n    const balance = this.protectedCreditBalance();\n\n    if (status === 'pending') {\n      return 'Configurar crédito protegido';\n    } else if (status === 'partial') {\n      const remaining = (this.protectedCreditTarget - balance) / 100;\n      return `Completar crédito (faltan USD ${remaining.toFixed(0)})`;\n    } else {\n      return 'Depositar fondos';\n    }\n  });\n\n  /**\n   * Tooltip/descripción para el CTA principal\n   */\n  readonly primaryDepositCTATooltip = computed(() => {\n    const status = this.protectedCreditStatus();\n\n    if (status === 'pending') {\n      return 'Deposita USD 300 para reservar sin tarjeta';\n    } else if (status === 'partial') {\n      return 'Completa tu crédito protegido para reservar sin tarjeta';\n    } else {\n      return 'Agregar fondos a tu wallet';\n    }\n  });\n\n  /**\n   * Clase CSS para el CTA principal (cambia color según urgencia)\n   */\n  readonly primaryDepositCTAClass = computed(() => {\n    const status = this.protectedCreditStatus();\n\n    if (status === 'pending') {\n      return 'bg-cta-default text-cta-text hover:bg-cta-default/90';\n    } else if (status === 'partial') {\n      return 'bg-warning-600 text-text-inverse hover:bg-warning-700';\n    } else {\n      return 'bg-primary-600 text-text-inverse hover:bg-primary-700';\n    }\n  });\n\n  constructor(\n    private withdrawalService: WithdrawalService,\n    private metaService: MetaService,\n  ) {\n    // Update SEO meta tags (private page)\n    this.metaService.updateWalletMeta();\n\n    // Track wallet page view\n    this.analyticsService.trackEvent('wallet_page_viewed', {\n      protected_credit_balance: this.protectedCreditBalance(),\n      protected_credit_progress: this.protectedCreditProgress(),\n    });\n\n    // Track onboarding banner view (only once per session)\n    effect(() => {\n      if (\n        this.protectedCreditStatus() === 'pending' &&\n        !this.onboardingBannerDismissed() &&\n        !this.bannerViewTracked\n      ) {\n        this.analyticsService.trackEvent('wallet_onboarding_banner_viewed', {\n          protected_credit_balance: this.protectedCreditBalance(),\n        });\n        this.bannerViewTracked = true;\n      }\n    });\n\n    // Cargar datos al iniciar (en paralelo para mejor performance)\n    void Promise.all([this.loadWithdrawalData(), this.loadWalletAccountNumber()]);\n  }\n\n  async ngOnInit(): Promise<void> {\n    try {\n      await this.walletService.refreshPendingDepositsCount();\n    } catch {\n      /* Silenced */\n    }\n  }\n\n  /**\n   * Configura el balance card después de que la vista se inicialice\n   */\n  ngAfterViewInit(): void {\n    if (this.balanceCard) {\n      this.balanceCard.setDepositClickHandler(() => this.navigateToDeposit());\n    }\n  }\n\n  /**\n   * Navega a la página de depósito\n   */\n  navigateToDeposit(amount?: number): void {\n    if (amount) {\n      void this.router.navigate(['/wallet/deposit'], { queryParams: { amount } });\n    } else {\n      void this.router.navigate(['/wallet/deposit']);\n    }\n  }\n\n  /**\n   * Navega a la página de depósito (alias para compatibilidad)\n   */\n  openDepositModal(amount?: number): void {\n    this.navigateToDeposit(amount);\n  }\n\n  /**\n   * Navega a la página de depósito con analytics para crédito protegido\n   */\n  openDepositModalForProtectedCredit(): void {\n    // Track analytics event\n    this.analyticsService.trackEvent('wallet_onboarding_cta_clicked', {\n      protected_credit_balance: this.protectedCreditBalance(),\n      protected_credit_progress: this.protectedCreditProgress(),\n    });\n\n    // Navigate to deposit page\n    this.navigateToDeposit();\n  }\n\n  /**\n   * Dismiss the onboarding banner\n   */\n  dismissOnboardingBanner(): void {\n    this.onboardingBannerDismissed.set(true);\n\n    // Track dismissal\n    this.analyticsService.trackEvent('wallet_onboarding_banner_viewed', {\n      protected_credit_balance: this.protectedCreditBalance(),\n      action: 'dismissed',\n    });\n  }\n\n  /**\n   * Toggle benefits section expansion\n   */\n  toggleBenefitsSection(): void {\n    const newState = !this.benefitsSectionExpanded();\n    this.benefitsSectionExpanded.set(newState);\n\n    // Track expansion\n    if (newState) {\n      this.analyticsService.trackEvent('wallet_benefits_section_expanded', {\n        protected_credit_status: this.protectedCreditStatus(),\n        protected_credit_balance: this.protectedCreditBalance(),\n      });\n    }\n  }\n\n  /**\n   * Cambia el tab activo\n   */\n  setActiveTab(tab: 'transactions' | 'withdrawals' | 'transfers'): void {\n    this.activeTab.set(tab);\n  }\n\n  /**\n   * Cambia el modo de retiro\n   */\n  setWithdrawalMode(mode: 'form' | 'accounts'): void {\n    this.withdrawalMode.set(mode);\n  }\n\n  /**\n   * Refresh manual del balance y depósitos pendientes\n   */\n  async refreshWalletData(): Promise<void> {\n    try {\n      const balanceRefresh = this.balanceCard ? this.balanceCard.loadBalance() : Promise.resolve();\n      await Promise.all([balanceRefresh, this.walletService.refreshPendingDepositsCount()]);\n    } catch {\n      /* Silenced */\n    }\n  }\n\n  /**\n   * Carga los datos de retiro (cuentas bancarias y solicitudes)\n   */\n  private async loadWithdrawalData(): Promise<void> {\n    try {\n      await Promise.all([\n        this.withdrawalService.getBankAccounts(),\n        this.withdrawalService.getWithdrawalRequests(),\n      ]);\n    } catch {\n      /* Silenced */\n    }\n  }\n\n  /**\n   * Maneja la creación de una cuenta bancaria\n   */\n  async handleAddBankAccount(params: AddBankAccountParams): Promise<void> {\n    try {\n      await this.withdrawalService.addBankAccount(params);\n      this.toastService.success('Éxito', 'Cuenta bancaria agregada exitosamente');\n      this.setWithdrawalMode('form');\n    } catch (error: unknown) {\n      const errorObj = error as { message?: string };\n      this.toastService.error(\n        'Error',\n        'Error al agregar cuenta bancaria: ' + (errorObj.message || 'Error desconocido'),\n      );\n    }\n  }\n\n  /**\n   * Maneja la solicitud de retiro\n   */\n  async handleWithdrawalRequest(params: RequestWithdrawalParams): Promise<void> {\n    try {\n      const result = await this.withdrawalService.requestWithdrawal(params);\n      if (result.success) {\n        this.toastService.success(\n          'Éxito',\n          `Retiro solicitado exitosamente! Monto: $${params.amount}, Comisión: $${result.fee_amount}, Neto: $${result.net_amount}`,\n        );\n        // Recargar historial\n        await this.withdrawalService.getWithdrawalRequests();\n      } else {\n        this.toastService.error('Error', 'Error: ' + result.message);\n      }\n    } catch (error: unknown) {\n      const errorObj = error as { message?: string };\n      this.toastService.error(\n        'Error',\n        'Error al solicitar retiro: ' + (errorObj.message || 'Error desconocido'),\n      );\n    }\n  }\n\n  /**\n   * Maneja el cambio de cuenta por defecto\n   */\n  async handleSetDefaultAccount(accountId: string): Promise<void> {\n    try {\n      await this.withdrawalService.setDefaultBankAccount(accountId);\n      this.toastService.success('Éxito', 'Cuenta establecida como predeterminada');\n    } catch (error: unknown) {\n      const errorObj = error as { message?: string };\n      this.toastService.error('Error', 'Error: ' + (errorObj.message || 'Error desconocido'));\n    }\n  }\n\n  /**\n   * Maneja la eliminación de cuenta bancaria\n   */\n  async handleDeleteAccount(accountId: string): Promise<void> {\n    try {\n      await this.withdrawalService.deleteBankAccount(accountId);\n      this.toastService.success('Éxito', 'Cuenta eliminada exitosamente');\n    } catch (error: unknown) {\n      const errorObj = error as { message?: string };\n      this.toastService.error(\n        'Error',\n        'Error al eliminar cuenta: ' + (errorObj.message || 'Error desconocido'),\n      );\n    }\n  }\n\n  /**\n   * Maneja la cancelación de solicitud de retiro\n   */\n  async handleCancelWithdrawal(requestId: string): Promise<void> {\n    try {\n      await this.withdrawalService.cancelWithdrawalRequest(requestId);\n      this.toastService.success('Éxito', 'Solicitud de retiro cancelada');\n    } catch (error: unknown) {\n      const errorObj = error as { message?: string };\n      this.toastService.error(\n        'Error',\n        'Error al cancelar: ' + (errorObj.message || 'Error desconocido'),\n      );\n    }\n  }\n\n  /**\n   * Recarga el historial de retiros\n   */\n  async handleRefreshWithdrawals(): Promise<void> {\n    try {\n      await this.withdrawalService.getWithdrawalRequests();\n    } catch {\n      /* Silenced */\n    }\n  }\n\n  /**\n   * Obtiene las cuentas bancarias\n   */\n  get bankAccounts() {\n    return this.withdrawalService.bankAccounts;\n  }\n\n  /**\n   * Obtiene las cuentas bancarias activas\n   */\n  get activeBankAccounts() {\n    return this.withdrawalService.activeBankAccounts;\n  }\n\n  /**\n   * Obtiene la cuenta bancaria por defecto\n   */\n  get defaultBankAccount() {\n    return this.withdrawalService.defaultBankAccount;\n  }\n\n  /**\n   * Obtiene las solicitudes de retiro\n   */\n  get withdrawalRequests() {\n    return this.withdrawalService.withdrawalRequests;\n  }\n\n  /**\n   * Carga el Wallet Account Number del usuario actual\n   */\n  private async loadWalletAccountNumber(): Promise<void> {\n    try {\n      const profile = await this.profileService.getCurrentProfile();\n      if (profile?.wallet_account_number) {\n        this.walletAccountNumber.set(profile.wallet_account_number);\n      }\n    } catch {\n      /* Silenced */\n    }\n  }\n\n  /**\n   * Navega a la página de transferencias\n   */\n  goToTransfer(): void {\n    void this.router.navigate(['/wallet/transfer']);\n  }\n\n  /**\n   * Copia el Wallet Account Number al portapapeles\n   */\n  async copyWalletAccountNumber(): Promise<void> {\n    const wan = this.walletAccountNumber();\n    if (!wan) return;\n\n    try {\n      await navigator.clipboard.writeText(wan);\n      this.copied.set(true);\n\n      // Reset copied state after 2 seconds\n      setTimeout(() => {\n        this.copied.set(false);\n      }, 2000);\n    } catch {\n      this.toastService.error('Error', 'Error al copiar el número de cuenta');\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/shared/components/ai-checklist-panel/ai-checklist-panel.component.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`@core/services/ai/gemini.service` import should occur before type import of `../../../core/models`","line":13,"column":1,"nodeType":"ImportDeclaration","endLine":13,"endColumn":66,"fix":{"range":[180,322],"text":"import { GeminiService } from '@core/services/ai/gemini.service';\nimport type { Booking, Car, VehicleChecklist } from '../../../core/models';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import {\n  ChangeDetectionStrategy,\n  Component,\n  computed,\n  effect,\n  inject,\n  input,\n  output,\n  signal,\n} from '@angular/core';\nimport { FormsModule } from '@angular/forms';\nimport type { Booking, Car, VehicleChecklist } from '../../../core/models';\nimport { GeminiService } from '@core/services/ai/gemini.service';\n\n/**\n * Panel de Checklist de Inspeccion IA\n *\n * Genera un checklist de inspeccion personalizado para el vehiculo\n * especifico del booking, considerando marca, modelo y ano.\n *\n * @example\n * ```html\n * <app-ai-checklist-panel\n *   [booking]=\"booking()\"\n *   [inspectionType]=\"'check_in'\"\n *   [isExpanded]=\"expandedPanel() === 'checklist'\"\n *   (togglePanel)=\"togglePanel('checklist')\"\n * />\n * ```\n */\n@Component({\n  selector: 'app-ai-checklist-panel',\n  standalone: true,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  imports: [FormsModule],\n  template: `\n    <div class=\"relative group/panel\">\n      <!-- Animated gradient border when expanded -->\n      @if (isExpanded()) {\n        <div class=\"absolute -inset-0.5 bg-gradient-to-r from-cyan-500 via-teal-500 to-emerald-500 rounded-2xl opacity-75 blur-sm transition-opacity duration-500 animate-gradient-xy\"></div>\n      }\n\n      <!-- Main card -->\n      <div\n        class=\"relative bg-white dark:bg-gray-900 rounded-2xl shadow-lg overflow-hidden transition-all duration-300\"\n        [class.shadow-2xl]=\"isExpanded()\"\n      >\n        <!-- Header -->\n        <button\n          type=\"button\"\n          class=\"flex w-full items-center justify-between p-4 text-left transition-colors hover:bg-gray-50 dark:hover:bg-gray-800/50\"\n          (click)=\"togglePanel.emit()\"\n        >\n          <div class=\"flex items-center gap-3\">\n            <!-- Icon with glow -->\n            <div class=\"relative\">\n              @if (isExpanded()) {\n                <div class=\"absolute inset-0 bg-teal-500/30 rounded-xl blur-md animate-pulse\"></div>\n              }\n              <div\n                class=\"relative flex h-10 w-10 items-center justify-center rounded-xl transition-all duration-300\"\n                [class.bg-gradient-to-br]=\"isExpanded()\"\n                [class.from-cyan-500]=\"isExpanded()\"\n                [class.to-teal-500]=\"isExpanded()\"\n                [class.bg-teal-500/10]=\"!isExpanded()\"\n                [class.shadow-lg]=\"isExpanded()\"\n              >\n                <svg\n                  class=\"h-5 w-5 transition-colors\"\n                  [class.text-white]=\"isExpanded()\"\n                  [class.text-teal-500]=\"!isExpanded()\"\n                  fill=\"none\"\n                  stroke=\"currentColor\"\n                  viewBox=\"0 0 24 24\"\n                >\n                  <path\n                    stroke-linecap=\"round\"\n                    stroke-linejoin=\"round\"\n                    stroke-width=\"2\"\n                    d=\"M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4\"\n                  />\n                </svg>\n              </div>\n            </div>\n            <div>\n              <h3 class=\"text-sm font-bold text-gray-900 dark:text-white flex items-center gap-2\">\n                Checklist de {{ inspectionType() === 'check_in' ? 'Recepcion' : 'Devolucion' }}\n                <span class=\"text-[10px] bg-gradient-to-r from-cyan-500 to-teal-500 text-white px-2 py-0.5 rounded-full font-bold uppercase tracking-wider\">\n                  AI\n                </span>\n              </h3>\n              <p class=\"text-xs text-gray-500 dark:text-gray-400\">Inspeccion personalizada para {{ vehicleName() }}</p>\n            </div>\n          </div>\n          <div class=\"flex items-center gap-2\">\n            <!-- Mini progress when collapsed -->\n            @if (!isExpanded() && checklist()) {\n              <div class=\"flex items-center gap-1.5 mr-2\">\n                <div class=\"w-16 h-1.5 bg-gray-200 dark:bg-gray-700 rounded-full overflow-hidden\">\n                  <div\n                    class=\"h-full bg-gradient-to-r from-cyan-500 to-teal-500 rounded-full transition-all duration-500\"\n                    [style.width.%]=\"totalCount() > 0 ? (completedCount() / totalCount()) * 100 : 0\"\n                  ></div>\n                </div>\n                <span class=\"text-[10px] font-medium text-gray-500\">{{ completedCount() }}/{{ totalCount() }}</span>\n              </div>\n            }\n            <svg\n              class=\"h-5 w-5 text-gray-400 transition-transform duration-300\"\n              [class.rotate-180]=\"isExpanded()\"\n              fill=\"none\"\n              stroke=\"currentColor\"\n              viewBox=\"0 0 24 24\"\n            >\n              <path\n                stroke-linecap=\"round\"\n                stroke-linejoin=\"round\"\n                stroke-width=\"2\"\n                d=\"M19 9l-7 7-7-7\"\n              />\n            </svg>\n          </div>\n        </button>\n\n        <!-- Content -->\n        <div\n          class=\"overflow-hidden transition-all duration-300\"\n          [class.max-h-0]=\"!isExpanded()\"\n          [class.max-h-[800px]]=\"isExpanded()\"\n          [class.overflow-y-auto]=\"isExpanded()\"\n        >\n          <!-- Top gradient line -->\n          <div class=\"h-1 bg-gradient-to-r from-cyan-500 via-teal-500 to-emerald-500\"></div>\n\n          <div class=\"space-y-4 p-5\">\n            <!-- Loading -->\n            @if (loading()) {\n              <div class=\"flex flex-col items-center justify-center py-10\">\n                <div class=\"relative\">\n                  <div class=\"w-12 h-12 border-3 border-teal-200 border-t-teal-500 rounded-full animate-spin\"></div>\n                  <div class=\"absolute inset-0 w-12 h-12 border-3 border-transparent border-b-cyan-500 rounded-full animate-spin\" style=\"animation-direction: reverse; animation-duration: 1.5s;\"></div>\n                </div>\n                <p class=\"mt-4 text-sm font-medium text-gray-700 dark:text-gray-300\">\n                  Generando checklist personalizado...\n                </p>\n                <p class=\"text-xs text-gray-500 dark:text-gray-400 mt-1\">\n                  Analizando {{ vehicleName() }}\n                </p>\n              </div>\n            }\n\n            <!-- Checklist -->\n            @if (checklist()) {\n              <div class=\"space-y-4\">\n                <!-- Progress Card -->\n                <div class=\"relative overflow-hidden bg-gradient-to-br from-cyan-50 to-teal-50 dark:from-cyan-900/20 dark:to-teal-900/20 rounded-xl p-4 border border-teal-200/50 dark:border-teal-700/30\">\n                  <div class=\"flex items-center justify-between mb-3\">\n                    <div class=\"flex items-center gap-2\">\n                      <div class=\"w-8 h-8 bg-gradient-to-br from-cyan-500 to-teal-500 rounded-lg flex items-center justify-center\">\n                        <svg class=\"w-4 h-4 text-white\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                          <path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z\" />\n                        </svg>\n                      </div>\n                      <div>\n                        <span class=\"text-sm font-bold text-gray-900 dark:text-white\">\n                          {{ completedCount() }} de {{ totalCount() }}\n                        </span>\n                        <span class=\"text-xs text-gray-500 dark:text-gray-400 ml-1\">verificados</span>\n                      </div>\n                    </div>\n                    <button\n                      type=\"button\"\n                      class=\"text-xs text-teal-600 hover:text-teal-700 dark:text-teal-400 font-medium flex items-center gap-1 hover:underline\"\n                      (click)=\"regenerate()\"\n                    >\n                      <svg class=\"w-3.5 h-3.5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                        <path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15\" />\n                      </svg>\n                      Regenerar\n                    </button>\n                  </div>\n                  <!-- Animated progress bar -->\n                  <div class=\"h-3 bg-white/50 dark:bg-gray-800/50 rounded-full overflow-hidden\">\n                    <div\n                      class=\"h-full bg-gradient-to-r from-cyan-500 via-teal-500 to-emerald-500 rounded-full transition-all duration-700 ease-out relative overflow-hidden\"\n                      [style.width.%]=\"totalCount() > 0 ? (completedCount() / totalCount()) * 100 : 0\"\n                    >\n                      <div class=\"absolute inset-0 bg-gradient-to-r from-white/0 via-white/30 to-white/0 animate-shimmer\"></div>\n                    </div>\n                  </div>\n                  @if (completedCount() === totalCount() && totalCount() > 0) {\n                    <div class=\"mt-2 flex items-center gap-1.5 text-emerald-600 dark:text-emerald-400\">\n                      <svg class=\"w-4 h-4\" fill=\"currentColor\" viewBox=\"0 0 24 24\">\n                        <path d=\"M12 2l2.4 7.4h7.6l-6 4.6 2.3 7-6.3-4.6-6.3 4.6 2.3-7-6-4.6h7.6z\"/>\n                      </svg>\n                      <span class=\"text-xs font-bold\">Inspeccion completa!</span>\n                    </div>\n                  }\n                </div>\n\n                <!-- Categories -->\n                @for (category of checklist()!.categories; track category.name; let i = $index) {\n                  <div class=\"rounded-xl border border-gray-200 dark:border-gray-700 overflow-hidden shadow-sm\">\n                    <div class=\"flex items-center justify-between bg-gray-50 dark:bg-gray-800/50 px-4 py-3 border-b border-gray-200 dark:border-gray-700\">\n                      <div class=\"flex items-center gap-2\">\n                        <div\n                          class=\"w-6 h-6 rounded-lg flex items-center justify-center text-white text-xs font-bold\"\n                          [class.bg-gradient-to-br]=\"true\"\n                          [class.from-cyan-500]=\"i % 3 === 0\"\n                          [class.to-teal-500]=\"i % 3 === 0\"\n                          [class.from-teal-500]=\"i % 3 === 1\"\n                          [class.to-emerald-500]=\"i % 3 === 1\"\n                          [class.from-emerald-500]=\"i % 3 === 2\"\n                          [class.to-cyan-500]=\"i % 3 === 2\"\n                        >\n                          {{ i + 1 }}\n                        </div>\n                        <span class=\"text-sm font-bold text-gray-900 dark:text-white\">{{ category.name }}</span>\n                      </div>\n                      <div class=\"flex items-center gap-2\">\n                        <div class=\"w-12 h-1.5 bg-gray-200 dark:bg-gray-600 rounded-full overflow-hidden\">\n                          <div\n                            class=\"h-full bg-gradient-to-r from-cyan-500 to-teal-500 rounded-full transition-all duration-500\"\n                            [style.width.%]=\"category.items.length > 0 ? (getCategoryCompletedCount(category.name) / category.items.length) * 100 : 0\"\n                          ></div>\n                        </div>\n                        <span class=\"text-xs font-medium text-gray-500 dark:text-gray-400\">\n                          {{ getCategoryCompletedCount(category.name) }}/{{ category.items.length }}\n                        </span>\n                      </div>\n                    </div>\n                    <div class=\"divide-y divide-gray-100 dark:divide-gray-800\">\n                      @for (item of category.items; track item.id) {\n                        <label\n                          [for]=\"'checklist-item-' + item.id\"\n                          class=\"flex cursor-pointer items-start gap-3 p-4 transition-all duration-200 hover:bg-gray-50 dark:hover:bg-gray-800/30\"\n                          [class.bg-emerald-50/50]=\"checkedItems()[item.id]\"\n                          [class.dark:bg-emerald-900/10]=\"checkedItems()[item.id]\"\n                        >\n                          <div class=\"relative mt-0.5\">\n                            <input\n                              type=\"checkbox\"\n                              [id]=\"'checklist-item-' + item.id\"\n                              [name]=\"'checklist-item-' + item.id\"\n                              [checked]=\"checkedItems()[item.id]\"\n                              (change)=\"toggleItem(item.id)\"\n                              class=\"peer sr-only\"\n                            />\n                            <div\n                              class=\"w-5 h-5 border-2 rounded-md transition-all duration-200 flex items-center justify-center\"\n                              [class.border-gray-300]=\"!checkedItems()[item.id]\"\n                              [class.dark:border-gray-600]=\"!checkedItems()[item.id]\"\n                              [class.border-emerald-500]=\"checkedItems()[item.id]\"\n                              [class.bg-emerald-500]=\"checkedItems()[item.id]\"\n                            >\n                              @if (checkedItems()[item.id]) {\n                                <svg class=\"w-3 h-3 text-white\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                                  <path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"3\" d=\"M5 13l4 4L19 7\" />\n                                </svg>\n                              }\n                            </div>\n                          </div>\n                          <div class=\"flex-1 min-w-0\">\n                            <div class=\"flex items-center gap-2 flex-wrap\">\n                              <span\n                                class=\"text-sm transition-all duration-200\"\n                                [class.text-gray-900]=\"!checkedItems()[item.id]\"\n                                [class.dark:text-white]=\"!checkedItems()[item.id]\"\n                                [class.text-gray-400]=\"checkedItems()[item.id]\"\n                                [class.dark:text-gray-500]=\"checkedItems()[item.id]\"\n                                [class.line-through]=\"checkedItems()[item.id]\"\n                              >\n                                {{ item.label }}\n                              </span>\n                              @if (item.critical) {\n                                <span class=\"inline-flex items-center gap-1 rounded-full bg-red-100 dark:bg-red-900/30 px-2 py-0.5 text-[10px] font-bold text-red-700 dark:text-red-400 uppercase\">\n                                  <svg class=\"w-3 h-3\" fill=\"currentColor\" viewBox=\"0 0 24 24\">\n                                    <path d=\"M12 2L2 22h20L12 2zm0 4l7.53 14H4.47L12 6zm-1 6v4h2v-4h-2zm0 6v2h2v-2h-2z\"/>\n                                  </svg>\n                                  Critico\n                                </span>\n                              }\n                              @if (item.modelSpecific) {\n                                <span class=\"inline-flex items-center gap-1 rounded-full bg-blue-100 dark:bg-blue-900/30 px-2 py-0.5 text-[10px] font-bold text-blue-700 dark:text-blue-400 uppercase\">\n                                  <svg class=\"w-3 h-3\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                                    <path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M13 10V3L4 14h7v7l9-11h-7z\" />\n                                  </svg>\n                                  Modelo\n                                </span>\n                              }\n                            </div>\n                            @if (item.description) {\n                              <p class=\"mt-1 text-xs text-gray-500 dark:text-gray-400\">{{ item.description }}</p>\n                            }\n                          </div>\n                        </label>\n                      }\n                    </div>\n                  </div>\n                }\n\n                <!-- Tips -->\n                @if (checklist()!.tips.length > 0) {\n                  <div class=\"relative overflow-hidden rounded-xl bg-gradient-to-br from-amber-50 to-yellow-50 dark:from-amber-900/20 dark:to-yellow-900/20 p-4 border border-amber-200/50 dark:border-amber-700/30\">\n                    <div class=\"absolute top-2 right-2 w-8 h-8 opacity-20\">\n                      <svg fill=\"currentColor\" class=\"text-amber-500\" viewBox=\"0 0 24 24\">\n                        <path d=\"M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z\"/>\n                      </svg>\n                    </div>\n                    <div class=\"flex items-center gap-2 mb-3\">\n                      <div class=\"w-7 h-7 bg-gradient-to-br from-amber-400 to-yellow-500 rounded-lg flex items-center justify-center\">\n                        <svg class=\"w-4 h-4 text-white\" fill=\"currentColor\" viewBox=\"0 0 24 24\">\n                          <path d=\"M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z\"/>\n                        </svg>\n                      </div>\n                      <h4 class=\"text-sm font-bold text-amber-800 dark:text-amber-300\">\n                        Tips para {{ vehicleName() }}\n                      </h4>\n                    </div>\n                    <ul class=\"space-y-2\">\n                      @for (tip of checklist()!.tips; track tip) {\n                        <li class=\"flex items-start gap-2 text-xs text-amber-800 dark:text-amber-300\">\n                          <svg class=\"w-4 h-4 text-amber-500 flex-shrink-0 mt-0.5\" fill=\"currentColor\" viewBox=\"0 0 24 24\">\n                            <path d=\"M12 2l2.4 7.4h7.6l-6 4.6 2.3 7-6.3-4.6-6.3 4.6 2.3-7-6-4.6h7.6z\"/>\n                          </svg>\n                          {{ tip }}\n                        </li>\n                      }\n                    </ul>\n                  </div>\n                }\n              </div>\n            }\n\n            <!-- Error -->\n            @if (error()) {\n              <div class=\"space-y-4\">\n                <div class=\"flex flex-col items-center py-6\">\n                  <div class=\"w-14 h-14 bg-red-50 dark:bg-red-900/20 rounded-full flex items-center justify-center mb-3 ring-4 ring-red-100 dark:ring-red-900/30\">\n                    <svg class=\"w-7 h-7 text-red-500\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                      <path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z\" />\n                    </svg>\n                  </div>\n                  <p class=\"text-sm font-medium text-red-600 dark:text-red-400 text-center mb-4\">\n                    {{ error() }}\n                  </p>\n                  <button\n                    type=\"button\"\n                    class=\"relative overflow-hidden bg-gradient-to-r from-cyan-500 to-teal-500 hover:from-cyan-600 hover:to-teal-600 text-white font-bold py-2.5 px-6 rounded-xl text-sm transition-all duration-300 shadow-lg hover:shadow-teal-500/25 flex items-center gap-2\"\n                    (click)=\"generateChecklist()\"\n                  >\n                    <svg class=\"w-4 h-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                      <path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15\" />\n                    </svg>\n                    Reintentar\n                  </button>\n                </div>\n              </div>\n            }\n          </div>\n        </div>\n      </div>\n    </div>\n  `,\n  styles: [`\n    :host { display: block; }\n\n    @keyframes gradient-xy {\n      0%, 100% { background-position: 0% 50%; }\n      50% { background-position: 100% 50%; }\n    }\n\n    @keyframes shimmer {\n      0% { transform: translateX(-100%); }\n      100% { transform: translateX(100%); }\n    }\n\n    .animate-gradient-xy {\n      animation: gradient-xy 3s ease infinite;\n      background-size: 200% 200%;\n    }\n\n    .animate-shimmer {\n      animation: shimmer 2s ease-in-out infinite;\n    }\n  `],\n})\nexport class AiChecklistPanelComponent {\n  private readonly gemini = inject(GeminiService);\n\n  /** Booking (opcional si se provee car) */\n  readonly booking = input<Booking | null>(null);\n\n  /** Car directo (opcional si se provee booking) */\n  readonly car = input<Car | null>(null);\n\n  readonly inspectionType = input<'check_in' | 'check_out'>('check_in');\n  readonly isExpanded = input<boolean>(false);\n  readonly togglePanel = output<void>();\n\n  // State\n  readonly checklist = signal<VehicleChecklist | null>(null);\n  readonly loading = signal(false);\n  readonly error = signal<string | null>(null);\n  readonly checkedItems = signal<Record<string, boolean>>({});\n\n  // Computed: obtiene datos del vehiculo desde car o booking\n  private readonly vehicleData = computed(() => {\n    const c = this.car();\n    const b = this.booking();\n    return {\n      brand: c?.brand || b?.car_brand || b?.car?.brand || 'Auto',\n      model: c?.model || b?.car_model || b?.car?.model || '',\n      year: c?.year || b?.car_year || b?.car?.year || new Date().getFullYear(),\n    };\n  });\n\n  readonly vehicleName = computed(() => {\n    const v = this.vehicleData();\n    return `${v.brand} ${v.model} ${v.year}`.trim() || 'Vehiculo';\n  });\n\n  readonly totalCount = () => {\n    const c = this.checklist();\n    if (!c) return 0;\n    return c.categories.reduce((sum, cat) => sum + cat.items.length, 0);\n  };\n\n  readonly completedCount = () => {\n    return Object.values(this.checkedItems()).filter(Boolean).length;\n  };\n\n  getCategoryCompletedCount(categoryName: string): number {\n    const c = this.checklist();\n    if (!c) return 0;\n    const category = c.categories.find((cat) => cat.name === categoryName);\n    if (!category) return 0;\n    return category.items.filter((item) => this.checkedItems()[item.id]).length;\n  }\n\n  constructor() {\n    // Auto-generate when expanded and no checklist\n    effect(() => {\n      if (this.isExpanded() && !this.checklist() && !this.loading() && !this.error()) {\n        this.generateChecklist();\n      }\n    });\n  }\n\n  toggleItem(itemId: string): void {\n    this.checkedItems.update((items) => ({\n      ...items,\n      [itemId]: !items[itemId],\n    }));\n  }\n\n  regenerate(): void {\n    this.checklist.set(null);\n    this.checkedItems.set({});\n    this.generateChecklist();\n  }\n\n  async generateChecklist(): Promise<void> {\n    this.loading.set(true);\n    this.error.set(null);\n\n    try {\n      const v = this.vehicleData();\n\n      const result = await this.gemini.generateVehicleChecklist({\n        brand: v.brand,\n        model: v.model,\n        year: v.year,\n        inspectionType: this.inspectionType(),\n      });\n\n      this.checklist.set(result);\n    } catch {\n      this.error.set('No pudimos generar el checklist. Intenta de nuevo.');\n    } finally {\n      this.loading.set(false);\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/shared/components/ai-legal-panel/ai-legal-panel.component.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`@core/services/ai/gemini.service` import should occur before type import of `../../../core/models`","line":12,"column":1,"nodeType":"ImportDeclaration","endLine":12,"endColumn":66,"fix":{"range":[170,334],"text":"import { GeminiService } from '@core/services/ai/gemini.service';\nimport type { Booking, BookingTerms, Car, LegalAnswer, VehicleInfo } from '../../../core/models';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import {\n  ChangeDetectionStrategy,\n  Component,\n  computed,\n  inject,\n  input,\n  output,\n  signal,\n} from '@angular/core';\nimport { FormsModule } from '@angular/forms';\nimport type { Booking, BookingTerms, Car, LegalAnswer, VehicleInfo } from '../../../core/models';\nimport { GeminiService } from '@core/services/ai/gemini.service';\n\n/**\n * Panel de Asistente Legal IA\n *\n * Permite a los usuarios hacer preguntas sobre los terminos del alquiler.\n * Usa Google Gemini para generar respuestas basadas en el contexto.\n *\n * @example\n * ```html\n * <app-ai-legal-panel\n *   [booking]=\"booking()\"\n *   [isExpanded]=\"expandedPanel() === 'legal'\"\n *   (togglePanel)=\"togglePanel('legal')\"\n * />\n * ```\n */\n@Component({\n  selector: 'app-ai-legal-panel',\n  standalone: true,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  imports: [FormsModule],\n  template: `\n    <div class=\"relative group/panel\">\n      <!-- Animated gradient border when expanded -->\n      @if (isExpanded()) {\n        <div class=\"absolute -inset-0.5 bg-gradient-to-r from-blue-500 via-indigo-500 to-purple-500 rounded-2xl opacity-75 blur-sm transition-opacity duration-500 animate-gradient-xy\"></div>\n      }\n\n      <!-- Main card -->\n      <div\n        class=\"relative bg-white dark:bg-gray-900 rounded-2xl shadow-lg overflow-hidden transition-all duration-300\"\n        [class.shadow-2xl]=\"isExpanded()\"\n      >\n        <!-- Header -->\n        <button\n          type=\"button\"\n          class=\"flex w-full items-center justify-between p-4 text-left transition-colors hover:bg-gray-50 dark:hover:bg-gray-800/50\"\n          (click)=\"togglePanel.emit()\"\n        >\n          <div class=\"flex items-center gap-3\">\n            <!-- Icon with glow -->\n            <div class=\"relative\">\n              @if (isExpanded()) {\n                <div class=\"absolute inset-0 bg-indigo-500/30 rounded-xl blur-md animate-pulse\"></div>\n              }\n              <div\n                class=\"relative flex h-10 w-10 items-center justify-center rounded-xl transition-all duration-300\"\n                [class.bg-gradient-to-br]=\"isExpanded()\"\n                [class.from-blue-500]=\"isExpanded()\"\n                [class.to-indigo-600]=\"isExpanded()\"\n                [class.bg-indigo-500/10]=\"!isExpanded()\"\n                [class.shadow-lg]=\"isExpanded()\"\n              >\n                <svg\n                  class=\"h-5 w-5 transition-colors\"\n                  [class.text-white]=\"isExpanded()\"\n                  [class.text-indigo-500]=\"!isExpanded()\"\n                  fill=\"none\"\n                  stroke=\"currentColor\"\n                  viewBox=\"0 0 24 24\"\n                >\n                  <path\n                    stroke-linecap=\"round\"\n                    stroke-linejoin=\"round\"\n                    stroke-width=\"2\"\n                    d=\"M3 6l3 1m0 0l-3 9a5.002 5.002 0 006.001 0M6 7l3 9M6 7l6-2m6 2l3-1m-3 1l-3 9a5.002 5.002 0 006.001 0M18 7l3 9m-3-9l-6-2m0-2v2m0 16V5m0 16H9m3 0h3\"\n                  />\n                </svg>\n              </div>\n            </div>\n            <div>\n              <h3 class=\"text-sm font-bold text-gray-900 dark:text-white flex items-center gap-2\">\n                Asistente Legal\n                <span class=\"text-[10px] bg-gradient-to-r from-blue-500 to-indigo-500 text-white px-2 py-0.5 rounded-full font-bold uppercase tracking-wider\">\n                  AI\n                </span>\n              </h3>\n              <p class=\"text-xs text-gray-500 dark:text-gray-400\">Consultas sobre terminos del alquiler</p>\n            </div>\n          </div>\n          <svg\n            class=\"h-5 w-5 text-gray-400 transition-transform duration-300\"\n            [class.rotate-180]=\"isExpanded()\"\n            fill=\"none\"\n            stroke=\"currentColor\"\n            viewBox=\"0 0 24 24\"\n          >\n            <path\n              stroke-linecap=\"round\"\n              stroke-linejoin=\"round\"\n              stroke-width=\"2\"\n              d=\"M19 9l-7 7-7-7\"\n            />\n          </svg>\n        </button>\n\n        <!-- Content (expandable) -->\n        <div\n          class=\"overflow-hidden transition-all duration-300\"\n          [class.max-h-0]=\"!isExpanded()\"\n          [class.max-h-[600px]]=\"isExpanded()\"\n          [class.overflow-y-auto]=\"isExpanded()\"\n        >\n          <!-- Top gradient line -->\n          <div class=\"h-1 bg-gradient-to-r from-blue-500 via-indigo-500 to-purple-500\"></div>\n\n          <div class=\"p-5 space-y-4\">\n            <!-- Quick questions - Chat style bubbles -->\n            <div>\n              <p class=\"text-xs font-bold text-gray-500 dark:text-gray-400 uppercase tracking-wider mb-3 flex items-center gap-2\">\n                <svg class=\"w-3.5 h-3.5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                  <path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z\" />\n                </svg>\n                Preguntas frecuentes\n              </p>\n              <div class=\"flex flex-wrap gap-2\">\n                @for (q of quickQuestions; track q) {\n                  <button\n                    type=\"button\"\n                    class=\"group/q relative overflow-hidden rounded-full border border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-800 px-3 py-1.5 text-xs font-medium text-gray-700 dark:text-gray-300 transition-all duration-200 hover:border-indigo-400 dark:hover:border-indigo-500 hover:bg-indigo-50 dark:hover:bg-indigo-900/20 hover:text-indigo-700 dark:hover:text-indigo-400 hover:shadow-md\"\n                    (click)=\"askQuestion(q)\"\n                  >\n                    {{ q }}\n                  </button>\n                }\n              </div>\n            </div>\n\n            <!-- Chat-style input -->\n            <div class=\"relative\">\n              <div class=\"flex gap-2\">\n                <div class=\"relative flex-1\">\n                  <input\n                    type=\"text\"\n                    id=\"legalQuestionInput\"\n                    name=\"legalQuestionInput\"\n                    [(ngModel)]=\"customQuestion\"\n                    placeholder=\"Escribe tu consulta legal...\"\n                    class=\"w-full rounded-xl border-2 border-gray-200 dark:border-gray-700 bg-gray-50 dark:bg-gray-800 px-4 py-3 pr-12 text-sm text-gray-900 dark:text-white placeholder-gray-400 transition-all duration-200 focus:border-indigo-500 focus:bg-white dark:focus:bg-gray-900 focus:outline-none focus:ring-4 focus:ring-indigo-500/10\"\n                    (keydown.enter)=\"askQuestion(customQuestion)\"\n                  />\n                  <div class=\"absolute right-3 top-1/2 -translate-y-1/2 text-gray-400\">\n                    <svg class=\"w-5 h-5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                      <path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z\" />\n                    </svg>\n                  </div>\n                </div>\n                <button\n                  type=\"button\"\n                  class=\"relative overflow-hidden group/btn bg-gradient-to-r from-blue-500 to-indigo-600 hover:from-blue-600 hover:to-indigo-700 disabled:from-gray-400 disabled:to-gray-500 text-white font-bold px-5 py-3 rounded-xl text-sm transition-all duration-300 shadow-lg hover:shadow-indigo-500/25 disabled:shadow-none disabled:cursor-not-allowed flex items-center gap-2\"\n                  [disabled]=\"loading() || !customQuestion.trim()\"\n                  (click)=\"askQuestion(customQuestion)\"\n                >\n                  @if (loading()) {\n                    <div class=\"w-4 h-4 border-2 border-white/30 border-t-white rounded-full animate-spin\"></div>\n                  } @else {\n                    <svg class=\"w-4 h-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                      <path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M13 9l3 3m0 0l-3 3m3-3H8m13 0a9 9 0 11-18 0 9 9 0 0118 0z\" />\n                    </svg>\n                  }\n                  <span>Consultar</span>\n                  <div class=\"absolute inset-0 bg-gradient-to-r from-white/0 via-white/20 to-white/0 -translate-x-full group-hover/btn:translate-x-full transition-transform duration-700\"></div>\n                </button>\n              </div>\n            </div>\n\n            <!-- Loading State - Chat bubble style -->\n            @if (loading()) {\n              <div class=\"flex gap-3\">\n                <div class=\"w-8 h-8 bg-gradient-to-br from-blue-500 to-indigo-600 rounded-full flex items-center justify-center flex-shrink-0 shadow-lg\">\n                  <svg class=\"w-4 h-4 text-white\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                    <path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M3 6l3 1m0 0l-3 9a5.002 5.002 0 006.001 0M6 7l3 9M6 7l6-2m6 2l3-1m-3 1l-3 9a5.002 5.002 0 006.001 0M18 7l3 9m-3-9l-6-2m0-2v2m0 16V5m0 16H9m3 0h3\" />\n                  </svg>\n                </div>\n                <div class=\"flex-1 bg-gradient-to-r from-indigo-50 to-blue-50 dark:from-indigo-900/20 dark:to-blue-900/20 rounded-2xl rounded-tl-none p-4\">\n                  <div class=\"flex items-center gap-2\">\n                    <div class=\"flex gap-1\">\n                      <div class=\"w-2 h-2 bg-indigo-400 rounded-full animate-bounce\" style=\"animation-delay: 0ms;\"></div>\n                      <div class=\"w-2 h-2 bg-indigo-400 rounded-full animate-bounce\" style=\"animation-delay: 150ms;\"></div>\n                      <div class=\"w-2 h-2 bg-indigo-400 rounded-full animate-bounce\" style=\"animation-delay: 300ms;\"></div>\n                    </div>\n                    <span class=\"text-sm text-gray-600 dark:text-gray-300\">Analizando tu consulta...</span>\n                  </div>\n                </div>\n              </div>\n            }\n\n            <!-- Answer - Chat bubble style -->\n            @if (answer()) {\n              <div class=\"flex gap-3\">\n                <div class=\"relative\">\n                  <div class=\"absolute inset-0 bg-indigo-500/30 rounded-full blur-md animate-pulse\"></div>\n                  <div class=\"relative w-8 h-8 bg-gradient-to-br from-blue-500 to-indigo-600 rounded-full flex items-center justify-center flex-shrink-0 shadow-lg\">\n                    <svg class=\"w-4 h-4 text-white\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                      <path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M3 6l3 1m0 0l-3 9a5.002 5.002 0 006.001 0M6 7l3 9M6 7l6-2m6 2l3-1m-3 1l-3 9a5.002 5.002 0 006.001 0M18 7l3 9m-3-9l-6-2m0-2v2m0 16V5m0 16H9m3 0h3\" />\n                    </svg>\n                  </div>\n                </div>\n                <div class=\"flex-1 space-y-3\">\n                  <!-- Main answer bubble -->\n                  <div class=\"bg-gradient-to-br from-indigo-50 to-blue-50 dark:from-indigo-900/20 dark:to-blue-900/20 rounded-2xl rounded-tl-none p-4 border border-indigo-100 dark:border-indigo-800/30\">\n                    <p class=\"text-sm text-gray-800 dark:text-gray-200 leading-relaxed\">{{ answer()!.answer }}</p>\n\n                    @if (answer()!.sources.length > 0) {\n                      <div class=\"flex flex-wrap gap-1.5 mt-3 pt-3 border-t border-indigo-200/50 dark:border-indigo-700/30\">\n                        <span class=\"text-[10px] text-gray-500 dark:text-gray-400 uppercase font-bold tracking-wider mr-1\">Fuentes:</span>\n                        @for (source of answer()!.sources; track source) {\n                          <span class=\"inline-flex items-center gap-1 rounded-full bg-white dark:bg-gray-800 border border-indigo-200 dark:border-indigo-700 px-2 py-0.5 text-[10px] font-medium text-indigo-700 dark:text-indigo-400\">\n                            <svg class=\"w-3 h-3\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                              <path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z\" />\n                            </svg>\n                            {{ source }}\n                          </span>\n                        }\n                      </div>\n                    }\n                  </div>\n\n                  <!-- Disclaimer -->\n                  <div class=\"flex items-start gap-2 px-1\">\n                    <svg class=\"w-3.5 h-3.5 text-gray-400 flex-shrink-0 mt-0.5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                      <path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z\" />\n                    </svg>\n                    <p class=\"text-[11px] italic text-gray-400 dark:text-gray-500\">{{ answer()!.disclaimer }}</p>\n                  </div>\n\n                  <!-- Related questions -->\n                  @if (answer()!.relatedQuestions?.length) {\n                    <div class=\"bg-gray-50 dark:bg-gray-800/50 rounded-xl p-3\">\n                      <p class=\"text-[10px] font-bold text-gray-500 dark:text-gray-400 uppercase tracking-wider mb-2 flex items-center gap-1\">\n                        <svg class=\"w-3 h-3\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                          <path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z\" />\n                        </svg>\n                        Preguntas relacionadas\n                      </p>\n                      <div class=\"flex flex-wrap gap-1.5\">\n                        @for (rq of answer()!.relatedQuestions; track rq) {\n                          <button\n                            type=\"button\"\n                            class=\"text-xs text-indigo-600 dark:text-indigo-400 hover:text-indigo-800 dark:hover:text-indigo-300 hover:underline bg-white dark:bg-gray-900 px-2 py-1 rounded-lg border border-gray-200 dark:border-gray-700 hover:border-indigo-300 dark:hover:border-indigo-600 transition-colors\"\n                            (click)=\"askQuestion(rq)\"\n                          >\n                            {{ rq }}\n                          </button>\n                        }\n                      </div>\n                    </div>\n                  }\n                </div>\n              </div>\n            }\n\n            <!-- Error State -->\n            @if (error()) {\n              <div class=\"flex gap-3\">\n                <div class=\"w-8 h-8 bg-red-100 dark:bg-red-900/30 rounded-full flex items-center justify-center flex-shrink-0\">\n                  <svg class=\"w-4 h-4 text-red-500\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                    <path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z\" />\n                  </svg>\n                </div>\n                <div class=\"flex-1 bg-red-50 dark:bg-red-900/20 rounded-2xl rounded-tl-none p-4 border border-red-200 dark:border-red-800/30\">\n                  <p class=\"text-sm text-red-700 dark:text-red-400 font-medium\">{{ error() }}</p>\n                  <button\n                    type=\"button\"\n                    class=\"mt-2 text-xs text-red-600 hover:text-red-800 dark:text-red-400 dark:hover:text-red-300 font-medium flex items-center gap-1 hover:underline\"\n                    (click)=\"error.set(null)\"\n                  >\n                    <svg class=\"w-3.5 h-3.5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                      <path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15\" />\n                    </svg>\n                    Intentar de nuevo\n                  </button>\n                </div>\n              </div>\n            }\n          </div>\n        </div>\n      </div>\n    </div>\n  `,\n  styles: [`\n    :host { display: block; }\n\n    @keyframes gradient-xy {\n      0%, 100% { background-position: 0% 50%; }\n      50% { background-position: 100% 50%; }\n    }\n\n    .animate-gradient-xy {\n      animation: gradient-xy 3s ease infinite;\n      background-size: 200% 200%;\n    }\n  `],\n})\nexport class AiLegalPanelComponent {\n  private readonly gemini = inject(GeminiService);\n\n  /** Booking actual (opcional si se provee car) */\n  readonly booking = input<Booking | null>(null);\n\n  /** Car directo (opcional si se provee booking) */\n  readonly car = input<Car | null>(null);\n\n  /** Si el panel esta expandido */\n  readonly isExpanded = input<boolean>(false);\n\n  /** Evento de toggle */\n  readonly togglePanel = output<void>();\n\n  // State\n  readonly answer = signal<LegalAnswer | null>(null);\n  readonly loading = signal(false);\n  readonly error = signal<string | null>(null);\n\n  customQuestion = '';\n\n  readonly quickQuestions = [\n    'Cual es la franquicia del seguro?',\n    'Que pasa si excedo los kilometros?',\n    'Puedo viajar a otra provincia?',\n    'Como es la politica de combustible?',\n  ];\n\n  /** Computed: obtiene el car desde booking o directamente */\n  private readonly effectiveCar = computed(() => {\n    const c = this.car();\n    if (c) return c;\n    const b = this.booking();\n    return b?.car as Car | undefined ?? null;\n  });\n\n  /** Computed: info del vehiculo para mostrar en UI */\n  readonly vehicleDisplay = computed(() => {\n    const c = this.effectiveCar();\n    const b = this.booking();\n    const brand = c?.brand || b?.car_brand || '';\n    const model = c?.model || b?.car_model || '';\n    return `${brand} ${model}`.trim() || 'el vehiculo';\n  });\n\n  async askQuestion(question: string): Promise<void> {\n    if (!question.trim()) return;\n\n    const c = this.effectiveCar();\n    const b = this.booking();\n\n    this.loading.set(true);\n    this.error.set(null);\n    this.answer.set(null);\n\n    try {\n      const bookingTerms: BookingTerms = {\n        cancellationPolicy: c?.cancel_policy || 'moderate',\n        mileageLimit: c?.mileage_limit ?? null,\n        extraKmPrice: c?.extra_km_price ?? null,\n        fuelPolicy: c?.fuel_policy ?? null,\n        allowedProvinces: c?.allowed_provinces ?? null,\n        maxDistanceKm: c?.max_distance_km ?? null,\n        insuranceDeductibleUsd: c?.insurance_deductible_usd ?? null,\n        allowSecondDriver: c?.allow_second_driver ?? null,\n        secondDriverCost: c?.second_driver_cost ?? null,\n        allowSmoking: c?.allow_smoking ?? null,\n        allowPets: c?.allow_pets ?? null,\n        allowRideshare: c?.allow_rideshare ?? null,\n      };\n\n      const vehicleInfo: VehicleInfo = {\n        brand: c?.brand || b?.car_brand || '',\n        model: c?.model || b?.car_model || '',\n        year: c?.year || b?.car_year || new Date().getFullYear(),\n      };\n\n      const result = await this.gemini.askLegalQuestion({\n        question: question.trim(),\n        bookingTerms,\n        vehicleInfo,\n      });\n\n      this.answer.set(result);\n      this.customQuestion = '';\n    } catch {\n      this.error.set('No pudimos procesar tu consulta. Intenta de nuevo.');\n    } finally {\n      this.loading.set(false);\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/shared/components/ai-trip-panel/ai-trip-panel.component.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`@core/services/ai/gemini.service` import should occur before type import of `../../../core/models`","line":12,"column":1,"nodeType":"ImportDeclaration","endLine":12,"endColumn":66,"fix":{"range":[170,326],"text":"import { GeminiService } from '@core/services/ai/gemini.service';\nimport type { Booking, Car, TripItinerary, TripPreferences } from '../../../core/models';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import {\n  ChangeDetectionStrategy,\n  Component,\n  computed,\n  inject,\n  input,\n  output,\n  signal,\n} from '@angular/core';\nimport { FormsModule } from '@angular/forms';\nimport type { Booking, Car, TripItinerary, TripPreferences } from '../../../core/models';\nimport { GeminiService } from '@core/services/ai/gemini.service';\n\n/**\n * Panel de Planificador de Viajes IA\n *\n * Genera itinerarios de viaje personalizados basados en la duracion\n * del alquiler, ubicacion y preferencias del usuario.\n *\n * @example\n * ```html\n * <app-ai-trip-panel\n *   [booking]=\"booking()\"\n *   [isExpanded]=\"expandedPanel() === 'trip'\"\n *   (togglePanel)=\"togglePanel('trip')\"\n * />\n * ```\n */\n@Component({\n  selector: 'app-ai-trip-panel',\n  standalone: true,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  imports: [FormsModule],\n  template: `\n    <div class=\"ai-panel border-b border-border-muted last:border-b-0\">\n      <!-- Header -->\n      <button\n        type=\"button\"\n        class=\"flex w-full items-center justify-between p-4 text-left transition-colors hover:bg-surface-base/50\"\n        (click)=\"togglePanel.emit()\"\n      >\n        <div class=\"flex items-center gap-3\">\n          <div class=\"flex h-8 w-8 items-center justify-center rounded-full bg-indigo-500/10\">\n            <svg\n              class=\"h-4 w-4 text-indigo-500\"\n              fill=\"none\"\n              stroke=\"currentColor\"\n              viewBox=\"0 0 24 24\"\n            >\n              <path\n                stroke-linecap=\"round\"\n                stroke-linejoin=\"round\"\n                stroke-width=\"2\"\n                d=\"M9 20l-5.447-2.724A1 1 0 013 16.382V5.618a1 1 0 011.447-.894L9 7m0 13l6-3m-6 3V7m6 10l4.553 2.276A1 1 0 0021 18.382V7.618a1 1 0 00-.553-.894L15 4m0 13V4m0 0L9 7\"\n              />\n            </svg>\n          </div>\n          <div>\n            <h3 class=\"text-sm font-semibold text-text-primary\">Planificador de Viaje</h3>\n            <p class=\"text-xs text-text-secondary\">\n              Genera un itinerario para {{ rentalDays() }} dias\n            </p>\n          </div>\n        </div>\n        <svg\n          class=\"h-5 w-5 text-text-muted transition-transform\"\n          [class.rotate-180]=\"isExpanded()\"\n          fill=\"none\"\n          stroke=\"currentColor\"\n          viewBox=\"0 0 24 24\"\n        >\n          <path\n            stroke-linecap=\"round\"\n            stroke-linejoin=\"round\"\n            stroke-width=\"2\"\n            d=\"M19 9l-7 7-7-7\"\n          />\n        </svg>\n      </button>\n\n      <!-- Content -->\n      <div\n        class=\"overflow-hidden transition-all duration-300\"\n        [class.max-h-0]=\"!isExpanded()\"\n        [class.max-h-[800px]]=\"isExpanded()\"\n        [class.overflow-y-auto]=\"isExpanded()\"\n      >\n        <div class=\"space-y-4 px-4 pb-4\">\n          <!-- Config form -->\n          @if (!itinerary()) {\n            <div class=\"space-y-3\">\n              <!-- Days -->\n              <div>\n                <label for=\"tripDaysSelect\" class=\"mb-1 block text-xs font-medium text-text-secondary\">\n                  Duracion del viaje\n                </label>\n                <select\n                  id=\"tripDaysSelect\"\n                  name=\"tripDaysSelect\"\n                  [(ngModel)]=\"selectedDays\"\n                  class=\"w-full rounded-lg border border-border-muted bg-surface-base px-3 py-2 text-sm\"\n                >\n                  @for (d of daysOptions; track d) {\n                    <option [value]=\"d\">{{ d }} {{ d === 1 ? 'dia' : 'dias' }}</option>\n                  }\n                </select>\n              </div>\n\n              <!-- Start Location -->\n              <div>\n                <label for=\"tripStartLocation\" class=\"mb-1 block text-xs font-medium text-text-secondary\">\n                  Punto de partida\n                </label>\n                <input\n                  type=\"text\"\n                  id=\"tripStartLocation\"\n                  name=\"tripStartLocation\"\n                  [(ngModel)]=\"startLocation\"\n                  class=\"w-full rounded-lg border border-border-muted bg-surface-base px-3 py-2 text-sm\"\n                  [placeholder]=\"defaultLocation()\"\n                />\n              </div>\n\n              <!-- Preferences -->\n              <div>\n                <label class=\"mb-2 block text-xs font-medium text-text-secondary\">\n                  Intereses (opcional)\n                </label>\n                <div class=\"flex flex-wrap gap-2\">\n                  @for (interest of interestOptions; track interest) {\n                    <button\n                      type=\"button\"\n                      class=\"rounded-full border px-3 py-1 text-xs transition-colors\"\n                      [class.border-cta-default]=\"selectedInterests.includes(interest)\"\n                      [class.bg-cta-default/10]=\"selectedInterests.includes(interest)\"\n                      [class.text-cta-default]=\"selectedInterests.includes(interest)\"\n                      [class.border-border-muted]=\"!selectedInterests.includes(interest)\"\n                      (click)=\"toggleInterest(interest)\"\n                    >\n                      {{ interest }}\n                    </button>\n                  }\n                </div>\n              </div>\n\n              <!-- Generate button -->\n              <button\n                type=\"button\"\n                class=\"w-full rounded-lg bg-indigo-500 py-2.5 text-sm font-medium text-white transition-colors hover:bg-indigo-600 disabled:cursor-not-allowed disabled:opacity-50\"\n                [disabled]=\"loading()\"\n                (click)=\"generateItinerary()\"\n              >\n                @if (loading()) {\n                  <span class=\"flex items-center justify-center gap-2\">\n                    <svg class=\"h-4 w-4 animate-spin\" fill=\"none\" viewBox=\"0 0 24 24\">\n                      <circle\n                        class=\"opacity-25\"\n                        cx=\"12\"\n                        cy=\"12\"\n                        r=\"10\"\n                        stroke=\"currentColor\"\n                        stroke-width=\"4\"\n                      />\n                      <path\n                        class=\"opacity-75\"\n                        fill=\"currentColor\"\n                        d=\"M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z\"\n                      />\n                    </svg>\n                    Generando itinerario...\n                  </span>\n                } @else {\n                  Generar Itinerario\n                }\n              </button>\n            </div>\n          }\n\n          <!-- Itinerary result -->\n          @if (itinerary()) {\n            <div class=\"space-y-4\">\n              <!-- Summary -->\n              <div\n                class=\"flex items-center justify-between rounded-lg bg-indigo-500/10 p-3 text-sm\"\n              >\n                <span class=\"text-indigo-700\">\n                  {{ itinerary()!.totalDays }} dias - {{ itinerary()!.totalKm }} km aprox.\n                </span>\n                <button\n                  type=\"button\"\n                  class=\"text-xs text-indigo-600 hover:underline\"\n                  (click)=\"itinerary.set(null)\"\n                >\n                  Regenerar\n                </button>\n              </div>\n\n              <!-- Days -->\n              @for (day of itinerary()!.days; track day.dayNumber) {\n                <div class=\"rounded-lg border border-border-muted bg-surface-base p-3\">\n                  <div class=\"mb-2 flex items-center justify-between\">\n                    <h4 class=\"font-semibold text-text-primary\">\n                      Dia {{ day.dayNumber }}: {{ day.title }}\n                    </h4>\n                    <span class=\"text-xs text-text-muted\">{{ day.estimatedKm }} km</span>\n                  </div>\n\n                  <div class=\"space-y-2\">\n                    @for (activity of day.activities; track activity.time) {\n                      <div class=\"flex gap-3 text-sm\">\n                        <span class=\"w-12 flex-shrink-0 font-medium text-text-secondary\">\n                          {{ activity.time }}\n                        </span>\n                        <div>\n                          <p class=\"text-text-primary\">{{ activity.activity }}</p>\n                          <p class=\"text-xs text-text-muted\">\n                            {{ activity.location }} - {{ activity.duration }}\n                          </p>\n                        </div>\n                      </div>\n                    }\n                  </div>\n\n                  @if (day.overnightLocation) {\n                    <div class=\"mt-2 border-t border-border-muted pt-2 text-xs text-text-muted\">\n                      Pernocte: {{ day.overnightLocation }}\n                    </div>\n                  }\n                </div>\n              }\n\n              <!-- Tips -->\n              @if (itinerary()!.tips.length > 0) {\n                <div class=\"rounded-lg bg-amber-50 p-3 dark:bg-amber-900/20\">\n                  <h4 class=\"mb-2 text-xs font-semibold text-amber-700 dark:text-amber-400\">\n                    Tips para el viaje\n                  </h4>\n                  <ul class=\"space-y-1 text-xs text-amber-800 dark:text-amber-300\">\n                    @for (tip of itinerary()!.tips; track tip) {\n                      <li>{{ tip }}</li>\n                    }\n                  </ul>\n                </div>\n              }\n\n              <!-- Warnings -->\n              @if (itinerary()!.warnings?.length) {\n                <div class=\"rounded-lg bg-red-50 p-3 dark:bg-red-900/20\">\n                  <h4 class=\"mb-2 text-xs font-semibold text-red-700 dark:text-red-400\">\n                    Advertencias\n                  </h4>\n                  <ul class=\"space-y-1 text-xs text-red-800 dark:text-red-300\">\n                    @for (warning of itinerary()!.warnings; track warning) {\n                      <li>{{ warning }}</li>\n                    }\n                  </ul>\n                </div>\n              }\n            </div>\n          }\n\n          <!-- Error -->\n          @if (error()) {\n            <div class=\"rounded-lg bg-error-bg p-3 text-sm text-error-strong\">\n              {{ error() }}\n            </div>\n          }\n        </div>\n      </div>\n    </div>\n  `,\n})\nexport class AiTripPanelComponent {\n  private readonly gemini = inject(GeminiService);\n\n  /** Booking (opcional si se provee car) */\n  readonly booking = input<Booking | null>(null);\n\n  /** Car directo (opcional si se provee booking) */\n  readonly car = input<Car | null>(null);\n\n  /** Dias sugeridos para el trip (opcional, para car-detail) */\n  readonly suggestedDays = input<number | null>(null);\n\n  readonly isExpanded = input<boolean>(false);\n  readonly togglePanel = output<void>();\n\n  // State\n  readonly itinerary = signal<TripItinerary | null>(null);\n  readonly loading = signal(false);\n  readonly error = signal<string | null>(null);\n\n  // Form state\n  selectedDays = 3;\n  startLocation = '';\n  selectedInterests: string[] = [];\n\n  readonly daysOptions = [1, 2, 3, 4, 5, 6, 7, 10, 14];\n  readonly interestOptions = [\n    'Playas',\n    'Montanas',\n    'Gastronomia',\n    'Naturaleza',\n    'Historia',\n    'Ciudades',\n    'Vinos',\n    'Aventura',\n  ];\n\n  readonly rentalDays = computed(() => {\n    const suggested = this.suggestedDays();\n    if (suggested) return suggested;\n\n    const b = this.booking();\n    if (!b?.start_at || !b?.end_at) return 3; // Default 3 days\n    const start = new Date(b.start_at);\n    const end = new Date(b.end_at);\n    return Math.ceil((end.getTime() - start.getTime()) / (1000 * 60 * 60 * 24)) || 3;\n  });\n\n  readonly defaultLocation = computed(() => {\n    const c = this.car();\n    if (c?.location_city) return c.location_city;\n    const b = this.booking();\n    return b?.car_city || b?.car?.location_city || 'Buenos Aires';\n  });\n\n  /** Computed: obtiene el tipo de vehiculo */\n  private readonly vehicleType = computed(() => {\n    const c = this.car();\n    const b = this.booking();\n    const brand = c?.brand || b?.car_brand || '';\n    const model = c?.model || b?.car_model || '';\n    return `${brand} ${model}`.trim() || 'Auto';\n  });\n\n  toggleInterest(interest: string): void {\n    if (this.selectedInterests.includes(interest)) {\n      this.selectedInterests = this.selectedInterests.filter((i) => i !== interest);\n    } else {\n      this.selectedInterests = [...this.selectedInterests, interest];\n    }\n  }\n\n  async generateItinerary(): Promise<void> {\n    this.loading.set(true);\n    this.error.set(null);\n    this.itinerary.set(null);\n\n    try {\n      const preferences: TripPreferences = {\n        interests: this.selectedInterests.length > 0 ? this.selectedInterests : undefined,\n        budget: 'moderado',\n      };\n\n      const result = await this.gemini.generateTripItinerary({\n        days: this.selectedDays || this.rentalDays(),\n        startLocation: this.startLocation || this.defaultLocation(),\n        vehicleType: this.vehicleType(),\n        preferences,\n      });\n\n      this.itinerary.set(result);\n    } catch {\n      this.error.set('No pudimos generar el itinerario. Intenta de nuevo.');\n    } finally {\n      this.loading.set(false);\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/shared/components/bank-account-form/bank-account-form.component.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`@core/services/auth/profile.service` import should occur before type import of `../../../core/models/wallet.model`","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":8,"endColumn":70,"fix":{"range":[394,560],"text":"import { ProfileService } from '@core/services/auth/profile.service';\nimport type { AddBankAccountParams, BankAccountType } from '../../../core/models/wallet.model';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { CommonModule } from '@angular/common';\nimport {Component, computed, EventEmitter, inject, OnInit, Output, signal, DestroyRef,\n  ChangeDetectionStrategy} from '@angular/core';\nimport { FormBuilder, FormGroup, ReactiveFormsModule, Validators } from '@angular/forms';\nimport { TranslateModule } from '@ngx-translate/core';\nimport { takeUntilDestroyed } from '@angular/core/rxjs-interop';\nimport type { AddBankAccountParams, BankAccountType } from '../../../core/models/wallet.model';\nimport { ProfileService } from '@core/services/auth/profile.service';\n\n/**\n * Componente para agregar cuentas bancarias\n * Soporta CBU, CVU y Alias\n *\n * NOTA: Los datos de titular (nombre y documento) se obtienen del perfil del usuario.\n * Si el usuario no tiene estos datos completados, debe completarlos primero en su perfil.\n */\n@Component({\n  selector: 'app-bank-account-form',\n  standalone: true,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  imports: [CommonModule, ReactiveFormsModule, TranslateModule],\n  templateUrl: './bank-account-form.component.html',\n  styleUrl: './bank-account-form.component.css',\n})\nexport class BankAccountFormComponent implements OnInit {\n  private readonly profileService = inject(ProfileService);\n  private readonly destroyRef = inject(DestroyRef);\n\n  @Output() submitAccount = new EventEmitter<AddBankAccountParams>();\n  @Output() cancelled = new EventEmitter<void>();\n\n  readonly form: FormGroup;\n  readonly submitting = signal(false);\n  readonly selectedType = signal<BankAccountType>('cbu');\n  readonly profileData = signal<{ fullName: string; govIdNumber: string } | null>(null);\n  readonly profileError = signal<string | null>(null);\n\n  readonly selectedAccountTypeInfo = computed(() => {\n    const selected = this.selectedType();\n    return this.accountTypes.find((t) => t.value === selected);\n  });\n\n  readonly accountTypes: {\n    value: BankAccountType;\n    label: string;\n    placeholder: string;\n    hint: string;\n  }[] = [\n    {\n      value: 'cbu',\n      label: 'CBU',\n      placeholder: '0000003100010000000001',\n      hint: '22 dígitos numéricos',\n    },\n    {\n      value: 'cvu',\n      label: 'CVU',\n      placeholder: '0000003100010000000001',\n      hint: '22 dígitos numéricos',\n    },\n    {\n      value: 'alias',\n      label: 'Alias',\n      placeholder: 'mi.alias.banco',\n      hint: '6-20 caracteres alfanuméricos',\n    },\n  ];\n\n  constructor(private readonly fb: FormBuilder) {\n    this.form = this.fb.group({\n      account_type: ['cbu', Validators.required],\n      account_number: ['', [Validators.required, Validators.minLength(6)]],\n      bank_name: [''],\n    });\n  }\n\n  async ngOnInit(): Promise<void> {\n    // Actualizar validaciones cuando cambia el tipo\n    this.form.get('account_type')?.valueChanges\n      .pipe(takeUntilDestroyed(this.destroyRef))\n      .subscribe((type: BankAccountType) => {\n        this.selectedType.set(type);\n        this.updateAccountNumberValidators(type);\n      });\n    try {\n      const profile = await this.profileService.getCurrentProfile();\n\n      if (!profile) {\n        this.profileError.set('No se pudo cargar tu perfil');\n        return;\n      }\n\n      // Verificar que el usuario tenga los datos necesarios\n      if (!profile.full_name || !profile.gov_id_number) {\n        this.profileError.set(\n          'Debes completar tu nombre completo y número de documento en tu perfil antes de agregar una cuenta bancaria',\n        );\n        return;\n      }\n\n      this.profileData.set({\n        fullName: profile.full_name,\n        govIdNumber: profile.gov_id_number,\n      });\n    } catch {\n      this.profileError.set('Error al cargar tu perfil');\n    }\n  }\n\n  private updateAccountNumberValidators(type: BankAccountType): void {\n    const accountNumberControl = this.form.get('account_number');\n\n    if (type === 'cbu' || type === 'cvu') {\n      // CBU y CVU: exactamente 22 dígitos\n      accountNumberControl?.setValidators([Validators.required, Validators.pattern(/^\\d{22}$/)]);\n    } else {\n      // Alias: 6-20 caracteres alfanuméricos\n      accountNumberControl?.setValidators([\n        Validators.required,\n        Validators.minLength(6),\n        Validators.maxLength(20),\n        Validators.pattern(/^[a-zA-Z0-9.]+$/),\n      ]);\n    }\n\n    accountNumberControl?.updateValueAndValidity();\n  }\n\n  onSubmit(): void {\n    if (this.form.invalid) {\n      this.form.markAllAsTouched();\n      return;\n    }\n\n    const profile = this.profileData();\n    if (!profile) {\n      this.profileError.set('No se pudieron obtener los datos del perfil');\n      return;\n    }\n\n    this.submitting.set(true);\n\n    const params: AddBankAccountParams = {\n      account_type: this.form.value.account_type,\n      account_number: this.form.value.account_number.trim(),\n      account_holder_name: profile.fullName,\n      account_holder_document: profile.govIdNumber,\n      bank_name: this.form.value.bank_name?.trim() || undefined,\n    };\n\n    this.submitAccount.emit(params);\n  }\n\n  onCancel(): void {\n    this.cancelled.emit();\n  }\n\n  getErrorMessage(fieldName: string): string {\n    const control = this.form.get(fieldName);\n\n    if (!control || !control.touched || !control.errors) {\n      return '';\n    }\n\n    if (control.errors['required']) {\n      const fieldLabels: Record<string, string> = {\n        account_type: 'El tipo de cuenta',\n        account_number: 'El número de cuenta',\n        bank_name: 'El nombre del banco',\n      };\n      return `${fieldLabels[fieldName] || 'Este campo'} es requerido`;\n    }\n\n    if (control.errors['minlength']) {\n      const min = control.errors['minlength'].requiredLength;\n      return `Debe tener al menos ${min} caracteres`;\n    }\n\n    if (control.errors['maxlength']) {\n      const max = control.errors['maxlength'].requiredLength;\n      return `No puede exceder ${max} caracteres`;\n    }\n\n    if (control.errors['pattern']) {\n      if (fieldName === 'account_number') {\n        const type = this.selectedType();\n        if (type === 'cbu' || type === 'cvu') {\n          return 'El CBU/CVU debe tener exactamente 22 dígitos numéricos';\n        } else {\n          return 'El alias solo puede contener letras, números y puntos';\n        }\n      }\n    }\n\n    return 'El formato ingresado no es válido';\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/shared/components/base-chat/base-chat.component.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`../../../core/models` type import should occur after import of `@core/services/ui/toast.service`","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":78,"fix":{"range":[235,693],"text":"import { AuthService } from '@core/services/auth/auth.service';\nimport { GeminiService } from '@core/services/ai/gemini.service';\nimport { Message, MessagesService } from '@core/services/bookings/messages.service';\nimport { NotificationSoundService } from '@core/services/infrastructure/notification-sound.service';\nimport { ToastService } from '@core/services/ui/toast.service';\nimport type { AiBookingContext, ChatSuggestion } from '../../../core/models';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"\nimport {Component, OnDestroy, OnInit, effect, inject, input, output, signal,\n  ChangeDetectionStrategy} from '@angular/core';\nimport { FormsModule } from '@angular/forms';\nimport type { RealtimeChannel } from '@supabase/supabase-js';\nimport type { AiBookingContext, ChatSuggestion } from '../../../core/models';\nimport { AuthService } from '@core/services/auth/auth.service';\nimport { GeminiService } from '@core/services/ai/gemini.service';\nimport { Message, MessagesService } from '@core/services/bookings/messages.service';\nimport { NotificationSoundService } from '@core/services/infrastructure/notification-sound.service';\nimport { ToastService } from '@core/services/ui/toast.service';\n\n/**\n * Contexto del chat (booking o car)\n */\nexport interface ChatContext {\n  type: 'booking' | 'car';\n  contextId: string; // bookingId o carId\n  recipientId: string;\n  recipientName: string;\n  headerSubtitle?: string; // Texto adicional para el header\n}\n\n/**\n * Componente base para chats (booking y car)\n * Unifica la UI y lógica compartida entre ambos tipos de chat\n */\n@Component({\n  selector: 'app-base-chat',\n  standalone: true,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  imports: [FormsModule],\n  template: `\n    <!-- Professional Chat Container -->\n    <div\n      class=\"chat-container flex h-[550px] flex-col overflow-hidden rounded-2xl border border-border-default bg-surface-raised shadow-sm\"\n    >\n      <!-- Professional Header -->\n      <div class=\"flex items-center gap-3 border-b border-border-default bg-surface-raised px-4 py-3\">\n        <!-- Avatar with Initials -->\n        <div class=\"relative flex-shrink-0\">\n          <div\n            class=\"flex h-12 w-12 items-center justify-center rounded-full bg-gradient-to-br from-indigo-500 to-purple-600 text-white font-bold text-lg\"\n          >\n            {{ getInitials() }}\n          </div>\n          <!-- Online indicator -->\n          <div class=\"absolute -bottom-0.5 -right-0.5 h-4 w-4 rounded-full border-2 border-surface-raised bg-emerald-500\"></div>\n        </div>\n\n        <!-- Contact Info -->\n        <div class=\"flex-1 min-w-0\">\n          <h3 class=\"text-base font-semibold text-text-primary truncate\">{{ context().recipientName }}</h3>\n          <div class=\"flex items-center gap-1.5\">\n            <span class=\"h-2 w-2 rounded-full bg-emerald-500\"></span>\n            <span class=\"text-xs text-emerald-600 dark:text-emerald-400 font-medium\">En línea</span>\n          </div>\n        </div>\n\n        <!-- Action buttons -->\n        <div class=\"flex items-center gap-1\">\n          <!-- Block/Unblock button -->\n          <button\n            type=\"button\"\n            class=\"flex h-9 w-9 items-center justify-center rounded-full text-text-secondary hover:bg-surface-hover transition-colors\"\n            [class.text-error-strong]=\"blocked()\"\n            (click)=\"toggleBlockUser()\"\n            [title]=\"blocked() ? 'Desbloquear' : 'Bloquear'\"\n          >\n            <svg class=\"h-5 w-5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n              <path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\"\n                d=\"M18.364 18.364A9 9 0 005.636 5.636m12.728 12.728A9 9 0 015.636 5.636m12.728 12.728L5.636 5.636\" />\n            </svg>\n          </button>\n          <!-- Menu button -->\n          <button\n            type=\"button\"\n            class=\"flex h-9 w-9 items-center justify-center rounded-full text-text-secondary hover:bg-surface-hover transition-colors\"\n            (click)=\"onMenuClick()\"\n          >\n            <svg class=\"h-5 w-5\" fill=\"currentColor\" viewBox=\"0 0 24 24\">\n              <path d=\"M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z\" />\n            </svg>\n          </button>\n        </div>\n      </div>\n\n      <!-- Blocked user banner -->\n      @if (blocked()) {\n        <div class=\"bg-error-bg/50 border-b border-error-border px-4 py-2.5 text-sm text-center text-error-strong\">\n          <span class=\"font-medium\">Usuario bloqueado</span> · Desbloquéalo para volver a chatear\n        </div>\n      }\n\n      <!-- Chat Messages Area -->\n      <div class=\"relative flex-1 overflow-y-auto bg-surface-base\">\n        <!-- Loading state -->\n        @if (loading()) {\n          <div class=\"flex h-full items-center justify-center\">\n            <div class=\"text-center\">\n              <div class=\"mb-3 inline-block h-10 w-10 animate-spin rounded-full border-4 border-border-muted border-t-indigo-500\"></div>\n              <p class=\"text-sm text-text-secondary\">Cargando mensajes...</p>\n            </div>\n          </div>\n        }\n\n        <!-- Error state -->\n        @if (error()) {\n          <div class=\"mx-4 mt-4 flex items-center gap-2 rounded-xl bg-error-bg/50 border border-error-border/50 p-4 text-sm text-error-strong\">\n            <svg class=\"h-5 w-5 flex-shrink-0\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n              <path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z\" />\n            </svg>\n            <span>{{ error() }}</span>\n          </div>\n        }\n\n        <!-- Empty state -->\n        @if (!loading() && messages().length === 0) {\n          <div class=\"flex h-full flex-col items-center justify-center px-6 text-center\">\n            <div class=\"mb-4 flex h-20 w-20 items-center justify-center rounded-full bg-indigo-50 dark:bg-indigo-900/20\">\n              <svg class=\"h-10 w-10 text-indigo-500\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"1.5\"\n                  d=\"M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z\" />\n              </svg>\n            </div>\n            <h4 class=\"mb-1 text-base font-semibold text-text-primary\">{{ getEmptyStateTitle() }}</h4>\n            <p class=\"text-sm text-text-secondary max-w-xs\">{{ getEmptyStateSubtitle() }}</p>\n          </div>\n        }\n\n        <!-- Messages list -->\n        @if (!loading() && messages().length > 0) {\n          <div class=\"px-4 py-4 space-y-3\">\n            <!-- Date separator (first message) -->\n            <div class=\"flex items-center justify-center mb-2\">\n              <span class=\"px-3 py-1 text-xs text-text-secondary bg-surface-raised rounded-full border border-border-default shadow-sm\">\n                {{ getConversationDateLabel() }}\n              </span>\n            </div>\n\n            @for (message of messages(); track message.id) {\n              <div [class]=\"isOwnMessage(message) ? 'flex justify-end' : 'flex justify-start'\">\n                <!-- Received message (left) -->\n                @if (!isOwnMessage(message)) {\n                  <div class=\"flex items-end gap-2 max-w-[80%]\">\n                    <!-- Small avatar -->\n                    <div class=\"flex h-7 w-7 flex-shrink-0 items-center justify-center rounded-full bg-gradient-to-br from-indigo-500 to-purple-600 text-white text-[10px] font-bold mb-1\">\n                      {{ getInitials() }}\n                    </div>\n                    <div class=\"relative\">\n                      <div class=\"rounded-2xl rounded-bl-md bg-white dark:bg-surface-secondary border border-border-default px-4 py-2.5 shadow-sm\">\n                        <p class=\"text-sm text-text-primary leading-relaxed whitespace-pre-wrap break-words\">{{ message.body }}</p>\n                        <div class=\"mt-1 flex items-center justify-end\">\n                          <span class=\"text-[10px] text-text-muted\">{{ formatTime(message.created_at) }}</span>\n                        </div>\n                      </div>\n                    </div>\n                  </div>\n                }\n\n                <!-- Sent message (right) -->\n                @if (isOwnMessage(message)) {\n                  <div class=\"max-w-[80%]\">\n                    <div class=\"relative\">\n                      <div class=\"rounded-2xl rounded-br-md bg-gradient-to-r from-indigo-500 to-purple-600 px-4 py-2.5 shadow-sm\">\n                        <p class=\"text-sm text-white leading-relaxed whitespace-pre-wrap break-words\">{{ message.body }}</p>\n                        <div class=\"mt-1 flex items-center justify-end gap-1\">\n                          <span class=\"text-[10px] text-white/70\">{{ formatTime(message.created_at) }}</span>\n                          <!-- Status indicators -->\n                          @if (getMessageStatus(message) === 'sent') {\n                            <svg class=\"h-3.5 w-3.5 text-white/70\" fill=\"currentColor\" viewBox=\"0 0 16 15\">\n                              <path d=\"M15.01 3.316l-.478-.372a.365.365 0 0 0-.51.063L8.666 9.879a.32.32 0 0 1-.484.033l-.358-.325a.319.319 0 0 0-.484.032l-.378.483a.418.418 0 0 0 .036.541l1.32 1.266c.143.14.361.125.484-.033l6.272-8.048a.366.366 0 0 0-.064-.512z\" />\n                            </svg>\n                          }\n                          @if (getMessageStatus(message) === 'delivered') {\n                            <svg class=\"h-3.5 w-3.5 text-white/70\" fill=\"currentColor\" viewBox=\"0 0 16 15\">\n                              <path d=\"M15.01 3.316l-.478-.372a.365.365 0 0 0-.51.063L8.666 9.879a.32.32 0 0 1-.484.033l-.358-.325a.319.319 0 0 0-.484.032l-.378.483a.418.418 0 0 0 .036.541l1.32 1.266c.143.14.361.125.484-.033l6.272-8.048a.366.366 0 0 0-.064-.512zm-4.1 0l-.478-.372a.365.365 0 0 0-.51.063L4.566 9.879a.32.32 0 0 1-.484.033L1.891 7.769a.366.366 0 0 0-.515.006l-.423.433a.364.364 0 0 0 .006.514l3.258 3.185c.143.14.361.125.484-.033l6.272-8.048a.365.365 0 0 0-.063-.51z\" />\n                            </svg>\n                          }\n                          @if (getMessageStatus(message) === 'read') {\n                            <svg class=\"h-3.5 w-3.5 text-cyan-300\" fill=\"currentColor\" viewBox=\"0 0 16 15\">\n                              <path d=\"M15.01 3.316l-.478-.372a.365.365 0 0 0-.51.063L8.666 9.879a.32.32 0 0 1-.484.033l-.358-.325a.319.319 0 0 0-.484.032l-.378.483a.418.418 0 0 0 .036.541l1.32 1.266c.143.14.361.125.484-.033l6.272-8.048a.366.366 0 0 0-.064-.512zm-4.1 0l-.478-.372a.365.365 0 0 0-.51.063L4.566 9.879a.32.32 0 0 1-.484.033L1.891 7.769a.366.366 0 0 0-.515.006l-.423.433a.364.364 0 0 0 .006.514l3.258 3.185c.143.14.361.125.484-.033l6.272-8.048a.365.365 0 0 0-.063-.51z\" />\n                            </svg>\n                          }\n                        </div>\n                      </div>\n                      <!-- \"Tú\" label -->\n                      <span class=\"absolute -bottom-4 right-2 text-[10px] text-text-muted font-medium\">Tú</span>\n                    </div>\n                  </div>\n                }\n              </div>\n            }\n\n            <!-- Typing indicator -->\n            @if (recipientTyping()) {\n              <div class=\"flex justify-start\">\n                <div class=\"flex items-end gap-2\">\n                  <div class=\"flex h-7 w-7 flex-shrink-0 items-center justify-center rounded-full bg-gradient-to-br from-indigo-500 to-purple-600 text-white text-[10px] font-bold\">\n                    {{ getInitials() }}\n                  </div>\n                  <div class=\"rounded-2xl rounded-bl-md bg-white dark:bg-surface-secondary border border-border-default px-4 py-3 shadow-sm\">\n                    <div class=\"flex items-center gap-1\">\n                      <div class=\"h-2 w-2 animate-bounce rounded-full bg-indigo-400\" style=\"animation-delay: 0ms\"></div>\n                      <div class=\"h-2 w-2 animate-bounce rounded-full bg-indigo-400\" style=\"animation-delay: 150ms\"></div>\n                      <div class=\"h-2 w-2 animate-bounce rounded-full bg-indigo-400\" style=\"animation-delay: 300ms\"></div>\n                    </div>\n                  </div>\n                </div>\n              </div>\n            }\n          </div>\n        }\n\n        <!-- Floating notification -->\n        @if (notification()) {\n          <div class=\"absolute left-1/2 top-4 z-10 -translate-x-1/2 transform animate-slide-down\">\n            <div class=\"rounded-full bg-indigo-500 px-4 py-2 text-sm text-white shadow-lg\">\n              {{ notification() }}\n            </div>\n          </div>\n        }\n      </div>\n\n      <!-- AI Suggestions Bar -->\n      @if (bookingContextForAI() && showSuggestions()) {\n        <div class=\"border-t border-border-default bg-indigo-50/50 dark:bg-indigo-900/10 px-4 py-2.5\">\n          @if (loadingSuggestions()) {\n            <div class=\"flex items-center gap-2 text-indigo-600 dark:text-indigo-400\">\n              <svg class=\"h-4 w-4 animate-spin\" fill=\"none\" viewBox=\"0 0 24 24\">\n                <circle class=\"opacity-25\" cx=\"12\" cy=\"12\" r=\"10\" stroke=\"currentColor\" stroke-width=\"4\" />\n                <path class=\"opacity-75\" fill=\"currentColor\" d=\"M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z\" />\n              </svg>\n              <span class=\"text-xs font-medium\">Generando sugerencias...</span>\n            </div>\n          } @else if (aiSuggestions().length > 0) {\n            <div class=\"flex flex-wrap gap-2\">\n              @for (suggestion of aiSuggestions(); track suggestion.id) {\n                <button\n                  type=\"button\"\n                  class=\"rounded-full bg-white dark:bg-surface-raised border border-indigo-200 dark:border-indigo-700 px-3 py-1.5 text-xs font-medium text-indigo-600 dark:text-indigo-400 transition-all hover:bg-indigo-50 dark:hover:bg-indigo-900/20 hover:border-indigo-300 shadow-sm\"\n                  (click)=\"useSuggestion(suggestion)\"\n                >\n                  {{ suggestion.text }}\n                </button>\n              }\n            </div>\n          } @else {\n            <p class=\"text-xs text-text-muted\">No hay sugerencias disponibles</p>\n          }\n        </div>\n      }\n\n      <!-- Input Area -->\n      <div class=\"border-t border-border-default bg-surface-raised px-4 py-3\">\n        <form (ngSubmit)=\"sendMessage()\" class=\"flex items-center gap-3\">\n          <!-- AI Sparkles button -->\n          @if (bookingContextForAI()) {\n            <button\n              type=\"button\"\n              class=\"flex h-10 w-10 flex-shrink-0 items-center justify-center rounded-full transition-all\"\n              [class.bg-indigo-100]=\"showSuggestions()\"\n              [class.text-indigo-600]=\"showSuggestions()\"\n              [class.dark:bg-indigo-900/30]=\"showSuggestions()\"\n              [class.text-text-secondary]=\"!showSuggestions()\"\n              [class.hover:bg-surface-hover]=\"!showSuggestions()\"\n              [disabled]=\"loadingSuggestions()\"\n              (click)=\"toggleSuggestions()\"\n              title=\"Sugerencias IA\"\n            >\n              <svg class=\"h-5 w-5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\"\n                  d=\"M5 3v4M3 5h4M6 17v4m-2-2h4m5-16l2.286 6.857L21 12l-5.714 2.143L13 21l-2.286-6.857L5 12l5.714-2.143L13 3z\" />\n              </svg>\n            </button>\n          }\n\n          <!-- Text input -->\n          <div class=\"flex-1 relative\">\n            <input\n              type=\"text\"\n              [ngModel]=\"draftMessage\"\n              (ngModelChange)=\"onMessageDraftChange($event)\"\n              name=\"message\"\n              [disabled]=\"sending() || blocked()\"\n              [placeholder]=\"blocked() ? 'Usuario bloqueado' : 'Escribe un mensaje...'\"\n              class=\"w-full rounded-full bg-surface-base border border-border-default px-4 py-2.5 text-sm text-text-primary placeholder-text-muted focus:outline-none focus:ring-2 focus:ring-indigo-500/30 focus:border-indigo-400 transition-all\"\n            />\n          </div>\n\n          <!-- Send button -->\n          <button\n            type=\"submit\"\n            [disabled]=\"!draftMessage.trim() || sending() || blocked()\"\n            class=\"flex h-10 w-10 flex-shrink-0 items-center justify-center rounded-full bg-gradient-to-r from-indigo-500 to-purple-600 text-white shadow-sm transition-all hover:shadow-md hover:scale-105 active:scale-95 disabled:opacity-50 disabled:hover:scale-100 disabled:hover:shadow-sm\"\n          >\n            @if (!sending()) {\n              <svg class=\"h-5 w-5\" fill=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path d=\"M2.01 21L23 12 2.01 3 2 10l15 2-15 2z\" />\n              </svg>\n            }\n            @if (sending()) {\n              <svg class=\"h-5 w-5 animate-spin\" fill=\"none\" viewBox=\"0 0 24 24\">\n                <circle class=\"opacity-25\" cx=\"12\" cy=\"12\" r=\"10\" stroke=\"currentColor\" stroke-width=\"4\"></circle>\n                <path class=\"opacity-75\" fill=\"currentColor\" d=\"M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z\"></path>\n              </svg>\n            }\n          </button>\n        </form>\n      </div>\n    </div>\n  `,\n})\nexport class BaseChatComponent implements OnInit, OnDestroy {\n  // Inputs\n  readonly context = input.required<ChatContext>();\n  /** Contexto de booking para sugerencias IA (opcional) */\n  readonly bookingContextForAI = input<AiBookingContext | null>(null);\n\n  // Outputs para analytics y eventos\n  readonly messageSent = output<{ messageId: string; context: ChatContext }>();\n  readonly messageReceived = output<{ message: Message; context: ChatContext }>();\n  readonly menuClicked = output<void>();\n\n  // Services\n  protected readonly messagesService = inject(MessagesService);\n  protected readonly authService = inject(AuthService);\n  protected readonly notificationSound = inject(NotificationSoundService);\n  protected readonly toastService = inject(ToastService);\n  protected readonly geminiService = inject(GeminiService);\n\n  // State\n  readonly messages = signal<Message[]>([]);\n  readonly loading = signal(false);\n  readonly sending = signal(false);\n  readonly error = signal<string | null>(null);\n  readonly newMessage = signal('');\n  readonly blocked = signal(false);\n  readonly notification = signal<string | null>(null);\n  readonly recipientTyping = signal(false);\n\n  // AI Suggestions State\n  readonly aiSuggestions = signal<ChatSuggestion[]>([]);\n  readonly loadingSuggestions = signal(false);\n  readonly showSuggestions = signal(false);\n\n  // Computed\n  readonly currentUserId = signal<string | null>(null);\n\n  protected notificationTimeout: ReturnType<typeof setTimeout> | null = null;\n  protected typingTimeout: ReturnType<typeof setTimeout> | null = null;\n  protected typingChannel?: RealtimeChannel;\n\n  constructor() {\n    // Update current user ID when session changes\n    effect(() => {\n      const session = this.authService.session$();\n      this.currentUserId.set(session?.user?.id ?? null);\n    });\n  }\n\n  async ngOnInit(): Promise<void> {\n    await this.loadMessages();\n    this.subscribeToMessages();\n    this.subscribeToTyping();\n\n    // Check initial blocked status from server\n    const ctx = this.context();\n    if (ctx.recipientId) {\n      this.messagesService.isUserBlocked(ctx.recipientId).then((isBlocked) => {\n        this.blocked.set(isBlocked);\n      });\n    }\n  }\n\n  ngOnDestroy(): void {\n    this.messagesService.unsubscribe();\n    if (this.typingChannel) {\n      this.typingChannel.unsubscribe();\n    }\n    if (this.notificationTimeout) {\n      clearTimeout(this.notificationTimeout);\n    }\n    if (this.typingTimeout) {\n      clearTimeout(this.typingTimeout);\n    }\n    // Stop typing on unmount\n    if (this.currentUserId()) {\n      this.stopTyping();\n    }\n  }\n\n  /**\n   * Bloquea / desbloquea al usuario actual del chat\n   */\n  async toggleBlockUser(): Promise<void> {\n    const ctx = this.context();\n    const target = ctx.recipientId;\n    if (!target) return;\n\n    const wasBlocked = this.blocked();\n    \n    // Optimistic update\n    this.blocked.set(!wasBlocked);\n\n    try {\n      if (wasBlocked) {\n        await this.messagesService.unblockUser(target);\n        this.toastService.info('Usuario desbloqueado', `${ctx.recipientName} puede volver a escribirte.`);\n      } else {\n        await this.messagesService.blockUser(target);\n        this.recipientTyping.set(false);\n        this.toastService.success('Usuario bloqueado', `No recibirás mensajes de ${ctx.recipientName}.`);\n      }\n    } catch {\n      // Revertir optimistic update en caso de error\n      this.blocked.set(wasBlocked);\n      this.toastService.error('Error', 'No se pudo actualizar el bloqueo.');\n    }\n  }\n\n  /**\n   * Carga los mensajes iniciales\n   */\n  protected async loadMessages(): Promise<void> {\n    this.loading.set(true);\n    this.error.set(null);\n\n    try {\n      const ctx = this.context();\n      const messages =\n        ctx.type === 'booking'\n          ? await this.messagesService.listByBooking(ctx.contextId)\n          : await this.messagesService.listByCar(ctx.contextId);\n      this.messages.set(messages);\n    } catch {\n      this.error.set('No pudimos cargar los mensajes');\n    } finally {\n      this.loading.set(false);\n    }\n  }\n\n  /**\n   * Suscribe a mensajes en tiempo real\n   * Con deduplicación para optimistic updates\n   */\n  protected subscribeToMessages(): void {\n    const ctx = this.context();\n    const handler = async (message: Message) => {\n      this.messages.update((prev) => {\n        // Check if message already exists by ID\n        const existing = prev.find((m) => m.id === message.id);\n        if (existing) {\n          return prev.map((m) => (m.id === message.id ? message : m));\n        }\n\n        // Deduplicación: reemplazar mensaje optimistic si coincide\n        // Buscar mensaje temporal con mismo contenido y timestamp cercano\n        const optimisticIndex = prev.findIndex(\n          (m) =>\n            m.id.startsWith('temp-') &&\n            m.body === message.body &&\n            m.sender_id === message.sender_id &&\n            Math.abs(new Date(m.created_at).getTime() - new Date(message.created_at).getTime()) <\n              5000,\n        );\n\n        if (optimisticIndex >= 0) {\n          // Reemplazar mensaje optimistic con el real\n          const updated = [...prev];\n          updated[optimisticIndex] = message;\n          return updated;\n        }\n\n        // Nuevo mensaje, agregarlo\n        return [...prev, message];\n      });\n\n      // Mark as delivered if it's for us\n      if (message.recipient_id === this.currentUserId() && !message.delivered_at) {\n        await this.messagesService.markAsDelivered(message.id);\n      }\n\n      // Mark as read if we're viewing and it's for us\n      if (message.recipient_id === this.currentUserId() && !message.read_at) {\n        setTimeout(async () => {\n          await this.messagesService.markAsRead(message.id);\n        }, 1000);\n      }\n\n      if (message.sender_id !== this.currentUserId()) {\n        this.showNotification(`Nuevo mensaje de ${ctx.recipientName}`);\n        this.notificationSound.playNotificationSound().catch(() => {});\n        this.messageReceived.emit({ message, context: ctx });\n      }\n    };\n\n    if (ctx.type === 'booking') {\n      this.messagesService.subscribeToBooking(ctx.contextId, handler);\n    } else {\n      this.messagesService.subscribeToCar(ctx.contextId, handler);\n    }\n  }\n\n  /**\n   * Suscribe a indicador de typing\n   */\n  protected subscribeToTyping(): void {\n    const ctx = this.context();\n    this.typingChannel = this.messagesService.subscribeToTyping(\n      ctx.contextId,\n      (typingUsers) => {\n        this.recipientTyping.set(typingUsers.includes(ctx.recipientId));\n      },\n      ctx.type,\n    );\n  }\n\n  /**\n   * Envía un mensaje con optimistic update\n   * El mensaje aparece inmediatamente mientras se envía al servidor\n   */\n  async sendMessage(): Promise<void> {\n    const text = this.newMessage().trim();\n    if (!text) return;\n    if (this.blocked()) {\n      this.toastService.warning(\n        'Usuario bloqueado',\n        'Debes desbloquear a este usuario para enviar mensajes.'\n      );\n      return;\n    }\n\n    // Guardar el texto actual por si falla\n    const draft = text;\n\n    this.sending.set(true);\n    this.error.set(null);\n\n    // Stop typing\n    this.stopTyping();\n\n    // Optimistic update: agregar mensaje inmediatamente con ID temporal\n    const optimisticId = `temp-${Date.now()}`;\n    const ctx = this.context();\n    const optimisticMessage: Message = {\n      id: optimisticId,\n      sender_id: this.currentUserId() || '',\n      recipient_id: ctx.recipientId,\n      body: text,\n      created_at: new Date().toISOString(),\n      delivered_at: null,\n      read_at: null,\n      booking_id: ctx.type === 'booking' ? ctx.contextId : null,\n      car_id: ctx.type === 'car' ? ctx.contextId : null,\n    };\n\n    // Agregar optimistic y limpiar input visualmente\n    this.messages.update((prev) => [...prev, optimisticMessage]);\n    this.newMessage.set('');\n\n    try {\n      await this.messagesService.sendMessage({\n        recipientId: ctx.recipientId,\n        body: text,\n        bookingId: ctx.type === 'booking' ? ctx.contextId : undefined,\n        carId: ctx.type === 'car' ? ctx.contextId : undefined,\n      });\n\n      // El mensaje real llegará via realtime subscription y reemplazará al optimistic\n      // Ver subscribeToMessages() para la lógica de deduplicación\n      this.messageSent.emit({ messageId: optimisticId, context: ctx });\n    } catch {\n      // Error: Remover mensaje optimistic\n      this.messages.update((prev) => prev.filter((m) => m.id !== optimisticId));\n      \n      // Restaurar el texto en el input\n      this.newMessage.set(draft);\n      \n      // Mostrar toast\n      this.toastService.error(\n        'Error al enviar', \n        'No pudimos enviar el mensaje. Inténtalo de nuevo.'\n      );\n      this.error.set('No pudimos enviar el mensaje. Intentá de nuevo.');\n    } finally {\n      this.sending.set(false);\n    }\n  }\n\n  /**\n   * Maneja cambios en el draft del mensaje\n   */\n  onMessageDraftChange(value: string): void {\n    this.newMessage.set(value);\n    this.onInputChange();\n  }\n\n  /**\n   * Maneja cambios en el input (para typing indicator)\n   */\n  protected onInputChange(): void {\n    if (!this.currentUserId()) return;\n\n    // Set typing status\n    const ctx = this.context();\n    this.messagesService\n      .setTyping(ctx.contextId, this.currentUserId()!, true, ctx.type)\n      .catch(() => {\n        // Typing is not critical\n      });\n\n    // Clear previous timeout\n    if (this.typingTimeout) {\n      clearTimeout(this.typingTimeout);\n    }\n\n    // Stop typing after 3 seconds of inactivity\n    this.typingTimeout = setTimeout(() => {\n      this.stopTyping();\n    }, 3000);\n  }\n\n  /**\n   * Detiene el indicador de typing\n   */\n  protected stopTyping(): void {\n    if (this.currentUserId()) {\n      const ctx = this.context();\n      this.messagesService\n        .setTyping(ctx.contextId, this.currentUserId()!, false, ctx.type)\n        .catch(() => {\n          // Ignore errors\n        });\n    }\n  }\n\n  /**\n   * Verifica si un mensaje es propio\n   */\n  isOwnMessage(message: Message): boolean {\n    return message.sender_id === this.currentUserId();\n  }\n\n  /**\n   * Obtiene el estado de un mensaje\n   */\n  getMessageStatus(message: Message): 'sent' | 'delivered' | 'read' {\n    if (message.read_at) return 'read';\n    if (message.delivered_at) return 'delivered';\n    return 'sent';\n  }\n\n  /**\n   * Formatea la hora de un mensaje\n   */\n  formatTime(dateStr: string): string {\n    return this.messagesService.formatTime(dateStr);\n  }\n\n  /**\n   * Muestra una notificación temporal\n   */\n  protected showNotification(message: string): void {\n    this.notification.set(message);\n    if (this.notificationTimeout) {\n      clearTimeout(this.notificationTimeout);\n    }\n    this.notificationTimeout = setTimeout(() => {\n      this.notification.set(null);\n    }, 4000);\n  }\n\n  /**\n   * Obtiene el draft del mensaje\n   */\n  get draftMessage(): string {\n    return this.newMessage();\n  }\n\n  /**\n   * Obtiene el subtítulo por defecto según el tipo de chat\n   */\n  protected getDefaultSubtitle(): string {\n    const ctx = this.context();\n    return ctx.type === 'booking' ? 'Conversación sobre reserva' : 'Consulta sobre auto';\n  }\n\n  /**\n   * Obtiene el título del empty state\n   */\n  protected getEmptyStateTitle(): string {\n    const ctx = this.context();\n    return ctx.type === 'booking' ? 'No hay mensajes todavía' : 'Inicia la conversación';\n  }\n\n  /**\n   * Obtiene el subtítulo del empty state\n   */\n  protected getEmptyStateSubtitle(): string {\n    const ctx = this.context();\n    return ctx.type === 'booking'\n      ? 'Envía un mensaje para empezar la conversación'\n      : 'Pregunta sobre disponibilidad, precios o lo que necesites';\n  }\n\n  /**\n   * Obtiene las iniciales del nombre del destinatario\n   */\n  getInitials(): string {\n    const name = this.context().recipientName || '';\n    const parts = name.trim().split(/\\s+/);\n    if (parts.length === 0 || !parts[0]) return '?';\n    if (parts.length === 1) {\n      return parts[0].substring(0, 2).toUpperCase();\n    }\n    return (parts[0][0] + parts[1][0]).toUpperCase();\n  }\n\n  /**\n   * Obtiene la etiqueta de fecha para el separador de conversación\n   */\n  getConversationDateLabel(): string {\n    const msgs = this.messages();\n    if (msgs.length === 0) return 'Hoy';\n\n    const firstMsgDate = new Date(msgs[0].created_at);\n    const now = new Date();\n    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());\n    const msgDay = new Date(firstMsgDate.getFullYear(), firstMsgDate.getMonth(), firstMsgDate.getDate());\n\n    const diffDays = Math.floor((today.getTime() - msgDay.getTime()) / (1000 * 60 * 60 * 24));\n\n    if (diffDays === 0) {\n      return `Hoy ${firstMsgDate.toLocaleTimeString('es-AR', { hour: '2-digit', minute: '2-digit' })}`;\n    } else if (diffDays === 1) {\n      return 'Ayer';\n    } else if (diffDays < 7) {\n      return firstMsgDate.toLocaleDateString('es-AR', { weekday: 'long' });\n    } else {\n      return firstMsgDate.toLocaleDateString('es-AR', { day: 'numeric', month: 'short', year: 'numeric' });\n    }\n  }\n\n  /**\n   * Maneja el click en el menú\n   */\n  protected onMenuClick(): void {\n    this.menuClicked.emit();\n  }\n\n  // ============================================\n  // AI SUGGESTIONS\n  // ============================================\n\n  /**\n   * Toggle para mostrar/ocultar sugerencias\n   */\n  toggleSuggestions(): void {\n    const newState = !this.showSuggestions();\n    this.showSuggestions.set(newState);\n\n    if (newState && this.aiSuggestions().length === 0) {\n      this.loadAiSuggestions();\n    }\n  }\n\n  /**\n   * Carga sugerencias de respuesta usando IA\n   */\n  async loadAiSuggestions(): Promise<void> {\n    const aiContext = this.bookingContextForAI();\n    if (!aiContext) {\n      return;\n    }\n\n    this.loadingSuggestions.set(true);\n    this.aiSuggestions.set([]);\n\n    try {\n      // Convertir mensajes al formato esperado\n      const history = this.messages().slice(-10).map(m => ({\n        role: m.sender_id === this.currentUserId() ? 'user' as const : 'recipient' as const,\n        text: m.body,\n      }));\n\n      const suggestions = await this.geminiService.generateChatSuggestions({\n        conversationHistory: history,\n        userRole: aiContext.userRole,\n        bookingContext: aiContext,\n      });\n\n      this.aiSuggestions.set(suggestions);\n    } catch {\n      this.toastService.error('Error', 'No pudimos generar sugerencias');\n    } finally {\n      this.loadingSuggestions.set(false);\n    }\n  }\n\n  /**\n   * Usa una sugerencia de IA\n   */\n  useSuggestion(suggestion: ChatSuggestion): void {\n    this.newMessage.set(suggestion.text);\n    this.showSuggestions.set(false);\n    this.aiSuggestions.set([]);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/shared/components/bonus-malus-card/bonus-malus-card.component.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`@core/services/payments/bonus-protector.service` import should occur before type import of `../../../core/models`","line":7,"column":1,"nodeType":"ImportDeclaration","endLine":7,"endColumn":89,"fix":{"range":[290,458],"text":"import { BonusProtectorService } from '@core/services/payments/bonus-protector.service';\nimport type { UserBonusMalus, BonusMalusDisplay } from '../../../core/models';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import {Component, OnInit, inject, signal, computed,\n  ChangeDetectionStrategy} from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { IonicModule } from '@ionic/angular';\nimport { BonusMalusService, TierDisplay } from '@core/services/payments/bonus-malus.service';\nimport type { UserBonusMalus, BonusMalusDisplay } from '../../../core/models';\nimport { BonusProtectorService } from '@core/services/payments/bonus-protector.service';\n\n@Component({\n  selector: 'app-bonus-malus-card',\n  standalone: true,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  imports: [CommonModule, IonicModule],\n  templateUrl: './bonus-malus-card.component.html',\n  styles: [`\n    :host { display: block; }\n    .tier-badge {\n      @apply px-3 py-1 rounded-full text-xs font-bold uppercase tracking-wider;\n    }\n  `]\n})\nexport class BonusMalusCardComponent implements OnInit {\n  private readonly bonusMalusService = inject(BonusMalusService);\n  private readonly bonusProtectorService = inject(BonusProtectorService);\n\n  readonly loading = signal(true);\n  readonly bonusMalus = signal<UserBonusMalus | null>(null);\n  readonly tips = signal<string[]>([]);\n  readonly showDetails = signal(false);\n\n  readonly display = computed<BonusMalusDisplay | null>(() => {\n    const bm = this.bonusMalus();\n    if (!bm) return null;\n    return this.bonusMalusService.getBonusMalusDisplay(bm.total_factor);\n  });\n\n  readonly tierDisplay = computed<TierDisplay | null>(() => {\n    const bm = this.bonusMalus();\n    if (!bm || !bm.tier) return null;\n    return this.bonusMalusService.getTierDisplay(bm.tier);\n  });\n\n  readonly depositBenefit = computed(() => {\n    const bm = this.bonusMalus();\n    if (!bm || !bm.tier) return 'Depósito estándar';\n    \n    switch(bm.tier) {\n      case 'elite': return '✨ Sin Depósito';\n      case 'trusted': return '50% OFF en Depósito';\n      default: return 'Depósito estándar';\n    }\n  });\n\n  readonly scorePercentage = computed(() => {\n    const bm = this.bonusMalus();\n    if (!bm) return 50;\n    // Map factor (-0.15 to +0.20) to 0-100 score\n    // -0.15 => 100 (Perfect)\n    // 0.00 => 70 (Good)\n    // +0.20 => 40 (Poor)\n    const factor = bm.total_factor;\n    // Formula aproximada\n    let score = 70 - (factor * 100); \n    return Math.max(0, Math.min(100, score));\n  });\n\n  // NEW: Bonus Protector Signals\n  readonly activeProtector = this.bonusProtectorService.activeProtector;\n  readonly hasActiveProtector = this.bonusProtectorService.hasActiveProtector;\n  readonly isProtectorNearExpiry = this.bonusProtectorService.isNearExpiry;\n  readonly protectorInfoMessage = computed(() => this.bonusProtectorService.getInfoMessage());\n\n  async ngOnInit(): Promise<void> {\n    await Promise.all([this.loadBonusMalus(), this.bonusProtectorService.loadActiveProtector()]);\n  }\n\n  async loadBonusMalus(): Promise<void> {\n    this.loading.set(true);\n    try {\n      const bm = await this.bonusMalusService.getUserBonusMalus();\n      this.bonusMalus.set(bm);\n\n      if (bm) {\n        const tips = await this.bonusMalusService.getImprovementTips();\n        this.tips.set(tips);\n      }\n    } finally {\n      this.loading.set(false);\n    }\n  }\n\n  async recalculate(): Promise<void> {\n    this.loading.set(true);\n    try {\n      await this.bonusMalusService.calculateBonusMalus();\n      await this.loadBonusMalus();\n    } finally {\n      this.loading.set(false);\n    }\n  }\n\n  toggleDetails(): void {\n    this.showDetails.update(v => !v);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/shared/components/booking-chat/booking-chat.component.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`@core/services/auth/auth.service` import should occur before type import of `../../../core/models`","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":64,"fix":{"range":[172,307],"text":"import { AuthService } from '@core/services/auth/auth.service';\nimport type { AiBookingContext, Booking } from '../../../core/models';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { LoggerService } from '@core/services/infrastructure/logger.service';\nimport {Component, computed, inject, input,\n  ChangeDetectionStrategy} from '@angular/core';\n\nimport type { AiBookingContext, Booking } from '../../../core/models';\nimport { AuthService } from '@core/services/auth/auth.service';\nimport { BaseChatComponent, ChatContext } from '../base-chat/base-chat.component';\n\n/**\n * Componente de chat para reservas\n * Wrapper alrededor de BaseChatComponent con contexto de booking\n * Mantiene compatibilidad hacia atrás con inputs individuales\n */\n@Component({\n  selector: 'app-booking-chat',\n  standalone: true,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  imports: [BaseChatComponent],\n  template: `\n    <app-base-chat\n      [context]=\"chatContext()\"\n      [bookingContextForAI]=\"aiContext()\"\n      (messageSent)=\"onMessageSent($event)\"\n      (messageReceived)=\"onMessageReceived($event)\"\n      (menuClicked)=\"onMenuClicked()\"\n    />\n  `,\n})\nexport class BookingChatComponent {\n  private readonly logger = inject(LoggerService);\n  private readonly authService = inject(AuthService);\n\n  // Inputs (compatibilidad hacia atrás)\n  readonly bookingId = input.required<string>();\n  readonly recipientId = input.required<string>();\n  readonly recipientName = input.required<string>();\n  /** Booking completo para contexto de IA (opcional) */\n  readonly booking = input<Booking | null>(null);\n\n  // Computed context para BaseChatComponent\n  readonly chatContext = computed<ChatContext>(() => ({\n    type: 'booking',\n    contextId: this.bookingId(),\n    recipientId: this.recipientId(),\n    recipientName: this.recipientName(),\n    headerSubtitle: 'Conversación sobre reserva',\n  }));\n\n  /**\n   * Computed: Contexto de booking para sugerencias de IA\n   * Retorna null si no hay booking disponible\n   */\n  readonly aiContext = computed<AiBookingContext | null>(() => {\n    const b = this.booking();\n    if (!b) return null;\n\n    const currentUserId = this.authService.session$()?.user?.id;\n    const isOwner = currentUserId === b.owner_id;\n\n    return {\n      bookingId: b.id,\n      status: b.status,\n      startDate: b.start_at || '',\n      endDate: b.end_at || '',\n      carBrand: b.car_brand || b.car?.brand || '',\n      carModel: b.car_model || b.car?.model || '',\n      ownerName: b.owner_name || 'Propietario',\n      renterName: b.renter_name || 'Locatario',\n      userRole: isOwner ? 'owner' : 'renter',\n    };\n  });\n\n  /**\n   * Maneja eventos de mensaje enviado (para analytics)\n   */\n  onMessageSent(event: { messageId: string; context: ChatContext }): void {\n    this.logger.debug('Message sent:', event);\n  }\n\n  /**\n   * Maneja eventos de mensaje recibido (para analytics)\n   */\n  onMessageReceived(event: { message: unknown; context: ChatContext }): void {\n    this.logger.debug('Message received:', event);\n  }\n\n  /**\n   * Maneja click en menú\n   */\n  onMenuClicked(): void {\n    this.logger.debug('Menu clicked');\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/shared/components/booking-confirmation-timeline/booking-confirmation-timeline.component.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`../../../core/models` import should occur after import of `@core/services/bookings/booking-confirmation.service`","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":48,"fix":{"range":[165,376],"text":"import { AuthService } from '@core/services/auth/auth.service';\nimport { BookingConfirmationService } from '@core/services/bookings/booking-confirmation.service';\nimport { Booking } from '../../../core/models';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"\nimport {Component, computed, inject, input, output, Signal,\n  ChangeDetectionStrategy} from '@angular/core';\nimport { TranslateModule } from '@ngx-translate/core';\nimport { Booking } from '../../../core/models';\nimport { AuthService } from '@core/services/auth/auth.service';\nimport { BookingConfirmationService } from '@core/services/bookings/booking-confirmation.service';\n\n/**\n * Timeline step interface\n */\nexport interface TimelineStep {\n  key: string;\n  label: string;\n  description: string;\n  completed: boolean;\n  timestamp: string | null;\n  actor: string | null;\n  actorId: string | null;\n  isConditional?: boolean;\n  requiresAction?: boolean;\n  actionLabel?: string;\n  actionDescription?: string;\n  metadata?: {\n    damageAmount?: number;\n    damageDescription?: string;\n  };\n}\n\n/**\n * BookingConfirmationTimelineComponent\n *\n * Displays the bilateral confirmation timeline for a booking showing:\n * - All 9 stages of the booking lifecycle\n * - Completion status, timestamps, and actors for each step\n * - Action buttons for pending confirmations (role-based)\n * - Real-time updates via signals\n * - Mobile responsive design\n *\n * Usage:\n * ```html\n * <app-booking-confirmation-timeline\n *   [booking]=\"booking()\"\n *   (confirmationRequested)=\"handleConfirmation($event)\"\n * />\n * ```\n */\n@Component({\n  selector: 'app-booking-confirmation-timeline',\n  standalone: true,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  imports: [TranslateModule],\n  templateUrl: './booking-confirmation-timeline.component.html',\n  styleUrl: './booking-confirmation-timeline.component.css',\n})\nexport class BookingConfirmationTimelineComponent {\n  private readonly authService = inject(AuthService);\n  private readonly confirmationService = inject(BookingConfirmationService);\n\n  // ==================== INPUTS ====================\n  /**\n   * Booking data with all confirmation fields\n   */\n  booking = input.required<Booking>();\n\n  /**\n   * Car owner name for display\n   */\n  ownerName = input<string>('el anfitrión');\n\n  /**\n   * Renter name for display\n   */\n  renterName = input<string>('el locatario');\n\n  // ==================== OUTPUTS ====================\n  /**\n   * Emitted when user clicks an action button\n   * Parent component handles the actual confirmation logic\n   */\n  confirmationRequested = output<{\n    action: 'owner_confirm' | 'renter_confirm' | 'mark_returned';\n    bookingId: string;\n  }>();\n\n  // ==================== COMPUTED SIGNALS ====================\n\n  /**\n   * Current authenticated user\n   */\n  private readonly currentUser = computed(() => this.authService.session$()?.user);\n\n  /**\n   * Is current user the booking renter\n   */\n  readonly isRenter = computed(() => {\n    const booking = this.booking();\n    const user = this.currentUser();\n    return booking?.renter_id === user?.id;\n  });\n\n  /**\n   * Is current user the car owner\n   */\n  readonly isOwner = computed(() => {\n    const booking = this.booking();\n    const user = this.currentUser();\n    return booking?.owner_id === user?.id;\n  });\n\n  /**\n   * Timeline steps with completion status and metadata\n   */\n  readonly timelineSteps: Signal<TimelineStep[]> = computed(() => {\n    const booking = this.booking();\n    if (!booking) return [];\n\n    const steps: TimelineStep[] = [\n      // 1. Booking Created\n      {\n        key: 'booking_created',\n        label: 'Reserva Creada',\n        description: 'El locatario solicitó la reserva',\n        completed: !!booking.created_at,\n        timestamp: booking.created_at || null,\n        actor: this.renterName(),\n        actorId: booking.renter_id,\n      },\n\n      // 2. Payment Locked\n      {\n        key: 'payment_locked',\n        label: 'Pago Bloqueado',\n        description: 'Fondos bloqueados en wallet o tarjeta autorizada',\n        completed: !!booking.paid_at || !!booking.wallet_lock_id,\n        timestamp: booking.paid_at || booking.wallet_charged_at || null,\n        actor: this.renterName(),\n        actorId: booking.renter_id,\n      },\n\n      // 3. Car Delivered/Picked Up\n      {\n        key: 'car_delivered',\n        label: 'Vehículo Entregado',\n        description: 'Check-in completado, alquiler iniciado',\n        completed:\n          booking.status === 'in_progress' ||\n          booking.status === 'completed' ||\n          !!booking.returned_at,\n        timestamp: booking.start_at,\n        actor: 'Ambas partes',\n        actorId: null,\n      },\n\n      // 4. Car Returned\n      {\n        key: 'car_returned',\n        label: 'Vehículo Devuelto',\n        description: 'Auto devuelto físicamente',\n        completed: !!booking.returned_at,\n        timestamp: booking.returned_at || null,\n        actor: booking.returned_at\n          ? this.isRenter()\n            ? this.renterName()\n            : this.ownerName()\n          : null,\n        actorId: booking.returned_at ? booking.renter_id : null,\n        requiresAction: !booking.returned_at && booking.status === 'in_progress' && this.isRenter(),\n        actionLabel: 'Marcar como devuelto',\n        actionDescription: 'Confirmar que devolviste el vehículo al propietario',\n      },\n\n      // 5. Owner Confirms Return\n      {\n        key: 'owner_confirms',\n        label: 'Propietario Confirma',\n        description: booking.owner_reported_damages\n          ? `Confirmado con daños reportados ($${booking.owner_damage_amount || 0} USD)`\n          : 'Vehículo recibido en buenas condiciones',\n        completed: !!booking.owner_confirmed_delivery,\n        timestamp: booking.owner_confirmation_at || null,\n        actor: this.ownerName(),\n        actorId: booking.owner_id || null,\n        requiresAction:\n          !!booking.returned_at && !booking.owner_confirmed_delivery && this.isOwner(),\n        actionLabel: 'Confirmar recepción',\n        actionDescription: 'Confirmar que recibiste el vehículo (con o sin daños)',\n        metadata: booking.owner_reported_damages\n          ? {\n              damageAmount: booking.owner_damage_amount || 0,\n              damageDescription: booking.owner_damage_description || undefined,\n            }\n          : undefined,\n      },\n\n      // 6. Damage Report (conditional)\n      {\n        key: 'damage_report',\n        label: 'Reporte de Daños',\n        description: booking.owner_damage_description || 'No se reportaron daños',\n        completed: true, // Always shown if we reach this step\n        timestamp: booking.owner_confirmation_at || null,\n        actor: this.ownerName(),\n        actorId: booking.owner_id || null,\n        isConditional: true, // Only show if damages reported\n        metadata: {\n          damageAmount: booking.owner_damage_amount || 0,\n          damageDescription: booking.owner_damage_description || undefined,\n        },\n      },\n\n      // 7. Renter Confirms Payment\n      {\n        key: 'renter_confirms',\n        label: 'Locatario Confirma',\n        description: 'Confirma liberar el pago al propietario',\n        completed: !!booking.renter_confirmed_payment,\n        timestamp: booking.renter_confirmation_at || null,\n        actor: this.renterName(),\n        actorId: booking.renter_id,\n        requiresAction:\n          !!booking.returned_at && !booking.renter_confirmed_payment && this.isRenter(),\n        actionLabel: 'Confirmar pago',\n        actionDescription: 'Autorizar la liberación de fondos al propietario',\n      },\n\n      // 8. Funds Released\n      {\n        key: 'funds_released',\n        label: 'Fondos Liberados',\n        description: 'Pago transferido al propietario y depósito devuelto',\n        completed: !!booking.funds_released_at,\n        timestamp: booking.funds_released_at || null,\n        actor: 'Sistema automático',\n        actorId: null,\n      },\n\n      // 9. Completed\n      {\n        key: 'completed',\n        label: 'Completado',\n        description: 'Reserva finalizada exitosamente',\n        completed: booking.status === 'completed',\n        timestamp: booking.funds_released_at || booking.updated_at || null,\n        actor: null,\n        actorId: null,\n      },\n    ];\n\n    // Filter out conditional steps if not applicable\n    return steps.filter((step) => {\n      if (step.key === 'damage_report') {\n        return booking.owner_reported_damages === true;\n      }\n      return true;\n    });\n  });\n\n  /**\n   * Current active step index\n   */\n  readonly currentStepIndex = computed(() => {\n    const steps = this.timelineSteps();\n    let lastCompletedIndex = -1;\n    for (let i = steps.length - 1; i >= 0; i--) {\n      if (steps[i].completed) {\n        lastCompletedIndex = i;\n        break;\n      }\n    }\n    return lastCompletedIndex + 1; // Next step is current\n  });\n\n  /**\n   * Is timeline complete\n   */\n  readonly isTimelineComplete = computed(() => {\n    const booking = this.booking();\n    return booking?.status === 'completed' && !!booking.funds_released_at;\n  });\n\n  /**\n   * Pending action message for current user\n   */\n  readonly pendingActionMessage = computed(() => {\n    const booking = this.booking();\n    const isOwner = this.isOwner();\n    const isRenter = this.isRenter();\n\n    if (booking?.completion_status === 'pending_owner' && isOwner) {\n      return 'Esperando tu confirmación como propietario';\n    }\n    if (booking?.completion_status === 'pending_renter' && isRenter) {\n      return 'Esperando tu confirmación como locatario';\n    }\n    if (booking?.completion_status === 'pending_both') {\n      if (isOwner && !booking.owner_confirmed_delivery) {\n        return 'Esperando tu confirmación como propietario';\n      }\n      if (isRenter && !booking.renter_confirmed_payment) {\n        return 'Esperando tu confirmación como locatario';\n      }\n    }\n    return null;\n  });\n\n  // ==================== PUBLIC METHODS ====================\n\n  /**\n   * Format timestamp to human readable date\n   */\n  formatTimestamp(timestamp: string | null): string {\n    if (!timestamp) return 'Pendiente';\n\n    const date = new Date(timestamp);\n    return new Intl.DateTimeFormat('es-AR', {\n      day: '2-digit',\n      month: 'short',\n      year: 'numeric',\n      hour: '2-digit',\n      minute: '2-digit',\n    }).format(date);\n  }\n\n  /**\n   * Handle action button click\n   */\n  handleAction(step: TimelineStep): void {\n    const booking = this.booking();\n    if (!booking) return;\n\n    let action: 'owner_confirm' | 'renter_confirm' | 'mark_returned';\n\n    switch (step.key) {\n      case 'car_returned':\n        action = 'mark_returned';\n        break;\n      case 'owner_confirms':\n        action = 'owner_confirm';\n        break;\n      case 'renter_confirms':\n        action = 'renter_confirm';\n        break;\n      default:\n        return;\n    }\n\n    this.confirmationRequested.emit({\n      action,\n      bookingId: booking.id,\n    });\n  }\n\n  /**\n   * Check if step is completed\n   */\n  isStepCompleted(index: number): boolean {\n    const currentIndex = this.currentStepIndex();\n    return index < currentIndex;\n  }\n\n  /**\n   * Check if step is current\n   */\n  isStepCurrent(index: number): boolean {\n    return index === this.currentStepIndex();\n  }\n\n  /**\n   * Check if step is upcoming\n   */\n  isStepUpcoming(index: number): boolean {\n    const currentIndex = this.currentStepIndex();\n    return index > currentIndex;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/shared/components/car-card/car-card.component.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`../../../core/models` import should occur after import of `@core/services/bookings/urgent-rental.service`","line":18,"column":1,"nodeType":"ImportDeclaration","endLine":18,"endColumn":44,"fix":{"range":[429,931],"text":"import { DynamicPricingService } from '@core/services/payments/dynamic-pricing.service';\nimport { NotificationManagerService } from '@core/services/infrastructure/notification-manager.service';\nimport { RealtimePricingService } from '@core/services/payments/realtime-pricing.service';\nimport { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\nimport { UrgentRentalService } from '@core/services/bookings/urgent-rental.service';\nimport { Car } from '../../../core/models';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { LoggerService } from '@core/services/infrastructure/logger.service';\nimport { CommonModule, NgOptimizedImage } from '@angular/common';\nimport {\n  ChangeDetectionStrategy,\n  ChangeDetectorRef,\n  Component,\n  computed,\n  EventEmitter,\n  inject,\n  Input,\n  OnDestroy,\n  OnInit,\n  Output,\n  signal,\n} from '@angular/core';\nimport { RouterLink } from '@angular/router';\nimport { TranslateModule } from '@ngx-translate/core';\nimport { Car } from '../../../core/models';\nimport { DynamicPricingService } from '@core/services/payments/dynamic-pricing.service';\nimport { NotificationManagerService } from '@core/services/infrastructure/notification-manager.service';\nimport { RealtimePricingService } from '@core/services/payments/realtime-pricing.service';\nimport { injectSupabase } from '@core/services/infrastructure/supabase-client.service';\nimport { UrgentRentalService } from '@core/services/bookings/urgent-rental.service';\nimport { getCarImageUrl } from '../../utils/car-placeholder.util';\n\n@Component({\n  selector: 'app-car-card',\n  standalone: true,\n  imports: [CommonModule, RouterLink, TranslateModule, NgOptimizedImage],\n  templateUrl: './car-card.component.html',\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class CarCardComponent implements OnInit, OnDestroy {\n  private readonly logger = inject(LoggerService);\n  private readonly cdr = inject(ChangeDetectorRef);\n  private readonly pricingService = inject(DynamicPricingService);\n  private readonly realtimePricing = inject(RealtimePricingService);\n  private readonly urgentRentalService = inject(UrgentRentalService);\n  private readonly supabase = injectSupabase();\n\n  protected readonly Math = Math;\n\n  private unsubscribeRealtime?: () => void;\n\n  private readonly _car = signal<Car | undefined>(undefined);\n  private readonly _selected = signal<boolean>(false);\n  private readonly _distance = signal<string | undefined>(undefined);\n  private readonly _isComparing = signal<boolean>(false);\n  private readonly _compareDisabled = signal<boolean>(false);\n  private readonly _showOwnerActions = signal<boolean>(false);\n  private readonly _priority = signal<boolean>(false);\n  private readonly _urgentMode = signal<boolean>(false);\n\n  readonly hourlyPrice = signal<number | null>(null);\n  readonly urgentAvailability = signal<{\n    available: boolean;\n    distance?: number;\n    eta?: number;\n  } | null>(null);\n\n  @Output() compareToggle = new EventEmitter<string>();\n  @Output() edit = new EventEmitter<string>();\n  @Output() delete = new EventEmitter<string>();\n  @Output() toggleAvailability = new EventEmitter<{ id: string; status: string }>();\n\n  readonly dynamicPrice = signal<number | null>(null);\n  readonly priceLoading = signal<boolean>(false);\n  readonly priceSurgeIcon = signal<string>('');\n\n  readonly displayPrice = computed(() => {\n    const dynamic = this.dynamicPrice();\n    const car = this._car();\n    return dynamic !== null ? dynamic : (car?.price_per_day ?? 0);\n  });\n\n  readonly hasValidPrice = computed(() => {\n    const price = this.displayPrice();\n    return Number.isFinite(price) && price > 0;\n  });\n\n  readonly displayTitle = computed(() => {\n    const car = this._car();\n    if (!car) return 'Próximamente';\n    if (car.title && car.title.trim().length > 0) return car.title.trim();\n\n    const parts = [\n      car.brand || car.brand_name || '',\n      car.model || car.model_name || '',\n      car.year || '',\n    ]\n      .map((p) => String(p).trim())\n      .filter(Boolean);\n\n    const fallback = parts.join(' ').trim();\n    return fallback || 'Próximamente';\n  });\n\n  readonly showPriceLoader = computed(() => {\n    return this.priceLoading() && this.dynamicPrice() === null;\n  });\n\n  @Input()\n  set showOwnerActions(value: boolean) {\n    this._showOwnerActions.set(value);\n  }\n\n  get showOwnerActions(): boolean {\n    return this._showOwnerActions();\n  }\n\n  @Input({ required: true })\n  set car(value: Car) {\n    this.logger.debug('🚗 [CarCard] Car set:', {\n      id: value?.id,\n      title: value?.title,\n      region_id: value?.region_id,\n      price: value?.price_per_day,\n      hasRegionId: !!value?.region_id,\n    });\n\n    this._car.set(value);\n\n    if (value?.region_id) {\n      void this.loadDynamicPrice();\n    } else {\n      console.warn('⚠️ [CarCard] No region_id, skipping dynamic pricing');\n    }\n  }\n\n  get car(): Car {\n    return this._car()!;\n  }\n\n  @Input()\n  set selected(value: boolean) {\n    this._selected.set(value);\n  }\n\n  get selected(): boolean {\n    return this._selected();\n  }\n\n  @Input()\n  set distance(value: string | undefined) {\n    this._distance.set(value);\n    this.cdr.markForCheck();\n  }\n\n  get distance(): string | undefined {\n    return this._distance();\n  }\n\n  @Input()\n  set isComparing(value: boolean) {\n    this._isComparing.set(value);\n  }\n\n  get isComparing(): boolean {\n    return this._isComparing();\n  }\n\n  @Input()\n  set compareDisabled(value: boolean) {\n    this._compareDisabled.set(value);\n  }\n\n  get compareDisabled(): boolean {\n    return this._compareDisabled();\n  }\n\n  @Input()\n  set priority(value: boolean) {\n    this._priority.set(value);\n  }\n\n  get priority(): boolean {\n    return this._priority();\n  }\n\n  @Input()\n  set urgentMode(value: boolean) {\n    this._urgentMode.set(value);\n    if (value && this.car) {\n      void this.loadUrgentModeData();\n    }\n  }\n\n  get urgentMode(): boolean {\n    return this._urgentMode();\n  }\n\n  readonly firstPhoto = computed(() => this._car()?.photos?.[0] ?? null);\n\n  readonly displayImage = computed(() => {\n    const car = this._car();\n    if (!car) return null;\n\n    const photos = car.photos || car.car_photos;\n    const url = getCarImageUrl(photos, {\n      brand: car.brand || car.brand_name,\n      model: car.model || car.model_name,\n      year: car.year,\n      id: car.id,\n    });\n\n    return { url, alt: car.title };\n  });\n\n  /**\n   * Verifica si una URL es una imagen Base64\n   * NgOptimizedImage no soporta Base64, así que debemos usar src normal\n   */\n  protected isBase64Image(url: string): boolean {\n    return url.startsWith('data:image');\n  }\n\n  readonly topFeatures = computed(() => {\n    const car = this._car();\n    if (!car?.features) return [];\n\n    const featureLabels: Record<string, string> = {\n      ac: 'Aire acondicionado',\n      bluetooth: 'Bluetooth',\n      gps: 'GPS',\n      usb: 'USB',\n      abs: 'ABS',\n      airbag: 'Airbag',\n      backup_camera: 'Cámara trasera',\n      parking_sensors: 'Sensores de estacionamiento',\n      cruise_control: 'Control crucero',\n      leather_seats: 'Asientos de cuero',\n      sunroof: 'Techo solar',\n      aux_input: 'Entrada auxiliar',\n    };\n\n    const activeFeatures = Object.entries(car.features)\n      .filter(([_, value]) => value === true)\n      .map(([key]) => featureLabels[key] || key)\n      .slice(0, 3);\n\n    return activeFeatures;\n  });\n\n  ngOnInit(): void {\n    if (this.car?.region_id) {\n      void this.loadDynamicPrice();\n      this.subscribeToRealtimePricing();\n    }\n    if (this._urgentMode()) {\n      void this.loadUrgentModeData();\n    }\n  }\n\n  ngOnDestroy(): void {\n    this.unsubscribeRealtime?.();\n  }\n\n  private subscribeToRealtimePricing(): void {\n    const car = this._car();\n    if (!car || !car.region_id) return;\n\n    this.unsubscribeRealtime = this.realtimePricing.subscribeToAllPricingUpdates({\n      onExchangeRateUpdate: () => {\n        void this.loadDynamicPrice();\n      },\n      onDemandUpdate: (regionId) => {\n        if (regionId === car.region_id) {\n          void this.loadDynamicPrice();\n        }\n      },\n      onEventUpdate: () => {\n        void this.loadDynamicPrice();\n      },\n    });\n  }\n\n  private async loadDynamicPrice(): Promise<void> {\n    const car = this._car();\n\n    this.logger.debug('💰 [CarCard] Loading dynamic price for:', {\n      carId: car?.id,\n      carTitle: car?.title,\n      regionId: car?.region_id,\n      staticPrice: car?.price_per_day,\n    });\n\n    if (!car || !car.region_id) {\n      console.warn('⚠️ [CarCard] Cannot load dynamic price: missing car or region_id');\n      return;\n    }\n\n    this.priceLoading.set(true);\n    this.cdr.markForCheck();\n\n    try {\n      const {\n        data: { user },\n      } = await this.supabase.auth.getUser();\n      const userId = user?.id || '00000000-0000-0000-0000-000000000000';\n\n      this.logger.debug('🔍 [CarCard] Calling calculate_dynamic_price RPC with:', {\n        regionId: car.region_id,\n        userId,\n      });\n\n      const { data, error } = await this.supabase.rpc('calculate_dynamic_price', {\n        p_region_id: car.region_id,\n        p_user_id: userId,\n        p_rental_start: new Date().toISOString(),\n        p_rental_hours: 24,\n      });\n\n      if (error) {\n        console.error('❌ [CarCard] RPC error:', error);\n        throw error;\n      }\n\n      this.logger.debug('✅ [CarCard] RPC response:', data);\n\n      if (data && data.total_price) {\n        const dynamicPricePerDay = data.total_price;\n        this.dynamicPrice.set(dynamicPricePerDay);\n        this.logger.debug(\n          `💰 [CarCard] Dynamic price set: $${dynamicPricePerDay} (was $${car.price_per_day})`,\n        );\n\n        if (data.surge_active || dynamicPricePerDay > car.price_per_day * 1.2) {\n          this.priceSurgeIcon.set('🔥');\n        }\n\n        this.cdr.detectChanges();\n      }\n    } catch (_error) {\n      console.error('❌ [CarCard] Error loading dynamic price:', _error);\n    } finally {\n      this.priceLoading.set(false);\n      this.cdr.markForCheck();\n    }\n  }\n\n  private readonly notificationManager = inject(NotificationManagerService);\n\n  onCompareToggle(event: Event): void {\n    event.stopPropagation();\n    event.preventDefault();\n    if (!this.compareDisabled || this.isComparing) {\n      this.compareToggle.emit(this.car.id);\n    } else {\n      this.notificationManager.warning('Límite alcanzado', 'Solo puedes comparar hasta 3 autos');\n    }\n  }\n\n  onEdit(event: Event): void {\n    event.stopPropagation();\n    event.preventDefault();\n    this.edit.emit(this.car.id);\n  }\n\n  onDelete(event: Event): void {\n    event.stopPropagation();\n    event.preventDefault();\n    this.delete.emit(this.car.id);\n  }\n\n  onToggleAvailability(event: Event): void {\n    event.stopPropagation();\n    event.preventDefault();\n    this.toggleAvailability.emit({\n      id: this.car.id,\n      status: this.car.status,\n    });\n  }\n\n  formatDistance(km: number): string {\n    return this.urgentRentalService.formatDistance(km);\n  }\n\n  private async loadUrgentModeData(): Promise<void> {\n    const car = this._car();\n    if (!car || !car.region_id) return;\n\n    try {\n      // Cargar precio por hora\n      const quote = await this.urgentRentalService.getUrgentQuote(car.id, car.region_id, 1);\n      this.hourlyPrice.set(quote.hourlyRate);\n\n      // Verificar disponibilidad inmediata\n      const availability = await this.urgentRentalService.checkImmediateAvailability(car.id);\n      this.urgentAvailability.set({\n        available: availability.available,\n        distance: availability.distance,\n        eta: availability.eta,\n      });\n\n      this.cdr.markForCheck();\n    } catch (_error) {\n      console.error('Error loading urgent mode data:', _error);\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/shared/components/cars-map/cars-map.component.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`../../../../environments/environment` import should occur after import of `@core/services/geo/mapbox-preloader.service`","line":26,"column":1,"nodeType":"ImportDeclaration","endLine":26,"endColumn":68,"fix":{"range":[479,802],"text":"import type { CarMapLocation } from '@core/services/cars/car-locations.service';\nimport { MapboxDirectionsService } from '@core/services/geo/mapbox-directions.service';\nimport { MapboxPreloaderService } from '@core/services/geo/mapbox-preloader.service';\nimport { environment } from '../../../../environments/environment';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { LoggerService } from '@core/services/infrastructure/logger.service';\nimport { isPlatformBrowser } from '@angular/common';\nimport {\n  AfterViewInit,\n  ApplicationRef,\n  ChangeDetectionStrategy,\n  Component,\n  ComponentRef,\n  computed,\n  createComponent,\n  ElementRef,\n  EnvironmentInjector,\n  EventEmitter,\n  inject,\n  Input,\n  OnChanges,\n  OnDestroy,\n  OnInit,\n  Output,\n  PLATFORM_ID,\n  signal,\n  SimpleChanges,\n  ViewChild,\n  ViewEncapsulation\n} from '@angular/core';\nimport { environment } from '../../../../environments/environment';\nimport type { CarMapLocation } from '@core/services/cars/car-locations.service';\nimport { MapboxDirectionsService } from '@core/services/geo/mapbox-directions.service';\nimport { MapboxPreloaderService } from '@core/services/geo/mapbox-preloader.service';\nimport { EnhancedMapTooltipComponent } from '../enhanced-map-tooltip/enhanced-map-tooltip.component';\nimport type { BookingFormData } from '../map-booking-panel/map-booking-panel.component';\nimport { MapBookingPanelComponent } from '../map-booking-panel/map-booking-panel.component';\nimport { MapDetailsPanelComponent } from '../map-details-panel/map-details-panel.component';\nimport {\n  MapLayersControlComponent,\n  type MapLayer,\n} from '../map-layers-control/map-layers-control.component';\nimport { MapMarkerComponent } from '../map-marker/map-marker.component';\n\ntype MapboxGL = typeof import('mapbox-gl').default;\ntype MapboxMap = import('mapbox-gl').Map;\ntype MapboxMarker = import('mapbox-gl').Marker;\ntype MapboxPopup = import('mapbox-gl').Popup;\ntype MapboxGeoJSONSource = import('mapbox-gl').GeoJSONSource;\ntype MapLayerMouseEvent = import('mapbox-gl').MapLayerMouseEvent;\ntype MapboxErrorEvent = import('mapbox-gl').ErrorEvent;\ntype MapboxGeoJSONFeature = import('mapbox-gl').MapboxGeoJSONFeature;\n\ntype MapboxErrorDetails = MapboxErrorEvent & {\n  status?: number;\n  error?: (Error & { status?: number }) | undefined;\n};\n\n/**\n * MAPBOX 10K+ CARS OPTIMIZATION\n * ===============================\n * This component is optimized to handle 10,000+ cars efficiently following Mapbox recommendations.\n *\n * Key optimizations implemented:\n * - Clustering: clusterMaxZoom=14, clusterRadius=50 (Mapbox recommended)\n * - GeoJSON: maxzoom=12, buffer=0, tolerance=0.375 (optimal for points)\n * - Coordinate precision: 6 decimals (~11cm accuracy) for smaller payload\n * - Feature-state: generateId=true for efficient hover/selection updates\n * - Performance: Supercluster handles 400K points at these settings\n *\n * Expected performance with 10K cars:\n * - Initial load: < 2s\n * - Cluster render: < 100ms\n * - 60fps panning/zooming\n * - Memory usage: < 150MB\n *\n * See: docs/guides/performance/MAPBOX_10K_CARS_OPTIMIZATION.md\n */\n\n/**\n * Simple QuadTree implementation for spatial indexing\n */\nclass QuadTree {\n  private bounds: { x: number; y: number; width: number; height: number };\n  private capacity: number;\n  private points: CarMapLocation[] = [];\n  private divided = false;\n  private northeast?: QuadTree;\n  private northwest?: QuadTree;\n  private southeast?: QuadTree;\n  private southwest?: QuadTree;\n\n  constructor(bounds: { x: number; y: number; width: number; height: number }, capacity = 4) {\n    this.bounds = bounds;\n    this.capacity = capacity;\n  }\n\n  insert(point: CarMapLocation): boolean {\n    if (!this.contains(point)) {\n      return false;\n    }\n\n    if (this.points.length < this.capacity) {\n      this.points.push(point);\n      return true;\n    }\n\n    if (!this.divided) {\n      this.subdivide();\n    }\n\n    return (\n      this.northeast!.insert(point) ||\n      this.northwest!.insert(point) ||\n      this.southeast!.insert(point) ||\n      this.southwest!.insert(point)\n    );\n  }\n\n  query(range: { x: number; y: number; width: number; height: number }): CarMapLocation[] {\n    const found: CarMapLocation[] = [];\n\n    if (!this.intersects(range)) {\n      return found;\n    }\n\n    for (const point of this.points) {\n      if (this.pointInRange(point, range)) {\n        found.push(point);\n      }\n    }\n\n    if (this.divided) {\n      found.push(...this.northeast!.query(range));\n      found.push(...this.northwest!.query(range));\n      found.push(...this.southeast!.query(range));\n      found.push(...this.southwest!.query(range));\n    }\n\n    return found;\n  }\n\n  private contains(point: CarMapLocation): boolean {\n    return (\n      point.lng >= this.bounds.x &&\n      point.lng <= this.bounds.x + this.bounds.width &&\n      point.lat >= this.bounds.y &&\n      point.lat <= this.bounds.y + this.bounds.height\n    );\n  }\n\n  private intersects(range: { x: number; y: number; width: number; height: number }): boolean {\n    return !(\n      range.x > this.bounds.x + this.bounds.width ||\n      range.x + range.width < this.bounds.x ||\n      range.y > this.bounds.y + this.bounds.height ||\n      range.y + range.height < this.bounds.y\n    );\n  }\n\n  private pointInRange(\n    point: CarMapLocation,\n    range: { x: number; y: number; width: number; height: number },\n  ): boolean {\n    return (\n      point.lng >= range.x &&\n      point.lng <= range.x + range.width &&\n      point.lat >= range.y &&\n      point.lat <= range.y + range.height\n    );\n  }\n\n  private subdivide(): void {\n    const x = this.bounds.x;\n    const y = this.bounds.y;\n    const w = this.bounds.width / 2;\n    const h = this.bounds.height / 2;\n\n    this.northeast = new QuadTree({ x: x + w, y: y, width: w, height: h }, this.capacity);\n    this.northwest = new QuadTree({ x, y, width: w, height: h }, this.capacity);\n    this.southeast = new QuadTree({ x: x + w, y: y + h, width: w, height: h }, this.capacity);\n    this.southwest = new QuadTree({ x, y: y + h, width: w, height: h }, this.capacity);\n\n    this.divided = true;\n  }\n}\n\n@Component({\n  selector: 'app-cars-map',\n  standalone: true,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  imports: [\n    MapBookingPanelComponent,\n    MapDetailsPanelComponent,\n    MapLayersControlComponent\n  ],\n  templateUrl: './cars-map.component.html',\n  styleUrls: ['./cars-map.component.css'],\n  encapsulation: ViewEncapsulation.None,\n})\nexport class CarsMapComponent implements OnInit, AfterViewInit, OnDestroy, OnChanges {\n  private readonly logger = inject(LoggerService);\n  @ViewChild('mapContainer') mapContainer!: ElementRef<HTMLDivElement>;\n\n  @Input() cars: CarMapLocation[] = [];\n  @Input() selectedCarId: string | null = null;\n  @Input() userLocation: { lat: number; lng: number } | null = null;\n  @Input() userAvatarUrl: string | null = null; // URL del avatar del usuario para el marcador de ubicación\n  @Input() locationMode: 'searching' | 'booking-confirmed' | 'default' = 'default';\n  @Input() searchRadiusKm: number = 5;\n  @Input() showSearchRadius: boolean = true;\n  @Input() showDeliveryIsochrone: boolean = false; // Show isochrone for selected car delivery area\n  @Input() deliveryTimeMinutes: number = 30; // Default delivery time for isochrone\n  @Input() showDirectionsRoute: boolean = false; // Show turn-by-turn route to selected car\n  @Input() followUserLocation: boolean = false;\n  @Input() lockZoomRotation: boolean = false;\n  @Input() locationAccuracy?: number; // Precisión GPS en metros\n  @Input() lastLocationUpdate?: Date; // Última actualización de ubicación\n  @Input() markerVariant: 'photo' | 'price' = 'photo'; // Change default to 'photo'\n\n  @Output() readonly carSelected = new EventEmitter<string>();\n  @Output() readonly userLocationChange = new EventEmitter<{ lat: number; lng: number }>();\n  @Output() readonly quickBook = new EventEmitter<string>();\n  @Output() readonly searchRadiusChange = new EventEmitter<number>();\n  @Output() readonly followLocationToggle = new EventEmitter<boolean>();\n  @Output() readonly lockToggle = new EventEmitter<boolean>();\n  @Output() readonly bookingConfirmed = new EventEmitter<{\n    carId: string;\n    bookingData: BookingFormData;\n  }>();\n  @Output() readonly boundsChange = new EventEmitter<{\n    north: number;\n    south: number;\n    east: number;\n    west: number;\n  }>();\n\n  private readonly platformId = inject(PLATFORM_ID);\n  private readonly isBrowser = isPlatformBrowser(this.platformId);\n  private readonly applicationRef = inject(ApplicationRef);\n  private readonly injector = inject(EnvironmentInjector);\n  private readonly directionsService = inject(MapboxDirectionsService);\n  private readonly mapboxPreloader = inject(MapboxPreloaderService);\n\n  readonly loading = signal(true);\n  readonly error = signal<string | null>(null);\n  readonly bookingPanelOpen = signal(false);\n  readonly selectedCarForBooking = signal<CarMapLocation | null>(null);\n  readonly selectedCar = signal<CarMapLocation | null>(null);\n  readonly viewMode = signal<'map' | 'list'>('map');\n\n  // Map Layers Control\n  readonly showBaseMap = signal(true);\n  readonly showUserLocation = signal(true);\n  readonly showMarketplaceCars = signal(true);\n\n  readonly mapLayers = computed<MapLayer[]>(() => [\n    {\n      id: 'base-map',\n      label: 'Mapa Base',\n      icon: '🗺️',\n      visible: this.showBaseMap(),\n      enabled: true,\n    },\n    {\n      id: 'user-location',\n      label: 'Ubicación Central',\n      icon: '📍',\n      visible: this.showUserLocation(),\n      enabled: !!this.userLocation,\n    },\n    {\n      id: 'marketplace-cars',\n      label: 'Autos del Marketplace',\n      icon: '🚗',\n      visible: this.showMarketplaceCars(),\n      enabled: this.cars.length > 0,\n    },\n  ]);\n\n  // Expose map instance for external components\n  get mapInstance(): MapboxMap | null {\n    return this.map;\n  }\n\n  /**\n   * Fly to a specific location\n   */\n  flyTo(location: { lat: number; lng: number }, zoom = 15): void {\n    if (this.map) {\n      this.map.flyTo({\n        center: [location.lng, location.lat],\n        zoom,\n        essential: true,\n      });\n    }\n  }\n\n  private mapboxgl: MapboxGL | null = null;\n  private map: MapboxMap | null = null;\n  private carMarkers = new Map<\n    string,\n    { marker: MapboxMarker; componentRef: ComponentRef<MapMarkerComponent> }\n  >();\n  private userLocationMarker: MapboxMarker | null = null;\n  private tooltipPopups = new Map<string, MapboxPopup>();\n  private tooltipComponents = new Map<string, ComponentRef<EnhancedMapTooltipComponent>>();\n  private hoverTimeouts = new Map<string, ReturnType<typeof setTimeout>>();\n  private hideTimeouts = new Map<string, ReturnType<typeof setTimeout>>();\n  public useClustering = true; // Enable clustering by default - public for template access\n  private clusterSourceId = 'cars-cluster-source';\n  private clusterLayerId = 'cars-cluster-layer';\n  private clusterCountLayerId = 'cars-cluster-count';\n  // Mapbox optimization: Clustering is efficient for 10K+ cars (Supercluster handles 400K)\n  public clusteringThreshold = 50; // Activate clustering at 50+ cars - public for template access\n  private virtualizationThreshold = 1000; // Only virtualize if NOT clustering (10K+ without clustering)\n  private viewportBuffer = 0.1; // 10% buffer around viewport for smoother experience\n  private maxVisibleMarkers = 500; // Increased for better 10K+ experience when not clustering\n  private visibleCarIds = new Set<string>(); // Track currently visible cars\n  private pendingUpdate: number | null = null; // For debounced updates\n  private spatialIndex: QuadTree | null = null; // Spatial index for efficient queries\n\n  // Component pools for memory management\n  private markerComponentPool: ComponentRef<MapMarkerComponent>[] = [];\n  private tooltipComponentPool: ComponentRef<EnhancedMapTooltipComponent>[] = [];\n  private hasWarmedMarkerPool = false;\n  private maxPoolSize = 100; // Maximum components to keep in pool\n\n  // User location tracking\n  private searchRadiusSourceId = 'search-radius-source';\n  private searchRadiusLayerId = 'search-radius-layer';\n  private isochroneSourceId = 'delivery-isochrone-source';\n  private isochroneLayerId = 'delivery-isochrone-layer';\n  private isochroneOutlineLayerId = 'delivery-isochrone-outline-layer';\n  private routeSourceId = 'directions-route-source';\n  private routeLayerId = 'directions-route-layer';\n  private routeOutlineLayerId = 'directions-route-outline-layer';\n  private followLocationInterval: ReturnType<typeof setInterval> | null = null;\n  private isDarkMode = signal(false);\n  private circleSizeMultiplier = signal(1.0); // Para ajustar tamaño del círculo\n\n  ngOnInit(): void {\n    if (!this.isBrowser) {\n      this.loading.set(false);\n      return;\n    }\n\n    // Detectar modo oscuro\n    this.detectDarkMode();\n\n    // Escuchar cambios de tema\n    if (this.isBrowser) {\n      const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');\n      mediaQuery.addEventListener('change', () => this.detectDarkMode());\n    }\n  }\n\n  private detectDarkMode(): void {\n    if (!this.isBrowser) return;\n    const isDark =\n      window.matchMedia('(prefers-color-scheme: dark)').matches ||\n      document.documentElement.classList.contains('dark');\n    this.isDarkMode.set(isDark);\n    this.updateMarkerStyles();\n    this.updateMapTheme();\n  }\n\n  /**\n   * Helper to get CSS variable value\n   */\n  private getCssVariableValue(variableName: string, defaultValue: string): string {\n    if (!this.isBrowser) return defaultValue;\n    return (\n      getComputedStyle(document.documentElement).getPropertyValue(variableName).trim() ||\n      defaultValue\n    );\n  }\n\n  /**\n   * Get light preset based on current time of day\n   * Returns: 'dawn', 'day', 'dusk', or 'night'\n   */\n  private getTimeBasedLightPreset(): 'dawn' | 'day' | 'dusk' | 'night' {\n    const hour = new Date().getHours();\n\n    if (hour >= 6 && hour < 11) return 'dawn'; // 6am - 11am: Amanecer\n    if (hour >= 11 && hour < 18) return 'day'; // 11am - 6pm: Día\n    if (hour >= 18 && hour < 21) return 'dusk'; // 6pm - 9pm: Atardecer\n    return 'night'; // 9pm - 6am: Noche\n  }\n\n  /**\n   * Update map theme based on time of day and marker variant\n   * Uses Mapbox Standard style configuration for native theme support\n   */\n  private updateMapTheme(): void {\n    if (!this.isBrowser) return;\n\n    const lightPreset = this.getTimeBasedLightPreset();\n    const variant = this.markerVariant;\n\n    // Update Mapbox Standard style theme\n    if (this.map && this.map.isStyleLoaded()) {\n      try {\n        this.map.setConfigProperty('basemap', 'lightPreset', lightPreset);\n\n        // No need for canvas filters with Standard style - it handles theming natively\n      } catch (error) {\n        console.warn('[CarsMap] Could not update theme, falling back to canvas filter', error);\n        // Fallback for older Mapbox versions or non-Standard styles\n        const canvas = this.map.getCanvas();\n        if (canvas) {\n          const isDark = lightPreset === 'night' || lightPreset === 'dusk';\n          const brightness = isDark ? '0.95' : '1';\n          const contrast = isDark ? '1.1' : '1';\n          const saturate = isDark ? '0.95' : '1';\n          canvas.style.filter = `brightness(${brightness}) contrast(${contrast}) saturate(${saturate})`;\n        }\n      }\n    }\n\n    // Ensure container has correct classes (template binding handles this, but we verify)\n    const container = this.mapContainer?.nativeElement?.parentElement;\n    if (container) {\n      // Remove old variant classes\n      container.classList.remove('map-variant-photo', 'map-variant-price');\n      // Add current variant class\n      container.classList.add(`map-variant-${variant}`);\n\n      // Apply dark mode class for night/dusk themes\n      const isDark = lightPreset === 'night' || lightPreset === 'dusk';\n      if (isDark) {\n        container.classList.add('dark');\n      } else {\n        container.classList.remove('dark');\n      }\n    }\n  }\n\n  async ngAfterViewInit(): Promise<void> {\n    if (!this.isBrowser || !this.mapContainer) {\n      return;\n    }\n\n    await this.initializeMap();\n  }\n\n  ngOnDestroy(): void {\n    this.cleanup();\n  }\n\n  /**\n   * Initialize Mapbox map with neutral light style\n   * Uses preloaded Mapbox GL module if available for faster initialization\n   */\n  private async initializeMap(): Promise<void> {\n    try {\n      this.loading.set(true);\n\n      // Check if we have a preloaded Mapbox GL module (from MapboxPreloaderService)\n      const preloadedMapboxGL = this.mapboxPreloader.getMapboxGL();\n\n      if (preloadedMapboxGL) {\n        this.logger.debug('[CarsMap] Using preloaded Mapbox GL module - faster initialization!');\n        this.mapboxgl = preloadedMapboxGL;\n      } else {\n        // Fallback: Lazy load Mapbox GL if not preloaded\n        this.logger.debug('[CarsMap] Mapbox GL not preloaded, loading dynamically...');\n        const mapboxModule = await import('mapbox-gl');\n        this.mapboxgl = mapboxModule.default;\n      }\n\n      if (!this.mapboxgl) {\n        throw new Error('Mapbox GL library failed to load');\n      }\n\n      // Validate Mapbox access token\n      if (!environment.mapboxAccessToken || environment.mapboxAccessToken.trim() === '') {\n        throw new Error(\n          'Mapbox access token no configurado. Por favor, configura NG_APP_MAPBOX_ACCESS_TOKEN en .env.local',\n        );\n      }\n\n      // Validate token format (should start with 'pk.')\n      if (!environment.mapboxAccessToken.startsWith('pk.')) {\n        throw new Error(\n          'Token de Mapbox inválido. El token debe comenzar con \"pk.\" y ser un Public Access Token válido.',\n        );\n      }\n\n      this.mapboxgl.accessToken = environment.mapboxAccessToken;\n\n      // Get initial light preset based on current time\n      const initialLightPreset = this.getTimeBasedLightPreset();\n\n      // Initialize map with Mapbox Standard style (v12+ with theme support)\n      this.map = new this.mapboxgl.Map({\n        container: this.mapContainer.nativeElement,\n        style: 'mapbox://styles/mapbox/standard', // Modern Standard style with theme support\n        center: [-58.3816, -34.6037], // Buenos Aires center\n        zoom: 14, // Standard zoom level for car marketplace\n        maxBounds: [\n          [-58.8, -34.9], // Southwest\n          [-57.9, -34.3], // Northeast\n        ],\n        // Mapbox Standard configuration - OPTIMIZED for car marketplace\n        config: {\n          basemap: {\n            lightPreset: initialLightPreset, // Auto-detect based on time: 'day', 'dusk', 'dawn', 'night'\n            showPointOfInterestLabels: false, // Hide restaurants, hotels, shops (performance + cleaner)\n            showTransitLabels: false, // Hide transit for cleaner car-focused map\n            showPlaceLabels: true, // Keep neighborhood/area names\n            showRoadLabels: true, // Keep street names (essential for car location)\n            show3dObjects: false, // Disabled for better performance\n          },\n        },\n        // 2D View Configuration - Optimized for performance\n        pitch: 0, // Flat 2D view (no 3D angle)\n        bearing: 0, // North-up orientation\n        antialias: false, // Disabled for better performance\n        // Disable 3D interactions for faster rendering\n        dragRotate: false, // Disable rotation drag\n        pitchWithRotate: false, // Disable pitch on rotate\n        touchPitch: false, // Disable touch pitch gestures\n      });\n\n      // Add navigation controls (zoom + compass)\n      this.map.addControl(new this.mapboxgl.NavigationControl(), 'top-right');\n\n      // Wait for map to load\n      this.map.on('load', () => {\n        try {\n          this.loading.set(false);\n          this.updateMapTheme(); // Apply theme on load\n          this.updateMarkersBasedOnCount();\n          this.setupViewportChangeListener();\n          this.addUserLocationMarker();\n          if (this.showSearchRadius) {\n            this.addSearchRadiusLayer();\n          }\n          this.setupFollowLocation();\n          this.setupLockControls();\n\n          // Emit initial bounds\n          this.emitBounds();\n\n          // Listen for move end to emit bounds\n          if (this.map) {\n            this.map.on('moveend', () => {\n              this.emitBounds();\n            });\n          }\n\n          // Pre-warm component pool during idle time for better performance\n          this.preWarmComponentPoolDuringIdle();\n        } catch (err) {\n          console.error('[CarsMap] Error during post-load setup:', err);\n          const message = err instanceof Error ? err['message'] : String(err);\n          this['error'].set(message || 'Error al inicializar el mapa');\n          this.loading.set(false);\n        }\n      });\n\n      // Handle map errors\n      this.map.on('error', (event: MapboxErrorDetails) => {\n        console.error('[CarsMap] Map error:', event);\n\n        const errorStatus =\n          (event['error'] && 'status' in event['error'] ? event['error']['status'] : undefined) ?? event['status'];\n        const errorMessage =\n          (event['error'] && event['error']['message']) || ('message' in event ? event['message'] : '');\n\n        if (\n          errorStatus === 401 ||\n          (typeof errorMessage === 'string' && errorMessage.includes('401'))\n        ) {\n          this['error'].set(\n            'Token de Mapbox inválido o expirado. Por favor, verifica tu NG_APP_MAPBOX_ACCESS_TOKEN en .env.local',\n          );\n        } else if (event['error']?.['message']) {\n          this['error'].set(`Error al cargar el mapa: ${event['error']['message']}`);\n        } else {\n          this['error'].set(\n            'Error al cargar el mapa. Por favor, verifica tu conexión e intenta nuevamente.',\n          );\n        }\n\n        this.loading.set(false);\n      });\n    } catch (err) {\n      console.error('[CarsMap] Initialization error:', err);\n      const errorMessage = err instanceof Error ? err['message'] : String(err);\n\n      if (errorMessage.includes('WebGL')) {\n        this['error'].set('El mapa requiere aceleración de hardware (WebGL). Por favor, actívala en tu navegador.');\n      } else {\n        this['error'].set(errorMessage || 'Error al inicializar el mapa');\n      }\n      this.loading.set(false);\n    }\n  }\n\n  /**\n   * Setup clustering for car markers\n   * Optimized for 10,000+ cars following Mapbox recommendations\n   */\n  private setupClustering(): void {\n    if (!this.map || !this.mapboxgl) return;\n\n    // Remove existing markers\n    this.clearMarkers();\n\n    // Create GeoJSON source from cars with optimized coordinate precision\n    const features = this.cars.map((car) => ({\n      type: 'Feature' as const,\n      geometry: {\n        type: 'Point' as const,\n        // Limit to 6 decimal places (~11cm accuracy) for smaller payload\n        coordinates: [parseFloat(car.lng.toFixed(6)), parseFloat(car.lat.toFixed(6))],\n      },\n      properties: {\n        carId: car['carId'],\n        title: car['title'],\n        pricePerDay: car.pricePerDay,\n        currency: car['currency'] || 'ARS',\n        photoUrl: car.photoUrl,\n        availabilityStatus: car.availabilityStatus || 'available',\n      },\n    }));\n\n    // Add source with Mapbox-recommended optimizations\n    const existingClusterSource = this.map.getSource(this.clusterSourceId) as\n      | MapboxGeoJSONSource\n      | undefined;\n\n    if (existingClusterSource) {\n      existingClusterSource.setData({\n        type: 'FeatureCollection',\n        features,\n      });\n    } else {\n      this.map.addSource(this.clusterSourceId, {\n        type: 'geojson',\n        data: {\n          type: 'FeatureCollection',\n          features,\n        },\n        cluster: true,\n        // Mapbox recommendation for 10K+ points\n        clusterMaxZoom: 14, // Don't cluster beyond zoom 14\n        clusterRadius: 50, // 50px radius for optimal clustering\n        clusterProperties: {\n          sum: ['+', ['get', 'pricePerDay']],\n          count: ['+', 1],\n        },\n        // GeoJSON optimization for points (Mapbox recommendation)\n        maxzoom: 12, // Limit tile generation to zoom 12 for points\n        buffer: 0, // No buffer needed for simple points\n        tolerance: 0.375, // Balance precision vs performance\n        generateId: true, // Enable efficient feature-state updates\n      });\n    }\n\n    // Resolve colors from CSS variables\n    const colorAvailable = this.getCssVariableValue('--map-marker-available-color', '#9db38b'); // Olive\n    const colorSoon = this.getCssVariableValue('--map-marker-soon-available-color', '#c4a882'); // Beige\n    const colorInUse = this.getCssVariableValue('--map-marker-in-use-color', '#4e4e4e'); // Gray\n    const colorUnavailable = this.getCssVariableValue('--map-marker-unavailable-color', '#b25e5e'); // Rust\n\n    // Add cluster circles layer\n    if (!this.map.getLayer(this.clusterLayerId)) {\n      this.map.addLayer({\n        id: this.clusterLayerId,\n        type: 'circle',\n        source: this.clusterSourceId,\n        filter: ['has', 'point_count'],\n        paint: {\n          'circle-color': [\n            'step',\n            ['get', 'point_count'],\n            colorAvailable, // Green for available\n            5,\n            colorSoon, // Amber for medium clusters\n            20,\n            colorInUse, // Neutral/Blue for large clusters\n          ],\n          'circle-radius': ['step', ['get', 'point_count'], 20, 5, 30, 20, 40, 50, 50],\n          'circle-stroke-width': 2,\n          'circle-stroke-color': 'var(--surface-primary, #ffffff)',\n          'circle-opacity': 0.8,\n        },\n      });\n    }\n\n    // Add cluster count labels\n    if (!this.map.getLayer(this.clusterCountLayerId)) {\n      this.map.addLayer({\n        id: this.clusterCountLayerId,\n        type: 'symbol',\n        source: this.clusterSourceId,\n        filter: ['has', 'point_count'],\n        layout: {\n          'text-field': '{point_count_abbreviated}',\n          'text-font': ['Open Sans Semibold', 'Arial Unicode MS Bold'],\n          'text-size': 12,\n        },\n        paint: {\n          'text-color': 'var(--surface-primary, #ffffff)',\n        },\n      });\n    }\n\n    // Add unclustered points (individual cars)\n    if (!this.map.getLayer('cars-unclustered')) {\n      this.map.addLayer({\n        id: 'cars-unclustered',\n        type: 'circle',\n        source: this.clusterSourceId,\n        filter: ['!', ['has', 'point_count']],\n        paint: {\n          'circle-color': [\n            'case',\n            ['==', ['get', 'availabilityStatus'], 'available'],\n            colorAvailable,\n            ['==', ['get', 'availabilityStatus'], 'soon_available'],\n            colorSoon,\n            ['==', ['get', 'availabilityStatus'], 'in_use'],\n            colorInUse,\n            colorUnavailable, // unavailable\n          ],\n          'circle-radius': 8,\n          'circle-stroke-width': 2,\n          'circle-stroke-color': 'var(--surface-primary, #ffffff)',\n          'circle-opacity': ['case', ['==', ['get', 'availabilityStatus'], 'unavailable'], 0.5, 1],\n        },\n      });\n    }\n\n    // Handle cluster clicks\n    this.map.on('click', this.clusterLayerId, (event: MapLayerMouseEvent) => {\n      if (!this.map) return;\n\n      const features = this.map.queryRenderedFeatures(event.point, {\n        layers: [this.clusterLayerId],\n      }) as MapboxGeoJSONFeature[];\n\n      if (!features.length) {\n        return;\n      }\n\n      const properties = (features[0].properties || {}) as Record<string, unknown>;\n      const clusterId =\n        typeof properties['cluster_id'] === 'number' ? (properties['cluster_id'] as number) : undefined;\n\n      if (clusterId === undefined) {\n        return;\n      }\n\n      const source = this.map.getSource(this.clusterSourceId) as MapboxGeoJSONSource | undefined;\n      if (!source) {\n        return;\n      }\n\n      source.getClusterExpansionZoom(clusterId, (err, zoom) => {\n        if (err || zoom === null || zoom === undefined) return;\n        this.map?.easeTo({\n          center: event.lngLat,\n          zoom,\n        });\n      });\n    });\n\n    // Handle individual car clicks\n    this.map.on('click', 'cars-unclustered', (event: MapLayerMouseEvent) => {\n      const carFeature = event.features?.[0] as MapboxGeoJSONFeature | undefined;\n      const properties = (carFeature?.properties || {}) as Record<string, unknown>;\n      const carId = typeof properties['carId'] === 'string' ? (properties['carId'] as string) : undefined;\n      if (carId) {\n        this.carSelected.emit(carId);\n        const car = this.cars.find((c) => c['carId'] === carId);\n        if (car) {\n          this.selectedCar.set(car);\n        }\n      }\n    });\n\n    // Change cursor on hover\n    this.map.on('mouseenter', this.clusterLayerId, () => {\n      if (this.map) {\n        this.map.getCanvas().style.cursor = 'pointer';\n      }\n    });\n    this.map.on('mouseleave', this.clusterLayerId, () => {\n      if (this.map) {\n        this.map.getCanvas().style.cursor = '';\n      }\n    });\n  }\n\n  /**\n   * Get adaptive cluster max zoom based on car count\n   * Optimized for 10K+ cars following Mapbox benchmarks\n   * Mapbox recommendation: clusterMaxZoom: 14 is optimal for most datasets\n   * Note: We use fixed value of 14 as recommended, keeping this method for backward compatibility\n   */\n  private getAdaptiveClusterMaxZoom(): number {\n    // Mapbox recommendation: Always use 14 for points datasets\n    // Supercluster can handle 400K points efficiently at this setting\n    return 14;\n  }\n\n  /**\n   * Get adaptive cluster radius based on car count\n   * Mapbox recommendation: clusterRadius: 50 is optimal balance\n   * Note: We use fixed value of 50 as recommended, keeping this method for backward compatibility\n   */\n  private getAdaptiveClusterRadius(): number {\n    // Mapbox recommendation: 50px radius provides optimal clustering\n    // This works well from 100 to 400,000 points\n    return 50;\n  }\n\n  /**\n   * Update markers based on car count - clustering, virtualization, or normal render\n   */\n  private updateMarkersBasedOnCount(): void {\n    if (!this.map) return;\n\n    const carCount = this.cars.length;\n\n    // Ensure spatial index is built for large datasets\n    if (carCount >= this.virtualizationThreshold && !this.spatialIndex) {\n      this.buildSpatialIndex();\n    }\n\n    if (this.useClustering && carCount > this.clusteringThreshold) {\n      this.setupClustering();\n    } else if (carCount > this.virtualizationThreshold) {\n      this.renderVirtualizedMarkers();\n    } else {\n      this.renderCarMarkers();\n    }\n  }\n\n  /**\n   * Schedule a debounced update using requestAnimationFrame\n   */\n  private scheduleDebouncedUpdate(callback: () => void): void {\n    if (this.pendingUpdate) {\n      cancelAnimationFrame(this.pendingUpdate);\n    }\n\n    this.pendingUpdate = requestAnimationFrame(() => {\n      callback();\n      this.pendingUpdate = null;\n    });\n  }\n\n  /**\n   * Build spatial index for efficient queries\n   */\n  private buildSpatialIndex(): void {\n    if (this.cars.length < this.virtualizationThreshold) {\n      this.spatialIndex = null;\n      return;\n    }\n\n    // Calculate bounds for the QuadTree (covering all cars with padding)\n    let minLng = Infinity,\n      maxLng = -Infinity;\n    let minLat = Infinity,\n      maxLat = -Infinity;\n\n    for (const car of this.cars) {\n      minLng = Math.min(minLng, car.lng);\n      maxLng = Math.max(maxLng, car.lng);\n      minLat = Math.min(minLat, car.lat);\n      maxLat = Math.max(maxLat, car.lat);\n    }\n\n    // Add padding\n    const padding = 0.01; // ~1km padding\n    minLng -= padding;\n    maxLng += padding;\n    minLat -= padding;\n    maxLat += padding;\n\n    this.spatialIndex = new QuadTree(\n      {\n        x: minLng,\n        y: minLat,\n        width: maxLng - minLng,\n        height: maxLat - minLat,\n      },\n      8,\n    );\n\n    for (const car of this.cars) {\n      this.spatialIndex.insert(car);\n    }\n  }\n\n  /**\n   * Emit current map bounds\n   */\n  private emitBounds(): void {\n    if (!this.map) return;\n\n    const bounds = this.map.getBounds();\n    if (!bounds) return;\n\n    this.boundsChange.emit({\n      north: bounds.getNorth(),\n      south: bounds.getSouth(),\n      east: bounds.getEast(),\n      west: bounds.getWest(),\n    });\n  }\n\n  /**\n   * Update spatial index when cars change\n   */\n  private updateSpatialIndex(): void {\n    this.buildSpatialIndex();\n  }\n\n  /**\n   * Pre-warm component pool during idle time using requestIdleCallback\n   * Creates a small number of components progressively to avoid blocking main thread.\n   * NOTE: Pre-warming is only helpful for medium/large marker counts; for small datasets it can\n   * cause unnecessary main-thread work and make the page appear unresponsive.\n   */\n  private preWarmComponentPoolDuringIdle(): void {\n    if (this.hasWarmedMarkerPool) {\n      return;\n    }\n\n    // Skip for small datasets; on-demand creation is fast enough.\n    if (this.cars.length < 25) {\n      return;\n    }\n\n    // Only pre-warm if pool is small\n    if (this.markerComponentPool.length > 50) {\n      return;\n    }\n\n    this.hasWarmedMarkerPool = true;\n\n    const targetPoolSize = Math.min(60, Math.max(20, this.cars.length * 2));\n    const maxPerTick = 2; // Keep batches tiny to avoid long tasks\n\n    const createBatch = (deadline?: IdleDeadline) => {\n      if (this.markerComponentPool.length >= targetPoolSize) {\n        return; // Done warming\n      }\n\n      let created = 0;\n\n      // Create a tiny batch during idle time\n      while (\n        created < maxPerTick &&\n        this.markerComponentPool.length < targetPoolSize &&\n        (!deadline || deadline.timeRemaining() > 8)\n      ) {\n        const newComponentRef = createComponent(MapMarkerComponent, {\n          environmentInjector: this.injector,\n        });\n\n        this.applicationRef.attachView(newComponentRef.hostView);\n\n        // Hide the element\n        const element = newComponentRef.location.nativeElement as HTMLElement;\n        if (element) {\n          element.style.display = 'none';\n        }\n\n        this.markerComponentPool.push(newComponentRef);\n\n        created++;\n      }\n\n      // Schedule next batch if needed\n      if (this.markerComponentPool.length < targetPoolSize) {\n        if ('requestIdleCallback' in window) {\n          // Modern browsers with requestIdleCallback\n          requestIdleCallback((d) => createBatch(d), { timeout: 2000 });\n        } else {\n          // Fallback for older browsers\n          setTimeout(() => createBatch(undefined), 150);\n        }\n      }\n    };\n\n    // Start warming with requestIdleCallback if available\n    if ('requestIdleCallback' in window) {\n      requestIdleCallback((d) => createBatch(d), { timeout: 1000 });\n    } else {\n      // Fallback for older browsers\n      setTimeout(() => createBatch(undefined), 500);\n    }\n  }\n\n  /**\n   * Get a marker component from pool or create new one\n   */\n  private getMarkerComponentFromPool(): ComponentRef<MapMarkerComponent> {\n    const componentRef = this.markerComponentPool.pop();\n    if (componentRef) {\n      return componentRef;\n    }\n\n    // Create new component if pool is empty\n    const newComponentRef = createComponent(MapMarkerComponent, {\n      environmentInjector: this.injector,\n    });\n\n    // Attach to application\n    this.applicationRef.attachView(newComponentRef.hostView);\n\n    return newComponentRef;\n  }\n\n  /**\n   * Return marker component to pool for reuse\n   */\n  private returnMarkerComponentToPool(componentRef: ComponentRef<MapMarkerComponent>): void {\n    if (this.markerComponentPool.length < this.maxPoolSize) {\n      // Reset component state before pooling\n      componentRef.setInput('car', null);\n      componentRef.setInput('isSelected', false);\n\n      // Hide the element\n      const element = componentRef.location.nativeElement as HTMLElement;\n      if (element) {\n        element.style.display = 'none';\n      }\n\n      this.markerComponentPool.push(componentRef);\n    } else {\n      // Pool is full, destroy component\n      this.applicationRef.detachView(componentRef.hostView);\n      componentRef.destroy();\n    }\n  }\n\n  /**\n   * Get a tooltip component from pool or create new one\n   */\n  private getTooltipComponentFromPool(): ComponentRef<EnhancedMapTooltipComponent> {\n    const componentRef = this.tooltipComponentPool.pop();\n    if (componentRef) {\n      return componentRef;\n    }\n\n    // Create new component if pool is empty\n    const newComponentRef = createComponent(EnhancedMapTooltipComponent, {\n      environmentInjector: this.injector,\n    });\n\n    // Attach to application\n    this.applicationRef.attachView(newComponentRef.hostView);\n\n    return newComponentRef;\n  }\n\n  /**\n   * Return tooltip component to pool for reuse\n   */\n  private returnTooltipComponentToPool(\n    componentRef: ComponentRef<EnhancedMapTooltipComponent>,\n  ): void {\n    if (this.tooltipComponentPool.length < this.maxPoolSize) {\n      // Reset component state before pooling\n      componentRef.setInput('car', null);\n      componentRef.setInput('selected', false);\n      componentRef.setInput('userLocation', undefined);\n\n      // Clear event subscriptions\n      if (componentRef.instance.viewDetails) {\n        componentRef.instance.viewDetails.unsubscribe();\n      }\n      if (componentRef.instance.quickBook) {\n        componentRef.instance.quickBook.unsubscribe();\n      }\n\n      // Hide the element\n      const element = componentRef.location.nativeElement as HTMLElement;\n      if (element) {\n        element.style.display = 'none';\n      }\n\n      this.tooltipComponentPool.push(componentRef);\n    } else {\n      // Pool is full, destroy component\n      this.applicationRef.detachView(componentRef.hostView);\n      componentRef.destroy();\n    }\n  }\n\n  /**\n   * Clear component pools (called during cleanup)\n   */\n  private clearComponentPools(): void {\n    // Destroy all pooled marker components\n    this.markerComponentPool.forEach((componentRef) => {\n      this.applicationRef.detachView(componentRef.hostView);\n      componentRef.destroy();\n    });\n    this.markerComponentPool = [];\n\n    // Destroy all pooled tooltip components\n    this.tooltipComponentPool.forEach((componentRef) => {\n      this.applicationRef.detachView(componentRef.hostView);\n      componentRef.destroy();\n    });\n    this.tooltipComponentPool = [];\n  }\n\n  /**\n   * Setup listener for viewport changes to update virtualized markers\n   */\n  private setupViewportChangeListener(): void {\n    if (!this.map) return;\n\n    // Use requestAnimationFrame with cooldown to prevent excessive updates\n    let animationFrameId: number;\n    let lastUpdateTime = 0;\n    const cooldownMs = 300; // Wait at least 300ms between updates\n    const throttledUpdate = () => {\n      const now = Date.now();\n      if (now - lastUpdateTime < cooldownMs) {\n        // Skip if within cooldown period\n        return;\n      }\n\n      if (animationFrameId) {\n        cancelAnimationFrame(animationFrameId);\n      }\n\n      animationFrameId = requestAnimationFrame(() => {\n        if (this.cars.length > this.virtualizationThreshold && !this.useClustering) {\n          lastUpdateTime = Date.now();\n          this.updateVirtualizedMarkers();\n        }\n        animationFrameId = 0;\n      });\n    };\n\n    this.map.on('moveend', throttledUpdate);\n    this.map.on('zoomend', throttledUpdate);\n  }\n\n  /**\n   * Render only visible markers within viewport + buffer\n   */\n  private renderVirtualizedMarkers(): void {\n    if (!this.map) return;\n\n    // Clear existing markers\n    this.clearMarkers();\n\n    // Get visible cars in current viewport\n    const visibleCars = this.getVisibleCarsInViewport();\n\n    // Limit to max visible markers\n    const carsToRender = visibleCars.slice(0, this.maxVisibleMarkers);\n\n    // Update visible car IDs\n    this.visibleCarIds = new Set(carsToRender.map((car) => car['carId']));\n\n    // Render markers for visible cars\n    carsToRender.forEach((car) => {\n      const markerData = this.createCarMarker(car);\n      if (markerData) {\n        this.carMarkers.set(car['carId'], markerData);\n      }\n    });\n\n    // Highlight selected car if it's visible\n    if (this.selectedCarId && this.visibleCarIds.has(this.selectedCarId)) {\n      this.highlightSelectedCar(this.selectedCarId);\n    }\n  }\n\n  /**\n   * Update virtualized markers when viewport changes\n   */\n  private updateVirtualizedMarkers(): void {\n    if (!this.map) return;\n\n    const newVisibleCars = this.getVisibleCarsInViewport();\n    const newVisibleCarIds = new Set(newVisibleCars.map((car) => car['carId']));\n\n    // Find cars that are no longer visible (need to be removed)\n    const carsToRemove = Array.from(this.visibleCarIds).filter((id) => !newVisibleCarIds.has(id));\n\n    // Find cars that are newly visible (need to be added)\n    const carsToAdd = newVisibleCars.filter((car) => !this.visibleCarIds.has(car['carId']));\n\n    // Remove markers for cars that are no longer visible\n    carsToRemove.forEach((carId) => {\n      const markerData = this.carMarkers.get(carId);\n      if (markerData) {\n        markerData.marker.remove();\n        this.returnMarkerComponentToPool(markerData.componentRef);\n        this.carMarkers.delete(carId);\n      }\n    });\n\n    // Add markers for newly visible cars (limited by maxVisibleMarkers)\n    const currentVisibleCount = this.carMarkers.size;\n    const availableSlots = Math.max(0, this.maxVisibleMarkers - currentVisibleCount);\n    const carsToAddLimited = carsToAdd.slice(0, availableSlots);\n\n    carsToAddLimited.forEach((car) => {\n      const markerData = this.createCarMarker(car);\n      if (markerData) {\n        this.carMarkers.set(car['carId'], markerData);\n      }\n    });\n\n    // Update visible car IDs\n    this.visibleCarIds = new Set([\n      ...Array.from(this.visibleCarIds).filter((id) => !carsToRemove.includes(id)),\n      ...carsToAddLimited.map((car) => car['carId']),\n    ]);\n\n    // Update selected car highlight if needed\n    if (this.selectedCarId) {\n      if (this.visibleCarIds.has(this.selectedCarId)) {\n        this.highlightSelectedCar(this.selectedCarId);\n      } else {\n        this.removeHighlightFromCar(this.selectedCarId);\n      }\n    }\n  }\n\n  /**\n   * Get cars visible in current viewport with buffer\n   */\n  private getVisibleCarsInViewport(): CarMapLocation[] {\n    if (!this.map) return [];\n\n    const bounds = this.map.getBounds();\n    if (!bounds) return [];\n\n    const zoom = this.map.getZoom();\n\n    // Expand bounds with buffer for smoother experience\n    const latDiff = (bounds.getNorth() - bounds.getSouth()) * this.viewportBuffer;\n    const lngDiff = (bounds.getEast() - bounds.getWest()) * this.viewportBuffer;\n\n    const expandedBounds = {\n      north: bounds.getNorth() + latDiff,\n      south: bounds.getSouth() - latDiff,\n      east: bounds.getEast() + lngDiff,\n      west: bounds.getWest() - lngDiff,\n    };\n\n    let visibleCars: CarMapLocation[];\n\n    // Use spatial index for large datasets, fallback to linear search\n    if (this.spatialIndex && this.cars.length >= this.virtualizationThreshold) {\n      const queryBounds = {\n        x: expandedBounds.west,\n        y: expandedBounds.south,\n        width: expandedBounds.east - expandedBounds.west,\n        height: expandedBounds.north - expandedBounds.south,\n      };\n\n      visibleCars = this.spatialIndex.query(queryBounds);\n    } else {\n      // Fallback to linear search for smaller datasets\n      visibleCars = this.cars.filter((car) => {\n        return (\n          car.lat >= expandedBounds.south &&\n          car.lat <= expandedBounds.north &&\n          car.lng >= expandedBounds.west &&\n          car.lng <= expandedBounds.east\n        );\n      });\n    }\n\n    // Sort by priority (distance from center for higher zoom levels)\n    if (zoom > 12) {\n      const center = this.map.getCenter();\n      visibleCars.sort((a, b) => {\n        const distA = this.calculateDistance(center.lat, center.lng, a.lat, a.lng);\n        const distB = this.calculateDistance(center.lat, center.lng, b.lat, b.lng);\n        return distA - distB;\n      });\n    }\n\n    return visibleCars;\n  }\n\n  /**\n   * Render car markers with custom tooltips\n   */\n  private renderCarMarkers(): void {\n    if (!this.map || !this.mapboxgl) return;\n\n    // Clear existing markers\n    this.clearMarkers();\n\n    // Si la capa de autos está oculta, no renderizar\n    if (!this.showMarketplaceCars()) {\n      return;\n    }\n\n    // Group cars by availability and price for visual organization\n    const groupedCars = this.groupCarsByAvailability();\n\n    // Create markers for each car\n    groupedCars.forEach((car) => {\n      const markerData = this.createCarMarker(car);\n      if (markerData) {\n        this.carMarkers.set(car['carId'], markerData);\n      }\n    });\n\n    // Highlight selected car\n    if (this.selectedCarId) {\n      this.highlightSelectedCar(this.selectedCarId);\n    }\n  }\n\n  /**\n   * Group cars by availability (immediate vs scheduled)\n   * Prioritizes cars available today with instant booking\n   */\n  private groupCarsByAvailability(): CarMapLocation[] {\n    const cars = [...this.cars];\n\n    // Group cars by priority:\n    // 1. Available today + instant booking (highest priority)\n    // 2. Available today (no instant booking)\n    // 3. Available tomorrow + instant booking\n    // 4. Available tomorrow\n    // 5. Soon available (within 7 days)\n    // 6. Unavailable or unknown status\n\n    const groups = {\n      immediateInstant: [] as CarMapLocation[],\n      immediate: [] as CarMapLocation[],\n      tomorrowInstant: [] as CarMapLocation[],\n      tomorrow: [] as CarMapLocation[],\n      soonAvailable: [] as CarMapLocation[],\n      unavailable: [] as CarMapLocation[],\n    };\n\n    cars.forEach((car) => {\n      const status = car.availabilityStatus || 'unavailable';\n      const isInstant = car.instantBooking === true;\n      const availableToday = car.availableToday === true;\n      const availableTomorrow = car.availableTomorrow === true;\n\n      if (status === 'available' && availableToday && isInstant) {\n        groups.immediateInstant.push(car);\n      } else if (status === 'available' && availableToday) {\n        groups.immediate.push(car);\n      } else if (status === 'available' && availableTomorrow && isInstant) {\n        groups.tomorrowInstant.push(car);\n      } else if (status === 'available' && availableTomorrow) {\n        groups.tomorrow.push(car);\n      } else if (status === 'soon_available') {\n        groups.soonAvailable.push(car);\n      } else {\n        groups.unavailable.push(car);\n      }\n    });\n\n    // Return prioritized list\n    return [\n      ...groups.immediateInstant,\n      ...groups.immediate,\n      ...groups.tomorrowInstant,\n      ...groups.tomorrow,\n      ...groups.soonAvailable,\n      ...groups.unavailable,\n    ];\n  }\n\n  /**\n   * Create a car marker with custom tooltip\n   */\n  private createCarMarker(\n    car: CarMapLocation,\n  ): { marker: MapboxMarker; componentRef: ComponentRef<MapMarkerComponent> } | null {\n    if (!this.map || !this.mapboxgl) return null;\n\n    // Get component from pool or create new one\n    const componentRef = this.getMarkerComponentFromPool();\n\n    // Set inputs\n    componentRef.setInput('car', car);\n    componentRef.setInput('isSelected', this.selectedCarId === car['carId']);\n\n    // Show the element (it might have been hidden in pool)\n    const markerElement = componentRef.location.nativeElement as HTMLElement;\n    markerElement.style.display = 'block';\n\n    // Create marker\n    const marker = new this.mapboxgl.Marker({\n      element: markerElement,\n      anchor: 'center',\n    })\n      .setLngLat([car.lng, car.lat])\n      .addTo(this.map);\n\n    // Handle hover with delay (150ms) - create tooltip on-demand\n    markerElement.addEventListener('mouseenter', () => {\n      const hideTimeout = this.hideTimeouts.get(car['carId']);\n      if (hideTimeout) {\n        clearTimeout(hideTimeout);\n        this.hideTimeouts.delete(car['carId']);\n      }\n\n      const timeout = setTimeout(() => {\n        this.showTooltipForCar(marker, car);\n      }, 150);\n      this.hoverTimeouts.set(car['carId'], timeout);\n    });\n\n    markerElement.addEventListener('mouseleave', () => {\n      const timeout = this.hoverTimeouts.get(car['carId']);\n      if (timeout) {\n        clearTimeout(timeout);\n        this.hoverTimeouts.delete(car['carId']);\n      }\n\n      const existingHideTimeout = this.hideTimeouts.get(car['carId']);\n      if (existingHideTimeout) {\n        clearTimeout(existingHideTimeout);\n      }\n\n      // Delay hide so the user can move from marker to popup\n      const hideTimeout = setTimeout(() => {\n        this.hideTooltipForCar(car['carId']);\n      }, 250);\n      this.hideTimeouts.set(car['carId'], hideTimeout);\n    });\n\n    // Handle click\n    markerElement.addEventListener('click', () => {\n      this.carSelected.emit(car['carId']);\n      this.selectedCar.set(car);\n    });\n\n    return { marker, componentRef };\n  }\n\n  /**\n   * Create tooltip popup with Angular component (using EnhancedMapTooltipComponent)\n   */\n  private createTooltipPopup(car: CarMapLocation): MapboxPopup {\n    if (!this.mapboxgl) {\n      throw new Error('Mapbox GL not initialized');\n    }\n\n    // Create container wrapper for the popup\n    const container = document.createElement('div');\n    container.className = 'map-tooltip-container';\n\n    // Keep popup open while hovering it\n    container.addEventListener('mouseenter', () => {\n      const hideTimeout = this.hideTimeouts.get(car['carId']);\n      if (hideTimeout) {\n        clearTimeout(hideTimeout);\n        this.hideTimeouts.delete(car['carId']);\n      }\n    });\n\n    container.addEventListener('mouseleave', () => {\n      this.hideTooltipForCar(car['carId']);\n    });\n\n    // Get component from pool or create new one\n    const componentRef = this.getTooltipComponentFromPool();\n\n    // Set inputs\n    componentRef.setInput('car', car);\n    componentRef.setInput('selected', this.selectedCarId === car['carId']);\n    componentRef.setInput('userLocation', this.userLocation || undefined);\n\n    // Subscribe to output events\n    componentRef.instance.viewDetails.subscribe((carId: string) => {\n      this.carSelected.emit(carId);\n    });\n\n    componentRef.instance.quickBook.subscribe((carId: string) => {\n      this.openBookingPanelForCarId(carId);\n      this.quickBook.emit(carId);\n    });\n\n    // Show the element (it might have been hidden in pool)\n    const element = componentRef.location.nativeElement as HTMLElement;\n    element.style.display = 'block';\n\n    // Append the component's native element to the container\n    container.appendChild(element);\n\n    // Store component reference\n    this.tooltipComponents.set(car['carId'], componentRef);\n\n    // Create popup with larger maxWidth for enhanced tooltip\n    const popup = new this.mapboxgl.Popup({\n      offset: 25,\n      closeButton: false,\n      closeOnClick: false,\n      maxWidth: '320px',\n    }).setDOMContent(container);\n\n    // Store popup reference\n    this.tooltipPopups.set(car['carId'], popup);\n\n    return popup;\n  }\n\n  /**\n   * Show tooltip for a car on-demand\n   */\n  private showTooltipForCar(marker: MapboxMarker, car: CarMapLocation): void {\n    const hideTimeout = this.hideTimeouts.get(car['carId']);\n    if (hideTimeout) {\n      clearTimeout(hideTimeout);\n      this.hideTimeouts.delete(car['carId']);\n    }\n\n    // Check if tooltip already exists\n    let popup = this.tooltipPopups.get(car['carId']);\n\n    if (!popup) {\n      // Create tooltip on-demand\n      popup = this.createTooltipPopup(car);\n      this.tooltipPopups.set(car['carId'], popup);\n      marker.setPopup(popup);\n    }\n\n    // Show the popup if not already open\n    if (!popup.isOpen()) {\n      marker.togglePopup();\n    }\n  }\n\n  /**\n   * Hide tooltip for a car\n   */\n  private hideTooltipForCar(carId: string): void {\n    const hideTimeout = this.hideTimeouts.get(carId);\n    if (hideTimeout) {\n      clearTimeout(hideTimeout);\n      this.hideTimeouts.delete(carId);\n    }\n\n    const popup = this.tooltipPopups.get(carId);\n    if (popup && popup.isOpen()) {\n      // Find the marker and toggle popup\n      const markerData = this.carMarkers.get(carId);\n      if (markerData && markerData.marker.getPopup() === popup) {\n        markerData.marker.togglePopup();\n      }\n    }\n\n    // Return tooltip component to pool after a delay to allow animations\n    const componentRef = this.tooltipComponents.get(carId);\n    if (componentRef) {\n      setTimeout(() => {\n        this.returnTooltipComponentToPool(componentRef);\n        this.tooltipComponents.delete(carId);\n        this.tooltipPopups.delete(carId);\n      }, 300); // Allow time for fade out animation\n    }\n  }\n\n  /**\n   * Add user location marker with custom styling and animations\n   */\n  private addUserLocationMarker(): void {\n    if (!this.map || !this.mapboxgl || !this.userLocation) return;\n\n    // Si la capa de ubicación está oculta, remover el marcador si existe\n    if (!this.showUserLocation()) {\n      if (this.userLocationMarker) {\n        this.userLocationMarker.remove();\n        this.userLocationMarker = null;\n      }\n      return;\n    }\n\n    // Save previous location before removing marker\n    let previousLocation: { lat: number; lng: number } | null = null;\n    if (this.userLocationMarker) {\n      const prevLngLat = this.userLocationMarker.getLngLat();\n      previousLocation = { lat: prevLngLat.lat, lng: prevLngLat.lng };\n      this.userLocationMarker.remove();\n    }\n\n    // Create custom marker element with contextual classes\n    const el = document.createElement('div');\n    el.className = `user-location-marker user-location-marker--${this.locationMode}`;\n    if (this.isDarkMode()) {\n      el.classList.add('user-location-marker--dark');\n    }\n\n    const circleSize = 20 * this.circleSizeMultiplier();\n    el.style.setProperty('--circle-size', `${circleSize}px`);\n\n    // ✅ P0-005 FIX: Use safe DOM methods instead of innerHTML\n    const haloDiv = document.createElement('div');\n    haloDiv.className = 'user-marker-halo';\n\n    const imgElement = document.createElement('img');\n    imgElement.src = this.userAvatarUrl || 'assets/images/default-avatar.svg';\n    imgElement.className = 'user-marker-avatar';\n    imgElement.alt = 'Tu ubicación';\n    imgElement.addEventListener('error', function handleImageError(this: HTMLImageElement) {\n      this.src = 'assets/images/default-avatar.svg';\n    });\n\n    el.appendChild(haloDiv);\n    el.appendChild(imgElement);\n\n    // Create marker\n    this.userLocationMarker = new this.mapboxgl.Marker({\n      element: el,\n      anchor: 'center',\n    })\n      .setLngLat([this.userLocation.lng, this.userLocation.lat])\n      .addTo(this.map);\n\n    // Animate marker movement if location changed\n    if (previousLocation) {\n      const distance = this.calculateDistance(\n        previousLocation.lat,\n        previousLocation.lng,\n        this.userLocation.lat,\n        this.userLocation.lng,\n      );\n\n      if (distance > 10) {\n        // Solo animar si se movió más de 10 metros\n        this.animateMarkerUpdate();\n      } else {\n        // Trigger pulse even for small movements\n        this.triggerLocationPulse();\n      }\n    }\n\n    // Create enhanced popup with contextual information\n    const popupHTML = this.createUserLocationPopup();\n    const popup = new this.mapboxgl.Popup({\n      offset: 25,\n      closeButton: true,\n      closeOnClick: true,\n      maxWidth: '280px',\n    }).setHTML(popupHTML);\n\n    this.userLocationMarker.setPopup(popup);\n\n    // Show popup initially with pulse animation (only if it's the first time)\n    if (!previousLocation) {\n      setTimeout(() => {\n        this.userLocationMarker?.togglePopup();\n        this.triggerLocationPulse();\n      }, 1000);\n    }\n  }\n\n  /**\n   * Create HTML content for user location popup\n   */\n  private createUserLocationPopup(): string {\n    const modeText = this.viewMode() === 'map' ? 'Tu ubicación actual' : 'Estás aquí';\n    const accuracyText = this.locationAccuracy\n      ? `Precisión: ±${Math.round(this.locationAccuracy)}m`\n      : 'Precisión: Desconocida';\n\n    const updateTime = this.lastLocationUpdate\n      ? this.formatUpdateTime(this.lastLocationUpdate)\n      : 'Actualizado ahora';\n\n    // Calculate nearby cars\n    const nearbyCars = this.getNearbyCarsCount();\n    const carsText =\n      nearbyCars > 0 ? `🚗 Hay <b>${nearbyCars}</b> autos cerca` : 'No hay autos cerca';\n\n    const popupHTML = `\n      <div class=\"user-location-popup\" style=\"font-family: 'Inter', sans-serif; padding: 4px;\">\n        <div style=\"display: flex; align-items: center; gap: 8px; margin-bottom: 4px;\">\n          <div style=\"width: 8px; height: 8px; background-color: var(--success-default, #10b981); border-radius: 50%; box-shadow: 0 0 0 2px rgba(16, 185, 129, 0.2);\"></div>\n          <p class=\"font-semibold text-slate-800 dark:text-white\" style=\"margin: 0; font-size: 14px;\">${modeText}</p>\n        </div>\n\n        <div style=\"display: flex; flex-direction: column; gap: 2px; margin-bottom: 8px; padding-left: 16px;\">\n          <p class=\"text-xs text-slate-500 dark:text-slate-500\" style=\"margin: 0;\">${accuracyText}</p>\n          <p class=\"text-xs text-gray-500 dark:text-slate-500\" style=\"margin: 0;\">${updateTime}</p>\n          <p class=\"text-xs text-cyan-600 dark:text-cyan-400 font-medium\" style=\"margin: 4px 0 0 0;\">${carsText}</p>\n        </div>\n\n        <div class=\"user-location-popup-actions\" style=\"display: flex; gap: 8px; margin-top: 8px;\">\n          <button class=\"user-location-cta\" data-action=\"search-nearby\"\n            style=\"flex: 1; background: var(--cta-default, #06b6d4); color: white; border: none; padding: 6px 12px; border-radius: 6px; font-size: 12px; font-weight: 500; cursor: pointer; transition: all 0.2s;\">\n            Buscar aquí\n          </button>\n          <button class=\"user-location-cta\" data-action=\"view-routes\"\n            style=\"flex: 1; background: var(--cta-alpha-10, rgba(6, 182, 212, 0.1)); color: var(--cta-default, #06b6d4); border: 1px solid var(--cta-alpha-20, rgba(6, 182, 212, 0.2)); padding: 6px 12px; border-radius: 6px; font-size: 12px; font-weight: 500; cursor: pointer; transition: all 0.2s;\">\n            Ver rutas\n          </button>\n        </div>\n      </div>\n    `;\n\n    return popupHTML;\n  }\n\n  /**\n   * Calculate distance between two points in km\n   */\n  private calculateDistanceKm(lat1: number, lon1: number, lat2: number, lon2: number): number {\n    const R = 6371; // Radius of the earth in km\n    const dLat = this.deg2rad(lat2 - lat1);\n    const dLon = this.deg2rad(lon2 - lon1);\n    const a =\n      Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n      Math.cos(this.deg2rad(lat1)) *\n      Math.cos(this.deg2rad(lat2)) *\n      Math.sin(dLon / 2) *\n      Math.sin(dLon / 2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n    const d = R * c; // Distance in km\n    return d;\n  }\n\n  private deg2rad(deg: number): number {\n    return deg * (Math.PI / 180);\n  }\n\n  /**\n   * Get count of cars near user location\n   */\n  /**\n   * Get count of cars near user location\n   */\n  private getNearbyCarsCount(): number {\n    const userLoc = this.userLocation;\n    if (!userLoc) return 0;\n\n    const radius = this.searchRadiusKm || 5; // Default 5km if not set\n\n    return this.cars.filter((car) => {\n      if (!car.lat || !car.lng) return false;\n\n      const dist = this.calculateDistanceKm(userLoc.lat, userLoc.lng, car.lat, car.lng);\n\n      return dist <= radius;\n    }).length;\n  }\n\n  /**\n   * Format update time for display\n   */\n  private formatUpdateTime(date: Date): string {\n    const now = new Date();\n    const diffMs = now.getTime() - date.getTime();\n    const diffSec = Math.floor(diffMs / 1000);\n    const diffMin = Math.floor(diffSec / 60);\n\n    if (diffSec < 10) return 'Actualizado ahora';\n    if (diffSec < 60) return `Actualizado hace ${diffSec}s`;\n    if (diffMin < 60) return `Actualizado hace ${diffMin}min`;\n    return `Actualizado ${date.toLocaleTimeString('es-AR', { hour: '2-digit', minute: '2-digit' })}`;\n  }\n\n  /**\n   * Get location update text for info layer\n   */\n  public getLocationUpdateText(): string {\n    if (!this.lastLocationUpdate) return 'Desconocido';\n    return this.formatUpdateTime(this.lastLocationUpdate);\n  }\n\n  /**\n   * Get count of available cars\n   */\n  public getAvailableCarsCount(): number {\n    return this.cars.filter((car) => car.availabilityStatus === 'available').length;\n  }\n\n  /**\n   * Get count of cars in use\n   */\n  public getInUseCarsCount(): number {\n    return this.cars.filter((car) => car.availabilityStatus === 'in_use').length;\n  }\n\n  /**\n   * Get count of soon available cars\n   */\n  public getSoonAvailableCarsCount(): number {\n    return this.cars.filter((car) => car.availabilityStatus === 'soon_available').length;\n  }\n\n  /**\n   * Get count of unavailable cars\n   */\n  public getUnavailableCarsCount(): number {\n    return this.cars.filter((car) => car.availabilityStatus === 'unavailable').length;\n  }\n\n  /**\n   * Animate marker update with smooth transitions\n   */\n  private animateMarkerUpdate(): void {\n    if (!this.map || !this.userLocation) return;\n\n    // Smooth camera transition\n    this.map.easeTo({\n      center: [this.userLocation.lng, this.userLocation.lat],\n      duration: 800,\n      easing: (t: number) => t * (2 - t), // ease-out\n    });\n\n    // Add pulse animation to marker\n    this.triggerLocationPulse();\n  }\n\n  /**\n   * Trigger pulse animation on location update\n   */\n  private triggerLocationPulse(): void {\n    if (!this.userLocationMarker) return;\n\n    const element = this.userLocationMarker.getElement();\n    if (element) {\n      element.classList.add('user-location-marker--pulse');\n      setTimeout(() => {\n        element.classList.remove('user-location-marker--pulse');\n      }, 1000);\n    }\n  }\n\n  /**\n   * Calculate distance between two coordinates (Haversine formula)\n   */\n  private calculateDistance(lat1: number, lon1: number, lat2: number, lon2: number): number {\n    const R = 6371e3; // Earth radius in meters\n    const φ1 = (lat1 * Math.PI) / 180;\n    const φ2 = (lat2 * Math.PI) / 180;\n    const Δφ = ((lat2 - lat1) * Math.PI) / 180;\n    const Δλ = ((lon2 - lon1) * Math.PI) / 180;\n\n    const a =\n      Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +\n      Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ / 2) * Math.sin(Δλ / 2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n\n    return R * c;\n  }\n\n  /**\n   * Update marker styles based on mode and theme\n   */\n  private updateMarkerStyles(): void {\n    if (!this.userLocationMarker) return;\n\n    const element = this.userLocationMarker.getElement();\n    if (element) {\n      element.className = `user-location-marker user-location-marker--${this.locationMode}`;\n      if (this.isDarkMode()) {\n        element.classList.add('user-location-marker--dark');\n      } else {\n        element.classList.remove('user-location-marker--dark');\n      }\n    }\n  }\n\n  /**\n   * Add search radius layer (circle around user location)\n   */\n  private addSearchRadiusLayer(): void {\n    if (!this.map || !this.mapboxgl || !this.userLocation) return;\n\n    // Check if style is loaded before adding layers\n    if (!this.map.isStyleLoaded()) {\n      // Wait for style to load, then add layer\n      this.map.once('styledata', () => {\n        this.addSearchRadiusLayer();\n      });\n      return;\n    }\n\n    // Convert radius from km to meters\n    const radiusMeters = this.searchRadiusKm * 1000;\n\n    // Create circle geometry\n    const circle = this.createCircleGeometry(\n      this.userLocation.lat,\n      this.userLocation.lng,\n      radiusMeters,\n    );\n\n    // Add or update source\n    const feature: GeoJSON.Feature<GeoJSON.Polygon> = {\n      type: 'Feature',\n      geometry: circle,\n      properties: {},\n    };\n\n    const source = this.map.getSource(this.searchRadiusSourceId) as MapboxGeoJSONSource | undefined;\n    if (source) {\n      source.setData(feature);\n    } else {\n      this.map.addSource(this.searchRadiusSourceId, {\n        type: 'geojson',\n        data: feature,\n      });\n    }\n\n    // Add or update layer\n    const fillColor = this.isDarkMode() ? 'rgba(167, 216, 244, 0.1)' : 'rgba(167, 216, 244, 0.15)';\n    const outlineColor = this.isDarkMode()\n      ? 'rgba(167, 216, 244, 0.4)'\n      : 'rgba(167, 216, 244, 0.5)';\n\n    if (!this.map.getLayer(this.searchRadiusLayerId)) {\n      this.map.addLayer({\n        id: this.searchRadiusLayerId,\n        type: 'fill',\n        source: this.searchRadiusSourceId,\n        paint: {\n          'fill-color': fillColor,\n          'fill-outline-color': outlineColor,\n        },\n      });\n    } else {\n      // Update paint properties with smooth transitions\n      // Mapbox GL JS handles transitions automatically when properties change\n      this.map.setPaintProperty(this.searchRadiusLayerId, 'fill-color', fillColor);\n      this.map.setPaintProperty(this.searchRadiusLayerId, 'fill-outline-color', outlineColor);\n    }\n  }\n\n  /**\n   * Create circle geometry for search radius\n   */\n  private createCircleGeometry(lat: number, lng: number, radiusMeters: number): GeoJSON.Polygon {\n    const points = 64;\n    const coordinates: [number, number][] = [];\n\n    for (let i = 0; i <= points; i++) {\n      const angle = (i * 360) / points;\n      const point = this.destinationPoint(lat, lng, radiusMeters, angle);\n      coordinates.push([point.lng, point.lat]);\n    }\n\n    return {\n      type: 'Polygon',\n      coordinates: [coordinates],\n    };\n  }\n\n  /**\n   * Calculate destination point given start point, distance and bearing\n   */\n  private destinationPoint(\n    lat: number,\n    lng: number,\n    distanceMeters: number,\n    bearingDegrees: number,\n  ): { lat: number; lng: number } {\n    const R = 6371e3; // Earth radius in meters\n    const bearing = (bearingDegrees * Math.PI) / 180;\n    const lat1 = (lat * Math.PI) / 180;\n    const lng1 = (lng * Math.PI) / 180;\n\n    const lat2 = Math.asin(\n      Math.sin(lat1) * Math.cos(distanceMeters / R) +\n      Math.cos(lat1) * Math.sin(distanceMeters / R) * Math.cos(bearing),\n    );\n\n    const lng2 =\n      lng1 +\n      Math.atan2(\n        Math.sin(bearing) * Math.sin(distanceMeters / R) * Math.cos(lat1),\n        Math.cos(distanceMeters / R) - Math.sin(lat1) * Math.sin(lat2),\n      );\n\n    return {\n      lat: (lat2 * 180) / Math.PI,\n      lng: (lng2 * 180) / Math.PI,\n    };\n  }\n\n  /**\n   * Setup follow user location functionality\n   */\n  private setupFollowLocation(): void {\n    if (this.followUserLocation) {\n      this.startFollowingLocation();\n    }\n  }\n\n  /**\n   * Start following user location\n   */\n  startFollowingLocation(): void {\n    if (!this.map || !this.userLocation || this.followLocationInterval) return;\n\n    this.followUserLocation = true;\n    this.followLocationToggle.emit(true);\n\n    // Fly to user location initially with reduced zoom and padding\n    this.map.flyTo({\n      center: [this.userLocation.lng, this.userLocation.lat],\n      zoom: 13, // Reduced from 14 to prevent marker overlap/duplication\n      duration: 1000,\n      padding: { top: 50, bottom: 50, left: 50, right: 50 }, // Add padding for better positioning\n    });\n\n    // Update position periodically with debounce to prevent animation overlap\n    let lastEaseToTime = 0;\n    const easeToDebounceMs = 1000; // Prevent animations from stacking\n    this.followLocationInterval = setInterval(() => {\n      if (this.userLocation && this.map) {\n        const now = Date.now();\n        // Only execute if enough time has passed since last animation\n        if (now - lastEaseToTime > easeToDebounceMs) {\n          lastEaseToTime = now;\n          this.map.easeTo({\n            center: [this.userLocation.lng, this.userLocation.lat],\n            duration: 500,\n          });\n        }\n      }\n    }, 3000); // Update every 3 seconds (increased from 2s to reduce animation frequency)\n  }\n\n  /**\n   * Stop following user location\n   */\n  stopFollowingLocation(): void {\n    if (this.followLocationInterval) {\n      clearInterval(this.followLocationInterval);\n      this.followLocationInterval = null;\n    }\n    this.followUserLocation = false;\n    this.followLocationToggle.emit(false);\n  }\n\n  /**\n   * Setup lock controls for zoom and rotation\n   */\n  private setupLockControls(): void {\n    if (!this.map) return;\n\n    if (this.lockZoomRotation) {\n      // Disable zoom and rotation\n      this.map.boxZoom.disable();\n      this.map.scrollZoom.disable();\n      this.map.dragRotate.disable();\n      this.map.touchZoomRotate.disable();\n    } else {\n      // Enable zoom and rotation\n      this.map.boxZoom.enable();\n      this.map.scrollZoom.enable();\n      this.map.dragRotate.enable();\n      this.map.touchZoomRotate.enable();\n    }\n  }\n\n  /**\n   * Toggle lock state\n   */\n  public toggleLock(): void {\n    this.lockZoomRotation = !this.lockZoomRotation;\n    this.lockToggle.emit(this.lockZoomRotation);\n    this.setupLockControls();\n  }\n\n  /**\n   * Toggle follow location\n   */\n  public toggleFollowLocation(): void {\n    if (this.followUserLocation) {\n      this.stopFollowingLocation();\n    } else {\n      this.startFollowingLocation();\n    }\n  }\n\n  /**\n   * Toggle delivery zone (isochrone)\n   */\n  public toggleDeliveryZone(): void {\n    this.showDeliveryIsochrone = !this.showDeliveryIsochrone;\n    if (this.showDeliveryIsochrone) {\n      this.addDeliveryIsochrone();\n    } else {\n      this.removeDeliveryIsochrone();\n    }\n  }\n\n  /**\n   * Toggle directions route\n   */\n  public toggleDirections(): void {\n    this.showDirectionsRoute = !this.showDirectionsRoute;\n    if (this.showDirectionsRoute) {\n      this.addDirectionsRoute();\n    } else {\n      this.removeDirectionsRoute();\n    }\n  }\n\n  /**\n   * Handle search radius slider change\n   */\n  public onSearchRadiusChange(event: Event): void {\n    const target = event.target as HTMLInputElement;\n    const value = parseFloat(target.value);\n    this.searchRadiusKm = value;\n    this.searchRadiusChange.emit(value);\n\n    // Update radius layer with animation\n    if (this.showSearchRadius && this.map) {\n      this.addSearchRadiusLayer();\n    }\n\n    // Note: The parent component (marketplace.page.ts) should handle\n    // refetching cars with the new radius filter via searchRadiusChange output\n  }\n\n  /**\n   * Highlight selected car marker\n   */\n  private highlightSelectedCar(carId: string): void {\n    const markerData = this.carMarkers.get(carId);\n    if (!markerData) return;\n\n    markerData.componentRef.instance.isSelected = true;\n\n    // Fly to selected car\n    const car = this.cars.find((c) => c['carId'] === carId);\n    if (car && this.map) {\n      this.map.flyTo({\n        center: [car.lng, car.lat],\n        zoom: 14,\n        duration: 1000,\n      });\n    }\n\n    // Update tooltip component\n    const componentRef = this.tooltipComponents.get(carId);\n    if (componentRef) {\n      componentRef.setInput('selected', true);\n    }\n  }\n\n  /**\n   * Remove highlight from car marker\n   */\n  private removeHighlightFromCar(carId: string): void {\n    const markerData = this.carMarkers.get(carId);\n    if (!markerData) return;\n\n    markerData.componentRef.instance.isSelected = false;\n\n    // Update tooltip component\n    const componentRef = this.tooltipComponents.get(carId);\n    if (componentRef) {\n      componentRef.setInput('selected', false);\n    }\n  }\n\n  /**\n   * Clear all markers and related resources\n   */\n  private clearMarkers(): void {\n    // Clear hover timeouts\n    this.hoverTimeouts.forEach((timeout) => clearTimeout(timeout));\n    this.hoverTimeouts.clear();\n\n    // Clear hide timeouts\n    this.hideTimeouts.forEach((timeout) => clearTimeout(timeout));\n    this.hideTimeouts.clear();\n\n    // Detach Angular components\n    this.tooltipComponents.forEach((componentRef) => {\n      this.applicationRef.detachView(componentRef.hostView);\n      componentRef.destroy();\n    });\n    this.tooltipComponents.clear();\n\n    // Remove popups\n    this.tooltipPopups.forEach((popup) => {\n      popup.remove();\n    });\n    this.tooltipPopups.clear();\n\n    // Remove markers and return components to pool\n    this.carMarkers.forEach((markerData) => {\n      markerData.marker.remove();\n      this.returnMarkerComponentToPool(markerData.componentRef);\n    });\n    this.carMarkers.clear();\n    this.visibleCarIds.clear();\n  }\n\n  /**\n   * Remove search radius layer\n   */\n  private removeSearchRadiusLayer(): void {\n    if (!this.map) return;\n\n    try {\n      if (this.map.getLayer(this.searchRadiusLayerId)) {\n        this.map.removeLayer(this.searchRadiusLayerId);\n      }\n      if (this.map.getSource(this.searchRadiusSourceId)) {\n        this.map.removeSource(this.searchRadiusSourceId);\n      }\n    } catch {\n      // Layers may not exist\n    }\n  }\n\n  /**\n   * Add delivery isochrone layer for selected car\n   * Shows the area reachable from the car's location within deliveryTimeMinutes\n   */\n  private async addDeliveryIsochrone(): Promise<void> {\n    if (!this.map || !this.mapboxgl) return;\n\n    const selectedCar = this.selectedCar();\n    if (!selectedCar) return;\n\n    // Check if style is loaded\n    if (!this.map.isStyleLoaded()) {\n      this.map.once('styledata', () => {\n        this.addDeliveryIsochrone();\n      });\n      return;\n    }\n\n    try {\n      // Fetch isochrone from Mapbox API\n      const lng = selectedCar.lng;\n      const lat = selectedCar.lat;\n      const profile = 'driving'; // Options: driving, walking, cycling\n      const minutes = this.deliveryTimeMinutes;\n\n      const url = `https://api.mapbox.com/isochrone/v1/mapbox/${profile}/${lng},${lat}?contours_minutes=${minutes}&polygons=true&access_token=${environment.mapboxAccessToken}`;\n\n      const response = await fetch(url);\n      if (!response.ok) {\n        console.warn('[CarsMap] Failed to fetch isochrone:', response.statusText);\n        return;\n      }\n\n      const data = (await response.json()) as GeoJSON.FeatureCollection;\n\n      // Add or update source\n      const source = this.map.getSource(this.isochroneSourceId) as MapboxGeoJSONSource | undefined;\n      if (source) {\n        source.setData(data);\n      } else {\n        this.map.addSource(this.isochroneSourceId, {\n          type: 'geojson',\n          data: data,\n        });\n      }\n\n      // Add fill layer\n      const fillColor = this.isDarkMode() ? 'rgba(16, 185, 129, 0.2)' : 'rgba(16, 185, 129, 0.25)';\n      if (!this.map.getLayer(this.isochroneLayerId)) {\n        this.map.addLayer({\n          id: this.isochroneLayerId,\n          type: 'fill',\n          source: this.isochroneSourceId,\n          paint: {\n            'fill-color': fillColor,\n            'fill-opacity': 0.8,\n          },\n        });\n      } else {\n        this.map.setPaintProperty(this.isochroneLayerId, 'fill-color', fillColor);\n      }\n\n      // Add outline layer for better visibility\n      const outlineColor = this.isDarkMode()\n        ? 'rgba(16, 185, 129, 0.8)'\n        : 'rgba(16, 185, 129, 0.9)';\n      if (!this.map.getLayer(this.isochroneOutlineLayerId)) {\n        this.map.addLayer({\n          id: this.isochroneOutlineLayerId,\n          type: 'line',\n          source: this.isochroneSourceId,\n          paint: {\n            'line-color': outlineColor,\n            'line-width': 2,\n            'line-dasharray': [2, 2],\n          },\n        });\n      } else {\n        this.map.setPaintProperty(this.isochroneOutlineLayerId, 'line-color', outlineColor);\n      }\n\n      this.logger.debug(\n        `[CarsMap] Added delivery isochrone: ${minutes} min driving radius from car location`,\n      );\n    } catch (error) {\n      console.error('[CarsMap] Error adding delivery isochrone:', error);\n    }\n  }\n\n  /**\n   * Remove delivery isochrone layer\n   */\n  private removeDeliveryIsochrone(): void {\n    if (!this.map) return;\n\n    try {\n      if (this.map.getLayer(this.isochroneOutlineLayerId)) {\n        this.map.removeLayer(this.isochroneOutlineLayerId);\n      }\n      if (this.map.getLayer(this.isochroneLayerId)) {\n        this.map.removeLayer(this.isochroneLayerId);\n      }\n      if (this.map.getSource(this.isochroneSourceId)) {\n        this.map.removeSource(this.isochroneSourceId);\n      }\n    } catch {\n      // Layers may not exist\n    }\n  }\n\n  /**\n   * Add directions route layer from user location to selected car\n   * Shows turn-by-turn directions with estimated time and distance\n   */\n  private async addDirectionsRoute(): Promise<void> {\n    if (!this.map || !this.mapboxgl || !this.userLocation) {\n      console.warn('[CarsMap] Cannot show directions: missing map or user location');\n      return;\n    }\n\n    const selectedCar = this.selectedCar();\n    if (!selectedCar) {\n      console.warn('[CarsMap] Cannot show directions: no selected car');\n      return;\n    }\n\n    // Check if style is loaded\n    if (!this.map.isStyleLoaded()) {\n      this.map.once('styledata', () => {\n        this.addDirectionsRoute();\n      });\n      return;\n    }\n\n    try {\n      const origin: [number, number] = [this.userLocation.lng, this.userLocation.lat];\n      const destination: [number, number] = [selectedCar.lng, selectedCar.lat];\n\n      // Fetch directions from API\n      const directions = await this.directionsService.getDirections(origin, destination, 'driving');\n\n      if (!directions || !directions.routes || directions.routes.length === 0) {\n        console.warn('[CarsMap] No route found');\n        return;\n      }\n\n      const route = directions.routes[0];\n      const routeGeometry = route.geometry;\n\n      // Create GeoJSON for the route\n      const routeGeoJSON: GeoJSON.Feature<GeoJSON.LineString> = {\n        type: 'Feature',\n        geometry: routeGeometry,\n        properties: {\n          duration: route.duration,\n          distance: route.distance,\n        },\n      };\n\n      // Add or update source\n      const source = this.map.getSource(this.routeSourceId) as MapboxGeoJSONSource | undefined;\n      if (source) {\n        source.setData(routeGeoJSON);\n      } else {\n        this.map.addSource(this.routeSourceId, {\n          type: 'geojson',\n          data: routeGeoJSON,\n        });\n      }\n\n      // Add outline layer (casing) - visible route styling\n      if (!this.map.getLayer(this.routeOutlineLayerId)) {\n        this.map.addLayer({\n          id: this.routeOutlineLayerId,\n          type: 'line',\n          source: this.routeSourceId,\n          paint: {\n            'line-color': '#ffffff',\n            'line-width': 20, // THICK outline to occupy whole street\n            'line-opacity': 0.8, // High visibility\n          },\n          layout: {\n            'line-cap': 'round', // Rounded ends for smooth appearance\n            'line-join': 'round', // Rounded corners for smooth turns\n          },\n        });\n      }\n\n      // Add main route layer - visible route styling\n      const routeColor = this.getCssVariableValue('--cta-default', '#A7D8F4'); // AutoRenta brand color\n      if (!this.map.getLayer(this.routeLayerId)) {\n        this.map.addLayer({\n          id: this.routeLayerId,\n          type: 'line',\n          source: this.routeSourceId,\n          paint: {\n            'line-color': routeColor,\n            'line-width': 16, // THICK main line to occupy whole street\n            'line-opacity': 0.9, // High visibility\n          },\n          layout: {\n            'line-cap': 'round', // Rounded ends for smooth appearance\n            'line-join': 'round', // Rounded corners for smooth turns\n          },\n        });\n      } else {\n        this.map.setPaintProperty(this.routeLayerId, 'line-color', routeColor);\n      }\n\n      // Fit map to show entire route\n      const coordinates = routeGeometry.coordinates as [number, number][];\n      const bounds = coordinates.reduce(\n        (bounds, coord) => {\n          return bounds.extend(coord as [number, number]);\n        },\n        new this.mapboxgl.LngLatBounds(coordinates[0], coordinates[0]),\n      );\n\n      this.map.fitBounds(bounds, {\n        padding: { top: 100, bottom: 100, left: 100, right: 100 },\n        maxZoom: 15,\n        duration: 1000,\n        pitch: 0, // Flat 2D view\n      });\n\n      this.logger.debug('[CarsMap] Directions route added:', {\n        duration: this.directionsService.formatDuration(route.duration),\n        distance: this.directionsService.formatDistance(route.distance),\n      });\n    } catch (error) {\n      console.error('[CarsMap] Error adding directions route:', error);\n    }\n  }\n\n  /**\n   * Remove directions route layer\n   */\n  private removeDirectionsRoute(): void {\n    if (!this.map) return;\n\n    try {\n      if (this.map.getLayer(this.routeLayerId)) {\n        this.map.removeLayer(this.routeLayerId);\n      }\n      if (this.map.getLayer(this.routeOutlineLayerId)) {\n        this.map.removeLayer(this.routeOutlineLayerId);\n      }\n      if (this.map.getSource(this.routeSourceId)) {\n        this.map.removeSource(this.routeSourceId);\n      }\n    } catch {\n      // Layers may not exist\n    }\n  }\n\n  /**\n   * Cleanup on destroy\n   */\n  private cleanup(): void {\n    // Cancel any pending updates\n    if (this.pendingUpdate) {\n      cancelAnimationFrame(this.pendingUpdate);\n      this.pendingUpdate = null;\n    }\n\n    this.clearMarkers();\n    this.stopFollowingLocation();\n\n    // Remove clustering layers\n    if (this.map) {\n      try {\n        if (this.map.getLayer(this.clusterLayerId)) {\n          this.map.removeLayer(this.clusterLayerId);\n        }\n        if (this.map.getLayer(this.clusterCountLayerId)) {\n          this.map.removeLayer(this.clusterCountLayerId);\n        }\n        if (this.map.getLayer('cars-unclustered')) {\n          this.map.removeLayer('cars-unclustered');\n        }\n        if (this.map.getSource(this.clusterSourceId)) {\n          this.map.removeSource(this.clusterSourceId);\n        }\n        this.removeSearchRadiusLayer();\n        this.removeDeliveryIsochrone();\n        this.removeDirectionsRoute();\n      } catch {\n        // Layers may not exist\n      }\n    }\n\n    if (this.userLocationMarker) {\n      this.userLocationMarker.remove();\n      this.userLocationMarker = null;\n    }\n\n    if (this.map) {\n      this.map.remove();\n      this.map = null;\n    }\n\n    // Clear component pools\n    this.clearComponentPools();\n  }\n\n  /**\n   * Public method to fly to car location with smooth animation\n   */\n  flyToCarLocation(carId: string): void {\n    const car = this.cars.find((c) => c['carId'] === carId);\n    if (car && this.map && car.lat && car.lng) {\n      this.map.flyTo({\n        center: [car.lng, car.lat],\n        zoom: 16, // Closer zoom for better focus\n        pitch: 0, // Flat 2D view\n        bearing: 0, // North-up orientation\n        duration: 1500, // Smooth animation\n        essential: true,\n      });\n      this.highlightSelectedCar(carId);\n    }\n  }\n\n  /**\n   * Public method to fly to a specific location (lat/lng)\n   */\n  flyToLocation(lat: number, lng: number, zoom = 14): void {\n    if (this.map) {\n      this.map.flyTo({\n        center: [lng, lat],\n        zoom,\n        essential: true,\n        duration: 1200,\n      });\n    }\n  }\n\n  /**\n   * Handle booking panel close\n   */\n  onBookingPanelClose(): void {\n    this.bookingPanelOpen.set(false);\n    this.selectedCarForBooking.set(null);\n  }\n\n  onDetailsPanelClose(): void {\n    this.selectedCar.set(null);\n    if (this.selectedCarId) {\n      this.removeHighlightFromCar(this.selectedCarId);\n    }\n  }\n\n  onQuickBookFromDetails(carId: string): void {\n    this.openBookingPanelForCarId(carId);\n  }\n\n  private openBookingPanelForCarId(carId: string): void {\n    const car = this.cars.find((c) => c['carId'] === carId) ?? null;\n    if (!car) {\n      return;\n    }\n\n    this.selectedCarForBooking.set(car);\n    this.bookingPanelOpen.set(true);\n  }\n\n  /**\n   * Handle booking confirmed\n   */\n  onBookingConfirmed(bookingData: BookingFormData): void {\n    const carId = this.selectedCarForBooking()?.['carId'];\n    if (carId) {\n      this.bookingConfirmed.emit({ carId, bookingData });\n    }\n    this.bookingPanelOpen.set(false);\n    this.selectedCarForBooking.set(null);\n  }\n\n  /**\n   * Update markers when cars input changes\n   */\n  ngOnChanges(changes: SimpleChanges): void {\n    if (changes['cars'] && !changes['cars'].firstChange && this.map) {\n      // Update spatial index first, then markers\n      this.updateSpatialIndex();\n      this.scheduleDebouncedUpdate(() => this.updateMarkersBasedOnCount());\n    }\n    if (changes['selectedCarId'] && !changes['selectedCarId'].firstChange && this.map) {\n      const previousId = changes['selectedCarId'].previousValue;\n      const currentId = changes['selectedCarId'].currentValue;\n\n      // Remove highlight from previous\n      if (previousId) {\n        this.removeHighlightFromCar(previousId);\n      }\n\n      // Highlight current\n      if (currentId) {\n        this.highlightSelectedCar(currentId);\n        const car = this.cars.find((c) => c['carId'] === currentId);\n        if (car) {\n          this.selectedCar.set(car);\n        }\n      } else {\n        this.selectedCar.set(null);\n      }\n    }\n    if (changes['userLocation'] && !changes['userLocation'].firstChange && this.map) {\n      this.addUserLocationMarker();\n      if (this.showSearchRadius) {\n        this.addSearchRadiusLayer();\n      }\n    }\n    if (changes['locationMode'] && !changes['locationMode'].firstChange) {\n      this.updateMarkerStyles();\n    }\n    if (changes['markerVariant'] && !changes['markerVariant'].firstChange) {\n      this.updateMapTheme();\n      // Re-render markers with new variant\n      if (this.map) {\n        this.scheduleDebouncedUpdate(() => this.updateMarkersBasedOnCount());\n      }\n    }\n    if (changes['searchRadiusKm'] && !changes['searchRadiusKm'].firstChange && this.map) {\n      if (this.showSearchRadius) {\n        this.addSearchRadiusLayer();\n      }\n      this.searchRadiusChange.emit(this.searchRadiusKm);\n    }\n    if (changes['showSearchRadius'] && !changes['showSearchRadius'].firstChange && this.map) {\n      if (this.showSearchRadius) {\n        this.addSearchRadiusLayer();\n      } else {\n        this.removeSearchRadiusLayer();\n      }\n    }\n    if (changes['followUserLocation'] && !changes['followUserLocation'].firstChange) {\n      if (this.followUserLocation) {\n        this.startFollowingLocation();\n      } else {\n        this.stopFollowingLocation();\n      }\n    }\n    if (changes['lockZoomRotation'] && !changes['lockZoomRotation'].firstChange) {\n      this.setupLockControls();\n    }\n    if (\n      changes['showDeliveryIsochrone'] ||\n      changes['selectedCarId'] ||\n      changes['deliveryTimeMinutes']\n    ) {\n      if (this.showDeliveryIsochrone && this.selectedCarId && this.map) {\n        this.addDeliveryIsochrone();\n      } else {\n        this.removeDeliveryIsochrone();\n      }\n    }\n    if (changes['showDirectionsRoute'] || changes['selectedCarId'] || changes['userLocation']) {\n      if (this.showDirectionsRoute && this.selectedCarId && this.userLocation && this.map) {\n        this.addDirectionsRoute();\n      } else {\n        this.removeDirectionsRoute();\n      }\n    }\n  }\n\n  /**\n   * Maneja el toggle de capas del mapa\n   */\n  onLayerToggle(event: { layerId: string; visible: boolean }): void {\n    switch (event.layerId) {\n      case 'base-map':\n        this.showBaseMap.set(event.visible);\n        // Ocultar/mostrar el mapa base (si es necesario)\n        if (this.map) {\n          const container = this.map.getContainer();\n          container.style.opacity = event.visible ? '1' : '0.3';\n        }\n        break;\n      case 'user-location':\n        this.showUserLocation.set(event.visible);\n        if (event.visible) {\n          this.addUserLocationMarker();\n        } else {\n          if (this.userLocationMarker) {\n            this.userLocationMarker.remove();\n            this.userLocationMarker = null;\n          }\n        }\n        break;\n      case 'marketplace-cars':\n        this.showMarketplaceCars.set(event.visible);\n        if (event.visible) {\n          this.renderCarMarkers();\n        } else {\n          this.clearMarkers();\n        }\n        break;\n      default:\n        console.warn(`[CarsMap] Unhandled layer toggle: ${event.layerId}`);\n        break;\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/shared/components/email-verification/email-verification.component.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`@core/services/auth/email-verification.service` import should occur before import of `../../../core/constants/timing.constants`","line":13,"column":1,"nodeType":"ImportDeclaration","endLine":13,"endColumn":91,"fix":{"range":[184,363],"text":"import { EmailVerificationService } from '@core/services/auth/email-verification.service';\nimport { SUCCESS_MESSAGE_DURATION_MS } from '../../../core/constants/timing.constants';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"\nimport {\n  ChangeDetectionStrategy,\n  Component,\n  OnDestroy,\n  OnInit,\n  computed,\n  inject,\n  signal,\n} from '@angular/core';\nimport { TranslateModule } from '@ngx-translate/core';\nimport { SUCCESS_MESSAGE_DURATION_MS } from '../../../core/constants/timing.constants';\nimport { EmailVerificationService } from '@core/services/auth/email-verification.service';\n\n@Component({\n  standalone: true,\n  selector: 'app-email-verification',\n  imports: [TranslateModule],\n  template: `\n    <div class=\"bg-surface-raised rounded-lg border border-border-default p-6\">\n      <!-- Header -->\n      <div class=\"flex items-start justify-between mb-4\">\n        <div class=\"flex items-center gap-3\">\n          <div\n            class=\"w-10 h-10 rounded-full flex items-center justify-center text-lg\"\n            [class]=\"getStatusBadgeClass()\"\n            >\n            {{ getStatusIcon() }}\n          </div>\n          <div>\n            <h4 class=\"font-semibold text-text-primary\">Verificación de Email</h4>\n            <p class=\"text-sm text-text-secondary dark:text-text-secondary\">\n              {{ status().value || 'No configurado' }}\n            </p>\n          </div>\n        </div>\n        <span class=\"text-xs font-medium px-2 py-1 rounded-full\" [class]=\"getStatusLabelClass()\">\n          {{ getStatusLabel() }}\n        </span>\n      </div>\n    \n      <!-- Verified State -->\n      @if (status().isVerified) {\n        <div\n          class=\"p-4 bg-success-light/10 border border-success-light/40 rounded-lg\"\n          >\n          <div class=\"flex items-center gap-2 text-success-strong\">\n            <svg class=\"w-5 h-5\" fill=\"currentColor\" viewBox=\"0 0 20 20\">\n              <path\n                fill-rule=\"evenodd\"\n                d=\"M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z\"\n                clip-rule=\"evenodd\"\n                />\n            </svg>\n            <span class=\"text-sm font-medium\">Email verificado exitosamente</span>\n          </div>\n          <p class=\"text-xs text-success-strong mt-2\">\n            Verificado el {{ formatDate(status().verifiedAt) }}\n          </p>\n        </div>\n      }\n    \n      <!-- Pending State -->\n      @if (!status().isVerified) {\n        <div class=\"space-y-4\">\n          <div class=\"p-4 bg-warning-bg border border-warning-border rounded-lg\">\n            <p class=\"text-sm text-warning-strong\">\n              Te enviamos un email de verificación a\n              <strong>{{ status().value }}</strong\n                >. Por favor revisa tu bandeja de entrada y haz click en el link de confirmación.\n              </p>\n            </div>\n            <!-- Resend Button -->\n            <div class=\"flex items-center gap-3\">\n              <button\n                type=\"button\"\n                (click)=\"resendEmail()\"\n                [disabled]=\"!canResend() || loading()\"\n                class=\"flex-grow px-4 py-2 text-sm font-medium rounded-lg transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed\"\n            [class]=\"\n              canResend()\n                ? 'bg-cta-default text-cta-text hover:bg-cta-default focus:ring-2 focus:ring-cta-default focus:ring-offset-2'\n                : 'bg-surface-hover text-text-secondary dark:text-text-secondary cursor-not-allowed'\n            \"\n                >\n                @if (!loading()) {\n                  <span class=\"flex items-center justify-center gap-2\">\n                    <svg class=\"w-4 h-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                      <path\n                        stroke-linecap=\"round\"\n                        stroke-linejoin=\"round\"\n                        stroke-width=\"2\"\n                        d=\"M3 8l7.89 5.26a2 2 0 002.22 0L21 8M5 19h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z\"\n                        />\n                    </svg>\n                    <span>{{\n                      cooldownRemaining() > 0 ? 'Espera ' + cooldownRemaining() + 's' : 'Reenviar email'\n                    }}</span>\n                  </span>\n                }\n                @if (loading()) {\n                  <span class=\"flex items-center justify-center gap-2\">\n                    <div class=\"animate-spin rounded-full h-4 w-4 border-b-2 border-white\"></div>\n                    <span>Enviando...</span>\n                  </span>\n                }\n              </button>\n            </div>\n            <!-- Success Message -->\n            @if (successMessage()) {\n              <div\n                class=\"p-3 bg-success-light/10 border border-success-light/40 rounded-lg text-sm text-success-strong\"\n                >\n                {{ successMessage() }}\n              </div>\n            }\n            <!-- Error Message -->\n            @if (error()) {\n              <div\n                class=\"p-3 bg-error-bg border border-error-border rounded-lg text-sm text-error-strong\"\n                >\n                {{ error() }}\n              </div>\n            }\n            <!-- Help Text -->\n            <div class=\"text-xs text-text-secondary dark:text-text-secondary\">\n              <p>• Revisa tu carpeta de spam si no encuentras el email</p>\n              <p>• El link de verificación expira en 24 horas</p>\n              <p>• Puedes reenviar el email cada 60 segundos</p>\n            </div>\n          </div>\n        }\n      </div>\n    `,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class EmailVerificationComponent implements OnInit, OnDestroy {\n  private readonly emailVerificationService = inject(EmailVerificationService);\n\n  readonly status = this.emailVerificationService.status;\n  readonly loading = this.emailVerificationService.loading;\n  readonly error = this.emailVerificationService.error;\n\n  readonly cooldownRemaining = signal(0);\n  readonly successMessage = signal<string | null>(null);\n  readonly canResend = computed(() => this.status().canResend && this.cooldownRemaining() === 0);\n\n  private unsubscribe?: () => void;\n  private stopCooldownTimer?: () => void;\n\n  async ngOnInit(): Promise<void> {\n    // Load initial status\n    await this.emailVerificationService.checkEmailStatus();\n\n    // Subscribe to changes\n    this.unsubscribe = this.emailVerificationService.subscribeToEmailChanges((verified) => {\n      if (verified) {\n        this.successMessage.set('¡Email verificado exitosamente!');\n        setTimeout(() => this.successMessage.set(null), SUCCESS_MESSAGE_DURATION_MS);\n      }\n    });\n\n    // Start cooldown timer if needed\n    if (this.status().cooldownSeconds && this.status()!.cooldownSeconds > 0) {\n      this.startCooldownTimer();\n    }\n  }\n\n  ngOnDestroy(): void {\n    this.unsubscribe?.();\n    this.stopCooldownTimer?.();\n  }\n\n  async resendEmail(): Promise<void> {\n    if (!this.canResend()) {\n      return;\n    }\n\n    this.successMessage.set(null);\n    this.emailVerificationService.clearError();\n\n    try {\n      await this.emailVerificationService.resendVerificationEmail();\n      this.successMessage.set('Email de verificación enviado. Revisa tu bandeja de entrada.');\n      this.startCooldownTimer();\n\n      // Auto-hide success message after 5 seconds\n      setTimeout(() => this.successMessage.set(null), SUCCESS_MESSAGE_DURATION_MS);\n    } catch (_error) {\n      // Error is handled by service\n      console.error('Failed to resend verification email:', _error);\n    }\n  }\n\n  private startCooldownTimer(): void {\n    this.stopCooldownTimer?.();\n\n    this.stopCooldownTimer = this.emailVerificationService.startCooldownTimer((remaining) => {\n      this.cooldownRemaining.set(remaining);\n    });\n  }\n\n  getStatusIcon(): string {\n    return this.status().isVerified ? '✓' : '○';\n  }\n\n  getStatusBadgeClass(): string {\n    return this.status().isVerified\n      ? 'bg-success-light/20 text-success-strong'\n      : 'bg-warning-bg-hover text-warning-text';\n  }\n\n  getStatusLabel(): string {\n    return this.status().isVerified ? 'Verificado' : 'Pendiente';\n  }\n\n  getStatusLabelClass(): string {\n    return this.status().isVerified\n      ? 'bg-success-light/20 text-success-strong'\n      : 'bg-warning-bg-hover text-warning-strong';\n  }\n\n  formatDate(dateStr: string | null | undefined): string {\n    if (!dateStr) return '';\n\n    const date = new Date(dateStr);\n    return date.toLocaleDateString('es-AR', {\n      day: 'numeric',\n      month: 'long',\n      year: 'numeric',\n      hour: '2-digit',\n      minute: '2-digit',\n    });\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/shared/components/help-button/help-button.component.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`@core/services/auth/auth.service` import should occur before import of `../../../core/guided-tour/guided-tour.service`","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":8,"endColumn":64,"fix":{"range":[182,418],"text":"import { AuthService } from '@core/services/auth/auth.service';\nimport { GuidedTourService } from '../../../core/guided-tour/guided-tour.service';\nimport { TourId } from '../../../core/guided-tour/interfaces/tour-definition.interface';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import {Component, inject, signal,\n  ChangeDetectionStrategy} from '@angular/core';\n\nimport { Router } from '@angular/router';\nimport { TranslateModule } from '@ngx-translate/core';\nimport { GuidedTourService } from '../../../core/guided-tour/guided-tour.service';\nimport { TourId } from '../../../core/guided-tour/interfaces/tour-definition.interface';\nimport { AuthService } from '@core/services/auth/auth.service';\nimport { HeaderIconComponent } from '../header-icon/header-icon.component';\n\n@Component({\n  selector: 'app-help-button',\n  standalone: true,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  imports: [TranslateModule, HeaderIconComponent],\n  template: `\n    <div class=\"relative\">\n      <button\n        id=\"help-center\"\n        data-tour-step=\"welcome-help\"\n        class=\"icon-button h-10 w-10 lg:h-11 lg:w-11\"\n        (click)=\"toggleMenu()\"\n        [attr.aria-label]=\"'common.help' | translate\"\n        [attr.aria-expanded]=\"showMenu()\"\n        title=\"Centro de ayuda\"\n        type=\"button\"\n      >\n        <app-header-icon\n          name=\"help\"\n          [size]=\"22\"\n          cssClass=\"lg:w-6 lg:h-6\"\n        />\n      </button>\n\n      @if (showMenu()) {\n        <!-- Backdrop -->\n        <div class=\"fixed inset-0 z-40\" (click)=\"closeMenu()\" aria-hidden=\"true\"></div>\n\n        <!-- Menu dropdown -->\n        <div\n          class=\"help-dropdown absolute right-0 mt-2 w-80 card-premium shadow-elevated p-4 z-50 animate-fade-in\"\n          role=\"menu\"\n          aria-labelledby=\"help-center\"\n        >\n          <h3 class=\"text-sm font-semibold mb-3 text-text-primary dark:text-text-primary\">\n            Centro de ayuda\n          </h3>\n\n          <!-- Convertite en Renter (destacado) -->\n          <button\n            (click)=\"navigateToBecomeRenter()\"\n            class=\"w-full text-left px-4 py-3 rounded-lg bg-gradient-to-r from-cta-default/10 to-cta-hover/10 hover:from-cta-default/20 hover:to-cta-hover/20 dark:from-cyan-500/10 dark:to-cyan-600/10 dark:hover:from-cyan-500/20 dark:hover:to-cyan-600/20 mb-3 transition-base border border-cta-default/20 dark:border-cyan-500/20\"\n            role=\"menuitem\"\n          >\n            <div class=\"flex items-start gap-3\">\n              <div class=\"text-xl\">🏠</div>\n              <div class=\"flex-1\">\n                <div class=\"font-semibold text-sm text-cta-default dark:text-cyan-400 mb-1\">\n                  Convertite en Renter\n                </div>\n                <div class=\"text-xs text-text-muted dark:text-gray-500\">\n                  Publicá tu auto y generá ingresos extras\n                </div>\n              </div>\n            </div>\n          </button>\n\n          <!-- Invitar amigo -->\n          @if (isAuthenticated()) {\n            <button\n              (click)=\"navigateToReferrals()\"\n              class=\"w-full text-left px-3 py-2.5 rounded-lg hover:bg-surface-secondary dark:hover:bg-slate-deep text-sm mb-2 transition-base text-text-secondary dark:text-text-secondary flex items-center gap-2\"\n              role=\"menuitem\"\n            >\n              <span class=\"text-lg\">🎁</span>\n              <span>Invitá a un amigo Renter</span>\n            </button>\n          }\n\n          <hr class=\"my-2 border-border-default/40 dark:border-white/10\" />\n\n          <!-- Tours guiados -->\n          <div class=\"text-xs font-medium text-text-muted dark:text-gray-500 px-3 mb-2\">\n            Tours guiados\n          </div>\n\n          <button\n            (click)=\"showTour('welcome')\"\n            class=\"w-full text-left px-3 py-2 rounded-lg hover:bg-surface-secondary dark:hover:bg-slate-deep text-sm mb-1 transition-base text-text-secondary dark:text-text-secondary flex items-center gap-2\"\n            role=\"menuitem\"\n          >\n            <span>🎯</span>\n            <span>Tour de bienvenida</span>\n          </button>\n\n          <button\n            (click)=\"showTour('renter')\"\n            class=\"w-full text-left px-3 py-2 rounded-lg hover:bg-surface-secondary dark:hover:bg-slate-deep text-sm mb-1 transition-base text-text-secondary dark:text-text-secondary flex items-center gap-2\"\n            role=\"menuitem\"\n          >\n            <span>🔍</span>\n            <span>Cómo buscar y reservar autos</span>\n          </button>\n\n          <button\n            (click)=\"showTour('become-renter')\"\n            class=\"w-full text-left px-3 py-2 rounded-lg hover:bg-surface-secondary dark:hover:bg-slate-deep text-sm mb-1 transition-base text-text-secondary dark:text-text-secondary flex items-center gap-2\"\n            role=\"menuitem\"\n          >\n            <span>🏠</span>\n            <span>Convertirse en Renter</span>\n          </button>\n\n          <button\n            (click)=\"showTour('publish-car')\"\n            class=\"w-full text-left px-3 py-2 rounded-lg hover:bg-surface-secondary dark:hover:bg-slate-deep text-sm mb-1 transition-base text-text-secondary dark:text-text-secondary flex items-center gap-2\"\n            role=\"menuitem\"\n          >\n            <span>💸</span>\n            <span>Cómo publicar mi auto</span>\n          </button>\n\n          <button\n            (click)=\"showTour('referrals')\"\n            class=\"w-full text-left px-3 py-2 rounded-lg hover:bg-surface-secondary dark:hover:bg-slate-deep text-sm mb-1 transition-base text-text-secondary dark:text-text-secondary flex items-center gap-2\"\n            role=\"menuitem\"\n          >\n            <span>🎁</span>\n            <span>Sistema de referidos</span>\n          </button>\n\n          @if (isAuthenticated()) {\n            <button\n              (click)=\"showTour('wallet')\"\n              class=\"w-full text-left px-3 py-2 rounded-lg hover:bg-surface-secondary dark:hover:bg-slate-deep text-sm mb-2 transition-base text-text-secondary dark:text-text-secondary flex items-center gap-2\"\n              role=\"menuitem\"\n            >\n              <span>💰</span>\n              <span>Wallet y ganancias</span>\n            </button>\n          }\n\n          <hr class=\"my-2 border-border-default/40 dark:border-white/10\" />\n\n          <!-- Soporte -->\n          <a\n            href=\"mailto:soporte@autorentar.com\"\n            class=\"w-full text-left px-3 py-2 rounded-lg hover:bg-surface-secondary dark:hover:bg-slate-deep text-sm flex items-center gap-2 transition-base text-text-secondary dark:text-text-secondary mb-2\"\n            role=\"menuitem\"\n          >\n            <svg\n              class=\"w-4 h-4\"\n              fill=\"none\"\n              stroke=\"currentColor\"\n              viewBox=\"0 0 24 24\"\n              aria-hidden=\"true\"\n            >\n              <path\n                stroke-linecap=\"round\"\n                stroke-linejoin=\"round\"\n                stroke-width=\"2\"\n                d=\"M3 8l7.89 5.26a2 2 0 002.22 0L21 8M5 19h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z\"\n              />\n            </svg>\n            Contactar soporte\n          </a>\n\n          <!-- Login si no está autenticado -->\n          @if (!isAuthenticated()) {\n            <button\n              (click)=\"navigateToLogin()\"\n              class=\"w-full text-left px-3 py-2 rounded-lg bg-cta-default hover:bg-cta-hover dark:bg-cyan-600 dark:hover:bg-cyan-500 text-cta-text dark:text-white text-sm font-medium transition-base flex items-center justify-center gap-2\"\n              role=\"menuitem\"\n            >\n              Iniciá sesión o registrate\n            </button>\n          }\n        </div>\n      }\n    </div>\n  `,\n  styles: [\n    `\n      :host {\n        display: inline-block;\n      }\n\n      .help-dropdown {\n        border-radius: 1rem;\n      }\n\n      @media (max-width: 768px) {\n        .help-dropdown {\n          position: fixed;\n          left: 1rem;\n          right: 1rem;\n          top: 4.25rem;\n          width: auto;\n          max-height: calc(100vh - 5.5rem);\n          overflow-y: auto;\n        }\n      }\n    `,\n  ],\n})\nexport class HelpButtonComponent {\n  private readonly guidedTour = inject(GuidedTourService);\n  private readonly router = inject(Router);\n  private readonly authService = inject(AuthService);\n\n  readonly showMenu = signal(false);\n  readonly isAuthenticated = this.authService.isAuthenticated;\n\n  toggleMenu(): void {\n    this.showMenu.update((v) => !v);\n  }\n\n  closeMenu(): void {\n    this.showMenu.set(false);\n  }\n\n  showTour(\n    tourType:\n      | 'welcome'\n      | 'renter'\n      | 'owner'\n      | 'become-renter'\n      | 'publish-car'\n      | 'referrals'\n      | 'wallet',\n  ): void {\n    this.closeMenu();\n\n    // Map tour types to Tour IDs\n    const tourIdMap: Record<\n      'welcome' | 'renter' | 'owner' | 'become-renter' | 'publish-car' | 'referrals' | 'wallet',\n      TourId\n    > = {\n      welcome: TourId.Welcome,\n      renter: TourId.Renter,\n      owner: TourId.Owner,\n      'become-renter': TourId.BecomeRenter,\n      'publish-car': TourId.PublishCar,\n      referrals: TourId.ReferralSystem,\n      wallet: TourId.WalletEarnings,\n    };\n\n    const tourId = tourIdMap[tourType];\n\n    // Define the required routes for each tour\n    const tourRoutes: Record<\n      'welcome' | 'renter' | 'owner' | 'become-renter' | 'publish-car' | 'referrals' | 'wallet',\n      string | null\n    > = {\n      welcome: null, // Can be shown anywhere\n      renter: '/cars',\n      owner: null, // Old tour, keep for compatibility\n      'become-renter': '/become-renter',\n      'publish-car': '/cars/publish',\n      referrals: '/referrals',\n      wallet: '/wallet',\n    };\n\n    const requiredRoute = tourRoutes[tourType];\n\n    if (requiredRoute && !this.router.url.includes(requiredRoute)) {\n      // Navigate to the required route first\n      this.router.navigate([requiredRoute]).then(() => {\n        setTimeout(() => {\n          this.guidedTour.reset(tourId);\n          this.guidedTour.request({\n            id: tourId,\n            mode: 'user-triggered',\n            force: true,\n          });\n        }, 500);\n      });\n    } else {\n      // Start tour immediately\n      this.guidedTour.reset(tourId);\n      this.guidedTour.request({\n        id: tourId,\n        mode: 'user-triggered',\n        force: true,\n      });\n    }\n  }\n\n  /**\n   * Navegar a la página \"Convertite en Renter\"\n   */\n  navigateToBecomeRenter(): void {\n    this.closeMenu();\n    this.router.navigate(['/become-renter']);\n  }\n\n  /**\n   * Navegar a la página de login/registro\n   */\n  navigateToLogin(): void {\n    this.closeMenu();\n    this.router.navigate(['/login']);\n  }\n\n  /**\n   * Navegar a la página de referidos\n   */\n  navigateToReferrals(): void {\n    this.closeMenu();\n    this.router.navigate(['/referrals']);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/shared/components/inspection-comparison-modal/inspection-comparison-modal.component.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":85,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":85,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3025,3028],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3025,3028],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@angular-eslint/use-lifecycle-interface","severity":1,"message":"Lifecycle interface 'OnInit' should be implemented for method 'ngOnInit'. (https://angular.dev/style-guide#use-lifecycle-hook-interfaces)","line":87,"column":9,"nodeType":"Identifier","messageId":"useLifecycleInterface","endLine":87,"endColumn":17,"fix":{"range":[41,2842],"text":", OnInit } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { IonicModule, ModalController } from '@ionic/angular';\nimport { VideoDamageDetectionService } from '@core/services/verification/video-damage-detection.service';\n\n@Component({\n  selector: 'app-inspection-comparison-modal',\n  standalone: true,\n  imports: [CommonModule, IonicModule],\n  template: `\n    <ion-header>\n      <ion-toolbar>\n        <ion-title>Comparación Check-In vs Check-Out</ion-title>\n        <ion-buttons slot=\"end\">\n          <ion-button (click)=\"dismiss()\">\n            <ion-icon name=\"close\"></ion-icon>\n          </ion-button>\n        </ion-buttons>\n      </ion-toolbar>\n    </ion-header>\n    \n    <ion-content>\n      @if (comparisonResult(); as result) {\n        <ion-card [color]=\"result.newDamages.length > 0 ? 'warning' : 'success'\">\n          <ion-card-header>\n            <ion-card-title>\n              @if (result.newDamages.length > 0) {\n                <ion-icon name=\"warning\"></ion-icon>\n                {{ result.newDamages.length }} Daño(s) Nuevo(s)\n              } @else {\n                <ion-icon name=\"checkmark-circle\"></ion-icon>\n                Sin Daños Nuevos\n              }\n            </ion-card-title>\n          </ion-card-header>\n          <ion-card-content>\n            <p>{{ result.summary }}</p>\n            @if (result.totalEstimatedCost > 0) {\n              <div class=\"cost\">\\${{ result.totalEstimatedCost.toFixed(2) }} USD</div>\n            }\n          </ion-card-content>\n        </ion-card>\n        \n        @if (result.newDamages.length > 0) {\n          <ion-list>\n            @for (damage of result.newDamages; track damage.id) {\n              <ion-item>\n                <ion-label>\n                  <h3>{{ damage.type }}</h3>\n                  <p>{{ damage.description }} - {{ damage.location }}</p>\n                </ion-label>\n                <ion-badge slot=\"end\">\\${{ damage.estimatedCostUsd }}</ion-badge>\n              </ion-item>\n            }\n          </ion-list>\n          \n          <div class=\"actions\">\n            <ion-button expand=\"block\" color=\"danger\" (click)=\"openDispute()\">\n              Abrir Disputa\n            </ion-button>\n            <ion-button expand=\"block\" fill=\"outline\" (click)=\"acceptCharges()\">\n              Aceptar Cargos\n            </ion-button>\n          </div>\n        }\n      } @else {\n        <div class=\"loading\">\n          <ion-spinner></ion-spinner>\n          <p>Comparando inspecciones...</p>\n        </div>\n      }\n    </ion-content>\n  `,\n  styles: [`\n    .cost { margin-top: 12px; font-size: 20px; font-weight: bold; }\n    .loading { text-align: center; padding: 64px 16px; }\n    .actions { padding: 16px; display: flex; flex-direction: column; gap: 12px; }\n  `]\n})\nexport class InspectionComparisonModalComponent implements OnInit"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { Component, inject, input, signal } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { IonicModule, ModalController } from '@ionic/angular';\nimport { VideoDamageDetectionService } from '@core/services/verification/video-damage-detection.service';\n\n@Component({\n  selector: 'app-inspection-comparison-modal',\n  standalone: true,\n  imports: [CommonModule, IonicModule],\n  template: `\n    <ion-header>\n      <ion-toolbar>\n        <ion-title>Comparación Check-In vs Check-Out</ion-title>\n        <ion-buttons slot=\"end\">\n          <ion-button (click)=\"dismiss()\">\n            <ion-icon name=\"close\"></ion-icon>\n          </ion-button>\n        </ion-buttons>\n      </ion-toolbar>\n    </ion-header>\n    \n    <ion-content>\n      @if (comparisonResult(); as result) {\n        <ion-card [color]=\"result.newDamages.length > 0 ? 'warning' : 'success'\">\n          <ion-card-header>\n            <ion-card-title>\n              @if (result.newDamages.length > 0) {\n                <ion-icon name=\"warning\"></ion-icon>\n                {{ result.newDamages.length }} Daño(s) Nuevo(s)\n              } @else {\n                <ion-icon name=\"checkmark-circle\"></ion-icon>\n                Sin Daños Nuevos\n              }\n            </ion-card-title>\n          </ion-card-header>\n          <ion-card-content>\n            <p>{{ result.summary }}</p>\n            @if (result.totalEstimatedCost > 0) {\n              <div class=\"cost\">\\${{ result.totalEstimatedCost.toFixed(2) }} USD</div>\n            }\n          </ion-card-content>\n        </ion-card>\n        \n        @if (result.newDamages.length > 0) {\n          <ion-list>\n            @for (damage of result.newDamages; track damage.id) {\n              <ion-item>\n                <ion-label>\n                  <h3>{{ damage.type }}</h3>\n                  <p>{{ damage.description }} - {{ damage.location }}</p>\n                </ion-label>\n                <ion-badge slot=\"end\">\\${{ damage.estimatedCostUsd }}</ion-badge>\n              </ion-item>\n            }\n          </ion-list>\n          \n          <div class=\"actions\">\n            <ion-button expand=\"block\" color=\"danger\" (click)=\"openDispute()\">\n              Abrir Disputa\n            </ion-button>\n            <ion-button expand=\"block\" fill=\"outline\" (click)=\"acceptCharges()\">\n              Aceptar Cargos\n            </ion-button>\n          </div>\n        }\n      } @else {\n        <div class=\"loading\">\n          <ion-spinner></ion-spinner>\n          <p>Comparando inspecciones...</p>\n        </div>\n      }\n    </ion-content>\n  `,\n  styles: [`\n    .cost { margin-top: 12px; font-size: 20px; font-weight: bold; }\n    .loading { text-align: center; padding: 64px 16px; }\n    .actions { padding: 16px; display: flex; flex-direction: column; gap: 12px; }\n  `]\n})\nexport class InspectionComparisonModalComponent {\n  private modalCtrl = inject(ModalController);\n  private videoService = inject(VideoDamageDetectionService);\n  \n  bookingId = input.required<string>();\n  comparisonResult = signal<any>(null);\n  \n  async ngOnInit() {\n    try {\n      const result = await this.videoService.compareInspections(this.bookingId());\n      this.comparisonResult.set(result);\n    } catch (error) {\n      console.error('Error comparing inspections:', error);\n    }\n  }\n  \n  dismiss() {\n    this.modalCtrl.dismiss();\n  }\n  \n  openDispute() {\n    this.modalCtrl.dismiss({ action: 'dispute' });\n  }\n  \n  acceptCharges() {\n    this.modalCtrl.dismiss({ \n      action: 'accept', \n      amount: this.comparisonResult()?.totalEstimatedCost \n    });\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/shared/components/inspection-uploader/inspection-uploader.component.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`@core/services/verification/fgo-v1-1.service` import should occur before import of `../icon/icon.component`","line":19,"column":1,"nodeType":"ImportDeclaration","endLine":19,"endColumn":79,"fix":{"range":[231,480],"text":"import { FgoV1_1Service } from '@core/services/verification/fgo-v1-1.service';\nimport { IconComponent } from '../icon/icon.component';\nimport {\n  BookingInspection,\n  InspectionPhoto,\n  InspectionStage,\n} from '../../../core/models/fgo-v1-1.model';\n"}},{"ruleId":"import/order","severity":1,"message":"`@core/services/infrastructure/supabase-client.service` import should occur before import of `../icon/icon.component`","line":20,"column":1,"nodeType":"ImportDeclaration","endLine":20,"endColumn":95,"fix":{"range":[231,575],"text":"import { SupabaseClientService } from '@core/services/infrastructure/supabase-client.service';\nimport { IconComponent } from '../icon/icon.component';\nimport {\n  BookingInspection,\n  InspectionPhoto,\n  InspectionStage,\n} from '../../../core/models/fgo-v1-1.model';\nimport { FgoV1_1Service } from '@core/services/verification/fgo-v1-1.service';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"\nimport {Component,\n  EventEmitter,\n  Input,\n  OnInit,\n  Output,\n  computed,\n  inject,\n  signal,\n  ChangeDetectionStrategy} from '@angular/core';\nimport { FormsModule } from '@angular/forms';\nimport { firstValueFrom } from 'rxjs';\nimport { IconComponent } from '../icon/icon.component';\nimport {\n  BookingInspection,\n  InspectionPhoto,\n  InspectionStage,\n} from '../../../core/models/fgo-v1-1.model';\nimport { FgoV1_1Service } from '@core/services/verification/fgo-v1-1.service';\nimport { SupabaseClientService } from '@core/services/infrastructure/supabase-client.service';\nimport {\n  validateFiles,\n  allFilesValid,\n  getFirstError,\n  logFileUpload,\n} from '../../../core/utils/file-validation.util';\n\n// Window extension for inspection callback\ninterface WindowWithInspectionCallback extends Window {\n  inspectionUploaderCallback?: (data: unknown) => void;\n}\n\n/**\n * Componente para subir inspecciones de vehículos (check-in/check-out)\n *\n * Standalone component que permite:\n * - Subir fotos (mínimo 8)\n * - Registrar odómetro\n * - Registrar nivel de combustible\n * - Firmar digitalmente\n *\n * Uso:\n * ```typescript\n * const modal = await this.modalCtrl.create({\n *   component: InspectionUploaderComponent,\n *   componentProps: { bookingId: '...', stage: 'check_in' }\n * });\n * ```\n */\n@Component({\n  selector: 'app-inspection-uploader',\n  standalone: true,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  imports: [FormsModule, IconComponent],\n  templateUrl: './inspection-uploader.component.html',\n  styleUrl: './inspection-uploader.component.css',\n})\nexport class InspectionUploaderComponent implements OnInit {\n  @Input() bookingId!: string;\n  @Input() stage!: InspectionStage;\n  @Output() inspectionCompleted = new EventEmitter<BookingInspection>();\n  @Output() inspectionCancelled = new EventEmitter<void>();\n\n  private readonly fgoService = inject(FgoV1_1Service);\n  private readonly supabaseService = inject(SupabaseClientService);\n\n  // Estado del componente\n  readonly photos = signal<InspectionPhoto[]>([]);\n  readonly uploading = signal(false);\n  readonly saving = signal(false);\n  readonly error = signal<string | null>(null);\n\n  // Datos de la inspección\n  odometer = 0;\n  fuelLevel = 100;\n\n  // Computed properties\n  readonly isValid = computed(() => {\n    return (\n      this.photos().length >= 8 && this.odometer > 0 && this.fuelLevel >= 0 && this.fuelLevel <= 100\n    );\n  });\n\n  readonly stageLabel = computed(() => {\n    if (this.stage === 'check_in') return 'Check-in';\n    if (this.stage === 'renter_check_in') return 'Recepción';\n    return 'Check-out';\n  });\n\n  readonly photoCount = computed(() => this.photos().length);\n\n  readonly missingPhotos = computed(() => {\n    const count = this.photoCount();\n    return count < 8 ? 8 - count : 0;\n  });\n\n  ngOnInit(): void {\n    if (!this.bookingId || !this.stage) {\n      this.error.set('Faltan parámetros requeridos: bookingId y stage');\n    }\n  }\n\n  /**\n   * Maneja la selección de fotos del input file\n   */\n  async onPhotosSelected(event: Event): Promise<void> {\n    const input = event.target as HTMLInputElement;\n    if (!input.files || input.files.length === 0) return;\n\n    this.uploading.set(true);\n    this.error.set(null);\n\n    try {\n      const files = Array.from(input.files);\n\n      // P0-014: Use centralized file validation\n      const validationResults = validateFiles(files, {\n        maxSizeBytes: 10 * 1024 * 1024, // 10MB max\n        allowedMimeTypes: ['image/jpeg', 'image/jpg', 'image/png', 'image/webp'],\n        checkMimeType: true,\n      });\n\n      if (!allFilesValid(validationResults)) {\n        const errorMsg = getFirstError(validationResults);\n        this.error.set(errorMsg || 'Invalid file detected');\n\n        // Log failed validation attempts\n        validationResults.forEach((result) => {\n          if (!result.valid) {\n            logFileUpload(result.fileName, false, result.error);\n          }\n        });\n        return;\n      }\n\n      // Subir fotos a Supabase Storage\n      for (const file of files) {\n        const photo = await this.uploadPhoto(file);\n        if (photo) {\n          this.photos.update((p) => [...p, photo]);\n          logFileUpload(file.name, true);\n        } else {\n          logFileUpload(file.name, false, 'Upload failed');\n        }\n      }\n    } catch {\n      this.error.set('Error al subir fotos. Intente nuevamente.');\n    } finally {\n      this.uploading.set(false);\n      // Limpiar input para permitir resubir las mismas fotos\n      input.value = '';\n    }\n  }\n\n  /**\n   * Sube una foto a Supabase Storage\n   */\n  private async uploadPhoto(file: File): Promise<InspectionPhoto | null> {\n    try {\n      const supabase = this.supabaseService.getClient();\n      const userId = (await supabase.auth.getUser()).data.user?.id;\n\n      if (!userId) {\n        throw new Error('Usuario no autenticado');\n      }\n\n      // Generar nombre único\n      const timestamp = Date.now();\n      const extension = file.name.split('.').pop() ?? 'jpg';\n      const fileName = `${this.bookingId}_${this.stage}_${timestamp}.${extension}`;\n      const filePath = `${userId}/inspections/${fileName}`;\n\n      // Subir a bucket 'car-images' (reutilizamos el bucket existente)\n      const { error: uploadError } = await supabase.storage\n        .from('car-images')\n        .upload(filePath, file, {\n          cacheControl: '3600',\n          upsert: false,\n        });\n\n      if (uploadError) {\n        throw uploadError;\n      }\n\n      // Obtener URL pública\n      const {\n        data: { publicUrl },\n      } = supabase.storage.from('car-images').getPublicUrl(filePath);\n\n      return {\n        url: publicUrl,\n        type: 'exterior', // Por defecto exterior, en versión avanzada podría categorizarse\n      };\n    } catch {\n      return null;\n    }\n  }\n\n  /**\n   * Elimina una foto de la lista\n   */\n  removePhoto(index: number): void {\n    this.photos.update((p) => p.filter((_, i) => i !== index));\n  }\n\n  /**\n   * Guarda la inspección y la firma\n   */\n  async save(): Promise<void> {\n    if (!this.isValid()) {\n      this.error.set('Complete todos los campos requeridos');\n      return;\n    }\n\n    this.saving.set(true);\n    this.error.set(null);\n\n    try {\n      // 1. Obtener ID del usuario actual (inspector)\n      const supabase = this.supabaseService.getClient();\n      const {\n        data: { user },\n      } = await supabase.auth.getUser();\n\n      if (!user) {\n        throw new Error('Usuario no autenticado');\n      }\n\n      // 2. Crear inspección\n      const inspection = await firstValueFrom(\n        this.fgoService.createInspection({\n          bookingId: this.bookingId,\n          stage: this.stage,\n          inspectorId: user.id,\n          photos: this.photos(),\n          odometer: this.odometer,\n          fuelLevel: this.fuelLevel,\n        }),\n      );\n\n      if (!inspection) {\n        throw new Error('No se pudo crear la inspección');\n      }\n\n      // 3. Firmar inspección\n      const signed = await firstValueFrom(this.fgoService.signInspection(inspection.id));\n\n      if (!signed) {\n        throw new Error('No se pudo firmar la inspección');\n      }\n\n      // 4. Emitir evento de completado\n      this.inspectionCompleted.emit(inspection);\n\n      // 5. También mantener compatibilidad con callback window (legacy)\n      const win = window as WindowWithInspectionCallback;\n      if (win.inspectionUploaderCallback) {\n        win.inspectionUploaderCallback(inspection);\n      }\n    } catch (_error) {\n      this.error.set(\n        _error instanceof Error\n          ? _error.message\n          : 'Error al guardar inspección. Intente nuevamente.',\n      );\n    } finally {\n      this.saving.set(false);\n    }\n  }\n\n  /**\n   * Cancela y cierra el modal\n   */\n  cancel(): void {\n    if (this.photos().length > 0 || this.odometer > 0) {\n      if (!confirm('¿Descartar inspección? Se perderán los datos ingresados.')) {\n        return;\n      }\n    }\n    this.inspectionCancelled.emit();\n\n    // También mantener compatibilidad con callback window (legacy)\n    const win = window as WindowWithInspectionCallback;\n    if (win.inspectionUploaderCallback) {\n      win.inspectionUploaderCallback(null);\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/shared/components/location-map-picker/location-map-picker.component.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`@core/services/geo/geocoding.service` import should occur before import of `../../../../environments/environment`","line":16,"column":1,"nodeType":"ImportDeclaration","endLine":16,"endColumn":73,"fix":{"range":[275,416],"text":"import { GeocodingService } from '@core/services/geo/geocoding.service';\nimport { environment } from '../../../../environments/environment';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"\nimport {AfterViewInit,\n  Component,\n  ElementRef,\n  EventEmitter,\n  Input,\n  OnDestroy,\n  OnInit,\n  Output,\n  signal,\n  ViewChild,\n  ChangeDetectionStrategy} from '@angular/core';\nimport { TranslateModule } from '@ngx-translate/core';\nimport type mapboxgl from 'mapbox-gl';\nimport { environment } from '../../../../environments/environment';\nimport { GeocodingService } from '@core/services/geo/geocoding.service';\n\n// Type import (doesn't increase bundle size)\n\nexport interface LocationCoordinates {\n  latitude: number;\n  longitude: number;\n  address?: string;\n}\n\n@Component({\n  selector: 'app-location-map-picker',\n  standalone: true,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  imports: [TranslateModule],\n  template: `\n    <div class=\"location-map-picker\">\n      <!-- Map container -->\n      <div #mapContainer class=\"map-container\"></div>\n    \n      <!-- Info panel -->\n      <div class=\"info-panel\">\n        <div class=\"flex items-start gap-2\">\n          <span class=\"text-cta-default text-lg\">ℹ️</span>\n          <div class=\"flex-1\">\n            <p class=\"text-sm font-medium text-text-primary\">\n              {{ isLoading() ? 'Cargando mapa...' : 'Ajusta la ubicación' }}\n            </p>\n            <p class=\"text-xs text-text-secondary dark:text-text-secondary mt-1\">\n              {{\n              isLoading()\n              ? 'Por favor espera...'\n              : 'Arrastra el marcador para ajustar la ubicación exacta de tu auto'\n              }}\n            </p>\n            @if (currentAddress()) {\n              <div\n                class=\"mt-2 text-xs text-text-primary bg-surface-base p-2 rounded\"\n                >\n                📍 {{ currentAddress() }}\n              </div>\n            }\n            @if (coordinates()) {\n              <div\n                class=\"mt-1 text-xs text-text-secondary dark:text-text-secondary\"\n                >\n                Lat: {{ coordinates()!.latitude.toFixed(6) }}, Lng:\n                {{ coordinates()!.longitude.toFixed(6) }}\n              </div>\n            }\n          </div>\n        </div>\n      </div>\n    </div>\n    `,\n  styles: [\n    `\n      .location-map-picker {\n        position: relative;\n        width: 100%;\n      }\n\n      .map-container {\n        width: 100%;\n        height: 400px;\n        border-radius: 0.5rem;\n        overflow: hidden;\n        border: 2px solid var(--border-default, #e5e7eb);\n      }\n\n      .info-panel {\n        margin-top: 1rem;\n        background: var(--surface-info-light, #eff6ff);\n        border: 1px solid var(--border-info-default, #bfdbfe);\n        border-radius: 0.5rem;\n        padding: 0.75rem;\n      }\n\n      :host {\n        display: block;\n      }\n\n      /* Ensure marker is visible */\n      ::ng-deep .mapboxgl-marker {\n        z-index: 10;\n      }\n    `,\n  ],\n})\nexport class LocationMapPickerComponent implements OnInit, AfterViewInit, OnDestroy {\n  @ViewChild('mapContainer') mapContainer!: ElementRef<HTMLDivElement>;\n\n  @Input() initialLatitude?: number;\n  @Input() initialLongitude?: number;\n  @Input() initialAddress?: string;\n\n  @Output() locationChange = new EventEmitter<LocationCoordinates>();\n\n  private map?: mapboxgl.Map;\n  private marker?: mapboxgl.Marker;\n  private mapboxgl?: typeof mapboxgl;\n\n  // Helper to get CSS variable value\n  private getCssVariableValue(variableName: string, defaultValue: string): string {\n    if (typeof document === 'undefined') return defaultValue; // Server-side rendering check\n    return (\n      getComputedStyle(document.documentElement).getPropertyValue(variableName).trim() ||\n      defaultValue\n    );\n  }\n\n  isLoading = signal(true);\n  coordinates = signal<LocationCoordinates | null>(null);\n  currentAddress = signal<string>('');\n\n  constructor(private readonly geocodingService: GeocodingService) {}\n\n  ngOnInit(): void {\n    if (this.initialAddress) {\n      this.currentAddress.set(this.initialAddress);\n    }\n  }\n\n  ngAfterViewInit(): void {\n    this.initializeMap();\n  }\n\n  ngOnDestroy(): void {\n    this.destroyMap();\n  }\n\n  private async initializeMap(): Promise<void> {\n    // Use initial coordinates or default to Buenos Aires center\n    const initialLng = this.initialLongitude ?? -58.3816;\n    const initialLat = this.initialLatitude ?? -34.6037;\n\n    try {\n      // Lazy load Mapbox GL (only imported at runtime, not in initial bundle)\n      const mapboxModule = await import('mapbox-gl');\n      const mapboxgl = mapboxModule.default;\n      this.mapboxgl = mapboxgl;\n\n      // Initialize Mapbox map\n      this.map = new mapboxgl.Map({\n        container: this.mapContainer.nativeElement,\n        style: 'mapbox://styles/mapbox/streets-v12',\n        center: [initialLng, initialLat],\n        zoom: 15,\n        accessToken: environment.mapboxAccessToken,\n      });\n\n      // Add navigation controls\n      this.map.addControl(new mapboxgl.NavigationControl(), 'top-right');\n\n      // Wait for map to load\n      this.map.on('load', () => {\n        this.isLoading.set(false);\n        this.addDraggableMarker(initialLng, initialLat);\n\n        // Set initial coordinates\n        const initialCoords: LocationCoordinates = {\n          latitude: initialLat,\n          longitude: initialLng,\n          address: this.initialAddress,\n        };\n        this.coordinates.set(initialCoords);\n        this.locationChange.emit(initialCoords);\n      });\n\n      // Handle map errors\n      this.map.on('error', (_e: unknown) => {\n        this.isLoading.set(false);\n      });\n    } catch {\n      this.isLoading.set(false);\n    }\n  }\n\n  private addDraggableMarker(lng: number, lat: number): void {\n    if (!this.map || !this.mapboxgl) return;\n\n    // Create draggable marker\n    this.marker = new this.mapboxgl.Marker({\n      draggable: true,\n      color: this.getCssVariableValue('--system-blue-default', '#4285F4'), // Blue color\n    })\n      .setLngLat([lng, lat])\n      .addTo(this.map);\n\n    // Handle marker drag end\n    this.marker.on('dragend', () => {\n      this.onMarkerDragEnd();\n    });\n  }\n\n  private async onMarkerDragEnd(): Promise<void> {\n    if (!this.marker) return;\n\n    const lngLat = this.marker.getLngLat();\n    const newCoordinates: LocationCoordinates = {\n      latitude: lngLat.lat,\n      longitude: lngLat.lng,\n    };\n\n    this.coordinates.set(newCoordinates);\n\n    // Perform reverse geocoding to get address\n    try {\n      // Note: Mapbox reverse geocoding would require a different API endpoint\n      // For now, we'll just emit the coordinates\n      // In a full implementation, you could call a reverse geocoding service\n      this.currentAddress.set('Ubicación ajustada manualmente');\n      newCoordinates.address = 'Ubicación ajustada manualmente';\n    } catch (__error) {\n      console.warn('No se pudo actualizar la dirección durante el drag del marcador', __error);\n    }\n\n    // Emit the new coordinates\n    this.locationChange.emit(newCoordinates);\n  }\n\n  /**\n   * Fly to a new location on the map\n   * This method can be called from parent components\n   */\n  public flyToLocation(latitude: number, longitude: number, address?: string): void {\n    if (!this.map || !this.marker) return;\n\n    this.map.flyTo({\n      center: [longitude, latitude],\n      zoom: 15,\n      essential: true,\n      duration: 1500,\n    });\n\n    this.marker.setLngLat([longitude, latitude]);\n\n    const newCoordinates: LocationCoordinates = {\n      latitude,\n      longitude,\n      address,\n    };\n\n    this.coordinates.set(newCoordinates);\n    if (address) {\n      this.currentAddress.set(address);\n    }\n    this.locationChange.emit(newCoordinates);\n  }\n\n  private destroyMap(): void {\n    if (this.marker) {\n      this.marker.remove();\n      this.marker = undefined;\n    }\n\n    if (this.map) {\n      this.map.remove();\n      this.map = undefined;\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/shared/components/mobile-menu-drawer/mobile-menu-drawer.component.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`../menu-icon/menu-icon.component` import should occur after import of `@core/services/auth/profile.service`","line":14,"column":1,"nodeType":"ImportDeclaration","endLine":14,"endColumn":70,"fix":{"range":[212,413],"text":"import { AuthService } from '@core/services/auth/auth.service';\nimport { UserProfile } from '@core/services/auth/profile.service';\nimport { MenuIconComponent } from '../menu-icon/menu-icon.component';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"\nimport {\n  ChangeDetectionStrategy,\n  Component,\n  ElementRef,\n  EventEmitter,\n  inject,\n  Input,\n  Output,\n  signal,\n  ViewChild,\n} from '@angular/core';\nimport { Router, RouterModule } from '@angular/router';\nimport { MenuIconComponent } from '../menu-icon/menu-icon.component';\nimport { AuthService } from '@core/services/auth/auth.service';\nimport { UserProfile } from '@core/services/auth/profile.service';\n\ninterface MenuItem {\n  label: string;\n  route: string;\n  icon: string;\n  badge?: string;\n}\n\ninterface MenuSection {\n  title: string;\n  color: string;\n  iconBgColor: string;\n  iconTextColor: string;\n  items: MenuItem[];\n}\n\n@Component({\n  selector: 'app-mobile-menu-drawer',\n  standalone: true,\n  imports: [RouterModule, MenuIconComponent],\n  templateUrl: './mobile-menu-drawer.component.html',\n  styleUrls: ['./mobile-menu-drawer.component.css'],\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class MobileMenuDrawerComponent {\n  private readonly router = inject(Router);\n  private readonly authService = inject(AuthService);\n\n  @ViewChild('drawerContent') drawerContent!: ElementRef<HTMLElement>;\n\n  @Input() set open(value: boolean) {\n    this.isOpen.set(value);\n    if (value) {\n      this.animateIn();\n    }\n  }\n\n  @Input() userProfile: UserProfile | null = null;\n\n  @Output() closeDrawer = new EventEmitter<void>();\n\n  readonly isOpen = signal(false);\n  readonly isAnimating = signal(false);\n\n  // User email from auth service\n  readonly userEmail = this.authService.userEmail;\n\n  // Menu sections based on the plan\n  readonly menuSections: MenuSection[] = [\n    {\n      title: 'Mis Actividades',\n      color: 'text-blue-600',\n      iconBgColor: 'bg-blue-500/10',\n      iconTextColor: 'text-blue-600',\n      items: [\n        { label: 'Mis Reservas', route: '/bookings', icon: 'calendar' },\n        { label: 'Mis Autos', route: '/cars/my', icon: 'archive' },\n        { label: 'Calendario', route: '/bookings/calendar', icon: 'calendar-days' },\n        { label: 'Favoritos', route: '/favorites', icon: 'heart' },\n      ],\n    },\n    {\n      title: 'Comunicacion',\n      color: 'text-violet-600',\n      iconBgColor: 'bg-violet-500/10',\n      iconTextColor: 'text-violet-600',\n      items: [\n        { label: 'Mensajes', route: '/messages', icon: 'message' },\n        { label: 'Notificaciones', route: '/profile/notifications-settings', icon: 'bell' },\n      ],\n    },\n    {\n      title: 'Finanzas',\n      color: 'text-emerald-600',\n      iconBgColor: 'bg-emerald-500/10',\n      iconTextColor: 'text-emerald-600',\n      items: [\n        { label: 'Wallet', route: '/wallet', icon: 'wallet' },\n        { label: 'Retiros', route: '/wallet/payouts', icon: 'credit-card' },\n        { label: 'Mis Ganancias', route: '/dashboard/earnings', icon: 'chart-bar', badge: 'NEW' },\n      ],\n    },\n    {\n      title: 'Configuracion',\n      color: 'text-gray-500',\n      iconBgColor: 'bg-gray-500/10',\n      iconTextColor: 'text-gray-600',\n      items: [\n        { label: 'Editar Perfil', route: '/profile', icon: 'user' },\n        { label: 'Mi Direccion', route: '/profile/location-settings', icon: 'location' },\n        { label: 'Seguridad', route: '/profile/security', icon: 'shield' },\n        { label: 'Preferencias', route: '/profile/preferences', icon: 'settings' },\n        { label: 'Conductor', route: '/profile/driver-profile', icon: 'document' },\n      ],\n    },\n    {\n      title: 'Ayuda',\n      color: 'text-amber-600',\n      iconBgColor: 'bg-amber-500/10',\n      iconTextColor: 'text-amber-600',\n      items: [\n        { label: 'Centro de Ayuda', route: '/help', icon: 'help', badge: 'NEW' },\n        { label: 'Contactar Soporte', route: '/profile/contact', icon: 'phone' },\n      ],\n    },\n  ];\n\n  private touchStartY = 0;\n  private isDragging = false;\n\n\n  private animateIn(): void {\n    this.isAnimating.set(true);\n    // Let CSS animation handle it\n    setTimeout(() => this.isAnimating.set(false), 300);\n  }\n\n  close(): void {\n    this.isOpen.set(false);\n    this.closeDrawer.emit();\n  }\n\n  onBackdropClick(): void {\n    this.close();\n  }\n\n  async navigateAndClose(route: string): Promise<void> {\n    // Haptic feedback\n    try {\n      if ('vibrate' in navigator) {\n        navigator.vibrate(10);\n      }\n    } catch {\n      // Silently fail\n    }\n\n    this.close();\n    await this.router.navigate([route]);\n  }\n\n  async signOut(): Promise<void> {\n    this.close();\n    await this.authService.signOut();\n    await this.router.navigate(['/']);\n  }\n\n  // Touch handling for swipe-to-close\n  onTouchStart(event: TouchEvent): void {\n    this.touchStartY = event.touches[0].clientY;\n    this.isDragging = true;\n  }\n\n  onTouchMove(event: TouchEvent): void {\n    if (!this.isDragging) return;\n\n    const currentY = event.touches[0].clientY;\n    const diff = currentY - this.touchStartY;\n\n    // Only allow dragging down\n    if (diff > 0 && this.drawerContent) {\n      this.drawerContent.nativeElement.style.transform = `translateY(${diff}px)`;\n    }\n  }\n\n  onTouchEnd(event: TouchEvent): void {\n    if (!this.isDragging) return;\n    this.isDragging = false;\n\n    const currentY = event.changedTouches[0].clientY;\n    const diff = currentY - this.touchStartY;\n\n    // If dragged more than 100px, close\n    if (diff > 100) {\n      this.close();\n    }\n\n    // Reset transform\n    if (this.drawerContent) {\n      this.drawerContent.nativeElement.style.transform = '';\n    }\n  }\n\n  trackBySection(index: number, section: MenuSection): string {\n    return section.title;\n  }\n\n  trackByItem(index: number, item: MenuItem): string {\n    return item.route;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/shared/components/payment-provider-selector/payment-provider-selector.component.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`../../../core/interfaces/payment-gateway.interface` import should occur after import of `@core/services/payments/fx.service`","line":12,"column":1,"nodeType":"ImportDeclaration","endLine":12,"endColumn":86,"fix":{"range":[239,478],"text":"import { PaymentGatewayFactory } from '@core/services/payments/payment-gateway.factory';\nimport { FxService } from '@core/services/payments/fx.service';\nimport { PaymentProvider } from '../../../core/interfaces/payment-gateway.interface';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import {Component,\n  OnInit,\n  Input,\n  Output,\n  EventEmitter,\n  signal,\n  inject,\n  computed,\n  ChangeDetectionStrategy} from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { FormsModule } from '@angular/forms';\nimport { PaymentProvider } from '../../../core/interfaces/payment-gateway.interface';\nimport { PaymentGatewayFactory } from '@core/services/payments/payment-gateway.factory';\nimport { FxService } from '@core/services/payments/fx.service';\n\n/**\n * Payment Provider Selector Component\n *\n * Permite al usuario seleccionar el proveedor de pago: MercadoPago o PayPal.\n *\n * Características:\n * - Muestra opciones con logos y descripciones\n * - Indica la moneda de cada proveedor (ARS vs USD)\n * - Muestra conversión de moneda en tiempo real\n * - Valida disponibilidad de cada proveedor\n *\n * Uso:\n * ```html\n * <app-payment-provider-selector\n *   [amount]=\"bookingTotal\"\n *   [currency]=\"'ARS'\"\n *   (providerChange)=\"handleProviderChange($event)\">\n * </app-payment-provider-selector>\n * ```\n */\n@Component({\n  selector: 'app-payment-provider-selector',\n  standalone: true,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  imports: [CommonModule, FormsModule],\n  templateUrl: './payment-provider-selector.component.html',\n  styleUrls: ['./payment-provider-selector.component.css'],\n})\nexport class PaymentProviderSelectorComponent implements OnInit {\n  private readonly gatewayFactory = inject(PaymentGatewayFactory);\n  private readonly fxService = inject(FxService);\n\n  // ==================== INPUTS & OUTPUTS ====================\n\n  /**\n   * Monto a pagar (en la moneda original del booking)\n   */\n  @Input({ required: true }) amount!: number;\n\n  /**\n   * Moneda original del booking (USD o ARS)\n   */\n  @Input() currency: 'USD' | 'ARS' = 'ARS';\n\n  /**\n   * Provider preseleccionado (opcional)\n   */\n  @Input() defaultProvider: PaymentProvider = 'mercadopago';\n\n  /**\n   * Evento emitido cuando cambia el proveedor seleccionado\n   */\n  @Output() providerChange = new EventEmitter<{\n    provider: PaymentProvider;\n    amountInProviderCurrency: number;\n    providerCurrency: string;\n  }>();\n\n  // ==================== SIGNALS ====================\n\n  /**\n   * Proveedor seleccionado\n   */\n  selectedProvider = signal<PaymentProvider>('mercadopago');\n\n  /**\n   * Tasa de cambio USD/ARS\n   */\n  exchangeRate = signal<number>(0);\n\n  /**\n   * Estado de carga\n   */\n  isLoading = signal(false);\n\n  // ==================== COMPUTED SIGNALS ====================\n\n  /**\n   * Proveedores disponibles\n   */\n  readonly availableProviders = computed(() => {\n    return this.gatewayFactory.getAvailableBookingProviders();\n  });\n\n  /**\n   * Monto en ARS (para MercadoPago)\n   */\n  readonly amountARS = computed(() => {\n    if (this.currency === 'ARS') {\n      return this.amount;\n    }\n    // Convertir USD a ARS\n    return this.amount * this.exchangeRate();\n  });\n\n  /**\n   * Monto en USD (para PayPal)\n   */\n  readonly amountUSD = computed(() => {\n    if (this.currency === 'USD') {\n      return this.amount;\n    }\n    // Convertir ARS a USD\n    const rate = this.exchangeRate();\n    return rate > 0 ? this.amount / rate : 0;\n  });\n\n  // ==================== LIFECYCLE ====================\n\n  async ngOnInit(): Promise<void> {\n    this.selectedProvider.set(this.defaultProvider);\n    await this.loadExchangeRate();\n    this.emitChange();\n  }\n\n  // ==================== PUBLIC METHODS ====================\n\n  /**\n   * Carga la tasa de cambio USD/ARS\n   */\n  async loadExchangeRate(): Promise<void> {\n    this.isLoading.set(true);\n    try {\n      const snapshot = await this.fxService.getFxSnapshot().toPromise();\n      if (snapshot) {\n        this.exchangeRate.set(snapshot.rate);\n      } else {\n        // Fallback rate if snapshot is null\n        this.exchangeRate.set(1015.0);\n      }\n    } catch (_error) {\n      console.error('Error loading exchange rate:', _error);\n      // Fallback rate\n      this.exchangeRate.set(1015.0);\n    } finally {\n      this.isLoading.set(false);\n    }\n  }\n\n  /**\n   * Selecciona un proveedor\n   */\n  selectProvider(provider: PaymentProvider): void {\n    if (!this.isProviderAvailable(provider)) {\n      return;\n    }\n\n    this.selectedProvider.set(provider);\n    this.emitChange();\n  }\n\n  /**\n   * Verifica si un proveedor está disponible\n   */\n  isProviderAvailable(provider: PaymentProvider): boolean {\n    return this.gatewayFactory.isBookingProviderAvailable(provider);\n  }\n\n  /**\n   * Emite el evento de cambio de proveedor\n   */\n  private emitChange(): void {\n    const provider = this.selectedProvider();\n    let amountInProviderCurrency: number;\n    let providerCurrency: string;\n\n    if (provider === 'paypal') {\n      amountInProviderCurrency = this.amountUSD();\n      providerCurrency = 'USD';\n    } else {\n      // MercadoPago\n      amountInProviderCurrency = this.amountARS();\n      providerCurrency = 'ARS';\n    }\n\n    this.providerChange.emit({\n      provider,\n      amountInProviderCurrency,\n      providerCurrency,\n    });\n  }\n\n  /**\n   * Formatea un número como moneda\n   */\n  formatCurrency(amount: number, currency: string): string {\n    return new Intl.NumberFormat(currency === 'ARS' ? 'es-AR' : 'en-US', {\n      style: 'currency',\n      currency: currency,\n      minimumFractionDigits: 2,\n      maximumFractionDigits: 2,\n    }).format(amount);\n  }\n\n  /**\n   * Obtiene el nombre de visualización del proveedor\n   */\n  getProviderDisplayName(provider: PaymentProvider): string {\n    switch (provider) {\n      case 'mercadopago':\n        return 'MercadoPago';\n      case 'paypal':\n        return 'PayPal';\n      default:\n        return provider;\n    }\n  }\n\n  /**\n   * Obtiene la descripción del proveedor\n   */\n  getProviderDescription(provider: PaymentProvider): string {\n    switch (provider) {\n      case 'mercadopago':\n        return 'Tarjetas, efectivo, saldo MP';\n      case 'paypal':\n        return 'Tarjetas internacionales';\n      default:\n        return '';\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/shared/components/paypal-button/paypal-button.component.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`@core/services/payments/paypal-booking-gateway.service` import should occur before import of `../../../../environments/environment`","line":14,"column":1,"nodeType":"ImportDeclaration","endLine":14,"endColumn":102,"fix":{"range":[299,469],"text":"import { PayPalBookingGatewayService } from '@core/services/payments/paypal-booking-gateway.service';\nimport { environment } from '../../../../environments/environment';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { LoggerService } from '@core/services/infrastructure/logger.service';\nimport { isPlatformBrowser } from '@angular/common';\nimport {AfterViewInit,\n  Component,\n  EventEmitter,\n  inject,\n  Input,\n  OnDestroy,\n  OnInit,\n  Output,\n  PLATFORM_ID,\n  ChangeDetectionStrategy} from '@angular/core';\nimport { environment } from '../../../../environments/environment';\nimport { PayPalBookingGatewayService } from '@core/services/payments/paypal-booking-gateway.service';\n\n// PayPal SDK types\ninterface PayPalWindow extends Window {\n  paypal?: {\n    Buttons: (config: unknown) => { render: (container: string) => void };\n  };\n}\n\ndeclare const window: PayPalWindow;\n\n/**\n * PayPal Button Component\n *\n * Integra el PayPal JS SDK para renderizar botones de pago inteligentes.\n * Maneja el flujo completo de pago: crear orden → aprobar → capturar.\n *\n * Features:\n * - PayPal Smart Payment Buttons\n * - Flujo de aprobación completo\n * - Manejo de errores\n * - Loading states\n * - Mobile responsive\n *\n * Usage:\n * ```html\n * <app-paypal-button\n *   [bookingId]=\"booking.id\"\n *   [useSplitPayment]=\"true\"\n *   (paymentApproved)=\"handleApproval($event)\"\n *   (paymentError)=\"handleError($event)\"\n * ></app-paypal-button>\n * ```\n */\n@Component({\n  selector: 'app-paypal-button',\n  standalone: true,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  imports: [],\n  templateUrl: './paypal-button.component.html',\n  styleUrls: ['./paypal-button.component.css'],\n})\nexport class PayPalButtonComponent implements OnInit, AfterViewInit, OnDestroy {\n  private readonly logger = inject(LoggerService);\n  @Input() bookingId!: string;\n  @Input() useSplitPayment = false;\n  @Input() clientId?: string; // Optional: Override PayPal client ID\n  @Input() currency = 'USD';\n  @Input() disabled = false;\n\n  @Output() paymentApproved = new EventEmitter<{ orderId: string; captureId: string }>();\n  @Output() paymentError = new EventEmitter<Error>();\n  @Output() paymentCancelled = new EventEmitter<void>();\n  @Output() loadingChange = new EventEmitter<boolean>();\n\n  private readonly platformId = inject(PLATFORM_ID);\n  private readonly gatewayService = inject(PayPalBookingGatewayService);\n\n  isLoading = false;\n  error: string | null = null;\n  sdkLoaded = false;\n  private paypalScript?: HTMLScriptElement;\n\n  ngOnInit(): void {\n    if (!this.bookingId) {\n      this.error = 'Booking ID is required';\n      this.paymentError.emit(new Error(this.error));\n      return;\n    }\n  }\n\n  ngAfterViewInit(): void {\n    if (isPlatformBrowser(this.platformId)) {\n      this.loadPayPalSDK();\n    }\n  }\n\n  ngOnDestroy(): void {\n    // Cleanup: remove PayPal script\n    if (this.paypalScript && this.paypalScript.parentNode) {\n      this.paypalScript.parentNode.removeChild(this.paypalScript);\n    }\n  }\n\n  /**\n   * Load PayPal JS SDK\n   */\n  loadPayPalSDK(): void {\n    // Check if already loaded\n    if (window.paypal) {\n      this.sdkLoaded = true;\n      this.renderPayPalButton();\n      return;\n    }\n\n    this.isLoading = true;\n    this.loadingChange.emit(true);\n\n    // Get client ID from environment or input\n    const clientId = this.clientId || this.getPayPalClientId();\n\n    if (!clientId) {\n      this.error = 'PayPal Client ID not configured';\n      this.paymentError.emit(new Error(this.error));\n      this.isLoading = false;\n      this.loadingChange.emit(false);\n      return;\n    }\n\n    // Create script tag\n    this.paypalScript = document.createElement('script');\n    this.paypalScript.src = `https://www.paypal.com/sdk/js?client-id=${clientId}&currency=${this.currency}&intent=capture`;\n    this.paypalScript.async = true;\n\n    this.paypalScript.onload = () => {\n      this.sdkLoaded = true;\n      this.isLoading = false;\n      this.loadingChange.emit(false);\n      this.renderPayPalButton();\n    };\n\n    this.paypalScript.onerror = () => {\n      this.error = 'Failed to load PayPal SDK';\n      this.paymentError.emit(new Error(this.error));\n      this.isLoading = false;\n      this.loadingChange.emit(false);\n    };\n\n    document.head.appendChild(this.paypalScript);\n  }\n\n  /**\n   * Render PayPal Smart Payment Buttons\n   */\n  private renderPayPalButton(): void {\n    const paypal = window.paypal;\n\n    if (!paypal) {\n      this.error = 'PayPal SDK not loaded';\n      return;\n    }\n\n    const container = document.getElementById('paypal-button-container');\n    if (!container) {\n      console.error('PayPal button container not found');\n      return;\n    }\n\n    // Clear existing buttons\n    container.innerHTML = '';\n\n    paypal\n      .Buttons({\n        // Create order on PayPal side\n        createOrder: async (_data: unknown, _actions: unknown) => {\n          return this.createOrder();\n        },\n\n        // Handle approval\n        onApprove: async (data: { orderID: string }, _actions: unknown) => {\n          return this.handleApproval(data.orderID);\n        },\n\n        // Handle errors\n        onError: (err: unknown) => {\n          console.error('PayPal button error:', err);\n          this.error = 'Error processing PayPal payment';\n          this.paymentError.emit(new Error(this.error));\n        },\n\n        // Handle cancellation\n        onCancel: (data: unknown) => {\n          this.logger.debug('PayPal payment cancelled', data);\n          this.paymentCancelled.emit();\n        },\n\n        // Styling\n        style: {\n          layout: 'vertical',\n          color: 'gold',\n          shape: 'rect',\n          label: 'paypal',\n          height: 45,\n        },\n      })\n      .render('#paypal-button-container');\n  }\n\n  /**\n   * Create PayPal order via backend Edge Function\n   */\n  private async createOrder(): Promise<string> {\n    try {\n      this.isLoading = true;\n      this.loadingChange.emit(true);\n      this.error = null;\n\n      const response = await this.gatewayService\n        .createBookingPreference(this.bookingId, this.useSplitPayment)\n        .toPromise();\n\n      if (!response || !response.success) {\n        throw new Error(response?.error || 'Failed to create PayPal order');\n      }\n\n      this.logger.debug('PayPal order created:', response.preference_id);\n\n      this.isLoading = false;\n      this.loadingChange.emit(false);\n\n      // Return order ID to PayPal SDK\n      return response.preference_id;\n    } catch (_error) {\n      this.isLoading = false;\n      this.loadingChange.emit(false);\n      this.error = _error instanceof Error ? _error.message : 'Unknown error';\n      this.paymentError.emit(_error instanceof Error ? _error : new Error(String(_error)));\n      throw _error;\n    }\n  }\n\n  /**\n   * Handle order approval and capture\n   */\n  private async handleApproval(orderId: string): Promise<void> {\n    try {\n      this.isLoading = true;\n      this.loadingChange.emit(true);\n      this.error = null;\n\n      this.logger.debug('Capturing PayPal order:', orderId);\n\n      const captureResponse = await this.gatewayService.captureOrder(orderId).toPromise();\n\n      if (!captureResponse || !captureResponse.success) {\n        throw new Error(captureResponse?.error || 'Failed to capture PayPal payment');\n      }\n\n      this.logger.debug('PayPal payment captured:', captureResponse.capture_id);\n\n      this.isLoading = false;\n      this.loadingChange.emit(false);\n\n      // Emit success to parent component\n      this.paymentApproved.emit({\n        orderId: captureResponse.order_id,\n        captureId: captureResponse.capture_id,\n      });\n    } catch (_error) {\n      this.isLoading = false;\n      this.loadingChange.emit(false);\n      this.error = _error instanceof Error ? _error.message : 'Failed to capture payment';\n      this.paymentError.emit(_error instanceof Error ? _error : new Error(String(_error)));\n    }\n  }\n\n  /**\n   * Get PayPal Client ID from environment\n   */\n  private getPayPalClientId(): string {\n    return environment.paypalClientId || '';\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/shared/components/phone-verification/phone-verification.component.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`@core/services/auth/phone-verification.service` import should occur before import of `../../../core/constants/timing.constants`","line":14,"column":1,"nodeType":"ImportDeclaration","endLine":14,"endColumn":91,"fix":{"range":[230,409],"text":"import { PhoneVerificationService } from '@core/services/auth/phone-verification.service';\nimport { SUCCESS_MESSAGE_DURATION_MS } from '../../../core/constants/timing.constants';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"\nimport {\n  ChangeDetectionStrategy,\n  Component,\n  OnDestroy,\n  OnInit,\n  computed,\n  inject,\n  signal,\n} from '@angular/core';\nimport { FormsModule } from '@angular/forms';\nimport { TranslateModule } from '@ngx-translate/core';\nimport { SUCCESS_MESSAGE_DURATION_MS } from '../../../core/constants/timing.constants';\nimport { PhoneVerificationService } from '@core/services/auth/phone-verification.service';\n\n@Component({\n  standalone: true,\n  selector: 'app-phone-verification',\n  imports: [FormsModule, TranslateModule],\n  template: `\n    <div class=\"bg-surface-raised rounded-lg border border-border-default p-6\">\n      <!-- Header -->\n      <div class=\"flex items-start justify-between mb-4\">\n        <div class=\"flex items-center gap-3\">\n          <div\n            class=\"w-10 h-10 rounded-full flex items-center justify-center text-lg\"\n            [class]=\"getStatusBadgeClass()\"\n            >\n            {{ getStatusIcon() }}\n          </div>\n          <div>\n            <h4 class=\"font-semibold text-text-primary\">Verificación de Teléfono</h4>\n            <p class=\"text-sm text-text-secondary dark:text-text-secondary\">\n              {{ status().value || 'No configurado' }}\n            </p>\n          </div>\n        </div>\n        <span class=\"text-xs font-medium px-2 py-1 rounded-full\" [class]=\"getStatusLabelClass()\">\n          {{ getStatusLabel() }}\n        </span>\n      </div>\n    \n      <!-- Verified State -->\n      @if (status().isVerified) {\n        <div\n          class=\"p-4 bg-success-light/10 border border-success-light/40 rounded-lg\"\n          >\n          <div class=\"flex items-center gap-2 text-success-strong\">\n            <svg class=\"w-5 h-5\" fill=\"currentColor\" viewBox=\"0 0 20 20\">\n              <path\n                fill-rule=\"evenodd\"\n                d=\"M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z\"\n                clip-rule=\"evenodd\"\n                />\n            </svg>\n            <span class=\"text-sm font-medium\">Teléfono verificado exitosamente</span>\n          </div>\n          <p class=\"text-xs text-success-strong mt-2\">\n            Verificado el {{ formatDate(status().verifiedAt) }}\n          </p>\n        </div>\n      }\n    \n      <!-- Pending State -->\n      @if (!status().isVerified) {\n        <div class=\"space-y-4\">\n          <!-- Phone Input (if OTP not sent yet) -->\n          @if (!status().otpSent) {\n            <div class=\"space-y-4\">\n              <div class=\"p-4 bg-cta-default/10 border border-cta-default/40 rounded-lg\">\n                <p class=\"text-sm text-cta-default\">\n                  Ingresa tu número de teléfono para recibir un código de verificación por SMS.\n                </p>\n              </div>\n              <div>\n                <label for=\"phone\" class=\"block text-sm font-medium text-text-primary mb-2\">\n                  Número de teléfono\n                </label>\n                <div class=\"flex gap-2\">\n                  <select\n                    [(ngModel)]=\"countryCode\"\n                    class=\"block w-24 rounded-lg border-border-muted shadow-sm focus:ring-cta-default focus:border-cta-default text-sm\"\n                    >\n                    <option value=\"+54\">🇦🇷 +54</option>\n                    <option value=\"+1\">🇺🇸 +1</option>\n                    <option value=\"+52\">🇲🇽 +52</option>\n                    <option value=\"+55\">🇧🇷 +55</option>\n                    <option value=\"+56\">🇨🇱 +56</option>\n                  </select>\n                  <input\n                    id=\"phone\"\n                    type=\"tel\"\n                    [(ngModel)]=\"phoneNumber\"\n                    placeholder=\"11 2345 6789\"\n                    maxlength=\"15\"\n                    class=\"flex-grow block rounded-lg border-border-muted shadow-sm focus:ring-cta-default focus:border-cta-default text-sm\"\n                    [disabled]=\"loading()\"\n                    />\n                </div>\n                <p class=\"text-xs text-text-secondary dark:text-text-secondary mt-1\">\n                  Formato: sin el 0 inicial. Ej: 11 2345 6789\n                </p>\n              </div>\n              <button\n                type=\"button\"\n                (click)=\"sendOTP()\"\n                [disabled]=\"!canSendOTP() || loading()\"\n                class=\"w-full px-4 py-3 text-sm font-medium rounded-lg transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed\"\n            [class]=\"\n              canSendOTP()\n                ? 'bg-cta-default text-cta-text hover:bg-cta-default focus:ring-2 focus:ring-cta-default focus:ring-offset-2'\n                : 'bg-surface-hover text-text-secondary dark:text-text-secondary cursor-not-allowed'\n            \"\n                >\n                @if (!loading()) {\n                  <span class=\"flex items-center justify-center gap-2\">\n                    <svg class=\"w-5 h-5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                      <path\n                        stroke-linecap=\"round\"\n                        stroke-linejoin=\"round\"\n                        stroke-width=\"2\"\n                        d=\"M12 18h.01M8 21h8a2 2 0 002-2V5a2 2 0 00-2-2H8a2 2 0 00-2 2v14a2 2 0 002 2z\"\n                        />\n                    </svg>\n                    <span>{{\n                      cooldownRemaining() > 0 ? 'Espera ' + cooldownRemaining() + 's' : 'Enviar código'\n                    }}</span>\n                  </span>\n                }\n                @if (loading()) {\n                  <span class=\"flex items-center justify-center gap-2\">\n                    <div class=\"animate-spin rounded-full h-5 w-5 border-b-2 border-white\"></div>\n                    <span>Enviando...</span>\n                  </span>\n                }\n              </button>\n              <!-- Rate Limit Warning -->\n              @if (remainingAttempts() < 3) {\n                <div\n                  class=\"p-3 bg-warning-light/10 border border-warning-light/40 rounded-lg text-sm text-warning-strong\"\n                  >\n                  ⚠️ Te quedan {{ remainingAttempts() }} intentos en esta hora\n                </div>\n              }\n            </div>\n          }\n          <!-- OTP Input (if OTP sent) -->\n          @if (status().otpSent) {\n            <div class=\"space-y-4\">\n              <div class=\"p-4 bg-cta-default/10 border border-cta-default/40 rounded-lg\">\n                <p class=\"text-sm text-cta-default font-medium\">\n                  Código enviado a {{ status().value }}\n                </p>\n                <p class=\"text-xs text-cta-default mt-1\">\n                  Ingresa el código de 6 dígitos que recibiste por SMS\n                </p>\n              </div>\n              <div>\n                <label for=\"otp\" class=\"block text-sm font-medium text-text-primary mb-2\">\n                  Código de verificación\n                </label>\n                <input\n                  id=\"otp\"\n                  type=\"text\"\n                  [(ngModel)]=\"otpCode\"\n                  placeholder=\"000000\"\n                  maxlength=\"6\"\n                  inputmode=\"numeric\"\n                  pattern=\"[0-9]*\"\n                  class=\"block w-full rounded-lg border-border-muted shadow-sm focus:ring-cta-default focus:border-cta-default text-center h4 tracking-widest font-mono\"\n                  [disabled]=\"loading()\"\n                  (input)=\"onOTPInput($event)\"\n                  />\n                <p class=\"text-xs text-text-secondary dark:text-text-secondary mt-1 text-center\">\n                  Solo números, 6 dígitos\n                </p>\n              </div>\n              <div class=\"flex gap-2\">\n                <button\n                  type=\"button\"\n                  (click)=\"verifyOTP()\"\n                  [disabled]=\"!canVerifyOTP() || loading()\"\n                  class=\"flex-grow px-4 py-3 text-sm font-medium rounded-lg transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed\"\n              [class]=\"\n                canVerifyOTP()\n                  ? 'bg-success-light text-text-primary hover:bg-success-light focus:ring-2 focus:ring-success-light focus:ring-offset-2'\n                  : 'bg-surface-hover text-text-secondary dark:text-text-secondary cursor-not-allowed'\n              \"\n                  >\n                  @if (!loading()) {\n                    <span class=\"flex items-center justify-center gap-2\">\n                      <svg class=\"w-5 h-5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                        <path\n                          stroke-linecap=\"round\"\n                          stroke-linejoin=\"round\"\n                          stroke-width=\"2\"\n                          d=\"M5 13l4 4L19 7\"\n                          />\n                      </svg>\n                      <span>Verificar código</span>\n                    </span>\n                  }\n                  @if (loading()) {\n                    <span class=\"flex items-center justify-center gap-2\">\n                      <div class=\"animate-spin rounded-full h-5 w-5 border-b-2 border-white\"></div>\n                      <span>Verificando...</span>\n                    </span>\n                  }\n                </button>\n                <button\n                  type=\"button\"\n                  (click)=\"cancelOTP()\"\n                  [disabled]=\"loading()\"\n                  class=\"px-4 py-3 text-sm font-medium text-text-primary bg-surface-raised border border-border-muted rounded-lg hover:bg-surface-base focus:ring-2 focus:ring-cta-default focus:ring-offset-2 disabled:opacity-50\"\n                  >\n                  Cambiar número\n                </button>\n              </div>\n              <button\n                type=\"button\"\n                (click)=\"resendOTP()\"\n                [disabled]=\"!canResend() || loading()\"\n                class=\"w-full px-4 py-2 text-sm text-cta-default hover:text-cta-default disabled:text-text-muted dark:text-text-secondary\"\n                >\n                {{\n                cooldownRemaining() > 0\n                ? 'Reenviar en ' + cooldownRemaining() + 's'\n                : '¿No recibiste el código? Reenviar'\n                }}\n              </button>\n            </div>\n          }\n          <!-- Success Message -->\n          @if (successMessage()) {\n            <div\n              class=\"p-3 bg-success-light/10 border border-success-light/40 rounded-lg text-sm text-success-strong\"\n              >\n              {{ successMessage() }}\n            </div>\n          }\n          <!-- Error Message -->\n          @if (error()) {\n            <div\n              class=\"p-3 bg-error-bg border border-error-border rounded-lg text-sm text-error-strong\"\n              >\n              {{ error() }}\n            </div>\n          }\n          <!-- Help Text -->\n          <div class=\"text-xs text-text-secondary dark:text-text-secondary space-y-1\">\n            <p>• El código expira en 10 minutos</p>\n            <p>• Máximo 3 intentos por hora</p>\n            <p>• Revisa que tu teléfono pueda recibir SMS</p>\n          </div>\n        </div>\n      }\n    </div>\n    `,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class PhoneVerificationComponent implements OnInit, OnDestroy {\n  private readonly phoneVerificationService = inject(PhoneVerificationService);\n\n  readonly status = this.phoneVerificationService.status;\n  readonly loading = this.phoneVerificationService.loading;\n  readonly error = this.phoneVerificationService.error;\n\n  readonly phoneNumber = signal('');\n  readonly countryCode = signal('+54');\n  readonly otpCode = signal('');\n  readonly cooldownRemaining = signal(0);\n  readonly successMessage = signal<string | null>(null);\n  readonly remainingAttempts = signal(3);\n\n  readonly canSendOTP = computed(\n    () =>\n      this.phoneNumber().length >= 10 &&\n      this.remainingAttempts() > 0 &&\n      this.cooldownRemaining() === 0,\n  );\n\n  readonly canVerifyOTP = computed(() => this.otpCode().length === 6);\n\n  readonly canResend = computed(\n    () => this.status().otpSent && this.cooldownRemaining() === 0 && this.remainingAttempts() > 0,\n  );\n\n  private unsubscribe?: () => void;\n  private stopCooldownTimer?: () => void;\n\n  async ngOnInit(): Promise<void> {\n    await this.phoneVerificationService.checkStatus();\n\n    this.unsubscribe = this.phoneVerificationService.subscribeToChanges((verified) => {\n      if (verified) {\n        this.successMessage.set('¡Teléfono verificado exitosamente!');\n        setTimeout(() => this.successMessage.set(null), SUCCESS_MESSAGE_DURATION_MS);\n      }\n    });\n\n    this.updateRemainingAttempts();\n\n    if (this.status().cooldownSeconds && this.status()!.cooldownSeconds > 0) {\n      this.startCooldownTimer();\n    }\n  }\n\n  ngOnDestroy(): void {\n    this.unsubscribe?.();\n    this.stopCooldownTimer?.();\n  }\n\n  async sendOTP(): Promise<void> {\n    if (!this.canSendOTP()) return;\n\n    this.successMessage.set(null);\n    this.phoneVerificationService.clearError();\n\n    try {\n      const phone = this.phoneNumber().replace(/\\s/g, '');\n      await this.phoneVerificationService.sendOTP(phone, this.countryCode());\n\n      this.successMessage.set('Código enviado. Revisa tus mensajes SMS.');\n      this.updateRemainingAttempts();\n      this.startCooldownTimer();\n\n      setTimeout(() => this.successMessage.set(null), SUCCESS_MESSAGE_DURATION_MS);\n    } catch (_error) {\n      console.error('Failed to send OTP:', _error);\n    }\n  }\n\n  async verifyOTP(): Promise<void> {\n    if (!this.canVerifyOTP()) return;\n\n    this.successMessage.set(null);\n    this.phoneVerificationService.clearError();\n\n    try {\n      const phone = this.status().value || '';\n      const result = await this.phoneVerificationService.verifyOTP(phone, this.otpCode());\n\n      if (result.verified) {\n        this.successMessage.set('¡Teléfono verificado exitosamente!');\n        this.otpCode.set('');\n      }\n    } catch (_error) {\n      console.error('Failed to verify OTP:', _error);\n    }\n  }\n\n  async resendOTP(): Promise<void> {\n    if (!this.canResend()) return;\n\n    await this.sendOTP();\n  }\n\n  cancelOTP(): void {\n    this.phoneVerificationService.resetOTPSentState();\n    this.otpCode.set('');\n    this.successMessage.set(null);\n  }\n\n  onOTPInput(event: Event): void {\n    const input = event.target as HTMLInputElement;\n    const value = input.value.replace(/\\D/g, '').slice(0, 6);\n    this.otpCode.set(value);\n    input.value = value;\n  }\n\n  private startCooldownTimer(): void {\n    this.stopCooldownTimer?.();\n\n    this.stopCooldownTimer = this.phoneVerificationService.startCooldownTimer((remaining) => {\n      this.cooldownRemaining.set(remaining);\n    });\n  }\n\n  private updateRemainingAttempts(): void {\n    const remaining = this.phoneVerificationService.getRemainingAttempts();\n    this.remainingAttempts.set(remaining);\n  }\n\n  getStatusIcon(): string {\n    return this.status().isVerified ? '✓' : '○';\n  }\n\n  getStatusBadgeClass(): string {\n    return this.status().isVerified\n      ? 'bg-success-light/20 text-success-strong'\n      : 'bg-warning-bg-hover text-warning-text';\n  }\n\n  getStatusLabel(): string {\n    return this.status().isVerified ? 'Verificado' : 'Pendiente';\n  }\n\n  getStatusLabelClass(): string {\n    return this.status().isVerified\n      ? 'bg-success-light/20 text-success-strong'\n      : 'bg-warning-bg-hover text-warning-strong';\n  }\n\n  formatDate(dateStr: string | null | undefined): string {\n    if (!dateStr) return '';\n\n    const date = new Date(dateStr);\n    return date.toLocaleDateString('es-AR', {\n      day: 'numeric',\n      month: 'long',\n      year: 'numeric',\n      hour: '2-digit',\n      minute: '2-digit',\n    });\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/shared/components/report-owner-no-show/report-owner-no-show.component.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`@core/services/infrastructure/logger.service` import should occur before import of `../../../core/models`","line":9,"column":1,"nodeType":"ImportDeclaration","endLine":9,"endColumn":78,"fix":{"range":[329,549],"text":"import { LoggerService } from '@core/services/infrastructure/logger.service';\nimport { Booking } from '../../../core/models';\nimport { EvidenceUploaderComponent } from '../evidence-uploader/evidence-uploader.component';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { CommonModule } from '@angular/common';\nimport {Component, EventEmitter, Input, Output, signal, inject,\n  ChangeDetectionStrategy} from '@angular/core';\nimport { FormsModule } from '@angular/forms';\nimport { IonicModule } from '@ionic/angular';\nimport { BookingsService } from '@core/services/bookings/bookings.service';\nimport { Booking } from '../../../core/models';\nimport { EvidenceUploaderComponent } from '../evidence-uploader/evidence-uploader.component';\nimport { LoggerService } from '@core/services/infrastructure/logger.service';\n\n@Component({\n  selector: 'app-report-owner-no-show',\n  standalone: true,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  imports: [CommonModule, FormsModule, IonicModule, EvidenceUploaderComponent],\n  templateUrl: './report-owner-no-show.component.html',\n  styleUrls: ['./report-owner-no-show.component.scss'],\n})\nexport class ReportOwnerNoShowComponent {\n  @Input({ required: true }) isOpen!: boolean;\n  @Input({ required: true }) booking!: Booking;\n  @Output() closeModal = new EventEmitter<void>();\n  @Output() noShowReported = new EventEmitter<{ success: boolean; message?: string }>();\n\n  private readonly bookingsService = inject(BookingsService);\n  private readonly logger = inject(LoggerService);\n\n  readonly loading = signal(false);\n  readonly formError = signal<string | null>(null);\n\n  // Form fields\n  details = signal<string>('');\n  evidenceUrls = signal<string[]>([]); // To be populated by EvidenceUploader\n\n\n\n  onEvidenceUploaded(urls: string[]): void {\n    this.evidenceUrls.set(urls);\n  }\n\n  async onSubmit(): Promise<void> {\n    this.formError.set(null);\n    if (!this.details().trim()) {\n      this.formError.set('Por favor, describe los detalles de la no-presentación.');\n      return;\n    }\n\n    this.loading.set(true);\n    try {\n      const result = await this.bookingsService.reportOwnerNoShow(\n        this.booking.id,\n        this.details(),\n        this.evidenceUrls()\n      );\n      this.noShowReported.emit(result);\n      this.closeModal.emit();\n    } catch (error) {\n      this.logger.error('Error reporting owner no-show', 'ReportOwnerNoShowComponent', error);\n      this.formError.set(error instanceof Error ? error.message : 'Error al reportar no-show.');\n    } finally {\n      this.loading.set(false);\n    }\n  }\n\n  onCancel(): void {\n    this.closeModal.emit();\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/shared/components/report-renter-no-show/report-renter-no-show.component.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`@core/services/infrastructure/logger.service` import should occur before import of `../../../core/models`","line":9,"column":1,"nodeType":"ImportDeclaration","endLine":9,"endColumn":78,"fix":{"range":[329,549],"text":"import { LoggerService } from '@core/services/infrastructure/logger.service';\nimport { Booking } from '../../../core/models';\nimport { EvidenceUploaderComponent } from '../evidence-uploader/evidence-uploader.component';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { CommonModule } from '@angular/common';\nimport {Component, EventEmitter, Input, Output, signal, inject,\n  ChangeDetectionStrategy} from '@angular/core';\nimport { FormsModule } from '@angular/forms';\nimport { IonicModule } from '@ionic/angular';\nimport { BookingsService } from '@core/services/bookings/bookings.service';\nimport { Booking } from '../../../core/models';\nimport { EvidenceUploaderComponent } from '../evidence-uploader/evidence-uploader.component';\nimport { LoggerService } from '@core/services/infrastructure/logger.service';\n\n@Component({\n  selector: 'app-report-renter-no-show',\n  standalone: true,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  imports: [CommonModule, FormsModule, IonicModule, EvidenceUploaderComponent],\n  templateUrl: './report-renter-no-show.component.html',\n  styleUrls: ['./report-renter-no-show.component.scss'],\n})\nexport class ReportRenterNoShowComponent {\n  @Input({ required: true }) isOpen!: boolean;\n  @Input({ required: true }) booking!: Booking;\n  @Output() closeModal = new EventEmitter<void>();\n  @Output() noShowReported = new EventEmitter<{ success: boolean; message?: string }>();\n\n  private readonly bookingsService = inject(BookingsService);\n  private readonly logger = inject(LoggerService);\n\n  readonly loading = signal(false);\n  readonly formError = signal<string | null>(null);\n\n  // Form fields\n  details = signal<string>('');\n  evidenceUrls = signal<string[]>([]); // To be populated by EvidenceUploader\n\n\n\n  onEvidenceUploaded(urls: string[]): void {\n    this.evidenceUrls.set(urls);\n  }\n\n  async onSubmit(): Promise<void> {\n    this.formError.set(null);\n    if (!this.details().trim()) {\n      this.formError.set('Por favor, describe los detalles de la no-presentación.');\n      return;\n    }\n\n    this.loading.set(true);\n    try {\n      const result = await this.bookingsService.reportRenterNoShow(\n        this.booking.id,\n        this.details(),\n        this.evidenceUrls()\n      );\n      this.noShowReported.emit(result);\n      this.closeModal.emit();\n    } catch (error) {\n      this.logger.error('Error reporting renter no-show', 'ReportRenterNoShowComponent', error);\n      this.formError.set(error instanceof Error ? error.message : 'Error al reportar no-show.');\n    } finally {\n      this.loading.set(false);\n    }\n  }\n\n  onCancel(): void {\n    this.closeModal.emit();\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/shared/components/report-traffic-fine/report-traffic-fine.component.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`@core/services/infrastructure/logger.service` import should occur before import of `../../../features/admin/traffic-infractions/admin-traffic-infractions.page`","line":10,"column":1,"nodeType":"ImportDeclaration","endLine":10,"endColumn":78,"fix":{"range":[364,762],"text":"import { LoggerService } from '@core/services/infrastructure/logger.service';\nimport { TrafficInfraction } from '../../../features/admin/traffic-infractions/admin-traffic-infractions.page'; // Re-use the interface\nimport { Booking } from '../../../core/models'; // To get owner_id, renter_id, booking_id\nimport { EvidenceUploaderComponent } from '../evidence-uploader/evidence-uploader.component';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { CommonModule } from '@angular/common';\nimport {Component, EventEmitter, Input, OnInit, Output, signal, inject,\n  ChangeDetectionStrategy} from '@angular/core';\nimport { FormsModule } from '@angular/forms';\nimport { IonicModule } from '@ionic/angular';\nimport { TrafficInfractionsService } from '@core/services/infrastructure/traffic-infractions.service';\nimport { TrafficInfraction } from '../../../features/admin/traffic-infractions/admin-traffic-infractions.page'; // Re-use the interface\nimport { Booking } from '../../../core/models'; // To get owner_id, renter_id, booking_id\nimport { EvidenceUploaderComponent } from '../evidence-uploader/evidence-uploader.component';\nimport { LoggerService } from '@core/services/infrastructure/logger.service';\n\n@Component({\n  selector: 'app-report-traffic-fine',\n  standalone: true,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  imports: [CommonModule, FormsModule, IonicModule, EvidenceUploaderComponent],\n  templateUrl: './report-traffic-fine.component.html',\n  styleUrls: ['./report-traffic-fine.component.scss'],\n})\nexport class ReportTrafficFineComponent implements OnInit {\n  @Input({ required: true }) isOpen!: boolean;\n  @Input({ required: true }) booking!: Booking;\n  @Output() closeModal = new EventEmitter<void>();\n  @Output() fineReported = new EventEmitter<TrafficInfraction>();\n\n  private readonly trafficInfractionsService = inject(TrafficInfractionsService);\n  private readonly logger = inject(LoggerService);\n\n  readonly loading = signal(false);\n  readonly formError = signal<string | null>(null);\n\n  // Form fields\n  infractionDate = signal<string>('');\n  amount = signal<number | null>(null);\n  description = signal<string>('');\n  evidenceUrls = signal<string[]>([]); // To be populated by EvidenceUploader\n\n  ngOnInit(): void {\n    // Set default infraction date to today\n    this.infractionDate.set(new Date().toISOString().split('T')[0]);\n  }\n\n  onEvidenceUploaded(urls: string[]): void {\n    this.evidenceUrls.set(urls);\n  }\n\n  async onSubmit(): Promise<void> {\n    this.formError.set(null);\n    if (!this.infractionDate() || !this.amount() || !this.description()) {\n      this.formError.set('Todos los campos obligatorios deben ser completados.');\n      return;\n    }\n    if (this.amount()! <= 0) {\n      this.formError.set('El monto de la multa debe ser mayor a cero.');\n      return;\n    }\n\n    this.loading.set(true);\n    try {\n      const newFine: Partial<TrafficInfraction> = {\n        booking_id: this.booking.id,\n        owner_id: this.booking.owner_id, // Assuming booking has owner_id\n        renter_id: this.booking.renter_id,\n        infraction_date: this.infractionDate(),\n        amount_cents: Math.round(this.amount()! * 100), // Store in cents\n        currency: this.booking.currency || 'ARS', // Use booking currency or default\n        description: this.description(),\n        evidence_urls: this.evidenceUrls(),\n      };\n\n      const reportedFine = await this.trafficInfractionsService.createInfraction(newFine);\n      this.fineReported.emit(reportedFine);\n      this.closeModal.emit();\n    } catch (error) {\n      this.logger.error('Error reporting traffic fine', 'ReportTrafficFineComponent', error);\n      this.formError.set(error instanceof Error ? error.message : 'Error al reportar multa.');\n    } finally {\n      this.loading.set(false);\n    }\n  }\n\n  onCancel(): void {\n    this.closeModal.emit();\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/shared/components/settlement-simulator/settlement-simulator.component.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`../../../core/models/fgo-v1-1.model` import should occur after import of `@core/services/payments/settlement.service`","line":5,"column":1,"nodeType":"ImportDeclaration","endLine":5,"endColumn":93,"fix":{"range":[138,416],"text":"import { NotificationManagerService } from '@core/services/infrastructure/notification-manager.service';\nimport { SettlementService } from '@core/services/payments/settlement.service';\nimport { EligibilityResult, WaterfallBreakdown } from '../../../core/models/fgo-v1-1.model';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"\nimport {Component, Input, inject, signal,\n  ChangeDetectionStrategy} from '@angular/core';\nimport { FormsModule } from '@angular/forms';\nimport { EligibilityResult, WaterfallBreakdown } from '../../../core/models/fgo-v1-1.model';\nimport { NotificationManagerService } from '@core/services/infrastructure/notification-manager.service';\nimport { SettlementService } from '@core/services/payments/settlement.service';\n\n@Component({\n  selector: 'app-settlement-simulator',\n  standalone: true,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  imports: [FormsModule],\n  templateUrl: './settlement-simulator.component.html',\n})\nexport class SettlementSimulatorComponent {\n  @Input({ required: true }) bookingId!: string;\n\n  private readonly settlementService = inject(SettlementService);\n  private readonly toastService = inject(NotificationManagerService);\n\n  claimAmountUsd = 100;\n  readonly simulating = signal(false);\n  readonly simulationResult = signal<{\n    eligibility: EligibilityResult | null;\n    estimatedBreakdown: Partial<WaterfallBreakdown> | null;\n  } | null>(null);\n  readonly error = signal<string | null>(null);\n\n  formatCurrency(amount: number): string {\n    return amount.toFixed(2);\n  }\n\n  async simulate(): Promise<void> {\n    this.simulating.set(true);\n    this['error'].set(null);\n\n    try {\n      const result = await this.settlementService.simulateWaterfall(\n        this['bookingId'],\n        this.claimAmountUsd,\n      );\n      this.simulationResult.set(result);\n    } catch (err) {\n      const errorMsg = err instanceof Error ? err['message'] : 'Error al simular';\n      this['error'].set(errorMsg);\n      this.toastService['error']('Error', errorMsg);\n    } finally {\n      this.simulating.set(false);\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/shared/components/verification-badge/verification-badge.component.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`@core/services/verification/verification.service` import should occur before type import of `../../../core/models`","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":88,"fix":{"range":[192,344],"text":"import { VerificationService } from '@core/services/verification/verification.service';\nimport type { VerificationStatus } from '../../../core/models';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"\nimport { ChangeDetectionStrategy, Component, OnInit, computed, inject } from '@angular/core';\nimport { Router } from '@angular/router';\nimport { TranslateModule } from '@ngx-translate/core';\nimport type { VerificationStatus } from '../../../core/models';\nimport { VerificationService } from '@core/services/verification/verification.service';\n\n@Component({\n  standalone: true,\n  selector: 'app-verification-badge',\n  imports: [TranslateModule],\n  template: `\n    @if (hasData()) {\n      <button\n        type=\"button\"\n        (click)=\"goToVerification()\"\n        class=\"inline-flex items-center gap-2 rounded-full px-3 py-1 text-xs font-semibold transition-all duration-200 hover:shadow-md hover:scale-105 cursor-pointer focus:outline-none focus:ring-2 focus:ring-offset-2\"\n        [class]=\"getBadgeClass(overallStatus())\"\n        [title]=\"getButtonTitle(overallStatus())\"\n        >\n        <span>{{ getStatusIcon(overallStatus()) }}</span>\n        <span>{{ getStatusLabel(overallStatus()) }}</span>\n        @if (overallStatus() !== 'VERIFICADO') {\n          <svg\n            class=\"w-3 h-3 ml-1\"\n            fill=\"none\"\n            stroke=\"currentColor\"\n            viewBox=\"0 0 24 24\"\n            >\n            <path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M9 5l7 7-7 7\" />\n          </svg>\n        }\n      </button>\n    }\n    `,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class VerificationBadgeComponent implements OnInit {\n  private readonly verificationService = inject(VerificationService);\n  private readonly router = inject(Router);\n\n  readonly statuses = this.verificationService.statuses;\n\n  readonly overallStatus = computed<VerificationStatus>(() => {\n    const current = this.statuses();\n    if (!current.length) {\n      return 'PENDIENTE';\n    }\n    if (current.some((status) => status.status === 'RECHAZADO')) {\n      return 'RECHAZADO';\n    }\n    if (current.every((status) => status.status === 'VERIFICADO')) {\n      return 'VERIFICADO';\n    }\n    return 'PENDIENTE';\n  });\n\n  hasData = computed(() => this.statuses().length > 0);\n\n  async ngOnInit(): Promise<void> {\n    if (!this.statuses().length) {\n      try {\n        await this.verificationService.loadStatuses();\n      } catch {\n        // Silent fail - verification status is optional\n      }\n    }\n  }\n\n  getStatusLabel(status: VerificationStatus): string {\n    switch (status) {\n      case 'VERIFICADO':\n        return 'Verificado para alquiler';\n      case 'RECHAZADO':\n        return 'Verificación rechazada';\n      default:\n        return 'Verificación pendiente';\n    }\n  }\n\n  getStatusIcon(status: VerificationStatus): string {\n    switch (status) {\n      case 'VERIFICADO':\n        return '🟢';\n      case 'RECHAZADO':\n        return '🔴';\n      default:\n        return '🔶';\n    }\n  }\n\n  getBadgeClass(status: VerificationStatus): string {\n    switch (status) {\n      case 'VERIFICADO':\n        return 'bg-success-bg text-success-strong border border-success-border';\n      case 'RECHAZADO':\n        return 'bg-error-bg text-error-strong border border-error-border';\n      default:\n        return 'bg-warning-bg text-warning-strong border border-warning-border';\n    }\n  }\n\n  goToVerification(): void {\n    // Navigate to profile page with verification tab\n    this.router.navigate(['/profile'], {\n      queryParams: { tab: 'verification' },\n    });\n  }\n\n  getButtonTitle(status: VerificationStatus): string {\n    switch (status) {\n      case 'VERIFICADO':\n        return 'Documento validado por Autorentar IA';\n      case 'RECHAZADO':\n        return 'Click para revisar y reintentar verificación';\n      default:\n        return 'Click para completar verificación de identidad';\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/shared/components/verification-prompt-banner/verification-prompt-banner.component.ts","messages":[{"ruleId":"import/order","severity":1,"message":"`../../../core/models` import should occur after import of `@core/services/verification/verification.service`","line":6,"column":1,"nodeType":"ImportDeclaration","endLine":6,"endColumn":52,"fix":{"range":[212,422],"text":"import { ProfileService } from '@core/services/auth/profile.service';\nimport { VerificationService } from '@core/services/verification/verification.service';\nimport { UserProfile } from '../../../core/models';\n"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"\nimport {Component, computed, inject, OnInit, signal,\n  ChangeDetectionStrategy} from '@angular/core';\nimport { Router, RouterLink } from '@angular/router';\nimport { TranslateModule } from '@ngx-translate/core';\nimport { UserProfile } from '../../../core/models';\nimport { ProfileService } from '@core/services/auth/profile.service';\nimport { VerificationService } from '@core/services/verification/verification.service';\n\n/**\n * VerificationPromptBannerComponent\n *\n * Banner prominente que aparece cuando el usuario tiene verificación pendiente\n * Guía al usuario al flujo de verificación con instrucciones claras\n *\n * Características:\n * - Aparece automáticamente después del login si no está verificado\n * - Muestra progreso de verificación (0%, 50%, 100%)\n * - Botón CTA directo a la página de verificación\n * - Dismissible (se puede cerrar temporalmente)\n * - Re-aparece en cada login hasta completar verificación\n *\n * Ubicación: Debajo del header en todas las páginas\n */\n@Component({\n  selector: 'app-verification-prompt-banner',\n  standalone: true,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  imports: [RouterLink, TranslateModule],\n  template: `\n    @if (shouldShow()) {\n      <div\n        class=\"bg-gradient-to-r from-warning-light to-cta-default text-text-primary shadow-lg\"\n        role=\"alert\"\n        aria-live=\"polite\"\n        >\n        <div class=\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-4\">\n          <div class=\"flex items-start justify-between gap-4\">\n            <!-- Avatar + Icon + Content -->\n            <div class=\"flex items-start gap-4 flex-1\">\n              <!-- Avatar -->\n              <div class=\"flex-shrink-0\">\n                <div class=\"relative h-12 w-12\">\n                  <!-- Avatar Image or Placeholder -->\n                  <div\n                    class=\"h-full w-full rounded-full overflow-hidden bg-surface-raised/20 border-2 border-white/40\"\n                    >\n                    @if (profile()?.avatar_url) {\n                      <img\n                        [src]=\"profile()!.avatar_url\"\n                        [alt]=\"profile()?.full_name || 'Usuario'\"\n                        class=\"h-full w-full object-cover\"\n                        loading=\"lazy\"\n                        />\n                    } @else {\n                      <div\n                        class=\"h-full w-full flex items-center justify-center bg-surface-raised/30\"\n                        >\n                        <svg\n                          class=\"h-7 w-7 text-text-primary/80\"\n                          fill=\"currentColor\"\n                          viewBox=\"0 0 24 24\"\n                          >\n                          <path\n                            d=\"M24 20.993V24H0v-2.996A14.977 14.977 0 0112.004 15c4.904 0 9.26 2.354 11.996 5.993zM16.002 8.999a4 4 0 11-8 0 4 4 0 018 0z\"\n                            />\n                        </svg>\n                      </div>\n                    }\n                  </div>\n                  <!-- Status Icon Badge -->\n                  <div\n                    class=\"absolute -bottom-1 -right-1 h-5 w-5 rounded-full bg-gradient-to-r from-warning-light to-cta-default border-2 border-white flex items-center justify-center\"\n                    >\n                    @if (verificationProgress() < 100) {\n                      <svg\n                        class=\"h-3 w-3 text-warning-300 animate-pulse\"\n                        fill=\"none\"\n                        viewBox=\"0 0 24 24\"\n                        stroke=\"currentColor\"\n                        aria-hidden=\"true\"\n                        >\n                        <path\n                          stroke-linecap=\"round\"\n                          stroke-linejoin=\"round\"\n                          stroke-width=\"2\"\n                          d=\"M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z\"\n                          />\n                      </svg>\n                    }\n                    @if (verificationProgress() === 100) {\n                      <svg\n                        class=\"h-3 w-3 text-success-strong\"\n                        fill=\"none\"\n                        viewBox=\"0 0 24 24\"\n                        stroke=\"currentColor\"\n                        aria-hidden=\"true\"\n                        >\n                        <path\n                          stroke-linecap=\"round\"\n                          stroke-linejoin=\"round\"\n                          stroke-width=\"2\"\n                          d=\"M9 12l2 2 4-4\"\n                          />\n                      </svg>\n                    }\n                  </div>\n                </div>\n              </div>\n              <!-- Text Content -->\n              <div class=\"flex-1 min-w-0 stack-sm\">\n                <h3 class=\"h4 text-text-primary\">\n                  {{ title() }}\n                </h3>\n                <p class=\"text-sm opacity-90\">\n                  {{ description() }}\n                </p>\n                <!-- Progress Bar (solo si no está completo) -->\n                @if (verificationProgress() < 100) {\n                  <div class=\"stack-xs\">\n                    <div class=\"flex items-center justify-between text-xs\">\n                      <span>Progreso de verificación</span>\n                      <span class=\"font-semibold\">{{ verificationProgress() }}%</span>\n                    </div>\n                    <div class=\"w-full bg-surface-raised/20 rounded-full h-2 overflow-hidden\">\n                      <div\n                        class=\"bg-surface-raised h-full rounded-full transition-all duration-500\"\n                        [style.width.%]=\"verificationProgress()\"\n                      ></div>\n                    </div>\n                  </div>\n                }\n                <!-- Action Buttons -->\n                <div class=\"flex flex-wrap items-center gap-3\">\n                  <a\n                    routerLink=\"/profile\"\n                    [queryParams]=\"{ tab: 'verification' }\"\n                    class=\"inline-flex items-center gap-2 px-4 py-2 bg-surface-raised text-cta-default rounded-lg text-sm font-semibold hover:bg-ivory-luminous transition-colors shadow-md hover:shadow-lg\"\n                    >\n                    <svg\n                      class=\"h-4 w-4\"\n                      fill=\"none\"\n                      viewBox=\"0 0 24 24\"\n                      stroke=\"currentColor\"\n                      aria-hidden=\"true\"\n                      >\n                      <path\n                        stroke-linecap=\"round\"\n                        stroke-linejoin=\"round\"\n                        stroke-width=\"2\"\n                        d=\"M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z\"\n                        />\n                    </svg>\n                    {{ ctaButtonText() }}\n                  </a>\n                  @if (!isWelcome()) {\n                    <button\n                      type=\"button\"\n                      (click)=\"viewBenefits()\"\n                      class=\"inline-flex items-center gap-1 text-sm text-text-inverse/90 hover:text-text-inverse underline\"\n                      >\n                      ¿Por qué verificar mi identidad?\n                    </button>\n                  }\n                </div>\n              </div>\n            </div>\n            <!-- Close Button -->\n            <button\n              type=\"button\"\n              (click)=\"dismiss()\"\n              class=\"flex-shrink-0 text-text-inverse/80 hover:text-text-inverse transition-colors\"\n              aria-label=\"Cerrar banner\"\n              >\n              <svg\n                class=\"h-5 w-5\"\n                fill=\"none\"\n                viewBox=\"0 0 24 24\"\n                stroke=\"currentColor\"\n                aria-hidden=\"true\"\n                >\n                <path\n                  stroke-linecap=\"round\"\n                  stroke-linejoin=\"round\"\n                  stroke-width=\"2\"\n                  d=\"M6 18L18 6M6 6l12 12\"\n                  />\n              </svg>\n            </button>\n          </div>\n        </div>\n      </div>\n    }\n    \n    <!-- Benefits Modal (inline simple version) -->\n    @if (showBenefits()) {\n      <div\n        class=\"fixed inset-0 bg-surface-overlay/50 z-50 flex items-center justify-center p-4\"\n        (click)=\"closeBenefits()\"\n        >\n        <div\n          class=\"bg-surface-raised dark:bg-graphite-light rounded-xl shadow-2xl max-w-2xl w-full p-6 max-h-[80vh] overflow-y-auto\"\n          (click)=\"$event.stopPropagation()\"\n          >\n          <div class=\"flex items-start justify-between mb-4\">\n            <h2 class=\"h3 text-text-primary dark:text-text-primary\">\n              ¿Por qué verificar tu identidad?\n            </h2>\n            <button\n              type=\"button\"\n              (click)=\"closeBenefits()\"\n              class=\"text-text-secondary dark:text-text-secondary hover:text-text-primary dark:hover:text-text-inverse transition-colors\"\n              >\n              <svg class=\"h-6 w-6\" fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\">\n                <path\n                  stroke-linecap=\"round\"\n                  stroke-linejoin=\"round\"\n                  stroke-width=\"2\"\n                  d=\"M6 18L18 6M6 6l12 12\"\n                  />\n              </svg>\n            </button>\n          </div>\n          <div class=\"space-y-4 text-text-primary dark:text-text-secondary\">\n            <div class=\"flex items-start gap-3\">\n              <div\n                class=\"flex-shrink-0 w-10 h-10 bg-success-light/20 dark:bg-success-light/30 rounded-full flex items-center justify-center\"\n                >\n                <svg\n                  class=\"w-5 h-5 text-success-700 dark:text-success-strong\"\n                  fill=\"none\"\n                  viewBox=\"0 0 24 24\"\n                  stroke=\"currentColor\"\n                  >\n                  <path\n                    stroke-linecap=\"round\"\n                    stroke-linejoin=\"round\"\n                    stroke-width=\"2\"\n                    d=\"M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z\"\n                    />\n                </svg>\n              </div>\n              <div>\n                <h3 class=\"font-semibold mb-1\">Mayor confianza en la comunidad</h3>\n                <p class=\"text-sm\">\n                  Los usuarios verificados generan +40% más reservas porque inspiran confianza.\n                </p>\n              </div>\n            </div>\n            <div class=\"flex items-start gap-3\">\n              <div\n                class=\"flex-shrink-0 w-10 h-10 bg-cta-default/20 dark:bg-cta-default/30 rounded-full flex items-center justify-center\"\n                >\n                <svg\n                  class=\"w-5 h-5 text-cta-default dark:text-cta-default\"\n                  fill=\"none\"\n                  viewBox=\"0 0 24 24\"\n                  stroke=\"currentColor\"\n                  >\n                  <path\n                    stroke-linecap=\"round\"\n                    stroke-linejoin=\"round\"\n                    stroke-width=\"2\"\n                    d=\"M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z\"\n                    />\n                </svg>\n              </div>\n              <div>\n                <h3 class=\"font-semibold mb-1\">Protección contra fraude</h3>\n                <p class=\"text-sm\">\n                  Verificamos tu identidad para prevenir suplantaciones y actividades fraudulentas.\n                </p>\n              </div>\n            </div>\n            <div class=\"flex items-start gap-3\">\n              <div\n                class=\"flex-shrink-0 w-10 h-10 bg-purple-100 dark:bg-purple-900/30 rounded-full flex items-center justify-center\"\n                >\n                <svg\n                  class=\"w-5 h-5 text-purple-600 dark:text-purple-400\"\n                  fill=\"none\"\n                  viewBox=\"0 0 24 24\"\n                  stroke=\"currentColor\"\n                  >\n                  <path\n                    stroke-linecap=\"round\"\n                    stroke-linejoin=\"round\"\n                    stroke-width=\"2\"\n                    d=\"M13 10V3L4 14h7v7l9-11h-7z\"\n                    />\n                </svg>\n              </div>\n              <div>\n                <h3 class=\"font-semibold mb-1\">Acceso prioritario a funciones</h3>\n                <p class=\"text-sm\">\n                  Usuarios verificados pueden publicar autos, solicitar retiros y acceder a beneficios\n                  exclusivos.\n                </p>\n              </div>\n            </div>\n            <div class=\"flex items-start gap-3\">\n              <div\n                class=\"flex-shrink-0 w-10 h-10 bg-warning-bg-hover dark:bg-warning-900/30 rounded-full flex items-center justify-center\"\n                >\n                <svg\n                  class=\"w-5 h-5 text-warning-text dark:text-warning-400\"\n                  fill=\"none\"\n                  viewBox=\"0 0 24 24\"\n                  stroke=\"currentColor\"\n                  >\n                  <path\n                    stroke-linecap=\"round\"\n                    stroke-linejoin=\"round\"\n                    stroke-width=\"2\"\n                    d=\"M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8c1.11 0 2.08.402 2.599 1M12 8V7m0 1v8m0 0v1m0-1c-1.11 0-2.08-.402-2.599-1M21 12a9 9 0 11-18 0 9 9 0 0118 0z\"\n                    />\n                </svg>\n              </div>\n              <div>\n                <h3 class=\"font-semibold mb-1\">Proceso rápido y seguro</h3>\n                <p class=\"text-sm\">\n                  Solo tomará 5 minutos. Tus datos están protegidos con encriptación de nivel\n                  bancario.\n                </p>\n              </div>\n            </div>\n          </div>\n          <div class=\"mt-6 flex justify-end gap-3\">\n            <button\n              type=\"button\"\n              (click)=\"closeBenefits()\"\n              class=\"px-4 py-2 text-sm font-medium text-text-secondary dark:text-text-secondary hover:text-text-primary dark:text-text-secondary dark:hover:text-text-inverse transition-colors\"\n              >\n              Cerrar\n            </button>\n            <a\n              routerLink=\"/profile\"\n              [queryParams]=\"{ tab: 'verification' }\"\n              (click)=\"closeBenefits()\"\n              class=\"px-4 py-2 bg-cta-default text-cta-text rounded-lg text-sm font-semibold hover:opacity-90 transition-opacity\"\n              >\n              Iniciar verificación\n            </a>\n          </div>\n        </div>\n      </div>\n    }\n    `,\n})\nexport class VerificationPromptBannerComponent implements OnInit {\n  private readonly profileService = inject(ProfileService);\n  private readonly verificationService = inject(VerificationService);\n  private readonly router = inject(Router);\n\n  private readonly dismissed = signal(false);\n  readonly showBenefits = signal(false);\n  readonly profile = signal<UserProfile | null>(null);\n\n  async ngOnInit(): Promise<void> {\n    // Check if banner was dismissed in this session\n    const dismissed = sessionStorage.getItem('verification_banner_dismissed');\n    if (dismissed) {\n      this.dismissed.set(true);\n      return;\n    }\n\n    // Load user profile\n    await this.loadProfile();\n  }\n\n  private async loadProfile(): Promise<void> {\n    try {\n      const profile = await this.profileService.getCurrentProfile();\n      this.profile.set(profile);\n    } catch {\n      /* Silenced */\n    }\n  }\n\n  /**\n   * Calcula si el banner debe mostrarse\n   */\n  readonly shouldShow = computed(() => {\n    const profile = this.profile();\n    const dismissed = this.dismissed();\n\n    if (!profile || dismissed) return false;\n\n    // Mostrar si el usuario no está verificado\n    const kyc = profile.kyc;\n    return kyc === 'not_started' || kyc === 'pending' || kyc === 'rejected';\n  });\n\n  /**\n   * Calcula el progreso de verificación (0-100)\n   */\n  readonly verificationProgress = computed(() => {\n    const profile = this.profile();\n    if (!profile) return 0;\n\n    const kyc = profile.kyc;\n\n    if (kyc === 'verified') return 100;\n    if (kyc === 'pending') return 50;\n    if (kyc === 'not_started') return 0;\n    if (kyc === 'rejected') return 25; // Rechazado, necesita resubir\n\n    return 0;\n  });\n\n  /**\n   * Determina si es el mensaje de bienvenida (primera vez)\n   */\n  readonly isWelcome = computed(() => {\n    const profile = this.profile();\n    return profile?.kyc === 'not_started';\n  });\n\n  /**\n   * Título del banner según el estado\n   */\n  readonly title = computed(() => {\n    const kyc = this.profile()?.kyc;\n\n    switch (kyc) {\n      case 'not_started':\n        return '👋 ¡Bienvenido a AutoRenta! Verificá tu identidad para comenzar';\n      case 'pending':\n        return '⏳ Verificación en proceso';\n      case 'rejected':\n        return '⚠️ Verificación rechazada - Se requiere acción';\n      default:\n        return 'Verificación pendiente';\n    }\n  });\n\n  /**\n   * Descripción del banner según el estado\n   */\n  readonly description = computed(() => {\n    const kyc = this.profile()?.kyc;\n\n    switch (kyc) {\n      case 'not_started':\n        return 'Verificá tu identidad en solo 5 minutos para publicar autos, reservar vehículos y acceder a todas las funciones de la plataforma.';\n      case 'pending':\n        return 'Estamos revisando tu documentación. Este proceso suele tomar entre 24 y 48 horas. Te notificaremos por email cuando esté lista.';\n      case 'rejected':\n        return 'Tu verificación fue rechazada. Por favor revisá los comentarios y volvé a subir la documentación correcta.';\n      default:\n        return 'Completá el proceso de verificación para acceder a todas las funcionalidades.';\n    }\n  });\n\n  /**\n   * Texto del botón CTA\n   */\n  readonly ctaButtonText = computed(() => {\n    const kyc = this.profile()?.kyc;\n\n    switch (kyc) {\n      case 'not_started':\n        return 'Verificar ahora';\n      case 'pending':\n        return 'Ver estado';\n      case 'rejected':\n        return 'Corregir documentos';\n      default:\n        return 'Ir a verificación';\n    }\n  });\n\n  dismiss(): void {\n    this.dismissed.set(true);\n\n    // Guardar en localStorage para no mostrar en esta sesión\n    sessionStorage.setItem('verification_banner_dismissed', Date.now().toString());\n  }\n\n  viewBenefits(): void {\n    this.showBenefits.set(true);\n  }\n\n  closeBenefits(): void {\n    this.showBenefits.set(false);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/edu/autorenta/apps/web/src/app/shared/components/video-inspection-recorder/video-inspection-recorder.component.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'effect' is defined but never used.","line":1,"column":75,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":81},{"ruleId":"@angular-eslint/no-output-native","severity":2,"message":"Output bindings, including aliases, should not be named as standard DOM events","line":215,"column":3,"nodeType":"Identifier","messageId":"noOutputNative","endLine":215,"endColumn":8},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":238,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":238,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7282,7285],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7282,7285],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@angular-eslint/use-lifecycle-interface","severity":1,"message":"Lifecycle interface 'AfterViewInit' should be implemented for method 'ngAfterViewInit'. (https://angular.dev/style-guide#use-lifecycle-hook-interfaces)","line":240,"column":9,"nodeType":"Identifier","messageId":"useLifecycleInterface","endLine":240,"endColumn":24,"fix":{"range":[80,5999],"text":", AfterViewInit } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { IonicModule } from '@ionic/angular';\nimport { VideoDamageDetectionService } from '@core/services/verification/video-damage-detection.service';\n\n/**\n * Video Inspection Recorder Component\n * \n * Permite grabar video de inspección vehicular con guías visuales\n */\n@Component({\n  selector: 'app-video-inspection-recorder',\n  standalone: true,\n  imports: [CommonModule, IonicModule],\n  template: `\n    <div class=\"video-recorder-container\">\n      <!-- Video Preview -->\n      <div class=\"video-preview\" [class.recording]=\"isRecording()\">\n        <video #videoElement autoplay playsinline muted></video>\n        \n        <!-- Recording indicator -->\n        @if (isRecording()) {\n          <div class=\"recording-indicator\">\n            <ion-icon name=\"ellipse\" color=\"danger\"></ion-icon>\n            <span>{{ formatTime(recordingDuration()) }}</span>\n          </div>\n        }\n        \n        <!-- Inspection guide -->\n        @if (isRecording()) {\n          <div class=\"inspection-guide\">\n            <div class=\"guide-text\">{{ currentGuide().text }}</div>\n            <div class=\"guide-checklist\">\n              @for (area of inspectionAreas; track area.id) {\n                <div class=\"area-item\" [class.completed]=\"area.completed\">\n                  <ion-icon \n                    [name]=\"area.completed ? 'checkmark-circle' : 'ellipse-outline'\"\n                    [color]=\"area.completed ? 'success' : 'medium'\">\n                  </ion-icon>\n                  <span>{{ area.label }}</span>\n                </div>\n              }\n            </div>\n          </div>\n        }\n        \n        <!-- Quality warning -->\n        @if (qualityWarning()) {\n          <div class=\"quality-warning\">\n            <ion-icon name=\"warning\" color=\"warning\"></ion-icon>\n            <span>{{ qualityWarning() }}</span>\n          </div>\n        }\n      </div>\n      \n      <!-- Controls -->\n      <div class=\"controls\">\n        @if (!isRecording() && !isProcessing()) {\n          <ion-button expand=\"block\" color=\"danger\" (click)=\"startRecording()\">\n            <ion-icon slot=\"start\" name=\"videocam\"></ion-icon>\n            Iniciar Inspección\n          </ion-button>\n        }\n        \n        @if (isRecording()) {\n          <ion-button \n            expand=\"block\" \n            color=\"success\"\n            [disabled]=\"recordingDuration() < 90\"\n            (click)=\"stopRecording()\">\n            <ion-icon slot=\"start\" name=\"stop-circle\"></ion-icon>\n            Finalizar (mín. 90s)\n          </ion-button>\n        }\n        \n        @if (isProcessing()) {\n          <div class=\"upload-progress\">\n            <ion-progress-bar [value]=\"uploadProgress() / 100\"></ion-progress-bar>\n            <p>Subiendo video... {{ uploadProgress() }}%</p>\n          </div>\n        }\n      </div>\n      \n      <!-- Instructions -->\n      @if (!isRecording() && !isProcessing()) {\n        <ion-card class=\"instructions\">\n          <ion-card-header>\n            <ion-card-title>Instrucciones de Inspección</ion-card-title>\n          </ion-card-header>\n          <ion-card-content>\n            <ul>\n              <li>Graba en buena iluminación (evita sombras)</li>\n              <li>Muestra TODO el auto en 360° (90 segundos mínimo)</li>\n              <li>Incluye: 4 puertas, capó, cajuela, techo, 4 llantas, luces</li>\n              <li>Acércate a daños existentes (rayones, abolladuras)</li>\n              <li>No tapes partes del auto con manos u objetos</li>\n              <li>Graba también el interior (asientos, tablero)</li>\n            </ul>\n          </ion-card-content>\n        </ion-card>\n      }\n    </div>\n  `,\n  styles: [`\n    .video-recorder-container {\n      padding: 16px;\n    }\n    .video-preview {\n      position: relative;\n      width: 100%;\n      aspect-ratio: 16/9;\n      background: #000;\n      border-radius: 8px;\n      overflow: hidden;\n      margin-bottom: 16px;\n    }\n    .video-preview.recording {\n      border: 3px solid var(--ion-color-danger);\n      animation: pulse 2s infinite;\n    }\n    @keyframes pulse {\n      0%, 100% { border-color: var(--ion-color-danger); }\n      50% { border-color: rgba(var(--ion-color-danger-rgb), 0.5); }\n    }\n    video {\n      width: 100%;\n      height: 100%;\n      object-fit: cover;\n    }\n    .recording-indicator {\n      position: absolute;\n      top: 16px;\n      left: 16px;\n      display: flex;\n      align-items: center;\n      gap: 8px;\n      background: rgba(0, 0, 0, 0.7);\n      padding: 8px 16px;\n      border-radius: 20px;\n      color: white;\n      font-weight: bold;\n    }\n    .inspection-guide {\n      position: absolute;\n      top: 16px;\n      right: 16px;\n      background: rgba(0, 0, 0, 0.8);\n      padding: 16px;\n      border-radius: 8px;\n      max-width: 250px;\n    }\n    .guide-text {\n      color: white;\n      font-size: 14px;\n      margin-bottom: 12px;\n      font-weight: 500;\n    }\n    .guide-checklist {\n      display: flex;\n      flex-direction: column;\n      gap: 8px;\n    }\n    .area-item {\n      display: flex;\n      align-items: center;\n      gap: 8px;\n      color: rgba(255, 255, 255, 0.7);\n      font-size: 12px;\n    }\n    .area-item.completed {\n      color: var(--ion-color-success);\n    }\n    .quality-warning {\n      position: absolute;\n      bottom: 16px;\n      left: 16px;\n      right: 16px;\n      display: flex;\n      align-items: center;\n      gap: 8px;\n      background: rgba(255, 193, 7, 0.9);\n      padding: 12px 16px;\n      border-radius: 8px;\n      color: #000;\n      font-weight: 500;\n    }\n    .upload-progress {\n      padding: 16px;\n      text-align: center;\n    }\n    .upload-progress p {\n      margin-top: 8px;\n      color: var(--ion-color-medium);\n    }\n    .instructions ul {\n      margin: 0;\n      padding-left: 20px;\n    }\n    .instructions li {\n      margin-bottom: 8px;\n      line-height: 1.5;\n    }\n  `]\n})\nexport class VideoInspectionRecorderComponent implements AfterViewInit"}},{"ruleId":"@angular-eslint/use-lifecycle-interface","severity":1,"message":"Lifecycle interface 'OnDestroy' should be implemented for method 'ngOnDestroy'. (https://angular.dev/style-guide#use-lifecycle-hook-interfaces)","line":244,"column":3,"nodeType":"Identifier","messageId":"useLifecycleInterface","endLine":244,"endColumn":14,"fix":{"range":[80,5999],"text":", OnDestroy } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { IonicModule } from '@ionic/angular';\nimport { VideoDamageDetectionService } from '@core/services/verification/video-damage-detection.service';\n\n/**\n * Video Inspection Recorder Component\n * \n * Permite grabar video de inspección vehicular con guías visuales\n */\n@Component({\n  selector: 'app-video-inspection-recorder',\n  standalone: true,\n  imports: [CommonModule, IonicModule],\n  template: `\n    <div class=\"video-recorder-container\">\n      <!-- Video Preview -->\n      <div class=\"video-preview\" [class.recording]=\"isRecording()\">\n        <video #videoElement autoplay playsinline muted></video>\n        \n        <!-- Recording indicator -->\n        @if (isRecording()) {\n          <div class=\"recording-indicator\">\n            <ion-icon name=\"ellipse\" color=\"danger\"></ion-icon>\n            <span>{{ formatTime(recordingDuration()) }}</span>\n          </div>\n        }\n        \n        <!-- Inspection guide -->\n        @if (isRecording()) {\n          <div class=\"inspection-guide\">\n            <div class=\"guide-text\">{{ currentGuide().text }}</div>\n            <div class=\"guide-checklist\">\n              @for (area of inspectionAreas; track area.id) {\n                <div class=\"area-item\" [class.completed]=\"area.completed\">\n                  <ion-icon \n                    [name]=\"area.completed ? 'checkmark-circle' : 'ellipse-outline'\"\n                    [color]=\"area.completed ? 'success' : 'medium'\">\n                  </ion-icon>\n                  <span>{{ area.label }}</span>\n                </div>\n              }\n            </div>\n          </div>\n        }\n        \n        <!-- Quality warning -->\n        @if (qualityWarning()) {\n          <div class=\"quality-warning\">\n            <ion-icon name=\"warning\" color=\"warning\"></ion-icon>\n            <span>{{ qualityWarning() }}</span>\n          </div>\n        }\n      </div>\n      \n      <!-- Controls -->\n      <div class=\"controls\">\n        @if (!isRecording() && !isProcessing()) {\n          <ion-button expand=\"block\" color=\"danger\" (click)=\"startRecording()\">\n            <ion-icon slot=\"start\" name=\"videocam\"></ion-icon>\n            Iniciar Inspección\n          </ion-button>\n        }\n        \n        @if (isRecording()) {\n          <ion-button \n            expand=\"block\" \n            color=\"success\"\n            [disabled]=\"recordingDuration() < 90\"\n            (click)=\"stopRecording()\">\n            <ion-icon slot=\"start\" name=\"stop-circle\"></ion-icon>\n            Finalizar (mín. 90s)\n          </ion-button>\n        }\n        \n        @if (isProcessing()) {\n          <div class=\"upload-progress\">\n            <ion-progress-bar [value]=\"uploadProgress() / 100\"></ion-progress-bar>\n            <p>Subiendo video... {{ uploadProgress() }}%</p>\n          </div>\n        }\n      </div>\n      \n      <!-- Instructions -->\n      @if (!isRecording() && !isProcessing()) {\n        <ion-card class=\"instructions\">\n          <ion-card-header>\n            <ion-card-title>Instrucciones de Inspección</ion-card-title>\n          </ion-card-header>\n          <ion-card-content>\n            <ul>\n              <li>Graba en buena iluminación (evita sombras)</li>\n              <li>Muestra TODO el auto en 360° (90 segundos mínimo)</li>\n              <li>Incluye: 4 puertas, capó, cajuela, techo, 4 llantas, luces</li>\n              <li>Acércate a daños existentes (rayones, abolladuras)</li>\n              <li>No tapes partes del auto con manos u objetos</li>\n              <li>Graba también el interior (asientos, tablero)</li>\n            </ul>\n          </ion-card-content>\n        </ion-card>\n      }\n    </div>\n  `,\n  styles: [`\n    .video-recorder-container {\n      padding: 16px;\n    }\n    .video-preview {\n      position: relative;\n      width: 100%;\n      aspect-ratio: 16/9;\n      background: #000;\n      border-radius: 8px;\n      overflow: hidden;\n      margin-bottom: 16px;\n    }\n    .video-preview.recording {\n      border: 3px solid var(--ion-color-danger);\n      animation: pulse 2s infinite;\n    }\n    @keyframes pulse {\n      0%, 100% { border-color: var(--ion-color-danger); }\n      50% { border-color: rgba(var(--ion-color-danger-rgb), 0.5); }\n    }\n    video {\n      width: 100%;\n      height: 100%;\n      object-fit: cover;\n    }\n    .recording-indicator {\n      position: absolute;\n      top: 16px;\n      left: 16px;\n      display: flex;\n      align-items: center;\n      gap: 8px;\n      background: rgba(0, 0, 0, 0.7);\n      padding: 8px 16px;\n      border-radius: 20px;\n      color: white;\n      font-weight: bold;\n    }\n    .inspection-guide {\n      position: absolute;\n      top: 16px;\n      right: 16px;\n      background: rgba(0, 0, 0, 0.8);\n      padding: 16px;\n      border-radius: 8px;\n      max-width: 250px;\n    }\n    .guide-text {\n      color: white;\n      font-size: 14px;\n      margin-bottom: 12px;\n      font-weight: 500;\n    }\n    .guide-checklist {\n      display: flex;\n      flex-direction: column;\n      gap: 8px;\n    }\n    .area-item {\n      display: flex;\n      align-items: center;\n      gap: 8px;\n      color: rgba(255, 255, 255, 0.7);\n      font-size: 12px;\n    }\n    .area-item.completed {\n      color: var(--ion-color-success);\n    }\n    .quality-warning {\n      position: absolute;\n      bottom: 16px;\n      left: 16px;\n      right: 16px;\n      display: flex;\n      align-items: center;\n      gap: 8px;\n      background: rgba(255, 193, 7, 0.9);\n      padding: 12px 16px;\n      border-radius: 8px;\n      color: #000;\n      font-weight: 500;\n    }\n    .upload-progress {\n      padding: 16px;\n      text-align: center;\n    }\n    .upload-progress p {\n      margin-top: 8px;\n      color: var(--ion-color-medium);\n    }\n    .instructions ul {\n      margin: 0;\n      padding-left: 20px;\n    }\n    .instructions li {\n      margin-bottom: 8px;\n      line-height: 1.5;\n    }\n  `]\n})\nexport class VideoInspectionRecorderComponent implements OnDestroy"}},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'err' is defined but never used.","line":258,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":258,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'err' is defined but never used.","line":288,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":288,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'err' is defined but never used.","line":322,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":322,"endColumn":17}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import { Component, signal, inject, output, input, ViewChild, ElementRef, effect } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { IonicModule } from '@ionic/angular';\nimport { VideoDamageDetectionService } from '@core/services/verification/video-damage-detection.service';\n\n/**\n * Video Inspection Recorder Component\n * \n * Permite grabar video de inspección vehicular con guías visuales\n */\n@Component({\n  selector: 'app-video-inspection-recorder',\n  standalone: true,\n  imports: [CommonModule, IonicModule],\n  template: `\n    <div class=\"video-recorder-container\">\n      <!-- Video Preview -->\n      <div class=\"video-preview\" [class.recording]=\"isRecording()\">\n        <video #videoElement autoplay playsinline muted></video>\n        \n        <!-- Recording indicator -->\n        @if (isRecording()) {\n          <div class=\"recording-indicator\">\n            <ion-icon name=\"ellipse\" color=\"danger\"></ion-icon>\n            <span>{{ formatTime(recordingDuration()) }}</span>\n          </div>\n        }\n        \n        <!-- Inspection guide -->\n        @if (isRecording()) {\n          <div class=\"inspection-guide\">\n            <div class=\"guide-text\">{{ currentGuide().text }}</div>\n            <div class=\"guide-checklist\">\n              @for (area of inspectionAreas; track area.id) {\n                <div class=\"area-item\" [class.completed]=\"area.completed\">\n                  <ion-icon \n                    [name]=\"area.completed ? 'checkmark-circle' : 'ellipse-outline'\"\n                    [color]=\"area.completed ? 'success' : 'medium'\">\n                  </ion-icon>\n                  <span>{{ area.label }}</span>\n                </div>\n              }\n            </div>\n          </div>\n        }\n        \n        <!-- Quality warning -->\n        @if (qualityWarning()) {\n          <div class=\"quality-warning\">\n            <ion-icon name=\"warning\" color=\"warning\"></ion-icon>\n            <span>{{ qualityWarning() }}</span>\n          </div>\n        }\n      </div>\n      \n      <!-- Controls -->\n      <div class=\"controls\">\n        @if (!isRecording() && !isProcessing()) {\n          <ion-button expand=\"block\" color=\"danger\" (click)=\"startRecording()\">\n            <ion-icon slot=\"start\" name=\"videocam\"></ion-icon>\n            Iniciar Inspección\n          </ion-button>\n        }\n        \n        @if (isRecording()) {\n          <ion-button \n            expand=\"block\" \n            color=\"success\"\n            [disabled]=\"recordingDuration() < 90\"\n            (click)=\"stopRecording()\">\n            <ion-icon slot=\"start\" name=\"stop-circle\"></ion-icon>\n            Finalizar (mín. 90s)\n          </ion-button>\n        }\n        \n        @if (isProcessing()) {\n          <div class=\"upload-progress\">\n            <ion-progress-bar [value]=\"uploadProgress() / 100\"></ion-progress-bar>\n            <p>Subiendo video... {{ uploadProgress() }}%</p>\n          </div>\n        }\n      </div>\n      \n      <!-- Instructions -->\n      @if (!isRecording() && !isProcessing()) {\n        <ion-card class=\"instructions\">\n          <ion-card-header>\n            <ion-card-title>Instrucciones de Inspección</ion-card-title>\n          </ion-card-header>\n          <ion-card-content>\n            <ul>\n              <li>Graba en buena iluminación (evita sombras)</li>\n              <li>Muestra TODO el auto en 360° (90 segundos mínimo)</li>\n              <li>Incluye: 4 puertas, capó, cajuela, techo, 4 llantas, luces</li>\n              <li>Acércate a daños existentes (rayones, abolladuras)</li>\n              <li>No tapes partes del auto con manos u objetos</li>\n              <li>Graba también el interior (asientos, tablero)</li>\n            </ul>\n          </ion-card-content>\n        </ion-card>\n      }\n    </div>\n  `,\n  styles: [`\n    .video-recorder-container {\n      padding: 16px;\n    }\n    .video-preview {\n      position: relative;\n      width: 100%;\n      aspect-ratio: 16/9;\n      background: #000;\n      border-radius: 8px;\n      overflow: hidden;\n      margin-bottom: 16px;\n    }\n    .video-preview.recording {\n      border: 3px solid var(--ion-color-danger);\n      animation: pulse 2s infinite;\n    }\n    @keyframes pulse {\n      0%, 100% { border-color: var(--ion-color-danger); }\n      50% { border-color: rgba(var(--ion-color-danger-rgb), 0.5); }\n    }\n    video {\n      width: 100%;\n      height: 100%;\n      object-fit: cover;\n    }\n    .recording-indicator {\n      position: absolute;\n      top: 16px;\n      left: 16px;\n      display: flex;\n      align-items: center;\n      gap: 8px;\n      background: rgba(0, 0, 0, 0.7);\n      padding: 8px 16px;\n      border-radius: 20px;\n      color: white;\n      font-weight: bold;\n    }\n    .inspection-guide {\n      position: absolute;\n      top: 16px;\n      right: 16px;\n      background: rgba(0, 0, 0, 0.8);\n      padding: 16px;\n      border-radius: 8px;\n      max-width: 250px;\n    }\n    .guide-text {\n      color: white;\n      font-size: 14px;\n      margin-bottom: 12px;\n      font-weight: 500;\n    }\n    .guide-checklist {\n      display: flex;\n      flex-direction: column;\n      gap: 8px;\n    }\n    .area-item {\n      display: flex;\n      align-items: center;\n      gap: 8px;\n      color: rgba(255, 255, 255, 0.7);\n      font-size: 12px;\n    }\n    .area-item.completed {\n      color: var(--ion-color-success);\n    }\n    .quality-warning {\n      position: absolute;\n      bottom: 16px;\n      left: 16px;\n      right: 16px;\n      display: flex;\n      align-items: center;\n      gap: 8px;\n      background: rgba(255, 193, 7, 0.9);\n      padding: 12px 16px;\n      border-radius: 8px;\n      color: #000;\n      font-weight: 500;\n    }\n    .upload-progress {\n      padding: 16px;\n      text-align: center;\n    }\n    .upload-progress p {\n      margin-top: 8px;\n      color: var(--ion-color-medium);\n    }\n    .instructions ul {\n      margin: 0;\n      padding-left: 20px;\n    }\n    .instructions li {\n      margin-bottom: 8px;\n      line-height: 1.5;\n    }\n  `]\n})\nexport class VideoInspectionRecorderComponent {\n  private readonly videoService = inject(VideoDamageDetectionService);\n  \n  @ViewChild('videoElement') videoElement!: ElementRef<HTMLVideoElement>;\n  \n  bookingId = input.required<string>();\n  carId = input.required<string>();\n  inspectionType = input<'checkin' | 'checkout'>('checkin');\n  \n  videoUploaded = output<string>();\n  error = output<string>();\n  \n  readonly isRecording = signal(false);\n  readonly isProcessing = signal(false);\n  readonly recordingDuration = signal(0);\n  readonly uploadProgress = this.videoService.uploadProgress;\n  readonly qualityWarning = signal<string | null>(null);\n  \n  inspectionAreas = [\n    { id: 'front', label: 'Frente', completed: false },\n    { id: 'left', label: 'Lateral Izq', completed: false },\n    { id: 'rear', label: 'Parte Trasera', completed: false },\n    { id: 'right', label: 'Lateral Der', completed: false },\n    { id: 'hood', label: 'Capó', completed: false },\n    { id: 'roof', label: 'Techo', completed: false },\n    { id: 'interior', label: 'Interior', completed: false }\n  ];\n  \n  currentGuide = signal({ text: 'Comienza por el frente del vehículo' });\n  \n  private mediaRecorder: MediaRecorder | null = null;\n  private recordedChunks: Blob[] = [];\n  private stream: MediaStream | null = null;\n  private recordingTimer: any = null;\n  \n  async ngAfterViewInit() {\n    await this.initCamera();\n  }\n  \n  ngOnDestroy() {\n    this.stopCamera();\n  }\n  \n  private async initCamera() {\n    try {\n      this.stream = await navigator.mediaDevices.getUserMedia({\n        video: { facingMode: 'environment', width: { ideal: 1920 }, height: { ideal: 1080 } },\n        audio: true\n      });\n      \n      if (this.videoElement) {\n        this.videoElement.nativeElement.srcObject = this.stream;\n      }\n    } catch (err) {\n      this.error.emit('No se pudo acceder a la cámara');\n    }\n  }\n  \n  async startRecording() {\n    if (!this.stream) await this.initCamera();\n    \n    try {\n      this.recordedChunks = [];\n      this.mediaRecorder = new MediaRecorder(this.stream!, {\n        mimeType: 'video/webm;codecs=vp9',\n        videoBitsPerSecond: 2500000\n      });\n      \n      this.mediaRecorder.ondataavailable = (event) => {\n        if (event.data.size > 0) this.recordedChunks.push(event.data);\n      };\n      \n      this.mediaRecorder.onstop = () => this.processRecording();\n      this.mediaRecorder.start(1000);\n      this.isRecording.set(true);\n      this.recordingDuration.set(0);\n      \n      this.recordingTimer = setInterval(() => {\n        const duration = this.recordingDuration() + 1;\n        this.recordingDuration.set(duration);\n        this.updateGuide(duration);\n        this.checkQuality();\n      }, 1000);\n    } catch (err) {\n      this.error.emit('Error al iniciar grabación');\n    }\n  }\n  \n  stopRecording() {\n    if (this.mediaRecorder && this.isRecording()) {\n      this.mediaRecorder.stop();\n      this.isRecording.set(false);\n      if (this.recordingTimer) clearInterval(this.recordingTimer);\n    }\n  }\n  \n  private async processRecording() {\n    const blob = new Blob(this.recordedChunks, { type: 'video/webm' });\n    const file = new File([blob], `inspection_${Date.now()}.webm`, { type: 'video/webm' });\n    \n    if (this.recordingDuration() < 90) {\n      this.error.emit('El video debe durar al menos 90 segundos');\n      return;\n    }\n    \n    try {\n      this.isProcessing.set(true);\n      \n      const videoPath = await this.videoService.uploadInspectionVideo({\n        bookingId: this.bookingId(),\n        inspectionType: this.inspectionType(),\n        videoFile: file,\n        carId: this.carId(),\n        userId: 'current-user-id'\n      });\n      \n      this.videoUploaded.emit(videoPath);\n    } catch (err) {\n      this.error.emit('Error al subir video');\n    } finally {\n      this.isProcessing.set(false);\n    }\n  }\n  \n  private updateGuide(duration: number) {\n    const guides = [\n      { time: 0, text: 'Comienza por el frente del vehículo', area: 'front' },\n      { time: 15, text: 'Ahora lateral izquierdo', area: 'left' },\n      { time: 30, text: 'Parte trasera y cajuela', area: 'rear' },\n      { time: 45, text: 'Lateral derecho', area: 'right' },\n      { time: 60, text: 'Capó y motor', area: 'hood' },\n      { time: 75, text: 'Techo del vehículo', area: 'roof' },\n      { time: 90, text: 'Interior: asientos y tablero', area: 'interior' }\n    ];\n    \n    const currentGuideItem = [...guides].reverse().find(g => duration >= g.time);\n    if (currentGuideItem) {\n      this.currentGuide.set({ text: currentGuideItem.text });\n      const area = this.inspectionAreas.find(a => a.id === currentGuideItem.area);\n      if (area) area.completed = true;\n    }\n  }\n  \n  private checkQuality() {\n    if (this.recordingDuration() < 30) {\n      this.qualityWarning.set('Asegúrate de grabar al menos 90 segundos');\n    } else {\n      this.qualityWarning.set(null);\n    }\n  }\n  \n  private stopCamera() {\n    if (this.stream) {\n      this.stream.getTracks().forEach(track => track.stop());\n    }\n  }\n  \n  formatTime(seconds: number): string {\n    const mins = Math.floor(seconds / 60);\n    const secs = seconds % 60;\n    return `${mins}:${secs.toString().padStart(2, '0')}`;\n  }\n}\n","usedDeprecatedRules":[]}]
