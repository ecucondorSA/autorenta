<!doctype html>
<html class="no-js" lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>autorenta-web documentation</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="icon" type="image/x-icon" href="../images/favicon.ico">
	   <link rel="stylesheet" href="../styles/style.css">
        <link rel="stylesheet" href="../styles/dark.css">
    </head>
    <body>
          <script>
               // Blocking script to avoid flickering dark mode
               // Dark mode toggle button
               var useDark = window.matchMedia('(prefers-color-scheme: dark)');
               var darkModeState = useDark.matches;
               var $darkModeToggleSwitchers = document.querySelectorAll('.dark-mode-switch input');
               var $darkModeToggles = document.querySelectorAll('.dark-mode-switch');
               var darkModeStateLocal = localStorage.getItem('compodoc_darkmode-state');

               function checkToggle(check) {
                    for (var i = 0; i < $darkModeToggleSwitchers.length; i++) {
                         $darkModeToggleSwitchers[i].checked = check;
                    }
               }

               function toggleDarkMode(state) {
                    if (window.localStorage) {
                         localStorage.setItem('compodoc_darkmode-state', state);
                    }

                    checkToggle(state);

                    const hasClass = document.body.classList.contains('dark');

                    if (state) {
                         for (var i = 0; i < $darkModeToggles.length; i++) {
                              $darkModeToggles[i].classList.add('dark');
                         }
                         if (!hasClass) {
                              document.body.classList.add('dark');
                         }
                    } else {
                         for (var i = 0; i < $darkModeToggles.length; i++) {
                              $darkModeToggles[i].classList.remove('dark');
                         }
                         if (hasClass) {
                              document.body.classList.remove('dark');
                         }
                    }
               }

               useDark.addEventListener('change', function (evt) {
                    toggleDarkMode(evt.matches);
               });
               if (darkModeStateLocal) {
                    darkModeState = darkModeStateLocal === 'true';
               }
               toggleDarkMode(darkModeState);
          </script>
          <script>
              // --- Iframe navigation tracking for Template Playground ---
              function sendCurrentUrlToParent() {
                  if (window.parent && window.parent !== window) {
                      window.parent.postMessage({
                          type: 'compodoc-iframe-navigate',
                          url: window.location.pathname + window.location.hash
                      }, '*');
                  }
              }
              window.addEventListener('hashchange', sendCurrentUrlToParent, false);
              window.addEventListener('popstate', sendCurrentUrlToParent, false);
              window.addEventListener('DOMContentLoaded', sendCurrentUrlToParent, false);
          </script>

        <div class="navbar navbar-default navbar-fixed-top d-md-none p-0">
               <div class="d-flex">
                    <a href="../" class="navbar-brand">autorenta-web documentation</a>
                    <button type="button" class="btn btn-default btn-menu ion-ios-menu" id="btn-menu"></button>
               </div>
        </div>

        <div class="xs-menu menu" id="mobile-menu">
                <div id="book-search-input" role="search"><input type="text" placeholder="Type to search"></div>            <compodoc-menu></compodoc-menu>
        </div>

        <div class="container-fluid main">
           <div class="row main">
               <div class="d-none d-md-block menu">
                   <compodoc-menu mode="normal"></compodoc-menu>
               </div>
               <!-- START CONTENT -->
               <div class="content class">
                   <div class="content-data">
















<ol class="breadcrumb">
  <li class="breadcrumb-item">Classes</li>
  <li class="breadcrumb-item" >QuadTree</li>
</ol>

<ul class="nav nav-tabs" role="tablist">
        <li class="nav-item">
            <a href="#info" 
                class="nav-link"
                class="nav-link active"
                role="tab" id="info-tab" data-bs-toggle="tab" data-link="info">Info</a>
        </li>
        <li class="nav-item">
            <a href="#source" 
                class="nav-link"
                
                role="tab" id="source-tab" data-bs-toggle="tab" data-link="source">Source</a>
        </li>
</ul>

<div class="tab-content">
    <div class="tab-pane fade active in" id="info">
        <p class="comment">
            <h3>File</h3>
        </p>
        <p class="comment">
            <code>src/app/shared/components/cars-map/cars-map.component.ts</code>
        </p>


            <p class="comment">
                <h3>Description</h3>
            </p>
            <p class="comment">
                <p>Simple QuadTree implementation for spatial indexing</p>

            </p>




            <section data-compodoc="block-index">
    <h3 id="index">Index</h3>
    <table class="table table-sm table-bordered index-table">
        <tbody>
                <tr>
                    <td class="col-md-4">
                        <h6><b>Properties</b></h6>
                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <ul class="index-list">
                            <li>
                                    <span class="modifier">Private</span>
                                <a href="#bounds" >bounds</a>
                            </li>
                            <li>
                                    <span class="modifier">Private</span>
                                <a href="#capacity" >capacity</a>
                            </li>
                            <li>
                                    <span class="modifier">Private</span>
                                <a href="#divided" >divided</a>
                            </li>
                            <li>
                                    <span class="modifier">Private</span>
                                    <span class="modifier">Optional</span>
                                <a href="#northeast" >northeast</a>
                            </li>
                            <li>
                                    <span class="modifier">Private</span>
                                    <span class="modifier">Optional</span>
                                <a href="#northwest" >northwest</a>
                            </li>
                            <li>
                                    <span class="modifier">Private</span>
                                <a href="#points" >points</a>
                            </li>
                            <li>
                                    <span class="modifier">Private</span>
                                    <span class="modifier">Optional</span>
                                <a href="#southeast" >southeast</a>
                            </li>
                            <li>
                                    <span class="modifier">Private</span>
                                    <span class="modifier">Optional</span>
                                <a href="#southwest" >southwest</a>
                            </li>
                        </ul>
                    </td>
                </tr>

                <tr>
                    <td class="col-md-4">
                        <h6><b>Methods</b></h6>
                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <ul class="index-list">
                            <li>
                                    <span class="modifier">Private</span>
                                <a href="#contains" >contains</a>
                            </li>
                            <li>
                                <a href="#insert" >insert</a>
                            </li>
                            <li>
                                    <span class="modifier">Private</span>
                                <a href="#intersects" >intersects</a>
                            </li>
                            <li>
                                    <span class="modifier">Private</span>
                                <a href="#pointInRange" >pointInRange</a>
                            </li>
                            <li>
                                <a href="#query" >query</a>
                            </li>
                            <li>
                                    <span class="modifier">Private</span>
                                <a href="#subdivide" >subdivide</a>
                            </li>
                        </ul>
                    </td>
                </tr>





        </tbody>
    </table>
</section>

            <section data-compodoc="block-constructor">
    <h3 id="constructor">Constructor</h3>
        <table class="table table-sm table-bordered">
            <tbody>
                <tr>
                    <td class="col-md-4">
<code>constructor(bounds: literal type, capacity: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/number" target="_blank">number</a>)</code>
                    </td>
                </tr>
                        <tr>
                            <td class="col-md-4">
                                <div class="io-line">Defined in <a href="" data-line="83" class="link-to-prism">src/app/shared/components/cars-map/cars-map.component.ts:83</a></div>
                            </td>
                        </tr>

                <tr>
                    <td class="col-md-4">
                            <div>
                                    <b>Parameters :</b>
                                    <table class="params">
                                        <thead>
                                            <tr>
                                                <td>Name</td>
                                                    <td>Type</td>
                                                <td>Optional</td>
                                            </tr>
                                        </thead>
                                        <tbody>
                                                <tr>
                                                        <td>bounds</td>
                                                  
                                                        <td>
                                                                    <code>literal type</code>
                                                        </td>
                                                  
                                                    <td>
                                                            No
                                                    </td>
                                                    
                                                </tr>
                                                <tr>
                                                        <td>capacity</td>
                                                  
                                                        <td>
                                                                        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/number" target="_blank" >number</a></code>
                                                        </td>
                                                  
                                                    <td>
                                                            No
                                                    </td>
                                                    
                                                </tr>
                                        </tbody>
                                    </table>
                            </div>
                    </td>
                </tr>
            </tbody>
        </table>
</section>

            <section data-compodoc="block-properties">
    
    <h3 id="inputs">
        Properties
    </h3>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="bounds"></a>
                    <span class="name">
                            <span class="modifier">Private</span>
                        <span ><b>bounds</b></span>
                        <a href="#bounds"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Type : </i>    <code>literal type</code>

                    </td>
                </tr>
                    <tr>
                        <td class="col-md-4">
                                <div class="io-line">Defined in <a href="" data-line="76" class="link-to-prism">src/app/shared/components/cars-map/cars-map.component.ts:76</a></div>
                        </td>
                    </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="capacity"></a>
                    <span class="name">
                            <span class="modifier">Private</span>
                        <span ><b>capacity</b></span>
                        <a href="#capacity"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/number" target="_blank" >number</a></code>

                    </td>
                </tr>
                    <tr>
                        <td class="col-md-4">
                                <div class="io-line">Defined in <a href="" data-line="77" class="link-to-prism">src/app/shared/components/cars-map/cars-map.component.ts:77</a></div>
                        </td>
                    </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="divided"></a>
                    <span class="name">
                            <span class="modifier">Private</span>
                        <span ><b>divided</b></span>
                        <a href="#divided"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Type : </i>    <code>unknown</code>

                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>false</code>
                    </td>
                </tr>
                    <tr>
                        <td class="col-md-4">
                                <div class="io-line">Defined in <a href="" data-line="79" class="link-to-prism">src/app/shared/components/cars-map/cars-map.component.ts:79</a></div>
                        </td>
                    </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="northeast"></a>
                    <span class="name">
                            <span class="modifier">Private</span>
                            <span class="modifier">Optional</span>
                        <span ><b>northeast</b></span>
                        <a href="#northeast"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Type : </i>        <code><a href="../classes/QuadTree.html" target="_self" >QuadTree</a></code>

                    </td>
                </tr>
                    <tr>
                        <td class="col-md-4">
                                <div class="io-line">Defined in <a href="" data-line="80" class="link-to-prism">src/app/shared/components/cars-map/cars-map.component.ts:80</a></div>
                        </td>
                    </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="northwest"></a>
                    <span class="name">
                            <span class="modifier">Private</span>
                            <span class="modifier">Optional</span>
                        <span ><b>northwest</b></span>
                        <a href="#northwest"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Type : </i>        <code><a href="../classes/QuadTree.html" target="_self" >QuadTree</a></code>

                    </td>
                </tr>
                    <tr>
                        <td class="col-md-4">
                                <div class="io-line">Defined in <a href="" data-line="81" class="link-to-prism">src/app/shared/components/cars-map/cars-map.component.ts:81</a></div>
                        </td>
                    </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="points"></a>
                    <span class="name">
                            <span class="modifier">Private</span>
                        <span ><b>points</b></span>
                        <a href="#points"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Type : </i>    <code>CarMapLocation[]</code>

                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>[]</code>
                    </td>
                </tr>
                    <tr>
                        <td class="col-md-4">
                                <div class="io-line">Defined in <a href="" data-line="78" class="link-to-prism">src/app/shared/components/cars-map/cars-map.component.ts:78</a></div>
                        </td>
                    </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="southeast"></a>
                    <span class="name">
                            <span class="modifier">Private</span>
                            <span class="modifier">Optional</span>
                        <span ><b>southeast</b></span>
                        <a href="#southeast"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Type : </i>        <code><a href="../classes/QuadTree.html" target="_self" >QuadTree</a></code>

                    </td>
                </tr>
                    <tr>
                        <td class="col-md-4">
                                <div class="io-line">Defined in <a href="" data-line="82" class="link-to-prism">src/app/shared/components/cars-map/cars-map.component.ts:82</a></div>
                        </td>
                    </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="southwest"></a>
                    <span class="name">
                            <span class="modifier">Private</span>
                            <span class="modifier">Optional</span>
                        <span ><b>southwest</b></span>
                        <a href="#southwest"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Type : </i>        <code><a href="../classes/QuadTree.html" target="_self" >QuadTree</a></code>

                    </td>
                </tr>
                    <tr>
                        <td class="col-md-4">
                                <div class="io-line">Defined in <a href="" data-line="83" class="link-to-prism">src/app/shared/components/cars-map/cars-map.component.ts:83</a></div>
                        </td>
                    </tr>


        </tbody>
    </table>
</section>

            <section data-compodoc="block-methods">
    
    <h3 id="methods">
        Methods
    </h3>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="contains"></a>
                    <span class="name">
                            <span class="modifier">Private</span>
                        <span ><b>contains</b></span>
                        <a href="#contains"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
            <tr>
                <td class="col-md-4">
                        <span class="modifier-icon icon ion-ios-reset"></span>
                    <code>contains(point: <a href="../interfaces/CarMapLocation.html" target="_self">CarMapLocation</a>)</code>
                </td>
            </tr>


                    <tr>
                        <td class="col-md-4">
                            <div class="io-line">Defined in <a href="" data-line="135"
                                    class="link-to-prism">src/app/shared/components/cars-map/cars-map.component.ts:135</a></div>
                        </td>
                    </tr>


            <tr>
                <td class="col-md-4">

                            <div class="io-description">
                                <b>Parameters :</b>
                                
                                <table class="params">
                                    <thead>
                                        <tr>
                                            <td>Name</td>
                                                <td>Type</td>
                                            <td>Optional</td>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr>
                                                <td>point</td>
                                            <td>
                                                            <code><a href="../interfaces/CarMapLocation.html" target="_self" >CarMapLocation</a></code>
                                            </td>

                                            <td>
                                                    No
                                            </td>


                                        </tr>
                                    </tbody>
                                </table>
                            </div>
                        <div class="io-description">
                            <b>Returns : </b>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/boolean" target="_blank" >boolean</a></code>

                        </div>
                            <div class="io-description">
                                
                            </div>
                </td>
            </tr>
        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="insert"></a>
                    <span class="name">
                        <span ><b>insert</b></span>
                        <a href="#insert"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
            <tr>
                <td class="col-md-4">
<code>insert(point: <a href="../interfaces/CarMapLocation.html" target="_self">CarMapLocation</a>)</code>
                </td>
            </tr>


                    <tr>
                        <td class="col-md-4">
                            <div class="io-line">Defined in <a href="" data-line="90"
                                    class="link-to-prism">src/app/shared/components/cars-map/cars-map.component.ts:90</a></div>
                        </td>
                    </tr>


            <tr>
                <td class="col-md-4">

                            <div class="io-description">
                                <b>Parameters :</b>
                                
                                <table class="params">
                                    <thead>
                                        <tr>
                                            <td>Name</td>
                                                <td>Type</td>
                                            <td>Optional</td>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr>
                                                <td>point</td>
                                            <td>
                                                            <code><a href="../interfaces/CarMapLocation.html" target="_self" >CarMapLocation</a></code>
                                            </td>

                                            <td>
                                                    No
                                            </td>


                                        </tr>
                                    </tbody>
                                </table>
                            </div>
                        <div class="io-description">
                            <b>Returns : </b>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/boolean" target="_blank" >boolean</a></code>

                        </div>
                            <div class="io-description">
                                
                            </div>
                </td>
            </tr>
        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="intersects"></a>
                    <span class="name">
                            <span class="modifier">Private</span>
                        <span ><b>intersects</b></span>
                        <a href="#intersects"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
            <tr>
                <td class="col-md-4">
                        <span class="modifier-icon icon ion-ios-reset"></span>
                    <code>intersects(range: literal type)</code>
                </td>
            </tr>


                    <tr>
                        <td class="col-md-4">
                            <div class="io-line">Defined in <a href="" data-line="144"
                                    class="link-to-prism">src/app/shared/components/cars-map/cars-map.component.ts:144</a></div>
                        </td>
                    </tr>


            <tr>
                <td class="col-md-4">

                            <div class="io-description">
                                <b>Parameters :</b>
                                
                                <table class="params">
                                    <thead>
                                        <tr>
                                            <td>Name</td>
                                                <td>Type</td>
                                            <td>Optional</td>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr>
                                                <td>range</td>
                                            <td>
                                                        <code>literal type</code>
                                            </td>

                                            <td>
                                                    No
                                            </td>


                                        </tr>
                                    </tbody>
                                </table>
                            </div>
                        <div class="io-description">
                            <b>Returns : </b>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/boolean" target="_blank" >boolean</a></code>

                        </div>
                            <div class="io-description">
                                
                            </div>
                </td>
            </tr>
        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="pointInRange"></a>
                    <span class="name">
                            <span class="modifier">Private</span>
                        <span ><b>pointInRange</b></span>
                        <a href="#pointInRange"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
            <tr>
                <td class="col-md-4">
                        <span class="modifier-icon icon ion-ios-reset"></span>
                    <code>pointInRange(point: <a href="../interfaces/CarMapLocation.html" target="_self">CarMapLocation</a>, range: literal type)</code>
                </td>
            </tr>


                    <tr>
                        <td class="col-md-4">
                            <div class="io-line">Defined in <a href="" data-line="153"
                                    class="link-to-prism">src/app/shared/components/cars-map/cars-map.component.ts:153</a></div>
                        </td>
                    </tr>


            <tr>
                <td class="col-md-4">

                            <div class="io-description">
                                <b>Parameters :</b>
                                
                                <table class="params">
                                    <thead>
                                        <tr>
                                            <td>Name</td>
                                                <td>Type</td>
                                            <td>Optional</td>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr>
                                                <td>point</td>
                                            <td>
                                                            <code><a href="../interfaces/CarMapLocation.html" target="_self" >CarMapLocation</a></code>
                                            </td>

                                            <td>
                                                    No
                                            </td>


                                        </tr>
                                        <tr>
                                                <td>range</td>
                                            <td>
                                                        <code>literal type</code>
                                            </td>

                                            <td>
                                                    No
                                            </td>


                                        </tr>
                                    </tbody>
                                </table>
                            </div>
                        <div class="io-description">
                            <b>Returns : </b>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/boolean" target="_blank" >boolean</a></code>

                        </div>
                            <div class="io-description">
                                
                            </div>
                </td>
            </tr>
        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="query"></a>
                    <span class="name">
                        <span ><b>query</b></span>
                        <a href="#query"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
            <tr>
                <td class="col-md-4">
<code>query(range: literal type)</code>
                </td>
            </tr>


                    <tr>
                        <td class="col-md-4">
                            <div class="io-line">Defined in <a href="" data-line="112"
                                    class="link-to-prism">src/app/shared/components/cars-map/cars-map.component.ts:112</a></div>
                        </td>
                    </tr>


            <tr>
                <td class="col-md-4">

                            <div class="io-description">
                                <b>Parameters :</b>
                                
                                <table class="params">
                                    <thead>
                                        <tr>
                                            <td>Name</td>
                                                <td>Type</td>
                                            <td>Optional</td>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr>
                                                <td>range</td>
                                            <td>
                                                        <code>literal type</code>
                                            </td>

                                            <td>
                                                    No
                                            </td>


                                        </tr>
                                    </tbody>
                                </table>
                            </div>
                        <div class="io-description">
                            <b>Returns : </b>    <code>CarMapLocation[]</code>

                        </div>
                            <div class="io-description">
                                
                            </div>
                </td>
            </tr>
        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="subdivide"></a>
                    <span class="name">
                            <span class="modifier">Private</span>
                        <span ><b>subdivide</b></span>
                        <a href="#subdivide"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
            <tr>
                <td class="col-md-4">
                        <span class="modifier-icon icon ion-ios-reset"></span>
                    <code>subdivide()</code>
                </td>
            </tr>


                    <tr>
                        <td class="col-md-4">
                            <div class="io-line">Defined in <a href="" data-line="165"
                                    class="link-to-prism">src/app/shared/components/cars-map/cars-map.component.ts:165</a></div>
                        </td>
                    </tr>


            <tr>
                <td class="col-md-4">

                        <div class="io-description">
                            <b>Returns : </b>        <code><a href="https://www.typescriptlang.org/docs/handbook/basic-types.html" target="_blank" >void</a></code>

                        </div>
                </td>
            </tr>
        </tbody>
    </table>
</section>





    </div>


    <div class="tab-pane fade  tab-source-code" id="source">
        <pre class="line-numbers compodoc-sourcecode"><code class="language-typescript">import { CommonModule, isPlatformBrowser } from &#x27;@angular/common&#x27;;
import {
  AfterViewInit,
  ApplicationRef,
  Component,
  ComponentRef,
  computed,
  createComponent,
  ElementRef,
  EnvironmentInjector,
  EventEmitter,
  inject,
  Input,
  OnChanges,
  OnDestroy,
  OnInit,
  Output,
  PLATFORM_ID,
  signal,
  SimpleChanges,
  ViewChild,
  ViewEncapsulation,
} from &#x27;@angular/core&#x27;;
import { environment } from &#x27;../../../../environments/environment&#x27;;
import type { CarMapLocation } from &#x27;../../../core/services/car-locations.service&#x27;;
import { MapboxDirectionsService } from &#x27;../../../core/services/mapbox-directions.service&#x27;;
import { EnhancedMapTooltipComponent } from &#x27;../enhanced-map-tooltip/enhanced-map-tooltip.component&#x27;;
import type { BookingFormData } from &#x27;../map-booking-panel/map-booking-panel.component&#x27;;
import { MapBookingPanelComponent } from &#x27;../map-booking-panel/map-booking-panel.component&#x27;;
import { MapDetailsPanelComponent } from &#x27;../map-details-panel/map-details-panel.component&#x27;;
import {
  MapLayersControlComponent,
  type MapLayer,
} from &#x27;../map-layers-control/map-layers-control.component&#x27;;
import { MapMarkerComponent } from &#x27;../map-marker/map-marker.component&#x27;;

type MapboxGL &#x3D; typeof import(&#x27;mapbox-gl&#x27;).default;
type MapboxMap &#x3D; import(&#x27;mapbox-gl&#x27;).Map;
type MapboxMarker &#x3D; import(&#x27;mapbox-gl&#x27;).Marker;
type MapboxPopup &#x3D; import(&#x27;mapbox-gl&#x27;).Popup;
type MapboxGeoJSONSource &#x3D; import(&#x27;mapbox-gl&#x27;).GeoJSONSource;
type MapLayerMouseEvent &#x3D; import(&#x27;mapbox-gl&#x27;).MapLayerMouseEvent;
type MapboxErrorEvent &#x3D; import(&#x27;mapbox-gl&#x27;).ErrorEvent;
type MapboxGeoJSONFeature &#x3D; import(&#x27;mapbox-gl&#x27;).MapboxGeoJSONFeature;

type MapboxErrorDetails &#x3D; MapboxErrorEvent &amp; {
  status?: number;
  error?: (Error &amp; { status?: number }) | undefined;
};

/**
 * MAPBOX 10K+ CARS OPTIMIZATION
 * &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
 * This component is optimized to handle 10,000+ cars efficiently following Mapbox recommendations.
 *
 * Key optimizations implemented:
 * - Clustering: clusterMaxZoom&#x3D;14, clusterRadius&#x3D;50 (Mapbox recommended)
 * - GeoJSON: maxzoom&#x3D;12, buffer&#x3D;0, tolerance&#x3D;0.375 (optimal for points)
 * - Coordinate precision: 6 decimals (~11cm accuracy) for smaller payload
 * - Feature-state: generateId&#x3D;true for efficient hover/selection updates
 * - Performance: Supercluster handles 400K points at these settings
 *
 * Expected performance with 10K cars:
 * - Initial load: &lt; 2s
 * - Cluster render: &lt; 100ms
 * - 60fps panning/zooming
 * - Memory usage: &lt; 150MB
 *
 * See: docs/guides/performance/MAPBOX_10K_CARS_OPTIMIZATION.md
 */

/**
 * Simple QuadTree implementation for spatial indexing
 */
class QuadTree {
  private bounds: { x: number; y: number; width: number; height: number };
  private capacity: number;
  private points: CarMapLocation[] &#x3D; [];
  private divided &#x3D; false;
  private northeast?: QuadTree;
  private northwest?: QuadTree;
  private southeast?: QuadTree;
  private southwest?: QuadTree;

  constructor(bounds: { x: number; y: number; width: number; height: number }, capacity &#x3D; 4) {
    this.bounds &#x3D; bounds;
    this.capacity &#x3D; capacity;
  }

  insert(point: CarMapLocation): boolean {
    if (!this.contains(point)) {
      return false;
    }

    if (this.points.length &lt; this.capacity) {
      this.points.push(point);
      return true;
    }

    if (!this.divided) {
      this.subdivide();
    }

    return (
      this.northeast!.insert(point) ||
      this.northwest!.insert(point) ||
      this.southeast!.insert(point) ||
      this.southwest!.insert(point)
    );
  }

  query(range: { x: number; y: number; width: number; height: number }): CarMapLocation[] {
    const found: CarMapLocation[] &#x3D; [];

    if (!this.intersects(range)) {
      return found;
    }

    for (const point of this.points) {
      if (this.pointInRange(point, range)) {
        found.push(point);
      }
    }

    if (this.divided) {
      found.push(...this.northeast!.query(range));
      found.push(...this.northwest!.query(range));
      found.push(...this.southeast!.query(range));
      found.push(...this.southwest!.query(range));
    }

    return found;
  }

  private contains(point: CarMapLocation): boolean {
    return (
      point.lng &gt;&#x3D; this.bounds.x &amp;&amp;
      point.lng &lt;&#x3D; this.bounds.x + this.bounds.width &amp;&amp;
      point.lat &gt;&#x3D; this.bounds.y &amp;&amp;
      point.lat &lt;&#x3D; this.bounds.y + this.bounds.height
    );
  }

  private intersects(range: { x: number; y: number; width: number; height: number }): boolean {
    return !(
      range.x &gt; this.bounds.x + this.bounds.width ||
      range.x + range.width &lt; this.bounds.x ||
      range.y &gt; this.bounds.y + this.bounds.height ||
      range.y + range.height &lt; this.bounds.y
    );
  }

  private pointInRange(
    point: CarMapLocation,
    range: { x: number; y: number; width: number; height: number },
  ): boolean {
    return (
      point.lng &gt;&#x3D; range.x &amp;&amp;
      point.lng &lt;&#x3D; range.x + range.width &amp;&amp;
      point.lat &gt;&#x3D; range.y &amp;&amp;
      point.lat &lt;&#x3D; range.y + range.height
    );
  }

  private subdivide(): void {
    const x &#x3D; this.bounds.x;
    const y &#x3D; this.bounds.y;
    const w &#x3D; this.bounds.width / 2;
    const h &#x3D; this.bounds.height / 2;

    this.northeast &#x3D; new QuadTree({ x: x + w, y: y, width: w, height: h }, this.capacity);
    this.northwest &#x3D; new QuadTree({ x, y, width: w, height: h }, this.capacity);
    this.southeast &#x3D; new QuadTree({ x: x + w, y: y + h, width: w, height: h }, this.capacity);
    this.southwest &#x3D; new QuadTree({ x, y: y + h, width: w, height: h }, this.capacity);

    this.divided &#x3D; true;
  }
}

@Component({
  selector: &#x27;app-cars-map&#x27;,
  standalone: true,
  imports: [
    CommonModule,
    MapBookingPanelComponent,
    MapDetailsPanelComponent,
    MapLayersControlComponent,
  ],
  templateUrl: &#x27;./cars-map.component.html&#x27;,
  styleUrls: [&#x27;./cars-map.component.css&#x27;],
  encapsulation: ViewEncapsulation.None,
})
export class CarsMapComponent implements OnInit, AfterViewInit, OnDestroy, OnChanges {
  @ViewChild(&#x27;mapContainer&#x27;) mapContainer!: ElementRef&lt;HTMLDivElement&gt;;

  @Input() cars: CarMapLocation[] &#x3D; [];
  @Input() selectedCarId: string | null &#x3D; null;
  @Input() userLocation: { lat: number; lng: number } | null &#x3D; null;
  @Input() userAvatarUrl: string | null &#x3D; null; // URL del avatar del usuario para el marcador de ubicaci√≥n
  @Input() locationMode: &#x27;searching&#x27; | &#x27;booking-confirmed&#x27; | &#x27;default&#x27; &#x3D; &#x27;default&#x27;;
  @Input() searchRadiusKm: number &#x3D; 5;
  @Input() showSearchRadius: boolean &#x3D; true;
  @Input() showDeliveryIsochrone: boolean &#x3D; false; // Show isochrone for selected car delivery area
  @Input() deliveryTimeMinutes: number &#x3D; 30; // Default delivery time for isochrone
  @Input() showDirectionsRoute: boolean &#x3D; false; // Show turn-by-turn route to selected car
  @Input() followUserLocation: boolean &#x3D; false;
  @Input() lockZoomRotation: boolean &#x3D; false;
  @Input() locationAccuracy?: number; // Precisi√≥n GPS en metros
  @Input() lastLocationUpdate?: Date; // √öltima actualizaci√≥n de ubicaci√≥n
  @Input() markerVariant: &#x27;photo&#x27; | &#x27;price&#x27; &#x3D; &#x27;photo&#x27;; // Change default to &#x27;photo&#x27;

  @Output() readonly carSelected &#x3D; new EventEmitter&lt;string&gt;();
  @Output() readonly userLocationChange &#x3D; new EventEmitter&lt;{ lat: number; lng: number }&gt;();
  @Output() readonly quickBook &#x3D; new EventEmitter&lt;string&gt;();
  @Output() readonly searchRadiusChange &#x3D; new EventEmitter&lt;number&gt;();
  @Output() readonly followLocationToggle &#x3D; new EventEmitter&lt;boolean&gt;();
  @Output() readonly lockToggle &#x3D; new EventEmitter&lt;boolean&gt;();
  @Output() readonly bookingConfirmed &#x3D; new EventEmitter&lt;{
    carId: string;
    bookingData: BookingFormData;
  }&gt;();
  @Output() readonly boundsChange &#x3D; new EventEmitter&lt;{
    north: number;
    south: number;
    east: number;
    west: number;
  }&gt;();

  private readonly platformId &#x3D; inject(PLATFORM_ID);
  private readonly isBrowser &#x3D; isPlatformBrowser(this.platformId);
  private readonly applicationRef &#x3D; inject(ApplicationRef);
  private readonly injector &#x3D; inject(EnvironmentInjector);
  private readonly directionsService &#x3D; inject(MapboxDirectionsService);

  readonly loading &#x3D; signal(true);
  readonly error &#x3D; signal&lt;string | null&gt;(null);
  readonly bookingPanelOpen &#x3D; signal(false);
  readonly selectedCarForBooking &#x3D; signal&lt;CarMapLocation | null&gt;(null);
  readonly selectedCar &#x3D; signal&lt;CarMapLocation | null&gt;(null);
  readonly viewMode &#x3D; signal&lt;&#x27;map&#x27; | &#x27;list&#x27;&gt;(&#x27;map&#x27;);

  // Map Layers Control
  readonly showBaseMap &#x3D; signal(true);
  readonly showUserLocation &#x3D; signal(true);
  readonly showMarketplaceCars &#x3D; signal(true);

  readonly mapLayers &#x3D; computed&lt;MapLayer[]&gt;(() &#x3D;&gt; [
    {
      id: &#x27;base-map&#x27;,
      label: &#x27;Mapa Base&#x27;,
      icon: &#x27;üó∫Ô∏è&#x27;,
      visible: this.showBaseMap(),
      enabled: true,
    },
    {
      id: &#x27;user-location&#x27;,
      label: &#x27;Ubicaci√≥n Central&#x27;,
      icon: &#x27;üìç&#x27;,
      visible: this.showUserLocation(),
      enabled: !!this.userLocation,
    },
    {
      id: &#x27;marketplace-cars&#x27;,
      label: &#x27;Autos del Marketplace&#x27;,
      icon: &#x27;üöó&#x27;,
      visible: this.showMarketplaceCars(),
      enabled: this.cars.length &gt; 0,
    },
  ]);

  // Expose map instance for external components
  get mapInstance(): MapboxMap | null {
    return this.map;
  }

  /**
   * Fly to a specific location
   */
  flyTo(location: { lat: number; lng: number }, zoom &#x3D; 15): void {
    if (this.map) {
      this.map.flyTo({
        center: [location.lng, location.lat],
        zoom,
        essential: true,
      });
    }
  }

  private mapboxgl: MapboxGL | null &#x3D; null;
  private map: MapboxMap | null &#x3D; null;
  private carMarkers &#x3D; new Map&lt;
    string,
    { marker: MapboxMarker; componentRef: ComponentRef&lt;MapMarkerComponent&gt; }
  &gt;();
  private userLocationMarker: MapboxMarker | null &#x3D; null;
  private tooltipPopups &#x3D; new Map&lt;string, MapboxPopup&gt;();
  private tooltipComponents &#x3D; new Map&lt;string, ComponentRef&lt;EnhancedMapTooltipComponent&gt;&gt;();
  private hoverTimeouts &#x3D; new Map&lt;string, ReturnType&lt;typeof setTimeout&gt;&gt;();
  public useClustering &#x3D; true; // Enable clustering by default - public for template access
  private clusterSourceId &#x3D; &#x27;cars-cluster-source&#x27;;
  private clusterLayerId &#x3D; &#x27;cars-cluster-layer&#x27;;
  private clusterCountLayerId &#x3D; &#x27;cars-cluster-count&#x27;;
  // Mapbox optimization: Clustering is efficient for 10K+ cars (Supercluster handles 400K)
  public clusteringThreshold &#x3D; 50; // Activate clustering at 50+ cars - public for template access
  private virtualizationThreshold &#x3D; 1000; // Only virtualize if NOT clustering (10K+ without clustering)
  private viewportBuffer &#x3D; 0.1; // 10% buffer around viewport for smoother experience
  private maxVisibleMarkers &#x3D; 500; // Increased for better 10K+ experience when not clustering
  private visibleCarIds &#x3D; new Set&lt;string&gt;(); // Track currently visible cars
  private pendingUpdate: number | null &#x3D; null; // For debounced updates
  private spatialIndex: QuadTree | null &#x3D; null; // Spatial index for efficient queries

  // Component pools for memory management
  private markerComponentPool: ComponentRef&lt;MapMarkerComponent&gt;[] &#x3D; [];
  private tooltipComponentPool: ComponentRef&lt;EnhancedMapTooltipComponent&gt;[] &#x3D; [];
  private maxPoolSize &#x3D; 100; // Maximum components to keep in pool

  // User location tracking
  private searchRadiusSourceId &#x3D; &#x27;search-radius-source&#x27;;
  private searchRadiusLayerId &#x3D; &#x27;search-radius-layer&#x27;;
  private isochroneSourceId &#x3D; &#x27;delivery-isochrone-source&#x27;;
  private isochroneLayerId &#x3D; &#x27;delivery-isochrone-layer&#x27;;
  private isochroneOutlineLayerId &#x3D; &#x27;delivery-isochrone-outline-layer&#x27;;
  private routeSourceId &#x3D; &#x27;directions-route-source&#x27;;
  private routeLayerId &#x3D; &#x27;directions-route-layer&#x27;;
  private routeOutlineLayerId &#x3D; &#x27;directions-route-outline-layer&#x27;;
  private followLocationInterval: ReturnType&lt;typeof setInterval&gt; | null &#x3D; null;
  private isDarkMode &#x3D; signal(false);
  private circleSizeMultiplier &#x3D; signal(1.0); // Para ajustar tama√±o del c√≠rculo

  ngOnInit(): void {
    if (!this.isBrowser) {
      this.loading.set(false);
      return;
    }

    // Detectar modo oscuro
    this.detectDarkMode();

    // Escuchar cambios de tema
    if (this.isBrowser) {
      const mediaQuery &#x3D; window.matchMedia(&#x27;(prefers-color-scheme: dark)&#x27;);
      mediaQuery.addEventListener(&#x27;change&#x27;, () &#x3D;&gt; this.detectDarkMode());
    }
  }

  private detectDarkMode(): void {
    if (!this.isBrowser) return;
    const isDark &#x3D;
      window.matchMedia(&#x27;(prefers-color-scheme: dark)&#x27;).matches ||
      document.documentElement.classList.contains(&#x27;dark&#x27;);
    this.isDarkMode.set(isDark);
    this.updateMarkerStyles();
    this.updateMapTheme();
  }

  /**
   * Helper to get CSS variable value
   */
  private getCssVariableValue(variableName: string, defaultValue: string): string {
    if (!this.isBrowser) return defaultValue;
    return (
      getComputedStyle(document.documentElement).getPropertyValue(variableName).trim() ||
      defaultValue
    );
  }

  /**
   * Get light preset based on current time of day
   * Returns: &#x27;dawn&#x27;, &#x27;day&#x27;, &#x27;dusk&#x27;, or &#x27;night&#x27;
   */
  private getTimeBasedLightPreset(): &#x27;dawn&#x27; | &#x27;day&#x27; | &#x27;dusk&#x27; | &#x27;night&#x27; {
    const hour &#x3D; new Date().getHours();

    if (hour &gt;&#x3D; 6 &amp;&amp; hour &lt; 11) return &#x27;dawn&#x27;; // 6am - 11am: Amanecer
    if (hour &gt;&#x3D; 11 &amp;&amp; hour &lt; 18) return &#x27;day&#x27;; // 11am - 6pm: D√≠a
    if (hour &gt;&#x3D; 18 &amp;&amp; hour &lt; 21) return &#x27;dusk&#x27;; // 6pm - 9pm: Atardecer
    return &#x27;night&#x27;; // 9pm - 6am: Noche
  }

  /**
   * Update map theme based on time of day and marker variant
   * Uses Mapbox Standard style configuration for native theme support
   */
  private updateMapTheme(): void {
    if (!this.isBrowser) return;

    const lightPreset &#x3D; this.getTimeBasedLightPreset();
    const variant &#x3D; this.markerVariant;

    // Update Mapbox Standard style theme
    if (this.map &amp;&amp; this.map.isStyleLoaded()) {
      try {
        this.map.setConfigProperty(&#x27;basemap&#x27;, &#x27;lightPreset&#x27;, lightPreset);

        // No need for canvas filters with Standard style - it handles theming natively
      } catch (error) {
        console.warn(&#x27;[CarsMap] Could not update theme, falling back to canvas filter&#x27;, error);
        // Fallback for older Mapbox versions or non-Standard styles
        const canvas &#x3D; this.map.getCanvas();
        if (canvas) {
          const isDark &#x3D; lightPreset &#x3D;&#x3D;&#x3D; &#x27;night&#x27; || lightPreset &#x3D;&#x3D;&#x3D; &#x27;dusk&#x27;;
          const brightness &#x3D; isDark ? &#x27;0.95&#x27; : &#x27;1&#x27;;
          const contrast &#x3D; isDark ? &#x27;1.1&#x27; : &#x27;1&#x27;;
          const saturate &#x3D; isDark ? &#x27;0.95&#x27; : &#x27;1&#x27;;
          canvas.style.filter &#x3D; &#x60;brightness(${brightness}) contrast(${contrast}) saturate(${saturate})&#x60;;
        }
      }
    }

    // Ensure container has correct classes (template binding handles this, but we verify)
    const container &#x3D; this.mapContainer?.nativeElement?.parentElement;
    if (container) {
      // Remove old variant classes
      container.classList.remove(&#x27;map-variant-photo&#x27;, &#x27;map-variant-price&#x27;);
      // Add current variant class
      container.classList.add(&#x60;map-variant-${variant}&#x60;);

      // Apply dark mode class for night/dusk themes
      const isDark &#x3D; lightPreset &#x3D;&#x3D;&#x3D; &#x27;night&#x27; || lightPreset &#x3D;&#x3D;&#x3D; &#x27;dusk&#x27;;
      if (isDark) {
        container.classList.add(&#x27;dark&#x27;);
      } else {
        container.classList.remove(&#x27;dark&#x27;);
      }
    }
  }

  async ngAfterViewInit(): Promise&lt;void&gt; {
    if (!this.isBrowser || !this.mapContainer) {
      return;
    }

    await this.initializeMap();
  }

  ngOnDestroy(): void {
    this.cleanup();
  }

  /**
   * Initialize Mapbox map with neutral light style
   */
  private async initializeMap(): Promise&lt;void&gt; {
    try {
      this.loading.set(true);

      // Lazy load Mapbox GL
      const mapboxModule &#x3D; await import(&#x27;mapbox-gl&#x27;);
      this.mapboxgl &#x3D; mapboxModule.default;

      if (!this.mapboxgl) {
        throw new Error(&#x27;Mapbox GL library failed to load&#x27;);
      }

      // Validate Mapbox access token
      if (!environment.mapboxAccessToken || environment.mapboxAccessToken.trim() &#x3D;&#x3D;&#x3D; &#x27;&#x27;) {
        throw new Error(
          &#x27;Mapbox access token no configurado. Por favor, configura NG_APP_MAPBOX_ACCESS_TOKEN en .env.local&#x27;,
        );
      }

      // Validate token format (should start with &#x27;pk.&#x27;)
      if (!environment.mapboxAccessToken.startsWith(&#x27;pk.&#x27;)) {
        throw new Error(
          &#x27;Token de Mapbox inv√°lido. El token debe comenzar con &quot;pk.&quot; y ser un Public Access Token v√°lido.&#x27;,
        );
      }

      this.mapboxgl.accessToken &#x3D; environment.mapboxAccessToken;

      // Get initial light preset based on current time
      const initialLightPreset &#x3D; this.getTimeBasedLightPreset();

      // Initialize map with Mapbox Standard style (v12+ with theme support)
      this.map &#x3D; new this.mapboxgl.Map({
        container: this.mapContainer.nativeElement,
        style: &#x27;mapbox://styles/mapbox/standard&#x27;, // Modern Standard style with theme support
        center: [-58.3816, -34.6037], // Buenos Aires center
        zoom: 15.5, // Higher zoom to show 3D buildings immediately
        maxBounds: [
          [-58.8, -34.9], // Southwest
          [-57.9, -34.3], // Northeast
        ],
        // Mapbox Standard configuration - OPTIMIZED for car marketplace
        config: {
          basemap: {
            lightPreset: initialLightPreset, // Auto-detect based on time: &#x27;day&#x27;, &#x27;dusk&#x27;, &#x27;dawn&#x27;, &#x27;night&#x27;
            showPointOfInterestLabels: false, // Hide restaurants, hotels, shops (performance + cleaner)
            showTransitLabels: false, // Hide transit for cleaner car-focused map
            showPlaceLabels: true, // Keep neighborhood/area names
            showRoadLabels: true, // Keep street names (essential for car location)
            show3dObjects: true, // Enable 3D buildings for immersive marketplace view
          },
        },
        // 3D View Configuration - User controlled
        pitch: 60, // Deep 3D perspective view (60¬∞ angle for immersive effect)
        bearing: 0, // North-up orientation (user can rotate)
        antialias: true, // Enable antialiasing for smooth 3D buildings
        // Enable 3D interactions - full user control
        dragRotate: true, // Enable rotation drag
        pitchWithRotate: true, // Enable pitch on rotate
        touchPitch: true, // Enable touch pitch gestures
      });

      // Add navigation controls (zoom + compass for full 3D control)
      this.map.addControl(new this.mapboxgl.NavigationControl(), &#x27;top-right&#x27;);

      // Wait for map to load
      this.map.on(&#x27;load&#x27;, () &#x3D;&gt; {
        this.loading.set(false);
        this.updateMapTheme(); // Apply theme on load
        this.updateMarkersBasedOnCount();
        this.setupViewportChangeListener();
        this.addUserLocationMarker();
        if (this.showSearchRadius) {
          this.addSearchRadiusLayer();
        }
        this.setupFollowLocation();
        this.setupLockControls();

        // Emit initial bounds
        this.emitBounds();

        // Listen for move end to emit bounds
        this.map.on(&#x27;moveend&#x27;, () &#x3D;&gt; {
          this.emitBounds();
        });

        // Pre-warm component pool during idle time for better performance
        this.preWarmComponentPoolDuringIdle();
      });

      // Handle map errors
      this.map.on(&#x27;error&#x27;, (event: MapboxErrorDetails) &#x3D;&gt; {
        console.error(&#x27;[CarsMap] Map error:&#x27;, event);

        const errorStatus &#x3D;
          (event.error &amp;&amp; &#x27;status&#x27; in event.error ? event.error.status : undefined) ?? event.status;
        const errorMessage &#x3D;
          (event.error &amp;&amp; event.error.message) || (&#x27;message&#x27; in event ? event.message : &#x27;&#x27;);

        if (
          errorStatus &#x3D;&#x3D;&#x3D; 401 ||
          (typeof errorMessage &#x3D;&#x3D;&#x3D; &#x27;string&#x27; &amp;&amp; errorMessage.includes(&#x27;401&#x27;))
        ) {
          this.error.set(
            &#x27;Token de Mapbox inv√°lido o expirado. Por favor, verifica tu NG_APP_MAPBOX_ACCESS_TOKEN en .env.local&#x27;,
          );
        } else if (event.error?.message) {
          this.error.set(&#x60;Error al cargar el mapa: ${event.error.message}&#x60;);
        } else {
          this.error.set(
            &#x27;Error al cargar el mapa. Por favor, verifica tu conexi√≥n e intenta nuevamente.&#x27;,
          );
        }

        this.loading.set(false);
      });
    } catch (err) {
      console.error(&#x27;[CarsMap] Initialization error:&#x27;, err);
      this.error.set(err instanceof Error ? err.message : &#x27;Error al inicializar el mapa&#x27;);
      this.loading.set(false);
    }
  }

  /**
   * Setup clustering for car markers
   * Optimized for 10,000+ cars following Mapbox recommendations
   */
  private setupClustering(): void {
    if (!this.map || !this.mapboxgl) return;

    // Remove existing markers
    this.clearMarkers();

    // Create GeoJSON source from cars with optimized coordinate precision
    const features &#x3D; this.cars.map((car) &#x3D;&gt; ({
      type: &#x27;Feature&#x27; as const,
      geometry: {
        type: &#x27;Point&#x27; as const,
        // Limit to 6 decimal places (~11cm accuracy) for smaller payload
        coordinates: [parseFloat(car.lng.toFixed(6)), parseFloat(car.lat.toFixed(6))],
      },
      properties: {
        carId: car.carId,
        title: car.title,
        pricePerDay: car.pricePerDay,
        currency: car.currency || &#x27;ARS&#x27;,
        photoUrl: car.photoUrl,
        availabilityStatus: car.availabilityStatus || &#x27;available&#x27;,
      },
    }));

    // Add source with Mapbox-recommended optimizations
    const existingClusterSource &#x3D; this.map.getSource(this.clusterSourceId) as
      | MapboxGeoJSONSource
      | undefined;

    if (existingClusterSource) {
      existingClusterSource.setData({
        type: &#x27;FeatureCollection&#x27;,
        features,
      });
    } else {
      this.map.addSource(this.clusterSourceId, {
        type: &#x27;geojson&#x27;,
        data: {
          type: &#x27;FeatureCollection&#x27;,
          features,
        },
        cluster: true,
        // Mapbox recommendation for 10K+ points
        clusterMaxZoom: 14, // Don&#x27;t cluster beyond zoom 14
        clusterRadius: 50, // 50px radius for optimal clustering
        clusterProperties: {
          sum: [&#x27;+&#x27;, [&#x27;get&#x27;, &#x27;pricePerDay&#x27;]],
          count: [&#x27;+&#x27;, 1],
        },
        // GeoJSON optimization for points (Mapbox recommendation)
        maxzoom: 12, // Limit tile generation to zoom 12 for points
        buffer: 0, // No buffer needed for simple points
        tolerance: 0.375, // Balance precision vs performance
        generateId: true, // Enable efficient feature-state updates
      });
    }

    // Resolve colors from CSS variables
    const colorAvailable &#x3D; this.getCssVariableValue(&#x27;--map-marker-available-color&#x27;, &#x27;#9db38b&#x27;); // Olive
    const colorSoon &#x3D; this.getCssVariableValue(&#x27;--map-marker-soon-available-color&#x27;, &#x27;#c4a882&#x27;); // Beige
    const colorInUse &#x3D; this.getCssVariableValue(&#x27;--map-marker-in-use-color&#x27;, &#x27;#4e4e4e&#x27;); // Gray
    const colorUnavailable &#x3D; this.getCssVariableValue(&#x27;--map-marker-unavailable-color&#x27;, &#x27;#b25e5e&#x27;); // Rust

    // Add cluster circles layer
    if (!this.map.getLayer(this.clusterLayerId)) {
      this.map.addLayer({
        id: this.clusterLayerId,
        type: &#x27;circle&#x27;,
        source: this.clusterSourceId,
        filter: [&#x27;has&#x27;, &#x27;point_count&#x27;],
        paint: {
          &#x27;circle-color&#x27;: [
            &#x27;step&#x27;,
            [&#x27;get&#x27;, &#x27;point_count&#x27;],
            colorAvailable, // Green for available
            5,
            colorSoon, // Amber for medium clusters
            20,
            colorInUse, // Neutral/Blue for large clusters
          ],
          &#x27;circle-radius&#x27;: [&#x27;step&#x27;, [&#x27;get&#x27;, &#x27;point_count&#x27;], 20, 5, 30, 20, 40, 50, 50],
          &#x27;circle-stroke-width&#x27;: 2,
          &#x27;circle-stroke-color&#x27;: &#x27;var(--surface-primary, #ffffff)&#x27;,
          &#x27;circle-opacity&#x27;: 0.8,
        },
      });
    }

    // Add cluster count labels
    if (!this.map.getLayer(this.clusterCountLayerId)) {
      this.map.addLayer({
        id: this.clusterCountLayerId,
        type: &#x27;symbol&#x27;,
        source: this.clusterSourceId,
        filter: [&#x27;has&#x27;, &#x27;point_count&#x27;],
        layout: {
          &#x27;text-field&#x27;: &#x27;{point_count_abbreviated}&#x27;,
          &#x27;text-font&#x27;: [&#x27;Open Sans Semibold&#x27;, &#x27;Arial Unicode MS Bold&#x27;],
          &#x27;text-size&#x27;: 12,
        },
        paint: {
          &#x27;text-color&#x27;: &#x27;var(--surface-primary, #ffffff)&#x27;,
        },
      });
    }

    // Add unclustered points (individual cars)
    if (!this.map.getLayer(&#x27;cars-unclustered&#x27;)) {
      this.map.addLayer({
        id: &#x27;cars-unclustered&#x27;,
        type: &#x27;circle&#x27;,
        source: this.clusterSourceId,
        filter: [&#x27;!&#x27;, [&#x27;has&#x27;, &#x27;point_count&#x27;]],
        paint: {
          &#x27;circle-color&#x27;: [
            &#x27;case&#x27;,
            [&#x27;&#x3D;&#x3D;&#x27;, [&#x27;get&#x27;, &#x27;availabilityStatus&#x27;], &#x27;available&#x27;],
            colorAvailable,
            [&#x27;&#x3D;&#x3D;&#x27;, [&#x27;get&#x27;, &#x27;availabilityStatus&#x27;], &#x27;soon_available&#x27;],
            colorSoon,
            [&#x27;&#x3D;&#x3D;&#x27;, [&#x27;get&#x27;, &#x27;availabilityStatus&#x27;], &#x27;in_use&#x27;],
            colorInUse,
            colorUnavailable, // unavailable
          ],
          &#x27;circle-radius&#x27;: 8,
          &#x27;circle-stroke-width&#x27;: 2,
          &#x27;circle-stroke-color&#x27;: &#x27;var(--surface-primary, #ffffff)&#x27;,
          &#x27;circle-opacity&#x27;: [&#x27;case&#x27;, [&#x27;&#x3D;&#x3D;&#x27;, [&#x27;get&#x27;, &#x27;availabilityStatus&#x27;], &#x27;unavailable&#x27;], 0.5, 1],
        },
      });
    }

    // Handle cluster clicks
    this.map.on(&#x27;click&#x27;, this.clusterLayerId, (event: MapLayerMouseEvent) &#x3D;&gt; {
      if (!this.map) return;

      const features &#x3D; this.map.queryRenderedFeatures(event.point, {
        layers: [this.clusterLayerId],
      }) as MapboxGeoJSONFeature[];

      if (!features.length) {
        return;
      }

      const properties &#x3D; (features[0].properties || {}) as Record&lt;string, unknown&gt;;
      const clusterId &#x3D;
        typeof properties.cluster_id &#x3D;&#x3D;&#x3D; &#x27;number&#x27; ? (properties.cluster_id as number) : undefined;

      if (clusterId &#x3D;&#x3D;&#x3D; undefined) {
        return;
      }

      const source &#x3D; this.map.getSource(this.clusterSourceId) as MapboxGeoJSONSource | undefined;
      if (!source) {
        return;
      }

      source.getClusterExpansionZoom(clusterId, (err, zoom) &#x3D;&gt; {
        if (err || zoom &#x3D;&#x3D;&#x3D; null || zoom &#x3D;&#x3D;&#x3D; undefined) return;
        this.map?.easeTo({
          center: event.lngLat,
          zoom,
        });
      });
    });

    // Handle individual car clicks
    this.map.on(&#x27;click&#x27;, &#x27;cars-unclustered&#x27;, (event: MapLayerMouseEvent) &#x3D;&gt; {
      const carFeature &#x3D; event.features?.[0] as MapboxGeoJSONFeature | undefined;
      const properties &#x3D; (carFeature?.properties || {}) as Record&lt;string, unknown&gt;;
      const carId &#x3D; typeof properties.carId &#x3D;&#x3D;&#x3D; &#x27;string&#x27; ? (properties.carId as string) : undefined;
      if (carId) {
        this.carSelected.emit(carId);
        const car &#x3D; this.cars.find((c) &#x3D;&gt; c.carId &#x3D;&#x3D;&#x3D; carId);
        if (car) {
          this.selectedCar.set(car);
        }
      }
    });

    // Change cursor on hover
    this.map.on(&#x27;mouseenter&#x27;, this.clusterLayerId, () &#x3D;&gt; {
      if (this.map) {
        this.map.getCanvas().style.cursor &#x3D; &#x27;pointer&#x27;;
      }
    });
    this.map.on(&#x27;mouseleave&#x27;, this.clusterLayerId, () &#x3D;&gt; {
      if (this.map) {
        this.map.getCanvas().style.cursor &#x3D; &#x27;&#x27;;
      }
    });
  }

  /**
   * Get adaptive cluster max zoom based on car count
   * Optimized for 10K+ cars following Mapbox benchmarks
   * Mapbox recommendation: clusterMaxZoom: 14 is optimal for most datasets
   * Note: We use fixed value of 14 as recommended, keeping this method for backward compatibility
   */
  private getAdaptiveClusterMaxZoom(): number {
    // Mapbox recommendation: Always use 14 for points datasets
    // Supercluster can handle 400K points efficiently at this setting
    return 14;
  }

  /**
   * Get adaptive cluster radius based on car count
   * Mapbox recommendation: clusterRadius: 50 is optimal balance
   * Note: We use fixed value of 50 as recommended, keeping this method for backward compatibility
   */
  private getAdaptiveClusterRadius(): number {
    // Mapbox recommendation: 50px radius provides optimal clustering
    // This works well from 100 to 400,000 points
    return 50;
  }

  /**
   * Update markers based on car count - clustering, virtualization, or normal render
   */
  private updateMarkersBasedOnCount(): void {
    if (!this.map) return;

    const carCount &#x3D; this.cars.length;

    // Ensure spatial index is built for large datasets
    if (carCount &gt;&#x3D; this.virtualizationThreshold &amp;&amp; !this.spatialIndex) {
      this.buildSpatialIndex();
    }

    if (this.useClustering &amp;&amp; carCount &gt; this.clusteringThreshold) {
      this.setupClustering();
    } else if (carCount &gt; this.virtualizationThreshold) {
      this.renderVirtualizedMarkers();
    } else {
      this.renderCarMarkers();
    }
  }

  /**
   * Schedule a debounced update using requestAnimationFrame
   */
  private scheduleDebouncedUpdate(callback: () &#x3D;&gt; void): void {
    if (this.pendingUpdate) {
      cancelAnimationFrame(this.pendingUpdate);
    }

    this.pendingUpdate &#x3D; requestAnimationFrame(() &#x3D;&gt; {
      callback();
      this.pendingUpdate &#x3D; null;
    });
  }

  /**
   * Build spatial index for efficient queries
   */
  private buildSpatialIndex(): void {
    if (this.cars.length &lt; this.virtualizationThreshold) {
      this.spatialIndex &#x3D; null;
      return;
    }

    // Calculate bounds for the QuadTree (covering all cars with padding)
    let minLng &#x3D; Infinity,
      maxLng &#x3D; -Infinity;
    let minLat &#x3D; Infinity,
      maxLat &#x3D; -Infinity;

    for (const car of this.cars) {
      minLng &#x3D; Math.min(minLng, car.lng);
      maxLng &#x3D; Math.max(maxLng, car.lng);
      minLat &#x3D; Math.min(minLat, car.lat);
      maxLat &#x3D; Math.max(maxLat, car.lat);
    }

    // Add padding
    const padding &#x3D; 0.01; // ~1km padding
    minLng -&#x3D; padding;
    maxLng +&#x3D; padding;
    minLat -&#x3D; padding;
    maxLat +&#x3D; padding;

    this.spatialIndex &#x3D; new QuadTree(
      {
        x: minLng,
        y: minLat,
        width: maxLng - minLng,
        height: maxLat - minLat,
      },
      8,
    );

    for (const car of this.cars) {
      this.spatialIndex.insert(car);
    }
  }

  /**
   * Emit current map bounds
   */
  private emitBounds(): void {
    if (!this.map) return;

    const bounds &#x3D; this.map.getBounds();
    this.boundsChange.emit({
      north: bounds.getNorth(),
      south: bounds.getSouth(),
      east: bounds.getEast(),
      west: bounds.getWest(),
    });
  }

  /**
   * Update spatial index when cars change
   */
  private updateSpatialIndex(): void {
    this.buildSpatialIndex();
  }

  /**
   * Pre-warm component pool during idle time using requestIdleCallback
   * Creates 50 components progressively to avoid blocking main thread
   */
  private preWarmComponentPoolDuringIdle(): void {
    // Only pre-warm if pool is small
    if (this.markerComponentPool.length &gt; 50) {
      return;
    }

    const targetPoolSize &#x3D; 100;
    const componentsPerBatch &#x3D; 5; // Create 5 at a time

    const createBatch &#x3D; () &#x3D;&gt; {
      if (this.markerComponentPool.length &gt;&#x3D; targetPoolSize) {
        return; // Done warming
      }

      // Create a batch during idle time
      for (
        let i &#x3D; 0;
        i &lt; componentsPerBatch &amp;&amp; this.markerComponentPool.length &lt; targetPoolSize;
        i++
      ) {
        const newComponentRef &#x3D; createComponent(MapMarkerComponent, {
          environmentInjector: this.injector,
        });

        this.applicationRef.attachView(newComponentRef.hostView);

        // Hide the element
        const element &#x3D; newComponentRef.location.nativeElement as HTMLElement;
        if (element) {
          element.style.display &#x3D; &#x27;none&#x27;;
        }

        this.markerComponentPool.push(newComponentRef);
      }

      // Schedule next batch if needed
      if (this.markerComponentPool.length &lt; targetPoolSize) {
        if (&#x27;requestIdleCallback&#x27; in window) {
          // Modern browsers with requestIdleCallback
          requestIdleCallback(() &#x3D;&gt; createBatch(), { timeout: 2000 });
        } else {
          // Fallback for older browsers
          setTimeout(() &#x3D;&gt; createBatch(), 100);
        }
      }
    };

    // Start warming with requestIdleCallback if available
    if (&#x27;requestIdleCallback&#x27; in window) {
      requestIdleCallback(() &#x3D;&gt; createBatch(), { timeout: 1000 });
    } else {
      // Fallback for older browsers
      setTimeout(() &#x3D;&gt; createBatch(), 500);
    }
  }

  /**
   * Get a marker component from pool or create new one
   */
  private getMarkerComponentFromPool(): ComponentRef&lt;MapMarkerComponent&gt; {
    const componentRef &#x3D; this.markerComponentPool.pop();
    if (componentRef) {
      return componentRef;
    }

    // Create new component if pool is empty
    const newComponentRef &#x3D; createComponent(MapMarkerComponent, {
      environmentInjector: this.injector,
    });

    // Attach to application
    this.applicationRef.attachView(newComponentRef.hostView);

    return newComponentRef;
  }

  /**
   * Return marker component to pool for reuse
   */
  private returnMarkerComponentToPool(componentRef: ComponentRef&lt;MapMarkerComponent&gt;): void {
    if (this.markerComponentPool.length &lt; this.maxPoolSize) {
      // Reset component state before pooling
      componentRef.setInput(&#x27;car&#x27;, null);
      componentRef.setInput(&#x27;isSelected&#x27;, false);

      // Hide the element
      const element &#x3D; componentRef.location.nativeElement as HTMLElement;
      if (element) {
        element.style.display &#x3D; &#x27;none&#x27;;
      }

      this.markerComponentPool.push(componentRef);
    } else {
      // Pool is full, destroy component
      this.applicationRef.detachView(componentRef.hostView);
      componentRef.destroy();
    }
  }

  /**
   * Get a tooltip component from pool or create new one
   */
  private getTooltipComponentFromPool(): ComponentRef&lt;EnhancedMapTooltipComponent&gt; {
    const componentRef &#x3D; this.tooltipComponentPool.pop();
    if (componentRef) {
      return componentRef;
    }

    // Create new component if pool is empty
    const newComponentRef &#x3D; createComponent(EnhancedMapTooltipComponent, {
      environmentInjector: this.injector,
    });

    // Attach to application
    this.applicationRef.attachView(newComponentRef.hostView);

    return newComponentRef;
  }

  /**
   * Return tooltip component to pool for reuse
   */
  private returnTooltipComponentToPool(
    componentRef: ComponentRef&lt;EnhancedMapTooltipComponent&gt;,
  ): void {
    if (this.tooltipComponentPool.length &lt; this.maxPoolSize) {
      // Reset component state before pooling
      componentRef.setInput(&#x27;car&#x27;, null);
      componentRef.setInput(&#x27;selected&#x27;, false);
      componentRef.setInput(&#x27;userLocation&#x27;, undefined);

      // Clear event subscriptions
      if (componentRef.instance.viewDetails) {
        componentRef.instance.viewDetails.unsubscribe();
      }
      if (componentRef.instance.quickBook) {
        componentRef.instance.quickBook.unsubscribe();
      }

      // Hide the element
      const element &#x3D; componentRef.location.nativeElement as HTMLElement;
      if (element) {
        element.style.display &#x3D; &#x27;none&#x27;;
      }

      this.tooltipComponentPool.push(componentRef);
    } else {
      // Pool is full, destroy component
      this.applicationRef.detachView(componentRef.hostView);
      componentRef.destroy();
    }
  }

  /**
   * Clear component pools (called during cleanup)
   */
  private clearComponentPools(): void {
    // Destroy all pooled marker components
    this.markerComponentPool.forEach((componentRef) &#x3D;&gt; {
      this.applicationRef.detachView(componentRef.hostView);
      componentRef.destroy();
    });
    this.markerComponentPool &#x3D; [];

    // Destroy all pooled tooltip components
    this.tooltipComponentPool.forEach((componentRef) &#x3D;&gt; {
      this.applicationRef.detachView(componentRef.hostView);
      componentRef.destroy();
    });
    this.tooltipComponentPool &#x3D; [];
  }

  /**
   * Setup listener for viewport changes to update virtualized markers
   */
  private setupViewportChangeListener(): void {
    if (!this.map) return;

    // Use requestAnimationFrame with cooldown to prevent excessive updates
    let animationFrameId: number;
    let lastUpdateTime &#x3D; 0;
    const cooldownMs &#x3D; 300; // Wait at least 300ms between updates
    const throttledUpdate &#x3D; () &#x3D;&gt; {
      const now &#x3D; Date.now();
      if (now - lastUpdateTime &lt; cooldownMs) {
        // Skip if within cooldown period
        return;
      }

      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
      }

      animationFrameId &#x3D; requestAnimationFrame(() &#x3D;&gt; {
        if (this.cars.length &gt; this.virtualizationThreshold &amp;&amp; !this.useClustering) {
          lastUpdateTime &#x3D; Date.now();
          this.updateVirtualizedMarkers();
        }
        animationFrameId &#x3D; 0;
      });
    };

    this.map.on(&#x27;moveend&#x27;, throttledUpdate);
    this.map.on(&#x27;zoomend&#x27;, throttledUpdate);
  }

  /**
   * Render only visible markers within viewport + buffer
   */
  private renderVirtualizedMarkers(): void {
    if (!this.map) return;

    // Clear existing markers
    this.clearMarkers();

    // Get visible cars in current viewport
    const visibleCars &#x3D; this.getVisibleCarsInViewport();

    // Limit to max visible markers
    const carsToRender &#x3D; visibleCars.slice(0, this.maxVisibleMarkers);

    // Update visible car IDs
    this.visibleCarIds &#x3D; new Set(carsToRender.map((car) &#x3D;&gt; car.carId));

    // Render markers for visible cars
    carsToRender.forEach((car) &#x3D;&gt; {
      const markerData &#x3D; this.createCarMarker(car);
      if (markerData) {
        this.carMarkers.set(car.carId, markerData);
      }
    });

    // Highlight selected car if it&#x27;s visible
    if (this.selectedCarId &amp;&amp; this.visibleCarIds.has(this.selectedCarId)) {
      this.highlightSelectedCar(this.selectedCarId);
    }
  }

  /**
   * Update virtualized markers when viewport changes
   */
  private updateVirtualizedMarkers(): void {
    if (!this.map) return;

    const newVisibleCars &#x3D; this.getVisibleCarsInViewport();
    const newVisibleCarIds &#x3D; new Set(newVisibleCars.map((car) &#x3D;&gt; car.carId));

    // Find cars that are no longer visible (need to be removed)
    const carsToRemove &#x3D; Array.from(this.visibleCarIds).filter((id) &#x3D;&gt; !newVisibleCarIds.has(id));

    // Find cars that are newly visible (need to be added)
    const carsToAdd &#x3D; newVisibleCars.filter((car) &#x3D;&gt; !this.visibleCarIds.has(car.carId));

    // Remove markers for cars that are no longer visible
    carsToRemove.forEach((carId) &#x3D;&gt; {
      const markerData &#x3D; this.carMarkers.get(carId);
      if (markerData) {
        markerData.marker.remove();
        this.returnMarkerComponentToPool(markerData.componentRef);
        this.carMarkers.delete(carId);
      }
    });

    // Add markers for newly visible cars (limited by maxVisibleMarkers)
    const currentVisibleCount &#x3D; this.carMarkers.size;
    const availableSlots &#x3D; Math.max(0, this.maxVisibleMarkers - currentVisibleCount);
    const carsToAddLimited &#x3D; carsToAdd.slice(0, availableSlots);

    carsToAddLimited.forEach((car) &#x3D;&gt; {
      const markerData &#x3D; this.createCarMarker(car);
      if (markerData) {
        this.carMarkers.set(car.carId, markerData);
      }
    });

    // Update visible car IDs
    this.visibleCarIds &#x3D; new Set([
      ...Array.from(this.visibleCarIds).filter((id) &#x3D;&gt; !carsToRemove.includes(id)),
      ...carsToAddLimited.map((car) &#x3D;&gt; car.carId),
    ]);

    // Update selected car highlight if needed
    if (this.selectedCarId) {
      if (this.visibleCarIds.has(this.selectedCarId)) {
        this.highlightSelectedCar(this.selectedCarId);
      } else {
        this.removeHighlightFromCar(this.selectedCarId);
      }
    }
  }

  /**
   * Get cars visible in current viewport with buffer
   */
  private getVisibleCarsInViewport(): CarMapLocation[] {
    if (!this.map) return [];

    const bounds &#x3D; this.map.getBounds();
    if (!bounds) return [];

    const zoom &#x3D; this.map.getZoom();

    // Expand bounds with buffer for smoother experience
    const latDiff &#x3D; (bounds.getNorth() - bounds.getSouth()) * this.viewportBuffer;
    const lngDiff &#x3D; (bounds.getEast() - bounds.getWest()) * this.viewportBuffer;

    const expandedBounds &#x3D; {
      north: bounds.getNorth() + latDiff,
      south: bounds.getSouth() - latDiff,
      east: bounds.getEast() + lngDiff,
      west: bounds.getWest() - lngDiff,
    };

    let visibleCars: CarMapLocation[];

    // Use spatial index for large datasets, fallback to linear search
    if (this.spatialIndex &amp;&amp; this.cars.length &gt;&#x3D; this.virtualizationThreshold) {
      const queryBounds &#x3D; {
        x: expandedBounds.west,
        y: expandedBounds.south,
        width: expandedBounds.east - expandedBounds.west,
        height: expandedBounds.north - expandedBounds.south,
      };

      visibleCars &#x3D; this.spatialIndex.query(queryBounds);
    } else {
      // Fallback to linear search for smaller datasets
      visibleCars &#x3D; this.cars.filter((car) &#x3D;&gt; {
        return (
          car.lat &gt;&#x3D; expandedBounds.south &amp;&amp;
          car.lat &lt;&#x3D; expandedBounds.north &amp;&amp;
          car.lng &gt;&#x3D; expandedBounds.west &amp;&amp;
          car.lng &lt;&#x3D; expandedBounds.east
        );
      });
    }

    // Sort by priority (distance from center for higher zoom levels)
    if (zoom &gt; 12) {
      const center &#x3D; this.map.getCenter();
      visibleCars.sort((a, b) &#x3D;&gt; {
        const distA &#x3D; this.calculateDistance(center.lat, center.lng, a.lat, a.lng);
        const distB &#x3D; this.calculateDistance(center.lat, center.lng, b.lat, b.lng);
        return distA - distB;
      });
    }

    return visibleCars;
  }

  /**
   * Render car markers with custom tooltips
   */
  private renderCarMarkers(): void {
    if (!this.map || !this.mapboxgl) return;

    // Clear existing markers
    this.clearMarkers();

    // Si la capa de autos est√° oculta, no renderizar
    if (!this.showMarketplaceCars()) {
      return;
    }

    // Group cars by availability and price for visual organization
    const groupedCars &#x3D; this.groupCarsByAvailability();

    // Create markers for each car
    groupedCars.forEach((car) &#x3D;&gt; {
      const markerData &#x3D; this.createCarMarker(car);
      if (markerData) {
        this.carMarkers.set(car.carId, markerData);
      }
    });

    // Highlight selected car
    if (this.selectedCarId) {
      this.highlightSelectedCar(this.selectedCarId);
    }
  }

  /**
   * Group cars by availability (immediate vs scheduled)
   * Prioritizes cars available today with instant booking
   */
  private groupCarsByAvailability(): CarMapLocation[] {
    const cars &#x3D; [...this.cars];

    // Group cars by priority:
    // 1. Available today + instant booking (highest priority)
    // 2. Available today (no instant booking)
    // 3. Available tomorrow + instant booking
    // 4. Available tomorrow
    // 5. Soon available (within 7 days)
    // 6. Unavailable or unknown status

    const groups &#x3D; {
      immediateInstant: [] as CarMapLocation[],
      immediate: [] as CarMapLocation[],
      tomorrowInstant: [] as CarMapLocation[],
      tomorrow: [] as CarMapLocation[],
      soonAvailable: [] as CarMapLocation[],
      unavailable: [] as CarMapLocation[],
    };

    cars.forEach((car) &#x3D;&gt; {
      const status &#x3D; car.availabilityStatus || &#x27;unavailable&#x27;;
      const isInstant &#x3D; car.instantBooking &#x3D;&#x3D;&#x3D; true;
      const availableToday &#x3D; car.availableToday &#x3D;&#x3D;&#x3D; true;
      const availableTomorrow &#x3D; car.availableTomorrow &#x3D;&#x3D;&#x3D; true;

      if (status &#x3D;&#x3D;&#x3D; &#x27;available&#x27; &amp;&amp; availableToday &amp;&amp; isInstant) {
        groups.immediateInstant.push(car);
      } else if (status &#x3D;&#x3D;&#x3D; &#x27;available&#x27; &amp;&amp; availableToday) {
        groups.immediate.push(car);
      } else if (status &#x3D;&#x3D;&#x3D; &#x27;available&#x27; &amp;&amp; availableTomorrow &amp;&amp; isInstant) {
        groups.tomorrowInstant.push(car);
      } else if (status &#x3D;&#x3D;&#x3D; &#x27;available&#x27; &amp;&amp; availableTomorrow) {
        groups.tomorrow.push(car);
      } else if (status &#x3D;&#x3D;&#x3D; &#x27;soon_available&#x27;) {
        groups.soonAvailable.push(car);
      } else {
        groups.unavailable.push(car);
      }
    });

    // Return prioritized list
    return [
      ...groups.immediateInstant,
      ...groups.immediate,
      ...groups.tomorrowInstant,
      ...groups.tomorrow,
      ...groups.soonAvailable,
      ...groups.unavailable,
    ];
  }

  /**
   * Create a car marker with custom tooltip
   */
  private createCarMarker(
    car: CarMapLocation,
  ): { marker: MapboxMarker; componentRef: ComponentRef&lt;MapMarkerComponent&gt; } | null {
    if (!this.map || !this.mapboxgl) return null;

    // Get component from pool or create new one
    const componentRef &#x3D; this.getMarkerComponentFromPool();

    // Set inputs
    componentRef.setInput(&#x27;car&#x27;, car);
    componentRef.setInput(&#x27;isSelected&#x27;, this.selectedCarId &#x3D;&#x3D;&#x3D; car.carId);

    // Show the element (it might have been hidden in pool)
    const markerElement &#x3D; componentRef.location.nativeElement as HTMLElement;
    markerElement.style.display &#x3D; &#x27;block&#x27;;

    // Create marker
    const marker &#x3D; new this.mapboxgl.Marker({
      element: markerElement,
      anchor: &#x27;center&#x27;,
    })
      .setLngLat([car.lng, car.lat])
      .addTo(this.map);

    // Handle hover with delay (150ms) - create tooltip on-demand
    markerElement.addEventListener(&#x27;mouseenter&#x27;, () &#x3D;&gt; {
      const timeout &#x3D; setTimeout(() &#x3D;&gt; {
        this.showTooltipForCar(marker, car);
      }, 150);
      this.hoverTimeouts.set(car.carId, timeout);
    });

    markerElement.addEventListener(&#x27;mouseleave&#x27;, () &#x3D;&gt; {
      const timeout &#x3D; this.hoverTimeouts.get(car.carId);
      if (timeout) {
        clearTimeout(timeout);
        this.hoverTimeouts.delete(car.carId);
      }
      this.hideTooltipForCar(car.carId);
    });

    // Handle click
    markerElement.addEventListener(&#x27;click&#x27;, () &#x3D;&gt; {
      this.carSelected.emit(car.carId);
      this.selectedCar.set(car);
    });

    return { marker, componentRef };
  }

  /**
   * Create tooltip popup with Angular component (using EnhancedMapTooltipComponent)
   */
  private createTooltipPopup(car: CarMapLocation): MapboxPopup {
    if (!this.mapboxgl) {
      throw new Error(&#x27;Mapbox GL not initialized&#x27;);
    }

    // Create container wrapper for the popup
    const container &#x3D; document.createElement(&#x27;div&#x27;);
    container.className &#x3D; &#x27;map-tooltip-container&#x27;;

    // Get component from pool or create new one
    const componentRef &#x3D; this.getTooltipComponentFromPool();

    // Set inputs
    componentRef.setInput(&#x27;car&#x27;, car);
    componentRef.setInput(&#x27;selected&#x27;, this.selectedCarId &#x3D;&#x3D;&#x3D; car.carId);
    componentRef.setInput(&#x27;userLocation&#x27;, this.userLocation || undefined);

    // Subscribe to output events
    componentRef.instance.viewDetails.subscribe((carId: string) &#x3D;&gt; {
      this.carSelected.emit(carId);
    });

    componentRef.instance.quickBook.subscribe((carId: string) &#x3D;&gt; {
      this.quickBook.emit(carId);
    });

    // Show the element (it might have been hidden in pool)
    const element &#x3D; componentRef.location.nativeElement as HTMLElement;
    element.style.display &#x3D; &#x27;block&#x27;;

    // Append the component&#x27;s native element to the container
    container.appendChild(element);

    // Store component reference
    this.tooltipComponents.set(car.carId, componentRef);

    // Create popup with larger maxWidth for enhanced tooltip
    const popup &#x3D; new this.mapboxgl.Popup({
      offset: 25,
      closeButton: false,
      closeOnClick: false,
      maxWidth: &#x27;320px&#x27;,
    }).setDOMContent(container);

    // Store popup reference
    this.tooltipPopups.set(car.carId, popup);

    return popup;
  }

  /**
   * Show tooltip for a car on-demand
   */
  private showTooltipForCar(marker: MapboxMarker, car: CarMapLocation): void {
    // Check if tooltip already exists
    let popup &#x3D; this.tooltipPopups.get(car.carId);

    if (!popup) {
      // Create tooltip on-demand
      popup &#x3D; this.createTooltipPopup(car);
      this.tooltipPopups.set(car.carId, popup);
      marker.setPopup(popup);
    }

    // Show the popup if not already open
    if (!popup.isOpen()) {
      marker.togglePopup();
    }
  }

  /**
   * Hide tooltip for a car
   */
  private hideTooltipForCar(carId: string): void {
    const popup &#x3D; this.tooltipPopups.get(carId);
    if (popup &amp;&amp; popup.isOpen()) {
      // Find the marker and toggle popup
      const markerData &#x3D; this.carMarkers.get(carId);
      if (markerData &amp;&amp; markerData.marker.getPopup() &#x3D;&#x3D;&#x3D; popup) {
        markerData.marker.togglePopup();
      }
    }

    // Return tooltip component to pool after a delay to allow animations
    const componentRef &#x3D; this.tooltipComponents.get(carId);
    if (componentRef) {
      setTimeout(() &#x3D;&gt; {
        this.returnTooltipComponentToPool(componentRef);
        this.tooltipComponents.delete(carId);
        this.tooltipPopups.delete(carId);
      }, 300); // Allow time for fade out animation
    }
  }

  /**
   * Add user location marker with custom styling and animations
   */
  private addUserLocationMarker(): void {
    if (!this.map || !this.mapboxgl || !this.userLocation) return;

    // Si la capa de ubicaci√≥n est√° oculta, remover el marcador si existe
    if (!this.showUserLocation()) {
      if (this.userLocationMarker) {
        this.userLocationMarker.remove();
        this.userLocationMarker &#x3D; null;
      }
      return;
    }

    // Save previous location before removing marker
    let previousLocation: { lat: number; lng: number } | null &#x3D; null;
    if (this.userLocationMarker) {
      const prevLngLat &#x3D; this.userLocationMarker.getLngLat();
      previousLocation &#x3D; { lat: prevLngLat.lat, lng: prevLngLat.lng };
      this.userLocationMarker.remove();
    }

    // Create custom marker element with contextual classes
    const el &#x3D; document.createElement(&#x27;div&#x27;);
    el.className &#x3D; &#x60;user-location-marker user-location-marker--${this.locationMode}&#x60;;
    if (this.isDarkMode()) {
      el.classList.add(&#x27;user-location-marker--dark&#x27;);
    }

    const circleSize &#x3D; 20 * this.circleSizeMultiplier();
    el.style.setProperty(&#x27;--circle-size&#x27;, &#x60;${circleSize}px&#x60;);

    // ‚úÖ P0-005 FIX: Use safe DOM methods instead of innerHTML
    const haloDiv &#x3D; document.createElement(&#x27;div&#x27;);
    haloDiv.className &#x3D; &#x27;user-marker-halo&#x27;;

    const imgElement &#x3D; document.createElement(&#x27;img&#x27;);
    imgElement.src &#x3D; this.userAvatarUrl || &#x27;assets/images/default-avatar.svg&#x27;;
    imgElement.className &#x3D; &#x27;user-marker-avatar&#x27;;
    imgElement.alt &#x3D; &#x27;Tu ubicaci√≥n&#x27;;
    imgElement.addEventListener(&#x27;error&#x27;, function handleImageError(this: HTMLImageElement) {
      this.src &#x3D; &#x27;assets/images/default-avatar.svg&#x27;;
    });

    el.appendChild(haloDiv);
    el.appendChild(imgElement);

    // Create marker
    this.userLocationMarker &#x3D; new this.mapboxgl.Marker({
      element: el,
      anchor: &#x27;center&#x27;,
    })
      .setLngLat([this.userLocation.lng, this.userLocation.lat])
      .addTo(this.map);

    // Animate marker movement if location changed
    if (previousLocation) {
      const distance &#x3D; this.calculateDistance(
        previousLocation.lat,
        previousLocation.lng,
        this.userLocation.lat,
        this.userLocation.lng,
      );

      if (distance &gt; 10) {
        // Solo animar si se movi√≥ m√°s de 10 metros
        this.animateMarkerUpdate();
      } else {
        // Trigger pulse even for small movements
        this.triggerLocationPulse();
      }
    }

    // Create enhanced popup with contextual information
    const popupHTML &#x3D; this.createUserLocationPopup();
    const popup &#x3D; new this.mapboxgl.Popup({
      offset: 25,
      closeButton: true,
      closeOnClick: false,
    }).setHTML(popupHTML);

    this.userLocationMarker.setPopup(popup);

    // Show popup initially with pulse animation (only if it&#x27;s the first time)
    if (!previousLocation) {
      setTimeout(() &#x3D;&gt; {
        this.userLocationMarker?.togglePopup();
        this.triggerLocationPulse();
      }, 1000);
    }
  }

  /**
   * Create HTML content for user location popup
   */
  private createUserLocationPopup(): string {
    const modeText &#x3D; this.viewMode() &#x3D;&#x3D;&#x3D; &#x27;map&#x27; ? &#x27;Tu ubicaci√≥n actual&#x27; : &#x27;Est√°s aqu√≠&#x27;;
    const accuracyText &#x3D; this.locationAccuracy
      ? &#x60;Precisi√≥n: ¬±${Math.round(this.locationAccuracy)}m&#x60;
      : &#x27;Precisi√≥n: Desconocida&#x27;;

    const updateTime &#x3D; this.lastLocationUpdate
      ? this.formatUpdateTime(this.lastLocationUpdate)
      : &#x27;Actualizado ahora&#x27;;

    // Calculate nearby cars
    const nearbyCars &#x3D; this.getNearbyCarsCount();
    const carsText &#x3D;
      nearbyCars &gt; 0 ? &#x60;üöó Hay &lt;b&gt;${nearbyCars}&lt;/b&gt; autos cerca&#x60; : &#x27;No hay autos cerca&#x27;;

    const popupHTML &#x3D; &#x60;
      &lt;div class&#x3D;&quot;user-location-popup&quot; style&#x3D;&quot;font-family: &#x27;Inter&#x27;, sans-serif; padding: 4px;&quot;&gt;
        &lt;div style&#x3D;&quot;display: flex; align-items: center; gap: 8px; margin-bottom: 4px;&quot;&gt;
          &lt;div style&#x3D;&quot;width: 8px; height: 8px; background-color: var(--success-default, #10b981); border-radius: 50%; box-shadow: 0 0 0 2px rgba(16, 185, 129, 0.2);&quot;&gt;&lt;/div&gt;
          &lt;p class&#x3D;&quot;font-semibold text-slate-800 dark:text-white&quot; style&#x3D;&quot;margin: 0; font-size: 14px;&quot;&gt;${modeText}&lt;/p&gt;
        &lt;/div&gt;

        &lt;div style&#x3D;&quot;display: flex; flex-direction: column; gap: 2px; margin-bottom: 8px; padding-left: 16px;&quot;&gt;
          &lt;p class&#x3D;&quot;text-xs text-slate-500 dark:text-slate-400&quot; style&#x3D;&quot;margin: 0;&quot;&gt;${accuracyText}&lt;/p&gt;
          &lt;p class&#x3D;&quot;text-xs text-slate-400 dark:text-slate-500&quot; style&#x3D;&quot;margin: 0;&quot;&gt;${updateTime}&lt;/p&gt;
          &lt;p class&#x3D;&quot;text-xs text-cyan-600 dark:text-cyan-400 font-medium&quot; style&#x3D;&quot;margin: 4px 0 0 0;&quot;&gt;${carsText}&lt;/p&gt;
        &lt;/div&gt;

        &lt;div class&#x3D;&quot;user-location-popup-actions&quot; style&#x3D;&quot;display: flex; gap: 8px; margin-top: 8px;&quot;&gt;
          &lt;button class&#x3D;&quot;user-location-cta&quot; data-action&#x3D;&quot;search-nearby&quot;
            style&#x3D;&quot;flex: 1; background: var(--cta-default, #06b6d4); color: white; border: none; padding: 6px 12px; border-radius: 6px; font-size: 12px; font-weight: 500; cursor: pointer; transition: all 0.2s;&quot;&gt;
            Buscar aqu√≠
          &lt;/button&gt;
          &lt;button class&#x3D;&quot;user-location-cta&quot; data-action&#x3D;&quot;view-routes&quot;
            style&#x3D;&quot;flex: 1; background: var(--cta-alpha-10, rgba(6, 182, 212, 0.1)); color: var(--cta-default, #06b6d4); border: 1px solid var(--cta-alpha-20, rgba(6, 182, 212, 0.2)); padding: 6px 12px; border-radius: 6px; font-size: 12px; font-weight: 500; cursor: pointer; transition: all 0.2s;&quot;&gt;
            Ver rutas
          &lt;/button&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &#x60;;

    return popupHTML;
  }

  /**
   * Calculate distance between two points in km
   */
  private calculateDistanceKm(lat1: number, lon1: number, lat2: number, lon2: number): number {
    const R &#x3D; 6371; // Radius of the earth in km
    const dLat &#x3D; this.deg2rad(lat2 - lat1);
    const dLon &#x3D; this.deg2rad(lon2 - lon1);
    const a &#x3D;
      Math.sin(dLat / 2) * Math.sin(dLat / 2) +
      Math.cos(this.deg2rad(lat1)) *
        Math.cos(this.deg2rad(lat2)) *
        Math.sin(dLon / 2) *
        Math.sin(dLon / 2);
    const c &#x3D; 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    const d &#x3D; R * c; // Distance in km
    return d;
  }

  private deg2rad(deg: number): number {
    return deg * (Math.PI / 180);
  }

  /**
   * Get count of cars near user location
   */
  /**
   * Get count of cars near user location
   */
  private getNearbyCarsCount(): number {
    const userLoc &#x3D; this.userLocation;
    if (!userLoc) return 0;

    const radius &#x3D; this.searchRadiusKm || 5; // Default 5km if not set

    return this.cars.filter((car) &#x3D;&gt; {
      if (!car.lat || !car.lng) return false;

      const dist &#x3D; this.calculateDistanceKm(userLoc.lat, userLoc.lng, car.lat, car.lng);

      return dist &lt;&#x3D; radius;
    }).length;
  }

  /**
   * Format update time for display
   */
  private formatUpdateTime(date: Date): string {
    const now &#x3D; new Date();
    const diffMs &#x3D; now.getTime() - date.getTime();
    const diffSec &#x3D; Math.floor(diffMs / 1000);
    const diffMin &#x3D; Math.floor(diffSec / 60);

    if (diffSec &lt; 10) return &#x27;Actualizado ahora&#x27;;
    if (diffSec &lt; 60) return &#x60;Actualizado hace ${diffSec}s&#x60;;
    if (diffMin &lt; 60) return &#x60;Actualizado hace ${diffMin}min&#x60;;
    return &#x60;Actualizado ${date.toLocaleTimeString(&#x27;es-AR&#x27;, { hour: &#x27;2-digit&#x27;, minute: &#x27;2-digit&#x27; })}&#x60;;
  }

  /**
   * Get location update text for info layer
   */
  public getLocationUpdateText(): string {
    if (!this.lastLocationUpdate) return &#x27;Desconocido&#x27;;
    return this.formatUpdateTime(this.lastLocationUpdate);
  }

  /**
   * Get count of available cars
   */
  public getAvailableCarsCount(): number {
    return this.cars.filter((car) &#x3D;&gt; car.availabilityStatus &#x3D;&#x3D;&#x3D; &#x27;available&#x27;).length;
  }

  /**
   * Get count of cars in use
   */
  public getInUseCarsCount(): number {
    return this.cars.filter((car) &#x3D;&gt; car.availabilityStatus &#x3D;&#x3D;&#x3D; &#x27;in_use&#x27;).length;
  }

  /**
   * Get count of soon available cars
   */
  public getSoonAvailableCarsCount(): number {
    return this.cars.filter((car) &#x3D;&gt; car.availabilityStatus &#x3D;&#x3D;&#x3D; &#x27;soon_available&#x27;).length;
  }

  /**
   * Get count of unavailable cars
   */
  public getUnavailableCarsCount(): number {
    return this.cars.filter((car) &#x3D;&gt; car.availabilityStatus &#x3D;&#x3D;&#x3D; &#x27;unavailable&#x27;).length;
  }

  /**
   * Animate marker update with smooth transitions
   */
  private animateMarkerUpdate(): void {
    if (!this.map || !this.userLocation) return;

    // Smooth camera transition
    this.map.easeTo({
      center: [this.userLocation.lng, this.userLocation.lat],
      duration: 800,
      easing: (t: number) &#x3D;&gt; t * (2 - t), // ease-out
    });

    // Add pulse animation to marker
    this.triggerLocationPulse();
  }

  /**
   * Trigger pulse animation on location update
   */
  private triggerLocationPulse(): void {
    if (!this.userLocationMarker) return;

    const element &#x3D; this.userLocationMarker.getElement();
    if (element) {
      element.classList.add(&#x27;user-location-marker--pulse&#x27;);
      setTimeout(() &#x3D;&gt; {
        element.classList.remove(&#x27;user-location-marker--pulse&#x27;);
      }, 1000);
    }
  }

  /**
   * Calculate distance between two coordinates (Haversine formula)
   */
  private calculateDistance(lat1: number, lon1: number, lat2: number, lon2: number): number {
    const R &#x3D; 6371e3; // Earth radius in meters
    const œÜ1 &#x3D; (lat1 * Math.PI) / 180;
    const œÜ2 &#x3D; (lat2 * Math.PI) / 180;
    const ŒîœÜ &#x3D; ((lat2 - lat1) * Math.PI) / 180;
    const ŒîŒª &#x3D; ((lon2 - lon1) * Math.PI) / 180;

    const a &#x3D;
      Math.sin(ŒîœÜ / 2) * Math.sin(ŒîœÜ / 2) +
      Math.cos(œÜ1) * Math.cos(œÜ2) * Math.sin(ŒîŒª / 2) * Math.sin(ŒîŒª / 2);
    const c &#x3D; 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

    return R * c;
  }

  /**
   * Update marker styles based on mode and theme
   */
  private updateMarkerStyles(): void {
    if (!this.userLocationMarker) return;

    const element &#x3D; this.userLocationMarker.getElement();
    if (element) {
      element.className &#x3D; &#x60;user-location-marker user-location-marker--${this.locationMode}&#x60;;
      if (this.isDarkMode()) {
        element.classList.add(&#x27;user-location-marker--dark&#x27;);
      } else {
        element.classList.remove(&#x27;user-location-marker--dark&#x27;);
      }
    }
  }

  /**
   * Add search radius layer (circle around user location)
   */
  private addSearchRadiusLayer(): void {
    if (!this.map || !this.mapboxgl || !this.userLocation) return;

    // Check if style is loaded before adding layers
    if (!this.map.isStyleLoaded()) {
      // Wait for style to load, then add layer
      this.map.once(&#x27;styledata&#x27;, () &#x3D;&gt; {
        this.addSearchRadiusLayer();
      });
      return;
    }

    // Convert radius from km to meters
    const radiusMeters &#x3D; this.searchRadiusKm * 1000;

    // Create circle geometry
    const circle &#x3D; this.createCircleGeometry(
      this.userLocation.lat,
      this.userLocation.lng,
      radiusMeters,
    );

    // Add or update source
    const feature: GeoJSON.Feature&lt;GeoJSON.Polygon&gt; &#x3D; {
      type: &#x27;Feature&#x27;,
      geometry: circle,
      properties: {},
    };

    const source &#x3D; this.map.getSource(this.searchRadiusSourceId) as MapboxGeoJSONSource | undefined;
    if (source) {
      source.setData(feature);
    } else {
      this.map.addSource(this.searchRadiusSourceId, {
        type: &#x27;geojson&#x27;,
        data: feature,
      });
    }

    // Add or update layer
    const fillColor &#x3D; this.isDarkMode() ? &#x27;rgba(167, 216, 244, 0.1)&#x27; : &#x27;rgba(167, 216, 244, 0.15)&#x27;;
    const outlineColor &#x3D; this.isDarkMode()
      ? &#x27;rgba(167, 216, 244, 0.4)&#x27;
      : &#x27;rgba(167, 216, 244, 0.5)&#x27;;

    if (!this.map.getLayer(this.searchRadiusLayerId)) {
      this.map.addLayer({
        id: this.searchRadiusLayerId,
        type: &#x27;fill&#x27;,
        source: this.searchRadiusSourceId,
        paint: {
          &#x27;fill-color&#x27;: fillColor,
          &#x27;fill-outline-color&#x27;: outlineColor,
        },
      });
    } else {
      // Update paint properties with smooth transitions
      // Mapbox GL JS handles transitions automatically when properties change
      this.map.setPaintProperty(this.searchRadiusLayerId, &#x27;fill-color&#x27;, fillColor);
      this.map.setPaintProperty(this.searchRadiusLayerId, &#x27;fill-outline-color&#x27;, outlineColor);
    }
  }

  /**
   * Create circle geometry for search radius
   */
  private createCircleGeometry(lat: number, lng: number, radiusMeters: number): GeoJSON.Polygon {
    const points &#x3D; 64;
    const coordinates: [number, number][] &#x3D; [];

    for (let i &#x3D; 0; i &lt;&#x3D; points; i++) {
      const angle &#x3D; (i * 360) / points;
      const point &#x3D; this.destinationPoint(lat, lng, radiusMeters, angle);
      coordinates.push([point.lng, point.lat]);
    }

    return {
      type: &#x27;Polygon&#x27;,
      coordinates: [coordinates],
    };
  }

  /**
   * Calculate destination point given start point, distance and bearing
   */
  private destinationPoint(
    lat: number,
    lng: number,
    distanceMeters: number,
    bearingDegrees: number,
  ): { lat: number; lng: number } {
    const R &#x3D; 6371e3; // Earth radius in meters
    const bearing &#x3D; (bearingDegrees * Math.PI) / 180;
    const lat1 &#x3D; (lat * Math.PI) / 180;
    const lng1 &#x3D; (lng * Math.PI) / 180;

    const lat2 &#x3D; Math.asin(
      Math.sin(lat1) * Math.cos(distanceMeters / R) +
        Math.cos(lat1) * Math.sin(distanceMeters / R) * Math.cos(bearing),
    );

    const lng2 &#x3D;
      lng1 +
      Math.atan2(
        Math.sin(bearing) * Math.sin(distanceMeters / R) * Math.cos(lat1),
        Math.cos(distanceMeters / R) - Math.sin(lat1) * Math.sin(lat2),
      );

    return {
      lat: (lat2 * 180) / Math.PI,
      lng: (lng2 * 180) / Math.PI,
    };
  }

  /**
   * Setup follow user location functionality
   */
  private setupFollowLocation(): void {
    if (this.followUserLocation) {
      this.startFollowingLocation();
    }
  }

  /**
   * Start following user location
   */
  startFollowingLocation(): void {
    if (!this.map || !this.userLocation || this.followLocationInterval) return;

    this.followUserLocation &#x3D; true;
    this.followLocationToggle.emit(true);

    // Fly to user location initially with reduced zoom and padding
    this.map.flyTo({
      center: [this.userLocation.lng, this.userLocation.lat],
      zoom: 13, // Reduced from 14 to prevent marker overlap/duplication
      duration: 1000,
      padding: { top: 50, bottom: 50, left: 50, right: 50 }, // Add padding for better positioning
    });

    // Update position periodically with debounce to prevent animation overlap
    let lastEaseToTime &#x3D; 0;
    const easeToDebounceMs &#x3D; 1000; // Prevent animations from stacking
    this.followLocationInterval &#x3D; setInterval(() &#x3D;&gt; {
      if (this.userLocation &amp;&amp; this.map) {
        const now &#x3D; Date.now();
        // Only execute if enough time has passed since last animation
        if (now - lastEaseToTime &gt; easeToDebounceMs) {
          lastEaseToTime &#x3D; now;
          this.map.easeTo({
            center: [this.userLocation.lng, this.userLocation.lat],
            duration: 500,
          });
        }
      }
    }, 3000); // Update every 3 seconds (increased from 2s to reduce animation frequency)
  }

  /**
   * Stop following user location
   */
  stopFollowingLocation(): void {
    if (this.followLocationInterval) {
      clearInterval(this.followLocationInterval);
      this.followLocationInterval &#x3D; null;
    }
    this.followUserLocation &#x3D; false;
    this.followLocationToggle.emit(false);
  }

  /**
   * Setup lock controls for zoom and rotation
   */
  private setupLockControls(): void {
    if (!this.map) return;

    if (this.lockZoomRotation) {
      // Disable zoom and rotation
      this.map.boxZoom.disable();
      this.map.scrollZoom.disable();
      this.map.dragRotate.disable();
      this.map.touchZoomRotate.disable();
    } else {
      // Enable zoom and rotation
      this.map.boxZoom.enable();
      this.map.scrollZoom.enable();
      this.map.dragRotate.enable();
      this.map.touchZoomRotate.enable();
    }
  }

  /**
   * Toggle lock state
   */
  public toggleLock(): void {
    this.lockZoomRotation &#x3D; !this.lockZoomRotation;
    this.lockToggle.emit(this.lockZoomRotation);
    this.setupLockControls();
  }

  /**
   * Toggle follow location
   */
  public toggleFollowLocation(): void {
    if (this.followUserLocation) {
      this.stopFollowingLocation();
    } else {
      this.startFollowingLocation();
    }
  }

  /**
   * Toggle delivery zone (isochrone)
   */
  public toggleDeliveryZone(): void {
    this.showDeliveryIsochrone &#x3D; !this.showDeliveryIsochrone;
    if (this.showDeliveryIsochrone) {
      this.addDeliveryIsochrone();
    } else {
      this.removeDeliveryIsochrone();
    }
  }

  /**
   * Toggle directions route
   */
  public toggleDirections(): void {
    this.showDirectionsRoute &#x3D; !this.showDirectionsRoute;
    if (this.showDirectionsRoute) {
      this.addDirectionsRoute();
    } else {
      this.removeDirectionsRoute();
    }
  }

  /**
   * Handle search radius slider change
   */
  public onSearchRadiusChange(event: Event): void {
    const target &#x3D; event.target as HTMLInputElement;
    const value &#x3D; parseFloat(target.value);
    this.searchRadiusKm &#x3D; value;
    this.searchRadiusChange.emit(value);

    // Update radius layer with animation
    if (this.showSearchRadius &amp;&amp; this.map) {
      this.addSearchRadiusLayer();
    }

    // Note: The parent component (marketplace.page.ts) should handle
    // refetching cars with the new radius filter via searchRadiusChange output
  }

  /**
   * Highlight selected car marker
   */
  private highlightSelectedCar(carId: string): void {
    const markerData &#x3D; this.carMarkers.get(carId);
    if (!markerData) return;

    markerData.componentRef.instance.isSelected &#x3D; true;

    // Fly to selected car
    const car &#x3D; this.cars.find((c) &#x3D;&gt; c.carId &#x3D;&#x3D;&#x3D; carId);
    if (car &amp;&amp; this.map) {
      this.map.flyTo({
        center: [car.lng, car.lat],
        zoom: 14,
        duration: 1000,
      });
    }

    // Update tooltip component
    const componentRef &#x3D; this.tooltipComponents.get(carId);
    if (componentRef) {
      componentRef.setInput(&#x27;selected&#x27;, true);
    }
  }

  /**
   * Remove highlight from car marker
   */
  private removeHighlightFromCar(carId: string): void {
    const markerData &#x3D; this.carMarkers.get(carId);
    if (!markerData) return;

    markerData.componentRef.instance.isSelected &#x3D; false;

    // Update tooltip component
    const componentRef &#x3D; this.tooltipComponents.get(carId);
    if (componentRef) {
      componentRef.setInput(&#x27;selected&#x27;, false);
    }
  }

  /**
   * Clear all markers and related resources
   */
  private clearMarkers(): void {
    // Clear hover timeouts
    this.hoverTimeouts.forEach((timeout) &#x3D;&gt; clearTimeout(timeout));
    this.hoverTimeouts.clear();

    // Detach Angular components
    this.tooltipComponents.forEach((componentRef) &#x3D;&gt; {
      this.applicationRef.detachView(componentRef.hostView);
      componentRef.destroy();
    });
    this.tooltipComponents.clear();

    // Remove popups
    this.tooltipPopups.forEach((popup) &#x3D;&gt; {
      popup.remove();
    });
    this.tooltipPopups.clear();

    // Remove markers and return components to pool
    this.carMarkers.forEach((markerData) &#x3D;&gt; {
      markerData.marker.remove();
      this.returnMarkerComponentToPool(markerData.componentRef);
    });
    this.carMarkers.clear();
    this.visibleCarIds.clear();
  }

  /**
   * Remove search radius layer
   */
  private removeSearchRadiusLayer(): void {
    if (!this.map) return;

    try {
      if (this.map.getLayer(this.searchRadiusLayerId)) {
        this.map.removeLayer(this.searchRadiusLayerId);
      }
      if (this.map.getSource(this.searchRadiusSourceId)) {
        this.map.removeSource(this.searchRadiusSourceId);
      }
    } catch {
      // Layers may not exist
    }
  }

  /**
   * Add delivery isochrone layer for selected car
   * Shows the area reachable from the car&#x27;s location within deliveryTimeMinutes
   */
  private async addDeliveryIsochrone(): Promise&lt;void&gt; {
    if (!this.map || !this.mapboxgl) return;

    const selectedCar &#x3D; this.selectedCar();
    if (!selectedCar) return;

    // Check if style is loaded
    if (!this.map.isStyleLoaded()) {
      this.map.once(&#x27;styledata&#x27;, () &#x3D;&gt; {
        this.addDeliveryIsochrone();
      });
      return;
    }

    try {
      // Fetch isochrone from Mapbox API
      const lng &#x3D; selectedCar.lng;
      const lat &#x3D; selectedCar.lat;
      const profile &#x3D; &#x27;driving&#x27;; // Options: driving, walking, cycling
      const minutes &#x3D; this.deliveryTimeMinutes;

      const url &#x3D; &#x60;https://api.mapbox.com/isochrone/v1/mapbox/${profile}/${lng},${lat}?contours_minutes&#x3D;${minutes}&amp;polygons&#x3D;true&amp;access_token&#x3D;${environment.mapboxAccessToken}&#x60;;

      const response &#x3D; await fetch(url);
      if (!response.ok) {
        console.warn(&#x27;[CarsMap] Failed to fetch isochrone:&#x27;, response.statusText);
        return;
      }

      const data &#x3D; (await response.json()) as GeoJSON.FeatureCollection;

      // Add or update source
      const source &#x3D; this.map.getSource(this.isochroneSourceId) as MapboxGeoJSONSource | undefined;
      if (source) {
        source.setData(data);
      } else {
        this.map.addSource(this.isochroneSourceId, {
          type: &#x27;geojson&#x27;,
          data: data,
        });
      }

      // Add fill layer
      const fillColor &#x3D; this.isDarkMode() ? &#x27;rgba(16, 185, 129, 0.2)&#x27; : &#x27;rgba(16, 185, 129, 0.25)&#x27;;
      if (!this.map.getLayer(this.isochroneLayerId)) {
        this.map.addLayer({
          id: this.isochroneLayerId,
          type: &#x27;fill&#x27;,
          source: this.isochroneSourceId,
          paint: {
            &#x27;fill-color&#x27;: fillColor,
            &#x27;fill-opacity&#x27;: 0.8,
          },
        });
      } else {
        this.map.setPaintProperty(this.isochroneLayerId, &#x27;fill-color&#x27;, fillColor);
      }

      // Add outline layer for better visibility
      const outlineColor &#x3D; this.isDarkMode()
        ? &#x27;rgba(16, 185, 129, 0.8)&#x27;
        : &#x27;rgba(16, 185, 129, 0.9)&#x27;;
      if (!this.map.getLayer(this.isochroneOutlineLayerId)) {
        this.map.addLayer({
          id: this.isochroneOutlineLayerId,
          type: &#x27;line&#x27;,
          source: this.isochroneSourceId,
          paint: {
            &#x27;line-color&#x27;: outlineColor,
            &#x27;line-width&#x27;: 2,
            &#x27;line-dasharray&#x27;: [2, 2],
          },
        });
      } else {
        this.map.setPaintProperty(this.isochroneOutlineLayerId, &#x27;line-color&#x27;, outlineColor);
      }

      console.log(
        &#x60;[CarsMap] Added delivery isochrone: ${minutes} min driving radius from car location&#x60;,
      );
    } catch (error) {
      console.error(&#x27;[CarsMap] Error adding delivery isochrone:&#x27;, error);
    }
  }

  /**
   * Remove delivery isochrone layer
   */
  private removeDeliveryIsochrone(): void {
    if (!this.map) return;

    try {
      if (this.map.getLayer(this.isochroneOutlineLayerId)) {
        this.map.removeLayer(this.isochroneOutlineLayerId);
      }
      if (this.map.getLayer(this.isochroneLayerId)) {
        this.map.removeLayer(this.isochroneLayerId);
      }
      if (this.map.getSource(this.isochroneSourceId)) {
        this.map.removeSource(this.isochroneSourceId);
      }
    } catch {
      // Layers may not exist
    }
  }

  /**
   * Add directions route layer from user location to selected car
   * Shows turn-by-turn directions with estimated time and distance
   */
  private async addDirectionsRoute(): Promise&lt;void&gt; {
    if (!this.map || !this.mapboxgl || !this.userLocation) {
      console.warn(&#x27;[CarsMap] Cannot show directions: missing map or user location&#x27;);
      return;
    }

    const selectedCar &#x3D; this.selectedCar();
    if (!selectedCar) {
      console.warn(&#x27;[CarsMap] Cannot show directions: no selected car&#x27;);
      return;
    }

    // Check if style is loaded
    if (!this.map.isStyleLoaded()) {
      this.map.once(&#x27;styledata&#x27;, () &#x3D;&gt; {
        this.addDirectionsRoute();
      });
      return;
    }

    try {
      const origin: [number, number] &#x3D; [this.userLocation.lng, this.userLocation.lat];
      const destination: [number, number] &#x3D; [selectedCar.lng, selectedCar.lat];

      // Fetch directions from API
      const directions &#x3D; await this.directionsService.getDirections(origin, destination, &#x27;driving&#x27;);

      if (!directions || !directions.routes || directions.routes.length &#x3D;&#x3D;&#x3D; 0) {
        console.warn(&#x27;[CarsMap] No route found&#x27;);
        return;
      }

      const route &#x3D; directions.routes[0];
      const routeGeometry &#x3D; route.geometry;

      // Create GeoJSON for the route
      const routeGeoJSON: GeoJSON.Feature&lt;GeoJSON.LineString&gt; &#x3D; {
        type: &#x27;Feature&#x27;,
        geometry: routeGeometry,
        properties: {
          duration: route.duration,
          distance: route.distance,
        },
      };

      // Add or update source
      const source &#x3D; this.map.getSource(this.routeSourceId) as MapboxGeoJSONSource | undefined;
      if (source) {
        source.setData(routeGeoJSON);
      } else {
        this.map.addSource(this.routeSourceId, {
          type: &#x27;geojson&#x27;,
          data: routeGeoJSON,
        });
      }

      // Add outline layer (casing) - THICK 3D styling to occupy street
      if (!this.map.getLayer(this.routeOutlineLayerId)) {
        this.map.addLayer({
          id: this.routeOutlineLayerId,
          type: &#x27;line&#x27;,
          source: this.routeSourceId,
          paint: {
            &#x27;line-color&#x27;: &#x27;var(--surface-primary, var(--surface-primary, #ffffff)fff)&#x27;,
            &#x27;line-width&#x27;: 20, // THICK outline to occupy whole street
            &#x27;line-opacity&#x27;: 0.8, // High visibility for 3D effect
          },
          layout: {
            &#x27;line-cap&#x27;: &#x27;round&#x27;, // Rounded ends for smooth appearance
            &#x27;line-join&#x27;: &#x27;round&#x27;, // Rounded corners for smooth turns
          },
        });
      }

      // Add main route layer - THICK 3D styling to occupy street
      const routeColor &#x3D; this.getCssVariableValue(&#x27;--cta-default&#x27;, &#x27;#A7D8F4&#x27;); // AutoRenta brand color
      if (!this.map.getLayer(this.routeLayerId)) {
        this.map.addLayer({
          id: this.routeLayerId,
          type: &#x27;line&#x27;,
          source: this.routeSourceId,
          paint: {
            &#x27;line-color&#x27;: routeColor,
            &#x27;line-width&#x27;: 16, // THICK main line to occupy whole street
            &#x27;line-opacity&#x27;: 0.9, // High visibility for 3D effect
          },
          layout: {
            &#x27;line-cap&#x27;: &#x27;round&#x27;, // Rounded ends for smooth appearance
            &#x27;line-join&#x27;: &#x27;round&#x27;, // Rounded corners for smooth turns
          },
        });
      } else {
        this.map.setPaintProperty(this.routeLayerId, &#x27;line-color&#x27;, routeColor);
      }

      // Fit map to show entire route
      const coordinates &#x3D; routeGeometry.coordinates as [number, number][];
      const bounds &#x3D; coordinates.reduce(
        (bounds, coord) &#x3D;&gt; {
          return bounds.extend(coord as [number, number]);
        },
        new this.mapboxgl.LngLatBounds(coordinates[0], coordinates[0]),
      );

      this.map.fitBounds(bounds, {
        padding: { top: 100, bottom: 100, left: 100, right: 100 },
        maxZoom: 15,
        duration: 1000,
        pitch: 60, // Maintain 3D perspective while showing route
      });

      console.log(&#x27;[CarsMap] Directions route added:&#x27;, {
        duration: this.directionsService.formatDuration(route.duration),
        distance: this.directionsService.formatDistance(route.distance),
      });
    } catch (error) {
      console.error(&#x27;[CarsMap] Error adding directions route:&#x27;, error);
    }
  }

  /**
   * Remove directions route layer
   */
  private removeDirectionsRoute(): void {
    if (!this.map) return;

    try {
      if (this.map.getLayer(this.routeLayerId)) {
        this.map.removeLayer(this.routeLayerId);
      }
      if (this.map.getLayer(this.routeOutlineLayerId)) {
        this.map.removeLayer(this.routeOutlineLayerId);
      }
      if (this.map.getSource(this.routeSourceId)) {
        this.map.removeSource(this.routeSourceId);
      }
    } catch {
      // Layers may not exist
    }
  }

  /**
   * Cleanup on destroy
   */
  private cleanup(): void {
    // Cancel any pending updates
    if (this.pendingUpdate) {
      cancelAnimationFrame(this.pendingUpdate);
      this.pendingUpdate &#x3D; null;
    }

    this.clearMarkers();
    this.stopFollowingLocation();

    // Remove clustering layers
    if (this.map) {
      try {
        if (this.map.getLayer(this.clusterLayerId)) {
          this.map.removeLayer(this.clusterLayerId);
        }
        if (this.map.getLayer(this.clusterCountLayerId)) {
          this.map.removeLayer(this.clusterCountLayerId);
        }
        if (this.map.getLayer(&#x27;cars-unclustered&#x27;)) {
          this.map.removeLayer(&#x27;cars-unclustered&#x27;);
        }
        if (this.map.getSource(this.clusterSourceId)) {
          this.map.removeSource(this.clusterSourceId);
        }
        this.removeSearchRadiusLayer();
        this.removeDeliveryIsochrone();
        this.removeDirectionsRoute();
      } catch {
        // Layers may not exist
      }
    }

    if (this.userLocationMarker) {
      this.userLocationMarker.remove();
      this.userLocationMarker &#x3D; null;
    }

    if (this.map) {
      this.map.remove();
      this.map &#x3D; null;
    }

    // Clear component pools
    this.clearComponentPools();
  }

  /**
   * Public method to fly to car location with smooth 3D animation
   */
  flyToCarLocation(carId: string): void {
    const car &#x3D; this.cars.find((c) &#x3D;&gt; c.carId &#x3D;&#x3D;&#x3D; carId);
    if (car &amp;&amp; this.map &amp;&amp; car.lat &amp;&amp; car.lng) {
      this.map.flyTo({
        center: [car.lng, car.lat],
        zoom: 16, // Closer zoom for better focus
        pitch: 45, // 3D tilt effect
        bearing: -15, // Slight rotation for dramatic effect
        duration: 1500, // Smooth animation
        essential: true,
      });
      this.highlightSelectedCar(carId);
    }
  }

  /**
   * Public method to fly to a specific location (lat/lng)
   */
  flyToLocation(lat: number, lng: number, zoom &#x3D; 14): void {
    if (this.map) {
      this.map.flyTo({
        center: [lng, lat],
        zoom,
        essential: true,
        duration: 1200,
      });
    }
  }

  /**
   * Handle booking panel close
   */
  onBookingPanelClose(): void {
    this.bookingPanelOpen.set(false);
    this.selectedCarForBooking.set(null);
  }

  onDetailsPanelClose(): void {
    this.selectedCar.set(null);
    if (this.selectedCarId) {
      this.removeHighlightFromCar(this.selectedCarId);
    }
  }

  /**
   * Handle booking confirmed
   */
  onBookingConfirmed(bookingData: BookingFormData): void {
    const carId &#x3D; this.selectedCarForBooking()?.carId;
    if (carId) {
      this.bookingConfirmed.emit({ carId, bookingData });
    }
    this.bookingPanelOpen.set(false);
    this.selectedCarForBooking.set(null);
  }

  /**
   * Update markers when cars input changes
   */
  ngOnChanges(changes: SimpleChanges): void {
    if (changes[&#x27;cars&#x27;] &amp;&amp; !changes[&#x27;cars&#x27;].firstChange &amp;&amp; this.map) {
      // Update spatial index first, then markers
      this.updateSpatialIndex();
      this.scheduleDebouncedUpdate(() &#x3D;&gt; this.updateMarkersBasedOnCount());
    }
    if (changes[&#x27;selectedCarId&#x27;] &amp;&amp; !changes[&#x27;selectedCarId&#x27;].firstChange &amp;&amp; this.map) {
      const previousId &#x3D; changes[&#x27;selectedCarId&#x27;].previousValue;
      const currentId &#x3D; changes[&#x27;selectedCarId&#x27;].currentValue;

      // Remove highlight from previous
      if (previousId) {
        this.removeHighlightFromCar(previousId);
      }

      // Highlight current
      if (currentId) {
        this.highlightSelectedCar(currentId);
        const car &#x3D; this.cars.find((c) &#x3D;&gt; c.carId &#x3D;&#x3D;&#x3D; currentId);
        if (car) {
          this.selectedCar.set(car);
        }
      } else {
        this.selectedCar.set(null);
      }
    }
    if (changes[&#x27;userLocation&#x27;] &amp;&amp; !changes[&#x27;userLocation&#x27;].firstChange &amp;&amp; this.map) {
      this.addUserLocationMarker();
      if (this.showSearchRadius) {
        this.addSearchRadiusLayer();
      }
    }
    if (changes[&#x27;locationMode&#x27;] &amp;&amp; !changes[&#x27;locationMode&#x27;].firstChange) {
      this.updateMarkerStyles();
    }
    if (changes[&#x27;markerVariant&#x27;] &amp;&amp; !changes[&#x27;markerVariant&#x27;].firstChange) {
      this.updateMapTheme();
      // Re-render markers with new variant
      if (this.map) {
        this.scheduleDebouncedUpdate(() &#x3D;&gt; this.updateMarkersBasedOnCount());
      }
    }
    if (changes[&#x27;searchRadiusKm&#x27;] &amp;&amp; !changes[&#x27;searchRadiusKm&#x27;].firstChange &amp;&amp; this.map) {
      if (this.showSearchRadius) {
        this.addSearchRadiusLayer();
      }
      this.searchRadiusChange.emit(this.searchRadiusKm);
    }
    if (changes[&#x27;showSearchRadius&#x27;] &amp;&amp; !changes[&#x27;showSearchRadius&#x27;].firstChange &amp;&amp; this.map) {
      if (this.showSearchRadius) {
        this.addSearchRadiusLayer();
      } else {
        this.removeSearchRadiusLayer();
      }
    }
    if (changes[&#x27;followUserLocation&#x27;] &amp;&amp; !changes[&#x27;followUserLocation&#x27;].firstChange) {
      if (this.followUserLocation) {
        this.startFollowingLocation();
      } else {
        this.stopFollowingLocation();
      }
    }
    if (changes[&#x27;lockZoomRotation&#x27;] &amp;&amp; !changes[&#x27;lockZoomRotation&#x27;].firstChange) {
      this.setupLockControls();
    }
    if (
      changes[&#x27;showDeliveryIsochrone&#x27;] ||
      changes[&#x27;selectedCarId&#x27;] ||
      changes[&#x27;deliveryTimeMinutes&#x27;]
    ) {
      if (this.showDeliveryIsochrone &amp;&amp; this.selectedCarId &amp;&amp; this.map) {
        this.addDeliveryIsochrone();
      } else {
        this.removeDeliveryIsochrone();
      }
    }
    if (changes[&#x27;showDirectionsRoute&#x27;] || changes[&#x27;selectedCarId&#x27;] || changes[&#x27;userLocation&#x27;]) {
      if (this.showDirectionsRoute &amp;&amp; this.selectedCarId &amp;&amp; this.userLocation &amp;&amp; this.map) {
        this.addDirectionsRoute();
      } else {
        this.removeDirectionsRoute();
      }
    }
  }

  /**
   * Maneja el toggle de capas del mapa
   */
  onLayerToggle(event: { layerId: string; visible: boolean }): void {
    switch (event.layerId) {
      case &#x27;base-map&#x27;:
        this.showBaseMap.set(event.visible);
        // Ocultar/mostrar el mapa base (si es necesario)
        if (this.map) {
          const container &#x3D; this.map.getContainer();
          container.style.opacity &#x3D; event.visible ? &#x27;1&#x27; : &#x27;0.3&#x27;;
        }
        break;
      case &#x27;user-location&#x27;:
        this.showUserLocation.set(event.visible);
        if (event.visible) {
          this.addUserLocationMarker();
        } else {
          if (this.userLocationMarker) {
            this.userLocationMarker.remove();
            this.userLocationMarker &#x3D; null;
          }
        }
        break;
      case &#x27;marketplace-cars&#x27;:
        this.showMarketplaceCars.set(event.visible);
        if (event.visible) {
          this.renderCarMarkers();
        } else {
          this.clearMarkers();
        }
        break;
      default:
        console.warn(&#x60;[CarsMap] Unhandled layer toggle: ${event.layerId}&#x60;);
        break;
    }
  }
}
</code></pre>
    </div>
</div>









                   </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div>
</div>
               <!-- END CONTENT -->
           </div>
       </div>

          <label class="dark-mode-switch">
               <input type="checkbox">
               <span class="slider">
                    <svg class="slider-icon" viewBox="0 0 24 24" fill="none" height="20" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" width="20" xmlns="http://www.w3.org/2000/svg">
                    <path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"></path>
                    </svg>
               </span>
          </label>

       <script>
            var COMPODOC_CURRENT_PAGE_DEPTH = 1;
            var COMPODOC_CURRENT_PAGE_CONTEXT = 'class';
            var COMPODOC_CURRENT_PAGE_URL = 'QuadTree-1.html';
            var MAX_SEARCH_RESULTS = 15;
       </script>

       <script>
               $darkModeToggleSwitchers = document.querySelectorAll('.dark-mode-switch input');
               checkToggle(darkModeState);
               if ($darkModeToggleSwitchers.length > 0) {
                    for (var i = 0; i < $darkModeToggleSwitchers.length; i++) {
                         $darkModeToggleSwitchers[i].addEventListener('change', function (event) {
                              darkModeState = !darkModeState;
                              toggleDarkMode(darkModeState);
                         });
                    }
               }
          </script>

       <script src="../js/libs/custom-elements.min.js"></script>
       <script src="../js/libs/lit-html.js"></script>

       <script src="../js/menu-wc.js" defer></script>
       <script nomodule src="../js/menu-wc_es5.js" defer></script>

       <script src="../js/libs/bootstrap-native.js"></script>

       <script src="../js/libs/es6-shim.min.js"></script>
       <script src="../js/libs/EventDispatcher.js"></script>
       <script src="../js/libs/promise.min.js"></script>

       <script src="../js/compodoc.js"></script>

       <script src="../js/tabs.js"></script>
       <script src="../js/menu.js"></script>
       <script src="../js/libs/clipboard.min.js"></script>
       <script src="../js/libs/prism.js"></script>
       <script src="../js/sourceCode.js"></script>
          <script src="../js/search/search.js"></script>
          <script src="../js/search/lunr.min.js"></script>
          <script src="../js/search/search-lunr.js"></script>
          <script src="../js/search/search_index.js"></script>
       <script src="../js/lazy-load-graphs.js"></script>


    </body>
</html>
