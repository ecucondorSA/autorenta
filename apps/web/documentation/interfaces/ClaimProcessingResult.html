<!doctype html>
<html class="no-js" lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>autorenta-web documentation</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="icon" type="image/x-icon" href="../images/favicon.ico">
	   <link rel="stylesheet" href="../styles/style.css">
        <link rel="stylesheet" href="../styles/dark.css">
    </head>
    <body>
          <script>
               // Blocking script to avoid flickering dark mode
               // Dark mode toggle button
               var useDark = window.matchMedia('(prefers-color-scheme: dark)');
               var darkModeState = useDark.matches;
               var $darkModeToggleSwitchers = document.querySelectorAll('.dark-mode-switch input');
               var $darkModeToggles = document.querySelectorAll('.dark-mode-switch');
               var darkModeStateLocal = localStorage.getItem('compodoc_darkmode-state');

               function checkToggle(check) {
                    for (var i = 0; i < $darkModeToggleSwitchers.length; i++) {
                         $darkModeToggleSwitchers[i].checked = check;
                    }
               }

               function toggleDarkMode(state) {
                    if (window.localStorage) {
                         localStorage.setItem('compodoc_darkmode-state', state);
                    }

                    checkToggle(state);

                    const hasClass = document.body.classList.contains('dark');

                    if (state) {
                         for (var i = 0; i < $darkModeToggles.length; i++) {
                              $darkModeToggles[i].classList.add('dark');
                         }
                         if (!hasClass) {
                              document.body.classList.add('dark');
                         }
                    } else {
                         for (var i = 0; i < $darkModeToggles.length; i++) {
                              $darkModeToggles[i].classList.remove('dark');
                         }
                         if (hasClass) {
                              document.body.classList.remove('dark');
                         }
                    }
               }

               useDark.addEventListener('change', function (evt) {
                    toggleDarkMode(evt.matches);
               });
               if (darkModeStateLocal) {
                    darkModeState = darkModeStateLocal === 'true';
               }
               toggleDarkMode(darkModeState);
          </script>
          <script>
              // --- Iframe navigation tracking for Template Playground ---
              function sendCurrentUrlToParent() {
                  if (window.parent && window.parent !== window) {
                      window.parent.postMessage({
                          type: 'compodoc-iframe-navigate',
                          url: window.location.pathname + window.location.hash
                      }, '*');
                  }
              }
              window.addEventListener('hashchange', sendCurrentUrlToParent, false);
              window.addEventListener('popstate', sendCurrentUrlToParent, false);
              window.addEventListener('DOMContentLoaded', sendCurrentUrlToParent, false);
          </script>

        <div class="navbar navbar-default navbar-fixed-top d-md-none p-0">
               <div class="d-flex">
                    <a href="../" class="navbar-brand">autorenta-web documentation</a>
                    <button type="button" class="btn btn-default btn-menu ion-ios-menu" id="btn-menu"></button>
               </div>
        </div>

        <div class="xs-menu menu" id="mobile-menu">
                <div id="book-search-input" role="search"><input type="text" placeholder="Type to search"></div>            <compodoc-menu></compodoc-menu>
        </div>

        <div class="container-fluid main">
           <div class="row main">
               <div class="d-none d-md-block menu">
                   <compodoc-menu mode="normal"></compodoc-menu>
               </div>
               <!-- START CONTENT -->
               <div class="content interface">
                   <div class="content-data">

















<ol class="breadcrumb">
  <li class="breadcrumb-item">Interfaces</li>
  <li class="breadcrumb-item"
  >
  ClaimProcessingResult</li>
</ol>

<ul class="nav nav-tabs" role="tablist">
        <li class="nav-item">
            <a href="#info" 
                class="nav-link"
                class="nav-link active"
                role="tab" id="info-tab" data-bs-toggle="tab" data-link="info">Info</a>
        </li>
        <li class="nav-item">
            <a href="#source" 
                class="nav-link"
                
                role="tab" id="source-tab" data-bs-toggle="tab" data-link="source">Source</a>
        </li>
</ul>

<div class="tab-content">
    <div class="tab-pane fade active in" id="info">
        <p class="comment">
            <h3>File</h3>
        </p>
        <p class="comment">
            <code>src/app/core/services/settlement.service.ts</code>
        </p>


            <p class="comment">
                <h3>Description</h3>
            </p>
            <p class="comment">
                <p>Resultado de procesamiento de claim</p>

            </p>


        <section data-compodoc="block-index">
            <h3 id="index">Index</h3>
            <table class="table table-sm table-bordered index-table">
                <tbody>
                    <tr>
                        <td class="col-md-4">
                            <h6><b>Properties</b></h6>
                        </td>
                    </tr>
                    <tr>
                        <td class="col-md-4">
                            <ul class="index-list">
                                <li>
                                        <a href="#claim" 
>
                                            claim
                                        </a>
                                </li>
                                <li>
                                            <span class="modifier">Optional</span>
                                        <a href="#eligibility" 
>
                                            eligibility
                                        </a>
                                </li>
                                <li>
                                            <span class="modifier">Optional</span>
                                        <a href="#error" 
>
                                            error
                                        </a>
                                </li>
                                <li>
                                        <a href="#ok" 
>
                                            ok
                                        </a>
                                </li>
                                <li>
                                            <span class="modifier">Optional</span>
                                        <a href="#waterfall" 
>
                                            waterfall
                                        </a>
                                </li>
                            </ul>
                        </td>
                    </tr>
                </tbody>
            </table>
        </section>



            <section data-compodoc="block-properties">
                <h3 id="inputs">Properties</h3>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="claim"></a>
                                        <span class="name "><b>claim</b>
                                            <a href="#claim">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>claim:         <code><a href="../interfaces/Claim.html" target="_self" >Claim</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="../interfaces/Claim.html" target="_self" >Claim</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="eligibility"></a>
                                        <span class="name "><b>eligibility</b>
                                            <a href="#eligibility">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>eligibility:         <code><a href="../interfaces/EligibilityResult.html" target="_self" >EligibilityResult | null</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="../interfaces/EligibilityResult.html" target="_self" >EligibilityResult | null</a></code>

                                        </td>
                                    </tr>

                                    <tr>
                                        <td class="col-md-4">
                                            <i>Optional</i>
                                        </td>
                                    </tr>




                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="error"></a>
                                        <span class="name "><b>error</b>
                                            <a href="#error">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>error:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>

                                        </td>
                                    </tr>

                                    <tr>
                                        <td class="col-md-4">
                                            <i>Optional</i>
                                        </td>
                                    </tr>




                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="ok"></a>
                                        <span class="name "><b>ok</b>
                                            <a href="#ok">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>ok:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/boolean" target="_blank" >boolean</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/boolean" target="_blank" >boolean</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="waterfall"></a>
                                        <span class="name "><b>waterfall</b>
                                            <a href="#waterfall">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>waterfall:         <code><a href="../interfaces/WaterfallResult.html" target="_self" >WaterfallResult</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="../interfaces/WaterfallResult.html" target="_self" >WaterfallResult</a></code>

                                        </td>
                                    </tr>

                                    <tr>
                                        <td class="col-md-4">
                                            <i>Optional</i>
                                        </td>
                                    </tr>




                        </tbody>
                    </table>
            </section>
    </div>


    <div class="tab-pane fade  tab-source-code" id="source">
        <pre class="line-numbers compodoc-sourcecode"><code class="language-typescript">import { Injectable, signal, inject } from &#x27;@angular/core&#x27;;
import { firstValueFrom } from &#x27;rxjs&#x27;;
import { SupabaseClient } from &#x27;@supabase/supabase-js&#x27;;
import {
  EligibilityResult,
  WaterfallResult,
  WaterfallBreakdown,
  InspectionStage,
  BookingInspection,
  CurrencyCode,
  centsToUsd,
  usdToCents,
  calculateWaterfallTotal,
  isInspectionComplete,
} from &#x27;../models/fgo-v1-1.model&#x27;;
import { SupabaseClientService } from &#x27;./supabase-client.service&#x27;;
import { FgoV1_1Service } from &#x27;./fgo-v1-1.service&#x27;;
import { RiskMatrixService } from &#x27;./risk-matrix.service&#x27;;
import { FgoService } from &#x27;./fgo.service&#x27;;
import { DamageDetectionService } from &#x27;./damage-detection.service&#x27;;
import { PaymentAuthorizationService } from &#x27;./payment-authorization.service&#x27;;
import { LoggerService } from &#x27;./logger.service&#x27;;

/**
 * Tipo de daño reportado
 */
export type DamageType &#x3D;
  | &#x27;scratch&#x27; // Rayón
  | &#x27;dent&#x27; // Abolladura
  | &#x27;broken_glass&#x27; // Vidrio roto
  | &#x27;tire_damage&#x27; // Daño en neumático
  | &#x27;mechanical&#x27; // Falla mecánica
  | &#x27;interior&#x27; // Daño interior
  | &#x27;missing_item&#x27; // Artículo faltante
  | &#x27;other&#x27;; // Otro

/**
 * Daño individual reportado
 */
export interface DamageItem {
  type: DamageType;
  description: string;
  estimatedCostUsd: number;
  photos: string[]; // URLs de evidencia
  severity: &#x27;minor&#x27; | &#x27;moderate&#x27; | &#x27;severe&#x27;;
}

/**
 * Claim (reclamo) de siniestro
 */
export interface Claim {
  id: string;
  bookingId: string;
  reportedBy: string; // locador_id
  damages: DamageItem[];
  totalEstimatedCostUsd: number;
  status: &#x27;draft&#x27; | &#x27;submitted&#x27; | &#x27;under_review&#x27; | &#x27;approved&#x27; | &#x27;rejected&#x27; | &#x27;paid&#x27; | &#x27;processing&#x27;;
  notes?: string;
  createdAt: Date;
  updatedAt: Date;
  // P0-SECURITY: Lock fields for optimistic locking
  lockedAt?: Date;
  lockedBy?: string;
  processedAt?: Date;
}

/**
 * Resultado de procesamiento de claim
 */
export interface ClaimProcessingResult {
  ok: boolean;
  claim: Claim;
  eligibility?: EligibilityResult | null;
  waterfall?: WaterfallResult;
  error?: string;
}

/**
 * Servicio de Settlement (Liquidación de Siniestros)
 *
 * Orquesta el flujo completo:
 * 1. Validar evidencias (inspecciones check-in/out)
 * 2. Crear claim con daños reportados
 * 3. Evaluar elegibilidad FGO
 * 4. Ejecutar waterfall de cobros
 * 5. Actualizar estado del booking
 */
@Injectable({
  providedIn: &#x27;root&#x27;,
})
export class SettlementService {
  private readonly supabaseClient: SupabaseClient;

  // Estado reactivo
  readonly processing &#x3D; signal(false);
  readonly currentClaim &#x3D; signal&lt;Claim | null&gt;(null);
  readonly error &#x3D; signal&lt;string | null&gt;(null);

  private readonly damageDetectionService &#x3D; inject(DamageDetectionService);
  private readonly paymentAuthorizationService &#x3D; inject(PaymentAuthorizationService);
  private readonly logger &#x3D; inject(LoggerService).createChildLogger(&#x27;Settlement&#x27;);

  constructor(
    private readonly supabaseService: SupabaseClientService,
    private readonly fgoV1_1Service: FgoV1_1Service,
    private readonly riskMatrixService: RiskMatrixService,
    private readonly fgoService: FgoService,
  ) {
    this.supabaseClient &#x3D; this.supabaseService.getClient();
  }

  // &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
  // VALIDACIÓN DE EVIDENCIAS
  // &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;

  /**
   * Valida que un booking tenga inspecciones completas (check-in y check-out)
   */
  async validateInspections(
    bookingId: string,
  ): Promise&lt;{ valid: boolean; missing: InspectionStage[] }&gt; {
    try {
      const inspections &#x3D; await firstValueFrom(this.fgoV1_1Service.getInspections(bookingId));

      const hasCheckIn &#x3D; inspections.some((i) &#x3D;&gt; i.stage &#x3D;&#x3D;&#x3D; &#x27;check_in&#x27; &amp;&amp; isInspectionComplete(i));
      const hasCheckOut &#x3D; inspections.some(
        (i) &#x3D;&gt; i.stage &#x3D;&#x3D;&#x3D; &#x27;check_out&#x27; &amp;&amp; isInspectionComplete(i),
      );

      const missing: InspectionStage[] &#x3D; [];
      if (!hasCheckIn) missing.push(&#x27;check_in&#x27;);
      if (!hasCheckOut) missing.push(&#x27;check_out&#x27;);

      return {
        valid: missing.length &#x3D;&#x3D;&#x3D; 0,
        missing,
      };
    } catch {
      return { valid: false, missing: [&#x27;check_in&#x27;, &#x27;check_out&#x27;] };
    }
  }

  /**
   * Compara check-in vs check-out para detectar daños nuevos automáticamente
   *
   * Utiliza análisis de imágenes para detectar cambios entre inspecciones.
   * Retorna array de daños detectados automáticamente.
   */
  async compareDamages(bookingId: string): Promise&lt;DamageItem[]&gt; {
    try {
      const inspections &#x3D; await firstValueFrom(this.fgoV1_1Service.getInspections(bookingId));

      const checkIn &#x3D; inspections.find((i) &#x3D;&gt; i.stage &#x3D;&#x3D;&#x3D; &#x27;check_in&#x27;);
      const checkOut &#x3D; inspections.find((i) &#x3D;&gt; i.stage &#x3D;&#x3D;&#x3D; &#x27;check_out&#x27;);

      if (!checkIn || !checkOut) {
        console.warn(&#x60;compareDamages: Missing inspections for booking ${bookingId}&#x60;);
        return [];
      }

      // Extraer URLs de fotos
      const checkInImages &#x3D; this.extractImageUrls(checkIn);
      const checkOutImages &#x3D; this.extractImageUrls(checkOut);

      if (checkInImages.length &#x3D;&#x3D;&#x3D; 0 || checkOutImages.length &#x3D;&#x3D;&#x3D; 0) {
        console.warn(&#x60;compareDamages: No images to analyze for booking ${bookingId}&#x60;);
        return [];
      }

      // Analizar imágenes con detección automática
      const analysisResult &#x3D; await this.damageDetectionService.analyzeImages(
        checkInImages,
        checkOutImages,
      );

      if (!analysisResult.success) {
        console.error(
          &#x60;compareDamages: Analysis failed for booking ${bookingId}:&#x60;,
          analysisResult.error,
        );
        return [];
      }

      // Convertir resultados a DamageItem[]
      return this.damageDetectionService.convertToDamageItems(analysisResult.damages);
    } catch (error) {
      console.error(&#x60;compareDamages: Error analyzing damages for booking ${bookingId}:&#x60;, error);
      return [];
    }
  }

  /**
   * Extrae URLs de imágenes de una inspección
   * @private
   */
  private extractImageUrls(inspection: BookingInspection | undefined): string[] {
    if (!inspection) return [];

    const images: string[] &#x3D; [];
    const insp &#x3D; inspection as unknown as {
      photos?: string[];
      images?: string[];
      photo_urls?: string[];
    };

    // Suportar diferentes estructuras de almacenamiento de fotos
    if (Array.isArray(insp.photos)) {
      images.push(...insp.photos);
    }

    if (Array.isArray(insp.images)) {
      images.push(...insp.images);
    }

    if (insp.photo_urls) {
      const urls &#x3D; insp.photo_urls;
      if (Array.isArray(urls)) {
        images.push(...urls);
      }
    }

    // Filtrar URLs vacías y duplicadas
    return Array.from(new Set(images.filter((url) &#x3D;&gt; url &amp;&amp; typeof url &#x3D;&#x3D;&#x3D; &#x27;string&#x27;)));
  }

  // &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
  // GESTIÓN DE CLAIMS
  // &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;

  /**
   * Crea un claim de siniestro
   * P0-SECURITY: Includes anti-fraud validation before creating claim
   */
  async createClaim(
    bookingId: string,
    damages: DamageItem[],
    notes?: string,
  ): Promise&lt;Claim | null&gt; {
    try {
      this.processing.set(true);
      this.error.set(null);

      // Validar evidencias
      const validation &#x3D; await this.validateInspections(bookingId);
      if (!validation.valid) {
        this.error.set(&#x60;Faltan inspecciones: ${validation.missing.join(&#x27;, &#x27;)}&#x60;);
        return null;
      }

      // Calcular total
      const totalEstimatedCostUsd &#x3D; damages.reduce((sum, d) &#x3D;&gt; sum + d.estimatedCostUsd, 0);

      // Obtener usuario actual
      const {
        data: { user },
      } &#x3D; await this.supabaseClient.auth.getUser();
      if (!user) {
        this.error.set(&#x27;Usuario no autenticado&#x27;);
        return null;
      }

      // P0-SECURITY: Anti-fraud validation
      const fraudCheck &#x3D; await this.validateClaimAntiFraud(
        bookingId,
        user.id,
        totalEstimatedCostUsd,
      );
      if (fraudCheck.blocked) {
        this.error.set(fraudCheck.blockReason || &#x27;Claim bloqueado por validación anti-fraude&#x27;);
        return null;
      }

      // Log warnings for manual review (don&#x27;t block)
      if (fraudCheck.warnings &amp;&amp; fraudCheck.warnings.length &gt; 0) {
        console.warn(&#x27;[SettlementService] Claim fraud warnings:&#x27;, {
          bookingId,
          userId: user.id,
          totalEstimatedCostUsd,
          warnings: fraudCheck.warnings,
        });
      }

      // P0-SECURITY: Generate claim ID server-side (not client-side)
      const { data: claimData, error: insertError } &#x3D; await this.supabaseClient
        .from(&#x27;claims&#x27;)
        .insert({
          booking_id: bookingId,
          reported_by: user.id,
          damages: damages,
          total_estimated_cost_usd: totalEstimatedCostUsd,
          status: &#x27;draft&#x27;,
          notes,
          fraud_warnings: fraudCheck.warnings || [],
          owner_claims_30d: fraudCheck.ownerClaims30d || 0,
        })
        .select(&#x27;id&#x27;)
        .single();

      // Fallback to in-memory claim if DB insert fails (for backwards compatibility)
      const claimId &#x3D; claimData?.id || crypto.randomUUID();
      if (insertError) {
        console.warn(
          &#x27;[SettlementService] Could not persist claim to DB, using in-memory:&#x27;,
          insertError,
        );
      }

      const claim: Claim &#x3D; {
        id: claimId,
        bookingId,
        reportedBy: user.id,
        damages,
        totalEstimatedCostUsd,
        status: &#x27;draft&#x27;,
        notes,
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      this.currentClaim.set(claim);
      return claim;
    } catch (err) {
      console.error(&#x27;[SettlementService] Error creating claim:&#x27;, err);
      this.error.set(&#x27;Error al crear el claim&#x27;);
      return null;
    } finally {
      this.processing.set(false);
    }
  }

  /**
   * P0-SECURITY: Anti-fraud validation for claims
   * Calls the database function that checks for:
   * - Short booking duration (&lt;24h)
   * - High claim frequency (3+ in 30 days)
   * - Unusually high amounts
   * - Suspicious round numbers
   */
  private async validateClaimAntiFraud(
    bookingId: string,
    ownerId: string,
    totalEstimatedUsd: number,
  ): Promise&lt;{
    ok: boolean;
    blocked: boolean;
    blockReason?: string;
    warnings?: Array&lt;{ type: string; message: string; value?: number }&gt;;
    ownerClaims30d?: number;
  }&gt; {
    try {
      const { data, error } &#x3D; await this.supabaseClient.rpc(&#x27;validate_claim_anti_fraud&#x27;, {
        p_booking_id: bookingId,
        p_owner_id: ownerId,
        p_total_estimated_usd: totalEstimatedUsd,
      });

      if (error) {
        console.warn(&#x27;[SettlementService] Anti-fraud check failed, allowing claim:&#x27;, error);
        // Don&#x27;t block if validation fails - fail open for UX
        return { ok: true, blocked: false };
      }

      const result &#x3D; data as {
        ok: boolean;
        blocked: boolean;
        block_reason?: string;
        warnings?: Array&lt;{ type: string; message: string; value?: number }&gt;;
        owner_claims_30d?: number;
      };

      return {
        ok: result.ok,
        blocked: result.blocked,
        blockReason: result.block_reason,
        warnings: result.warnings,
        ownerClaims30d: result.owner_claims_30d,
      };
    } catch (err) {
      console.warn(&#x27;[SettlementService] Anti-fraud validation exception:&#x27;, err);
      // Fail open - don&#x27;t block on errors
      return { ok: true, blocked: false };
    }
  }

  /**
   * Evalúa elegibilidad de un claim sin ejecutar cobros
   */
  async evaluateClaim(claim: Claim): Promise&lt;EligibilityResult | null&gt; {
    try {
      this.processing.set(true);
      this.error.set(null);

      // Obtener snapshot de riesgo
      const snapshot &#x3D; await firstValueFrom(this.fgoV1_1Service.getRiskSnapshot(claim.bookingId));
      if (!snapshot) {
        this.error.set(&#x27;No se encontró snapshot de riesgo para el booking&#x27;);
        return null;
      }

      // Convertir total a centavos (moneda local)
      const claimAmountCents &#x3D; usdToCents(claim.totalEstimatedCostUsd * snapshot.fxSnapshot);

      // Evaluar elegibilidad
      const eligibility &#x3D; await firstValueFrom(
        this.fgoV1_1Service.assessEligibility({
          bookingId: claim.bookingId,
          claimAmountCents,
        }),
      );

      return eligibility;
    } catch {
      this.error.set(&#x27;Error al evaluar elegibilidad&#x27;);
      return null;
    } finally {
      this.processing.set(false);
    }
  }

  /**
   * Procesa un claim completo: evalúa y ejecuta waterfall
   * IMPORTANTE: Solo ejecutable por admins o sistema
   * P0-SECURITY: Implementa lock optimista para prevenir double-spend
   */
  async processClaim(claim: Claim): Promise&lt;ClaimProcessingResult&gt; {
    try {
      this.processing.set(true);
      this.error.set(null);

      // P0-SECURITY: Acquire optimistic lock BEFORE processing
      const lockResult &#x3D; await this.acquireClaimLock(claim.id);
      if (!lockResult.ok) {
        return {
          ok: false,
          claim,
          error: lockResult.error || &#x27;Claim is already being processed by another user&#x27;,
        };
      }

      // 1. Get risk policy and snapshot
      const snapshot &#x3D; await firstValueFrom(this.fgoV1_1Service.getRiskSnapshot(claim.bookingId));
      if (!snapshot) {
        return {
          ok: false,
          claim,
          error: &#x27;No se encontró snapshot de riesgo&#x27;,
        };
      }

      const { data: booking } &#x3D; await this.supabaseClient
        .from(&#x27;bookings&#x27;)
        .select(&#x27;car_id&#x27;)
        .eq(&#x27;id&#x27;, claim.bookingId)
        .single();
      if (!booking) {
        return {
          ok: false,
          claim,
          error: &#x27;No se encontró la reserva&#x27;,
        };
      }

      const { data: car } &#x3D; await this.supabaseClient
        .from(&#x27;cars&#x27;)
        .select(&#x27;price_per_day&#x27;)
        .eq(&#x27;id&#x27;, booking.car_id)
        .single();
      if (!car) {
        return {
          ok: false,
          claim,
          error: &#x27;No se encontró el auto&#x27;,
        };
      }

      const policy &#x3D; await this.riskMatrixService.getRiskPolicy(car.price_per_day);
      if (!policy) {
        return {
          ok: false,
          claim,
          error: &#x27;No se encontró política de riesgo&#x27;,
        };
      }

      // 2. Evaluate eligibility
      const eligibility &#x3D; await this.evaluateClaim(claim);
      if (!eligibility || !eligibility.eligible) {
        return {
          ok: false,
          claim: { ...claim, status: &#x27;rejected&#x27;, updatedAt: new Date() },
          eligibility,
          error: &#x60;Claim no elegible: ${eligibility?.reasons.join(&#x27;, &#x27;)}&#x60;,
        };
      }

      // 3. Execute waterfall
      const claimAmountCents &#x3D; usdToCents(claim.totalEstimatedCostUsd * snapshot.fxSnapshot);
      let remainingCents &#x3D; claimAmountCents;
      const breakdown: WaterfallBreakdown &#x3D; {
        holdCaptured: 0,
        walletDebited: 0,
        extraCharged: 0,
        fgoPaid: 0,
        remainingUncovered: 0,
      };

      if (snapshot.hasCard) {
        // With credit card
        const holdAmount &#x3D; snapshot.estimatedHoldAmount ?? 0;
        const captureAmount &#x3D; Math.min(remainingCents, holdAmount);

        // Implement partial capture logic with payment provider
        if (captureAmount &gt; 0 &amp;&amp; snapshot.authorizedPaymentId) {
          try {
            // Convert cents to ARS for payment provider (MercadoPago uses ARS)
            // Note: captureAmount is in USD cents, need to convert to ARS
            const captureAmountArs &#x3D; Math.round((captureAmount * snapshot.fxSnapshot) / 100);

            // Capture the partial amount from the credit card hold
            const captureResult &#x3D; await firstValueFrom(
              this.paymentAuthorizationService.captureAuthorization(
                snapshot.authorizedPaymentId,
                captureAmountArs,
              ),
            );

            if (captureResult.ok) {
              breakdown.holdCaptured &#x3D; captureAmount;
              this.logger.info(
                &#x60;Partial capture: ${centsToUsd(captureAmount)} USD &#x60; +
                  &#x60;(${captureAmountArs} ARS) from auth ${snapshot.authorizedPaymentId}&#x60;,
              );
            } else {
              // If capture fails, log the error but continue with waterfall
              this.logger.error(
                &#x60;Partial capture failed for auth ${snapshot.authorizedPaymentId}&#x60;,
                String(captureResult.error),
              );
              // Don&#x27;t mark as captured if it failed
              breakdown.holdCaptured &#x3D; 0;
            }
          } catch (error) {
            this.logger.error(&#x27;Partial capture exception&#x27;, String(error));
            // Don&#x27;t mark as captured if there was an exception
            breakdown.holdCaptured &#x3D; 0;
          }
        } else {
          // If no authorization ID or amount is 0, just record what we would have captured
          breakdown.holdCaptured &#x3D; captureAmount;
          if (!snapshot.authorizedPaymentId &amp;&amp; captureAmount &gt; 0) {
            this.logger.warn(&#x27;No authorization ID available for capture&#x27;);
          }
        }

        remainingCents -&#x3D; breakdown.holdCaptured;
      } else {
        // Without credit card - debit from wallet security deposit
        const securityCredit &#x3D; snapshot.estimatedDeposit ?? 0;
        const maxDebitCents &#x3D; Math.min(remainingCents, securityCredit);

        if (maxDebitCents &gt; 0) {
          // Call wallet debit RPC to actually debit from renter&#x27;s wallet
          const debitResult &#x3D; await this.debitWalletForDamage(
            claim.bookingId,
            claim.id,
            centsToUsd(maxDebitCents), // Convert cents to USD for RPC
          );

          if (debitResult.success) {
            // Convert debited USD back to cents for breakdown
            breakdown.walletDebited &#x3D; usdToCents(debitResult.debitedAmountUsd);
            remainingCents -&#x3D; breakdown.walletDebited;
            this.logger.info(
              &#x60;Wallet debit: ${debitResult.debitedAmountUsd} USD for booking ${claim.bookingId}&#x60;,
            );
          } else {
            // Wallet debit failed or insufficient funds
            // FGO will cover everything (per user decision)
            this.logger.warn(
              &#x60;Wallet debit failed: ${debitResult.error}. FGO will cover full amount.&#x60;,
            );
            breakdown.walletDebited &#x3D; 0;
          }
        }
        // Note: No top-up logic needed - FGO covers any remaining amount
      }

      // FGO Coverage - FGO covers ALL remaining (per business decision)
      // This ensures renters are never left with uncovered damages
      if (remainingCents &gt; 0) {
        // FGO covers the full remaining amount (not limited by maxCoverCents)
        // Business decision: FGO absorbs all risk when renter wallet insufficient
        const fgoCoverage &#x3D; remainingCents;

        // Log if exceeding normal coverage limits (for monitoring)
        if (fgoCoverage &gt; eligibility.maxCoverCents) {
          this.logger.warn(
            &#x60;FGO covering ${centsToUsd(fgoCoverage)} USD exceeds limit &#x60; +
              &#x60;${centsToUsd(eligibility.maxCoverCents)} USD for claim ${claim.id}&#x60;,
          );
        }

        try {
          // Convert from cents to USD for FGO service
          const fgoAmountUsd &#x3D; centsToUsd(fgoCoverage);

          // Record the FGO payout in the ledger
          // This creates an audit trail and updates the FGO reserve balance
          await this.fgoService.addPayout(
            fgoAmountUsd,
            claim.bookingId,
            snapshot.fxSnapshot, // Exchange rate at time of booking
          );

          // Track successful FGO payout in breakdown
          breakdown.fgoPaid &#x3D; fgoCoverage;
          remainingCents &#x3D; 0; // FGO covers everything

          // Log for audit trail
          this.logger.info(&#x60;FGO payout: ${fgoAmountUsd} USD for booking ${claim.bookingId}&#x60;);
        } catch (fgoError) {
          // If FGO payout fails, log error but continue with settlement
          // The claim still needs to be processed even if FGO recording fails
          this.logger.error(&#x27;FGO payout recording failed&#x27;, String(fgoError));

          // Still mark as paid in breakdown (payment intent exists)
          // Manual reconciliation may be needed
          breakdown.fgoPaid &#x3D; fgoCoverage;
          remainingCents &#x3D; 0; // Mark as covered for claim processing
        }
      }

      breakdown.remainingUncovered &#x3D; remainingCents;

      const waterfallResult: WaterfallResult &#x3D; {
        ok: true,
        bookingId: claim.bookingId,
        totalClaimCents: claimAmountCents,
        breakdown,
        executedAt: new Date(),
        eligibility: eligibility,
      };

      // 4. Update claim as paid in DB (releases lock)
      await this.markClaimAsPaid(claim.id);

      const updatedClaim: Claim &#x3D; {
        ...claim,
        status: &#x27;paid&#x27;,
        updatedAt: new Date(),
        processedAt: new Date(),
      };

      this.currentClaim.set(updatedClaim);

      return {
        ok: true,
        claim: updatedClaim,
        eligibility,
        waterfall: waterfallResult,
      };
    } catch (_error) {
      // P0-SECURITY: Release lock on failure so claim can be retried
      await this.releaseClaimLock(claim.id, &#x27;approved&#x27;);

      this.error.set(&#x27;Error al procesar claim&#x27;);
      return {
        ok: false,
        claim,
        error: String(_error),
      };
    } finally {
      this.processing.set(false);
    }
  }

  // &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
  // SIMULADORES Y HELPERS
  // &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;

  /**
   * Simula el resultado de un waterfall sin ejecutarlo (dry-run)
   */
  async simulateWaterfall(
    bookingId: string,
    claimAmountUsd: number,
  ): Promise&lt;{
    eligibility: EligibilityResult | null;
    estimatedBreakdown: Partial&lt;WaterfallBreakdown&gt; | null;
  }&gt; {
    try {
      // Obtener snapshot
      const snapshot &#x3D; await firstValueFrom(this.fgoV1_1Service.getRiskSnapshot(bookingId));
      if (!snapshot) {
        return { eligibility: null, estimatedBreakdown: null };
      }

      // Evaluar elegibilidad
      const claimAmountCents &#x3D; usdToCents(claimAmountUsd * snapshot.fxSnapshot);
      const eligibility &#x3D; await firstValueFrom(
        this.fgoV1_1Service.assessEligibility({
          bookingId,
          claimAmountCents,
        }),
      );

      if (!eligibility) {
        return { eligibility: null, estimatedBreakdown: null };
      }

      // Simular breakdown
      let remaining &#x3D; claimAmountCents;
      const breakdown: WaterfallBreakdown &#x3D; {
        holdCaptured: 0,
        walletDebited: 0,
        extraCharged: 0,
        fgoPaid: 0,
        remainingUncovered: 0,
      };

      // STEP 1: Hold
      if (snapshot.hasCard &amp;&amp; snapshot.estimatedHoldAmount) {
        breakdown.holdCaptured &#x3D; Math.min(remaining, snapshot.estimatedHoldAmount);
        remaining -&#x3D; breakdown.holdCaptured;
      }

      // STEP 2: Wallet
      if (snapshot.hasWalletSecurity &amp;&amp; snapshot.estimatedDeposit &amp;&amp; remaining &gt; 0) {
        breakdown.walletDebited &#x3D; Math.min(remaining, snapshot.estimatedDeposit);
        remaining -&#x3D; breakdown.walletDebited;
      }

      // STEP 3: Extra (hasta franquicia)
      if (remaining &gt; 0) {
        const franchiseCents &#x3D; snapshot.franchiseUsd * 100 * snapshot.fxSnapshot;
        const alreadyCharged &#x3D; breakdown.holdCaptured + breakdown.walletDebited;
        const maxExtra &#x3D; Math.max(0, franchiseCents - alreadyCharged);

        breakdown.extraCharged &#x3D; Math.min(remaining, maxExtra);
        remaining -&#x3D; breakdown.extraCharged;
      }

      // STEP 4: FGO
      if (remaining &gt; 0) {
        breakdown.fgoPaid &#x3D; Math.min(remaining, eligibility.maxCoverCents);
        remaining -&#x3D; breakdown.fgoPaid;
      }

      breakdown.remainingUncovered &#x3D; remaining;

      return { eligibility, estimatedBreakdown: breakdown };
    } catch {
      return { eligibility: null, estimatedBreakdown: null };
    }
  }

  /**
   * Calcula el costo estimado de daños según severidad y tipo
   */
  estimateDamageCost(type: DamageType, severity: &#x27;minor&#x27; | &#x27;moderate&#x27; | &#x27;severe&#x27;): number {
    // Costos base en USD
    const baseCosts: Record&lt;DamageType, number&gt; &#x3D; {
      scratch: 50,
      dent: 150,
      broken_glass: 300,
      tire_damage: 200,
      mechanical: 500,
      interior: 100,
      missing_item: 80,
      other: 100,
    };

    const multipliers &#x3D; {
      minor: 1.0,
      moderate: 2.0,
      severe: 4.0,
    };

    return baseCosts[type] * multipliers[severity];
  }

  /**
   * Formatea un breakdown de waterfall para mostrar al usuario
   */
  formatBreakdown(breakdown: WaterfallBreakdown, currency: CurrencyCode &#x3D; &#x27;USD&#x27;): string {
    const parts: string[] &#x3D; [];
    const symbol &#x3D; currency &#x3D;&#x3D;&#x3D; &#x27;USD&#x27; ? &#x27;$&#x27; : currency;

    if (breakdown.holdCaptured &gt; 0) {
      parts.push(&#x60;Hold: ${symbol}${centsToUsd(breakdown.holdCaptured)}&#x60;);
    }
    if (breakdown.walletDebited &gt; 0) {
      parts.push(&#x60;Wallet: ${symbol}${centsToUsd(breakdown.walletDebited)}&#x60;);
    }
    if (breakdown.extraCharged &gt; 0) {
      parts.push(&#x60;Adicional: ${symbol}${centsToUsd(breakdown.extraCharged)}&#x60;);
    }
    if (breakdown.fgoPaid &gt; 0) {
      parts.push(&#x60;FGO: ${symbol}${centsToUsd(breakdown.fgoPaid)}&#x60;);
    }

    const total &#x3D; calculateWaterfallTotal(breakdown);
    parts.push(&#x60;Total: ${symbol}${centsToUsd(total)}&#x60;);

    if (breakdown.remainingUncovered &gt; 0) {
      parts.push(&#x60;Sin cubrir: ${symbol}${centsToUsd(breakdown.remainingUncovered)}&#x60;);
    }

    return parts.join(&#x27; | &#x27;);
  }

  // &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
  // ESTADO Y UTILIDADES
  // &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;

  /**
   * Limpia el estado del servicio
   */
  clearState(): void {
    this.processing.set(false);
    this.currentClaim.set(null);
    this.error.set(null);
  }

  /**
   * Obtiene el estado actual
   */
  getState(): { processing: boolean; currentClaim: Claim | null; error: string | null } {
    return {
      processing: this.processing(),
      currentClaim: this.currentClaim(),
      error: this.error(),
    };
  }

  // &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
  // P0-SECURITY: CLAIM LOCKING (previene double-spend)
  // &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;

  /**
   * Acquire optimistic lock on a claim before processing
   * Uses atomic UPDATE with WHERE clause to prevent race conditions
   */
  private async acquireClaimLock(claimId: string): Promise&lt;{ ok: boolean; error?: string }&gt; {
    try {
      const {
        data: { user },
      } &#x3D; await this.supabaseClient.auth.getUser();
      if (!user) {
        return { ok: false, error: &#x27;Usuario no autenticado&#x27; };
      }

      // Atomic lock acquisition: only succeeds if claim is in &#x27;approved&#x27; status
      // and not already locked (locked_at is null or expired &gt; 5 minutes)
      const lockExpiry &#x3D; new Date(Date.now() - 5 * 60 * 1000).toISOString(); // 5 min expiry

      const { data, error } &#x3D; await this.supabaseClient
        .from(&#x27;claims&#x27;)
        .update({
          status: &#x27;processing&#x27;,
          locked_at: new Date().toISOString(),
          locked_by: user.id,
        })
        .eq(&#x27;id&#x27;, claimId)
        .eq(&#x27;status&#x27;, &#x27;approved&#x27;) // Only lock if still in approved state
        .or(&#x60;locked_at.is.null,locked_at.lt.${lockExpiry}&#x60;) // Not locked or lock expired
        .select()
        .single();

      if (error) {
        // Check if it&#x27;s a &quot;no rows returned&quot; error (claim already locked/processed)
        if (error.code &#x3D;&#x3D;&#x3D; &#x27;PGRST116&#x27;) {
          return {
            ok: false,
            error: &#x27;Claim ya está siendo procesado o no está en estado aprobado&#x27;,
          };
        }
        return { ok: false, error: error.message };
      }

      if (!data) {
        return {
          ok: false,
          error: &#x27;No se pudo adquirir lock - claim puede estar siendo procesado por otro usuario&#x27;,
        };
      }

      return { ok: true };
    } catch (err) {
      return {
        ok: false,
        error: err instanceof Error ? err.message : &#x27;Error al adquirir lock&#x27;,
      };
    }
  }

  /**
   * Release lock on a claim (called on error/failure)
   */
  private async releaseClaimLock(
    claimId: string,
    revertToStatus: &#x27;approved&#x27; | &#x27;rejected&#x27; &#x3D; &#x27;approved&#x27;,
  ): Promise&lt;void&gt; {
    try {
      await this.supabaseClient
        .from(&#x27;claims&#x27;)
        .update({
          status: revertToStatus,
          locked_at: null,
          locked_by: null,
        })
        .eq(&#x27;id&#x27;, claimId)
        .eq(&#x27;status&#x27;, &#x27;processing&#x27;); // Only release if still in processing
    } catch (err) {
      this.logger.error(&#x27;Failed to release claim lock&#x27;, String(err));
    }
  }

  /**
   * Mark claim as successfully paid (final state)
   */
  private async markClaimAsPaid(claimId: string): Promise&lt;void&gt; {
    try {
      await this.supabaseClient
        .from(&#x27;claims&#x27;)
        .update({
          status: &#x27;paid&#x27;,
          processed_at: new Date().toISOString(),
          locked_at: null,
          locked_by: null,
        })
        .eq(&#x27;id&#x27;, claimId);
    } catch (err) {
      this.logger.error(&#x27;Failed to mark claim as paid&#x27;, String(err));
    }
  }

  // &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
  // WALLET DEBIT FOR DAMAGES
  // &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;

  /**
   * Debit from renter&#x27;s wallet for damage claim
   * Uses the wallet_debit_for_damage RPC which handles:
   * - Balance verification
   * - Partial debit if insufficient funds
   * - Transaction recording
   *
   * @param bookingId - Booking ID for audit trail
   * @param claimId - Claim ID for audit trail
   * @param amountUsd - Amount to debit in USD
   * @returns Result with success status and amount actually debited
   */
  private async debitWalletForDamage(
    bookingId: string,
    claimId: string,
    amountUsd: number,
  ): Promise&lt;{ success: boolean; debitedAmountUsd: number; error?: string }&gt; {
    try {
      const { data, error } &#x3D; await this.supabaseClient.rpc(&#x27;wallet_debit_for_damage&#x27;, {
        p_booking_id: bookingId,
        p_claim_id: claimId,
        p_amount_usd: amountUsd,
      });

      if (error) {
        this.logger.error(&#x27;Wallet debit RPC error&#x27;, error.message);
        return { success: false, debitedAmountUsd: 0, error: error.message };
      }

      // RPC returns array with single row
      const result &#x3D; Array.isArray(data) ? data[0] : data;

      return {
        success: result?.success ?? false,
        debitedAmountUsd: result?.debited_amount_usd ?? 0,
        error: result?.error,
      };
    } catch (err) {
      this.logger.error(&#x27;Wallet debit exception&#x27;, String(err));
      return {
        success: false,
        debitedAmountUsd: 0,
        error: err instanceof Error ? err.message : &#x27;Unknown error&#x27;,
      };
    }
  }
}
</code></pre>
    </div>
</div>








                   </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div>
</div>
               <!-- END CONTENT -->
           </div>
       </div>

          <label class="dark-mode-switch">
               <input type="checkbox">
               <span class="slider">
                    <svg class="slider-icon" viewBox="0 0 24 24" fill="none" height="20" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" width="20" xmlns="http://www.w3.org/2000/svg">
                    <path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"></path>
                    </svg>
               </span>
          </label>

       <script>
            var COMPODOC_CURRENT_PAGE_DEPTH = 1;
            var COMPODOC_CURRENT_PAGE_CONTEXT = 'interface';
            var COMPODOC_CURRENT_PAGE_URL = 'ClaimProcessingResult.html';
            var MAX_SEARCH_RESULTS = 15;
       </script>

       <script>
               $darkModeToggleSwitchers = document.querySelectorAll('.dark-mode-switch input');
               checkToggle(darkModeState);
               if ($darkModeToggleSwitchers.length > 0) {
                    for (var i = 0; i < $darkModeToggleSwitchers.length; i++) {
                         $darkModeToggleSwitchers[i].addEventListener('change', function (event) {
                              darkModeState = !darkModeState;
                              toggleDarkMode(darkModeState);
                         });
                    }
               }
          </script>

       <script src="../js/libs/custom-elements.min.js"></script>
       <script src="../js/libs/lit-html.js"></script>

       <script src="../js/menu-wc.js" defer></script>
       <script nomodule src="../js/menu-wc_es5.js" defer></script>

       <script src="../js/libs/bootstrap-native.js"></script>

       <script src="../js/libs/es6-shim.min.js"></script>
       <script src="../js/libs/EventDispatcher.js"></script>
       <script src="../js/libs/promise.min.js"></script>

       <script src="../js/compodoc.js"></script>

       <script src="../js/tabs.js"></script>
       <script src="../js/menu.js"></script>
       <script src="../js/libs/clipboard.min.js"></script>
       <script src="../js/libs/prism.js"></script>
       <script src="../js/sourceCode.js"></script>
          <script src="../js/search/search.js"></script>
          <script src="../js/search/lunr.min.js"></script>
          <script src="../js/search/search-lunr.js"></script>
          <script src="../js/search/search_index.js"></script>
       <script src="../js/lazy-load-graphs.js"></script>


    </body>
</html>
