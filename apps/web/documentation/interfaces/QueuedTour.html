<!doctype html>
<html class="no-js" lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>autorenta-web documentation</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="icon" type="image/x-icon" href="../images/favicon.ico">
	   <link rel="stylesheet" href="../styles/style.css">
        <link rel="stylesheet" href="../styles/dark.css">
    </head>
    <body>
          <script>
               // Blocking script to avoid flickering dark mode
               // Dark mode toggle button
               var useDark = window.matchMedia('(prefers-color-scheme: dark)');
               var darkModeState = useDark.matches;
               var $darkModeToggleSwitchers = document.querySelectorAll('.dark-mode-switch input');
               var $darkModeToggles = document.querySelectorAll('.dark-mode-switch');
               var darkModeStateLocal = localStorage.getItem('compodoc_darkmode-state');

               function checkToggle(check) {
                    for (var i = 0; i < $darkModeToggleSwitchers.length; i++) {
                         $darkModeToggleSwitchers[i].checked = check;
                    }
               }

               function toggleDarkMode(state) {
                    if (window.localStorage) {
                         localStorage.setItem('compodoc_darkmode-state', state);
                    }

                    checkToggle(state);

                    const hasClass = document.body.classList.contains('dark');

                    if (state) {
                         for (var i = 0; i < $darkModeToggles.length; i++) {
                              $darkModeToggles[i].classList.add('dark');
                         }
                         if (!hasClass) {
                              document.body.classList.add('dark');
                         }
                    } else {
                         for (var i = 0; i < $darkModeToggles.length; i++) {
                              $darkModeToggles[i].classList.remove('dark');
                         }
                         if (hasClass) {
                              document.body.classList.remove('dark');
                         }
                    }
               }

               useDark.addEventListener('change', function (evt) {
                    toggleDarkMode(evt.matches);
               });
               if (darkModeStateLocal) {
                    darkModeState = darkModeStateLocal === 'true';
               }
               toggleDarkMode(darkModeState);
          </script>
          <script>
              // --- Iframe navigation tracking for Template Playground ---
              function sendCurrentUrlToParent() {
                  if (window.parent && window.parent !== window) {
                      window.parent.postMessage({
                          type: 'compodoc-iframe-navigate',
                          url: window.location.pathname + window.location.hash
                      }, '*');
                  }
              }
              window.addEventListener('hashchange', sendCurrentUrlToParent, false);
              window.addEventListener('popstate', sendCurrentUrlToParent, false);
              window.addEventListener('DOMContentLoaded', sendCurrentUrlToParent, false);
          </script>

        <div class="navbar navbar-default navbar-fixed-top d-md-none p-0">
               <div class="d-flex">
                    <a href="../" class="navbar-brand">autorenta-web documentation</a>
                    <button type="button" class="btn btn-default btn-menu ion-ios-menu" id="btn-menu"></button>
               </div>
        </div>

        <div class="xs-menu menu" id="mobile-menu">
                <div id="book-search-input" role="search"><input type="text" placeholder="Type to search"></div>            <compodoc-menu></compodoc-menu>
        </div>

        <div class="container-fluid main">
           <div class="row main">
               <div class="d-none d-md-block menu">
                   <compodoc-menu mode="normal"></compodoc-menu>
               </div>
               <!-- START CONTENT -->
               <div class="content interface">
                   <div class="content-data">

















<ol class="breadcrumb">
  <li class="breadcrumb-item">Interfaces</li>
  <li class="breadcrumb-item"
  >
  QueuedTour</li>
</ol>

<ul class="nav nav-tabs" role="tablist">
        <li class="nav-item">
            <a href="#info" 
                class="nav-link"
                class="nav-link active"
                role="tab" id="info-tab" data-bs-toggle="tab" data-link="info">Info</a>
        </li>
        <li class="nav-item">
            <a href="#source" 
                class="nav-link"
                
                role="tab" id="source-tab" data-bs-toggle="tab" data-link="source">Source</a>
        </li>
</ul>

<div class="tab-content">
    <div class="tab-pane fade active in" id="info">
        <p class="comment">
            <h3>File</h3>
        </p>
        <p class="comment">
            <code>src/app/core/guided-tour/services/tour-orchestrator.service.ts</code>
        </p>




        <section data-compodoc="block-index">
            <h3 id="index">Index</h3>
            <table class="table table-sm table-bordered index-table">
                <tbody>
                    <tr>
                        <td class="col-md-4">
                            <h6><b>Properties</b></h6>
                        </td>
                    </tr>
                    <tr>
                        <td class="col-md-4">
                            <ul class="index-list">
                                <li>
                                        <a href="#options" 
>
                                            options
                                        </a>
                                </li>
                                <li>
                                        <a href="#priority" 
>
                                            priority
                                        </a>
                                </li>
                                <li>
                                        <a href="#timestamp" 
>
                                            timestamp
                                        </a>
                                </li>
                                <li>
                                        <a href="#tourId" 
>
                                            tourId
                                        </a>
                                </li>
                            </ul>
                        </td>
                    </tr>
                </tbody>
            </table>
        </section>



            <section data-compodoc="block-properties">
                <h3 id="inputs">Properties</h3>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="options"></a>
                                        <span class="name "><b>options</b>
                                            <a href="#options">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>options:         <code><a href="../interfaces/TourRequestOptions.html" target="_self" >TourRequestOptions</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="../interfaces/TourRequestOptions.html" target="_self" >TourRequestOptions</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="priority"></a>
                                        <span class="name "><b>priority</b>
                                            <a href="#priority">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>priority:         <code><a href="../miscellaneous/enumerations.html#TourPriority" target="_self" >TourPriority</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="../miscellaneous/enumerations.html#TourPriority" target="_self" >TourPriority</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="timestamp"></a>
                                        <span class="name "><b>timestamp</b>
                                            <a href="#timestamp">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>timestamp:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/number" target="_blank" >number</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/number" target="_blank" >number</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="tourId"></a>
                                        <span class="name "><b>tourId</b>
                                            <a href="#tourId">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>tourId:         <code><a href="../miscellaneous/enumerations.html#TourId" target="_self" >TourId</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="../miscellaneous/enumerations.html#TourId" target="_self" >TourId</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
            </section>
    </div>


    <div class="tab-pane fade  tab-source-code" id="source">
        <pre class="line-numbers compodoc-sourcecode"><code class="language-typescript">import { inject, Injectable, OnDestroy, signal } from &#x27;@angular/core&#x27;;
import { NavigationEnd, Router } from &#x27;@angular/router&#x27;;
import { filter, Subscription } from &#x27;rxjs&#x27;;
import { ShepherdAdapterService } from &#x27;../adapters/shepherd-adapter.service&#x27;;
import {
  StepDefinition,
  TourDefinition,
  TourId,
  TourPriority,
  TourRequestOptions,
  TourState,
} from &#x27;../interfaces/tour-definition.interface&#x27;;
import { TourRegistryService } from &#x27;../registry/tour-registry.service&#x27;;
import { StepResolverService } from &#x27;../resolvers/step-resolver.service&#x27;;
import { TelemetryBridgeService } from &#x27;./telemetry-bridge.service&#x27;;

interface QueuedTour {
  tourId: TourId;
  options: TourRequestOptions;
  priority: TourPriority;
  timestamp: number;
}

@Injectable({
  providedIn: &#x27;root&#x27;,
})
export class TourOrchestratorService implements OnDestroy {
  private readonly STORAGE_PREFIX &#x3D; &#x27;autorenta:tour:&#x27;;
  private readonly router &#x3D; inject(Router);
  private readonly registry &#x3D; inject(TourRegistryService);
  private readonly adapter &#x3D; inject(ShepherdAdapterService);
  private readonly resolver &#x3D; inject(StepResolverService);
  private readonly telemetry &#x3D; inject(TelemetryBridgeService);

  // Reactive state using Angular Signals
  private stateSignal &#x3D; signal&lt;TourState&gt;({
    activeTourId: null,
    currentStepIndex: 0,
    isRunning: false,
    isPaused: false,
    completedTours: new Set&lt;string&gt;(),
  });

  readonly state &#x3D; this.stateSignal.asReadonly();

  private queue: QueuedTour[] &#x3D; [];
  private routeSubscription?: Subscription;
  private currentDefinition?: TourDefinition;
  private stepIndexMap &#x3D; new Map&lt;string, number&gt;();
  private isCancelling &#x3D; false; // Prevent infinite loop

  constructor() {
    this.loadCompletedTours();
    this.setupRouteListener();
  }

  /**
   * Request a tour to be started
   */
  async requestTour(options: TourRequestOptions): Promise&lt;boolean&gt; {
    const { id, force &#x3D; false } &#x3D; options;

    // Get definition
    const definition &#x3D; this.registry.getDefinition(id);
    if (!definition) {
      return false;
    }

    // Check if should skip
    if (!force &amp;&amp; this.shouldSkipTour(definition)) {
      return false;
    }

    // Evaluate guards
    const guardsPass &#x3D; await this.evaluateGuards(definition.guards || []);
    if (!guardsPass &amp;&amp; !force) {
      return false;
    }

    // Check if a tour is already running
    if (this.state().isRunning &amp;&amp; !force) {
      this.enqueueTour({
        tourId: id,
        options,
        priority: definition.priority || TourPriority.Normal,
        timestamp: Date.now(),
      });
      return false;
    }

    // Start tour
    await this.startTour(definition, options);
    return true;
  }

  /**
   * Cancel the current tour
   */
  cancelTour(): void {
    // Prevent infinite recursion (onCancel callback calls cancelTour again)
    if (this.isCancelling) return;
    if (!this.state().isRunning) return;

    this.isCancelling &#x3D; true;

    try {
      const tourId &#x3D; this.state().activeTourId;
      if (tourId) {
        this.telemetry.trackTourCancelled(tourId, this.adapter.getCurrentStepId());
      }

      this.adapter.cancel();
      this.cleanupTour();
      this.processQueue();
    } finally {
      this.isCancelling &#x3D; false;
    }
  }

  /**
   * Complete the current tour
   */
  completeTour(): void {
    const tourId &#x3D; this.state().activeTourId;
    if (!tourId) return;

    this.markTourCompleted(tourId);
    this.telemetry.trackTourCompleted(tourId);
    this.adapter.complete();
    this.cleanupTour();
    this.processQueue();
  }

  /**
   * Dismiss tour temporarily (will show again after throttle period)
   */
  dismissTour(tourId: TourId): void {
    const definition &#x3D; this.currentDefinition || this.registry.getDefinition(tourId);
    if (!definition) return;

    const throttleMs &#x3D; (definition.throttleHours || 24) * 60 * 60 * 1000;
    const resumeAt &#x3D; Date.now() + throttleMs;

    this.saveToStorage(&#x60;${tourId}:dismissed-until&#x60;, resumeAt.toString());
    this.telemetry.trackTourCancelled(tourId, this.adapter.getCurrentStepId(), {
      dismissed: true,
    });

    this.adapter.cancel();
    this.cleanupTour();
  }

  /**
   * Reset tour state (for testing or manual restart)
   */
  resetTour(tourId: TourId): void {
    this.clearTourStorage(tourId);
    this.stateSignal.update((state) &#x3D;&gt; {
      const completed &#x3D; new Set(state.completedTours);
      completed.delete(tourId);
      return { ...state, completedTours: completed };
    });
  }

  /**
   * Get available tours that can be started
   */
  getAvailableTours(): TourDefinition[] {
    return this.registry.getAllDefinitions().filter((def) &#x3D;&gt; !this.shouldSkipTour(def));
  }

  /**
   * Check if a tour has been completed
   */
  hasTourBeenCompleted(tourId: TourId): boolean {
    return this.state().completedTours.has(tourId);
  }

  // Private Methods

  private async startTour(definition: TourDefinition, options: TourRequestOptions): Promise&lt;void&gt; {
    try {
      this.currentDefinition &#x3D; definition;

      // Update state
      this.stateSignal.update((state) &#x3D;&gt; ({
        ...state,
        activeTourId: definition.id,
        currentStepIndex: 0,
        isRunning: true,
        isPaused: false,
      }));

      // Track start
      this.telemetry.trackTourStarted(definition.id, {
        mode: options.mode,
        reason: options.reason,
      });

      // Create tour with adapter
      await this.adapter.createTour(definition.id, {
        useModalOverlay: true,
        canClickTarget: true,
      });

      // Add steps
      for (let i &#x3D; 0; i &lt; definition.steps.length; i++) {
        const step &#x3D; definition.steps[i];
        this.stepIndexMap.set(step.id, i);
        await this.addStepToTour(step, i, definition.steps.length);
      }

      // Start the tour
      this.adapter.start();
    } catch (error) {
      this.telemetry.trackTourError(definition.id, error instanceof Error ? error : String(error));
      this.cleanupTour();
    }
  }

  private async addStepToTour(
    step: StepDefinition,
    index: number,
    totalSteps: number,
  ): Promise&lt;void&gt; {
    // Resolve responsive configuration
    const resolvedStep &#x3D; this.resolveResponsiveStep(step);

    this.adapter.addStep(resolvedStep, {
      onShow: async () &#x3D;&gt; {
        // Execute onBefore hook
        if (step.onBefore) {
          await step.onBefore();
        }

        // Resolve target
        if (step.target) {
          const element &#x3D; await this.resolver.resolveStepTarget(step.target, {
            timeout: 10000,
            onTimeout: step.target.required ? &#x27;abort&#x27; : &#x27;skip&#x27;,
          });

          if (!element &amp;&amp; step.target.required) {
            this.adapter.next();
            return;
          }

          // Scroll to element if needed
          if (element &amp;&amp; !this.resolver.isElementInViewport(element)) {
            await this.resolver.scrollToElement(element);
          }
        }

        // Track step shown
        const tourId &#x3D; this.state().activeTourId;
        if (tourId) {
          this.telemetry.trackStepShown(tourId, step.id, {
            index,
            total: totalSteps,
          });
        }

        // Update state
        this.stateSignal.update((state) &#x3D;&gt; ({
          ...state,
          currentStepIndex: index,
        }));
      },
      onHide: async () &#x3D;&gt; {
        // Execute onAfter hook
        if (step.onAfter) {
          await step.onAfter();
        }

        // Track step completed
        const tourId &#x3D; this.state().activeTourId;
        if (tourId) {
          this.telemetry.trackStepCompleted(tourId, step.id);
        }
      },
      onComplete: () &#x3D;&gt; {
        this.completeTour();
      },
      onCancel: () &#x3D;&gt; {
        this.cancelTour();
      },
    });
  }

  private resolveResponsiveStep(step: StepDefinition): StepDefinition {
    if (!step.responsive) return step;

    const breakpoint &#x3D; this.getCurrentBreakpoint();
    const responsiveConfig &#x3D; step.responsive[breakpoint];

    if (!responsiveConfig) return step;

    return {
      ...step,
      ...responsiveConfig,
      target: responsiveConfig.target || step.target,
      position: responsiveConfig.position || step.position,
    };
  }

  private getCurrentBreakpoint(): &#x27;desktop&#x27; | &#x27;tablet&#x27; | &#x27;mobile&#x27; {
    if (typeof window &#x3D;&#x3D;&#x3D; &#x27;undefined&#x27;) return &#x27;desktop&#x27;;

    const width &#x3D; window.innerWidth;
    if (width &lt; 768) return &#x27;mobile&#x27;;
    if (width &lt; 1024) return &#x27;tablet&#x27;;
    return &#x27;desktop&#x27;;
  }

  private shouldSkipTour(definition: TourDefinition): boolean {
    // Check if completed
    if (this.hasTourBeenCompleted(definition.id)) {
      return true;
    }

    // Check throttle
    if (this.isThrottled(definition.id)) {
      return true;
    }

    return false;
  }

  private isThrottled(tourId: TourId): boolean {
    const dismissedUntil &#x3D; this.loadFromStorage(&#x60;${tourId}:dismissed-until&#x60;);
    if (dismissedUntil) {
      const resumeAt &#x3D; Number(dismissedUntil);
      if (Date.now() &lt; resumeAt) {
        return true;
      }
      // Clear expired throttle
      this.removeFromStorage(&#x60;${tourId}:dismissed-until&#x60;);
    }
    return false;
  }

  private async evaluateGuards(
    guards: Array&lt;{ check: () &#x3D;&gt; Promise&lt;boolean&gt; | boolean }&gt;,
  ): Promise&lt;boolean&gt; {
    for (const guard of guards) {
      try {
        const result &#x3D; await guard.check();
        if (!result) return false;
      } catch {
        return false;
      }
    }
    return true;
  }

  private enqueueTour(queuedTour: QueuedTour): void {
    // Remove duplicates
    this.queue &#x3D; this.queue.filter((t) &#x3D;&gt; t.tourId !&#x3D;&#x3D; queuedTour.tourId);

    // Add to queue
    this.queue.push(queuedTour);

    // Sort by priority (highest first)
    this.queue.sort((a, b) &#x3D;&gt; b.priority - a.priority);
  }

  private processQueue(): void {
    if (this.queue.length &#x3D;&#x3D;&#x3D; 0) return;

    const next &#x3D; this.queue.shift();
    if (next) {
      setTimeout(() &#x3D;&gt; {
        this.requestTour(next.options);
      }, 500); // Small delay before starting next tour
    }
  }

  private cleanupTour(): void {
    this.adapter.destroy();
    this.currentDefinition &#x3D; undefined;
    this.stepIndexMap.clear();

    this.stateSignal.update((state) &#x3D;&gt; ({
      ...state,
      activeTourId: null,
      currentStepIndex: 0,
      isRunning: false,
      isPaused: false,
    }));
  }

  private markTourCompleted(tourId: TourId): void {
    this.saveToStorage(tourId, &#x27;completed&#x27;);
    this.removeFromStorage(&#x60;${tourId}:dismissed-until&#x60;);

    this.stateSignal.update((state) &#x3D;&gt; {
      const completed &#x3D; new Set(state.completedTours);
      completed.add(tourId);
      return { ...state, completedTours: completed };
    });
  }

  private loadCompletedTours(): void {
    const completed &#x3D; new Set&lt;string&gt;();

    // SSR guard
    if (typeof window &#x3D;&#x3D;&#x3D; &#x27;undefined&#x27; || typeof localStorage &#x3D;&#x3D;&#x3D; &#x27;undefined&#x27;) {
      this.stateSignal.update((state) &#x3D;&gt; ({ ...state, completedTours: completed }));
      return;
    }

    Object.keys(localStorage)
      .filter((key) &#x3D;&gt; key.startsWith(this.STORAGE_PREFIX))
      .filter((key) &#x3D;&gt; !key.includes(&#x27;:dismissed&#x27;))
      .forEach((key) &#x3D;&gt; {
        const value &#x3D; localStorage.getItem(key);
        if (value &#x3D;&#x3D;&#x3D; &#x27;completed&#x27;) {
          const tourId &#x3D; key.replace(this.STORAGE_PREFIX, &#x27;&#x27;);
          completed.add(tourId);
        }
      });

    this.stateSignal.update((state) &#x3D;&gt; ({ ...state, completedTours: completed }));
  }

  private setupRouteListener(): void {
    this.routeSubscription &#x3D; this.router.events
      .pipe(filter((event): event is NavigationEnd &#x3D;&gt; event instanceof NavigationEnd))
      .subscribe((event) &#x3D;&gt; {
        this.handleRouteChange(event);
      });
  }

  private handleRouteChange(event: NavigationEnd): void {
    // Check if current tour should pause/cancel on route change
    if (this.currentDefinition) {
      // You can add logic here for route-sensitive tours
      // For now, we&#x27;ll keep the tour running
    }

    // Check for auto-start tours based on route
    this.checkAutoStartTours(event.urlAfterRedirects || event.url);
  }

  private checkAutoStartTours(url: string): void {
    const definitions &#x3D; this.registry.getAllDefinitions();

    for (const definition of definitions) {
      if (!definition.autoStart) continue;
      if (this.shouldSkipTour(definition)) continue;

      // Check route-based triggers
      if (definition.triggers) {
        for (const trigger of definition.triggers) {
          if (trigger.type &#x3D;&#x3D;&#x3D; &#x27;route&#x27; &amp;&amp; trigger.routePattern) {
            if (trigger.routePattern.test(url)) {
              this.requestTour({ id: definition.id, mode: &#x27;auto&#x27; });
              break;
            }
          }
        }
      }
    }
  }

  private clearTourStorage(tourId: TourId): void {
    this.removeFromStorage(tourId);
    this.removeFromStorage(&#x60;${tourId}:dismissed&#x60;);
    this.removeFromStorage(&#x60;${tourId}:dismissed-until&#x60;);
  }

  private saveToStorage(key: string, value: string): void {
    if (typeof window &#x3D;&#x3D;&#x3D; &#x27;undefined&#x27;) return;
    localStorage.setItem(&#x60;${this.STORAGE_PREFIX}${key}&#x60;, value);
  }

  private loadFromStorage(key: string): string | null {
    if (typeof window &#x3D;&#x3D;&#x3D; &#x27;undefined&#x27;) return null;
    return localStorage.getItem(&#x60;${this.STORAGE_PREFIX}${key}&#x60;);
  }

  private removeFromStorage(key: string): void {
    if (typeof window &#x3D;&#x3D;&#x3D; &#x27;undefined&#x27;) return;
    localStorage.removeItem(&#x60;${this.STORAGE_PREFIX}${key}&#x60;);
  }

  ngOnDestroy(): void {
    this.routeSubscription?.unsubscribe();
    this.resolver.cleanup();
    this.adapter.destroy();
  }
}
</code></pre>
    </div>
</div>








                   </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div>
</div>
               <!-- END CONTENT -->
           </div>
       </div>

          <label class="dark-mode-switch">
               <input type="checkbox">
               <span class="slider">
                    <svg class="slider-icon" viewBox="0 0 24 24" fill="none" height="20" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" width="20" xmlns="http://www.w3.org/2000/svg">
                    <path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"></path>
                    </svg>
               </span>
          </label>

       <script>
            var COMPODOC_CURRENT_PAGE_DEPTH = 1;
            var COMPODOC_CURRENT_PAGE_CONTEXT = 'interface';
            var COMPODOC_CURRENT_PAGE_URL = 'QueuedTour.html';
            var MAX_SEARCH_RESULTS = 15;
       </script>

       <script>
               $darkModeToggleSwitchers = document.querySelectorAll('.dark-mode-switch input');
               checkToggle(darkModeState);
               if ($darkModeToggleSwitchers.length > 0) {
                    for (var i = 0; i < $darkModeToggleSwitchers.length; i++) {
                         $darkModeToggleSwitchers[i].addEventListener('change', function (event) {
                              darkModeState = !darkModeState;
                              toggleDarkMode(darkModeState);
                         });
                    }
               }
          </script>

       <script src="../js/libs/custom-elements.min.js"></script>
       <script src="../js/libs/lit-html.js"></script>

       <script src="../js/menu-wc.js" defer></script>
       <script nomodule src="../js/menu-wc_es5.js" defer></script>

       <script src="../js/libs/bootstrap-native.js"></script>

       <script src="../js/libs/es6-shim.min.js"></script>
       <script src="../js/libs/EventDispatcher.js"></script>
       <script src="../js/libs/promise.min.js"></script>

       <script src="../js/compodoc.js"></script>

       <script src="../js/tabs.js"></script>
       <script src="../js/menu.js"></script>
       <script src="../js/libs/clipboard.min.js"></script>
       <script src="../js/libs/prism.js"></script>
       <script src="../js/sourceCode.js"></script>
          <script src="../js/search/search.js"></script>
          <script src="../js/search/lunr.min.js"></script>
          <script src="../js/search/search-lunr.js"></script>
          <script src="../js/search/search_index.js"></script>
       <script src="../js/lazy-load-graphs.js"></script>


    </body>
</html>
