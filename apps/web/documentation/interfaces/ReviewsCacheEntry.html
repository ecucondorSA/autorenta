<!doctype html>
<html class="no-js" lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>autorenta-web documentation</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="icon" type="image/x-icon" href="../images/favicon.ico">
	   <link rel="stylesheet" href="../styles/style.css">
        <link rel="stylesheet" href="../styles/dark.css">
    </head>
    <body>
          <script>
               // Blocking script to avoid flickering dark mode
               // Dark mode toggle button
               var useDark = window.matchMedia('(prefers-color-scheme: dark)');
               var darkModeState = useDark.matches;
               var $darkModeToggleSwitchers = document.querySelectorAll('.dark-mode-switch input');
               var $darkModeToggles = document.querySelectorAll('.dark-mode-switch');
               var darkModeStateLocal = localStorage.getItem('compodoc_darkmode-state');

               function checkToggle(check) {
                    for (var i = 0; i < $darkModeToggleSwitchers.length; i++) {
                         $darkModeToggleSwitchers[i].checked = check;
                    }
               }

               function toggleDarkMode(state) {
                    if (window.localStorage) {
                         localStorage.setItem('compodoc_darkmode-state', state);
                    }

                    checkToggle(state);

                    const hasClass = document.body.classList.contains('dark');

                    if (state) {
                         for (var i = 0; i < $darkModeToggles.length; i++) {
                              $darkModeToggles[i].classList.add('dark');
                         }
                         if (!hasClass) {
                              document.body.classList.add('dark');
                         }
                    } else {
                         for (var i = 0; i < $darkModeToggles.length; i++) {
                              $darkModeToggles[i].classList.remove('dark');
                         }
                         if (hasClass) {
                              document.body.classList.remove('dark');
                         }
                    }
               }

               useDark.addEventListener('change', function (evt) {
                    toggleDarkMode(evt.matches);
               });
               if (darkModeStateLocal) {
                    darkModeState = darkModeStateLocal === 'true';
               }
               toggleDarkMode(darkModeState);
          </script>
          <script>
              // --- Iframe navigation tracking for Template Playground ---
              function sendCurrentUrlToParent() {
                  if (window.parent && window.parent !== window) {
                      window.parent.postMessage({
                          type: 'compodoc-iframe-navigate',
                          url: window.location.pathname + window.location.hash
                      }, '*');
                  }
              }
              window.addEventListener('hashchange', sendCurrentUrlToParent, false);
              window.addEventListener('popstate', sendCurrentUrlToParent, false);
              window.addEventListener('DOMContentLoaded', sendCurrentUrlToParent, false);
          </script>

        <div class="navbar navbar-default navbar-fixed-top d-md-none p-0">
               <div class="d-flex">
                    <a href="../" class="navbar-brand">autorenta-web documentation</a>
                    <button type="button" class="btn btn-default btn-menu ion-ios-menu" id="btn-menu"></button>
               </div>
        </div>

        <div class="xs-menu menu" id="mobile-menu">
                <div id="book-search-input" role="search"><input type="text" placeholder="Type to search"></div>            <compodoc-menu></compodoc-menu>
        </div>

        <div class="container-fluid main">
           <div class="row main">
               <div class="d-none d-md-block menu">
                   <compodoc-menu mode="normal"></compodoc-menu>
               </div>
               <!-- START CONTENT -->
               <div class="content interface">
                   <div class="content-data">

















<ol class="breadcrumb">
  <li class="breadcrumb-item">Interfaces</li>
  <li class="breadcrumb-item"
  >
  ReviewsCacheEntry</li>
</ol>

<ul class="nav nav-tabs" role="tablist">
        <li class="nav-item">
            <a href="#info" 
                class="nav-link"
                class="nav-link active"
                role="tab" id="info-tab" data-bs-toggle="tab" data-link="info">Info</a>
        </li>
        <li class="nav-item">
            <a href="#source" 
                class="nav-link"
                
                role="tab" id="source-tab" data-bs-toggle="tab" data-link="source">Source</a>
        </li>
</ul>

<div class="tab-content">
    <div class="tab-pane fade active in" id="info">
        <p class="comment">
            <h3>File</h3>
        </p>
        <p class="comment">
            <code>src/app/core/services/car-locations.service.ts</code>
        </p>




        <section data-compodoc="block-index">
            <h3 id="index">Index</h3>
            <table class="table table-sm table-bordered index-table">
                <tbody>
                    <tr>
                        <td class="col-md-4">
                            <h6><b>Properties</b></h6>
                        </td>
                    </tr>
                    <tr>
                        <td class="col-md-4">
                            <ul class="index-list">
                                <li>
                                        <a href="#expiresAt" 
>
                                            expiresAt
                                        </a>
                                </li>
                                <li>
                                        <a href="#reviewsCount" 
>
                                            reviewsCount
                                        </a>
                                </li>
                            </ul>
                        </td>
                    </tr>
                </tbody>
            </table>
        </section>



            <section data-compodoc="block-properties">
                <h3 id="inputs">Properties</h3>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="expiresAt"></a>
                                        <span class="name "><b>expiresAt</b>
                                            <a href="#expiresAt">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>expiresAt:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/number" target="_blank" >number</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/number" target="_blank" >number</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="reviewsCount"></a>
                                        <span class="name "><b>reviewsCount</b>
                                            <a href="#reviewsCount">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>reviewsCount:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/number" target="_blank" >number</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/number" target="_blank" >number</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
            </section>
    </div>


    <div class="tab-pane fade  tab-source-code" id="source">
        <pre class="line-numbers compodoc-sourcecode"><code class="language-typescript">import { Injectable, inject } from &#x27;@angular/core&#x27;;
import type { RealtimeChannel, RealtimePostgresChangesPayload } from &#x27;@supabase/supabase-js&#x27;;
import { environment } from &#x27;../../../environments/environment&#x27;;
import { injectSupabase } from &#x27;./supabase-client.service&#x27;;
import { CarAvailabilityService } from &#x27;./car-availability.service&#x27;;

const DEFAULT_CACHE_TTL_MS &#x3D; 5 * 60 * 1000;
const DEFAULT_REFRESH_MS &#x3D; 60 * 1000;

export interface CarMapLocation {
  carId: string;
  title: string;
  pricePerDay: number;
  pricePerHour?: number; // Dynamic pricing
  currency: string;
  surgeActive?: boolean; // Surge pricing indicator
  lat: number;
  lng: number;
  updatedAt: string;
  city?: string | null;
  state?: string | null;
  country?: string | null;
  locationLabel: string;
  formattedAddress?: string | null;
  photoUrl?: string | null;
  photoGallery?: string[] | null;
  description?: string | null;
  // Availability status
  availabilityStatus?: &#x27;available&#x27; | &#x27;in_use&#x27; | &#x27;soon_available&#x27; | &#x27;unavailable&#x27;;
  nextAvailableDate?: string | null; // ISO date string
  currentBookingEndDate?: string | null; // ISO date string for &quot;soon_available&quot;
  // Instant booking &amp; availability flags
  instantBooking?: boolean; // Auto-approval enabled (can book immediately)
  availableToday?: boolean; // Available for pickup today
  availableTomorrow?: boolean; // Available for pickup tomorrow
  minRentalDays?: number; // Minimum rental period
  maxRentalDays?: number; // Maximum rental period
  // Dynamic pricing info
  depositRequired?: boolean;
  depositAmount?: number;
  insuranceIncluded?: boolean;
  usesDynamicPricing?: boolean; // Car opts into dynamic pricing
}

interface CacheEntry {
  data: CarMapLocation[];
  expiresAt: number;
}

interface ReviewsCacheEntry {
  reviewsCount: number;
  expiresAt: number;
}

@Injectable({
  providedIn: &#x27;root&#x27;,
})
export class CarLocationsService {
  private readonly supabase &#x3D; injectSupabase();
  private readonly availabilityService &#x3D; inject(CarAvailabilityService);
  private readonly cacheTtlMs &#x3D; environment.carLocationsCacheTtlMs ?? DEFAULT_CACHE_TTL_MS;
  private readonly refreshMs &#x3D; environment.carLocationsRefreshMs ?? DEFAULT_REFRESH_MS;
  private readonly reviewsCacheTtlMs &#x3D; 10 * 60 * 1000; // 10 minutes for reviews cache

  private cache: CacheEntry | null &#x3D; null;
  private reviewsCache &#x3D; new Map&lt;string, ReviewsCacheEntry&gt;();
  private realtimeChannel: RealtimeChannel | null &#x3D; null;

  async fetchActiveLocations(
    force &#x3D; false,
    includeAvailability &#x3D; false,
    options?: {
      center?: { lat: number; lng: number };
      radiusKm?: number;
      dateRange?: { from: string; to: string };
      instantBookingOnly?: boolean;
    },
  ): Promise&lt;CarMapLocation[]&gt; {
    const now &#x3D; Date.now();
    if (!force &amp;&amp; this.cache &amp;&amp; this.cache.expiresAt &gt; now) {
      const cached &#x3D; this.cache.data;
      if (includeAvailability) {
        return this.enrichWithAvailability(cached, options);
      }
      return cached;
    }

    const edgeData &#x3D; await this.tryEdgeFunction();
    const data &#x3D; edgeData ?? (await this.fetchFromDatabase(options));

    // Enrich with availability if requested
    const enriched &#x3D; includeAvailability ? await this.enrichWithAvailability(data, options) : data;

    this.cache &#x3D; {
      data: enriched,
      expiresAt: now + this.cacheTtlMs,
    };
    return enriched;
  }

  /**
   * Enrich car locations with availability status and instant booking flags
   */
  private async enrichWithAvailability(
    locations: CarMapLocation[],
    options?: {
      center?: { lat: number; lng: number };
      radiusKm?: number;
      dateRange?: { from: string; to: string };
      instantBookingOnly?: boolean;
    },
  ): Promise&lt;CarMapLocation[]&gt; {
    const today &#x3D; new Date();
    today.setHours(0, 0, 0, 0);
    const tomorrow &#x3D; new Date(today);
    tomorrow.setDate(tomorrow.getDate() + 1);
    const in7Days &#x3D; new Date(today);
    in7Days.setDate(in7Days.getDate() + 7);

    // Use provided date range or default to today-tomorrow
    const checkFrom &#x3D; options?.dateRange?.from || today.toISOString().split(&#x27;T&#x27;)[0];
    const checkTo &#x3D; options?.dateRange?.to || tomorrow.toISOString().split(&#x27;T&#x27;)[0];

    // Check availability for each car in parallel (limited concurrency)
    const enriched &#x3D; await Promise.all(
      locations.map(async (location) &#x3D;&gt; {
        try {
          // Check if available today
          const availableToday &#x3D; await this.availabilityService.checkAvailability(
            location.carId,
            today.toISOString().split(&#x27;T&#x27;)[0],
            tomorrow.toISOString().split(&#x27;T&#x27;)[0],
          );

          // Check if available tomorrow
          const tomorrowDate &#x3D; new Date(tomorrow);
          const dayAfterTomorrow &#x3D; new Date(tomorrow);
          dayAfterTomorrow.setDate(dayAfterTomorrow.getDate() + 1);
          const availableTomorrow &#x3D; await this.availabilityService.checkAvailability(
            location.carId,
            tomorrowDate.toISOString().split(&#x27;T&#x27;)[0],
            dayAfterTomorrow.toISOString().split(&#x27;T&#x27;)[0],
          );

          // Check if available for requested date range (stored for potential future use)
          if (options?.dateRange) {
            await this.availabilityService.checkAvailability(location.carId, checkFrom, checkTo);
          }

          if (availableToday) {
            return {
              ...location,
              availabilityStatus: &#x27;available&#x27; as const,
              availableToday: true,
              availableTomorrow,
            };
          }

          // Check if available in next 7 days
          const nextAvailable &#x3D; await this.availabilityService.getNextAvailableDate(
            location.carId,
            today.toISOString().split(&#x27;T&#x27;)[0],
          );

          if (nextAvailable) {
            const nextDate &#x3D; new Date(nextAvailable);
            const daysUntilAvailable &#x3D; Math.ceil(
              (nextDate.getTime() - today.getTime()) / (1000 * 60 * 60 * 24),
            );

            if (daysUntilAvailable &lt;&#x3D; 7) {
              // Get current booking end date
              const blockedDates &#x3D; await this.availabilityService.getBlockedDates(location.carId);
              const currentBlock &#x3D; blockedDates.find(
                (block) &#x3D;&gt; new Date(block.to) &gt;&#x3D; today &amp;&amp; new Date(block.from) &lt;&#x3D; today,
              );

              return {
                ...location,
                availabilityStatus: &#x27;soon_available&#x27; as const,
                nextAvailableDate: nextAvailable,
                currentBookingEndDate: currentBlock?.to || null,
                availableToday: false,
                availableTomorrow,
              };
            }
          }

          return {
            ...location,
            availabilityStatus: &#x27;unavailable&#x27; as const,
            availableToday: false,
            availableTomorrow: false,
          };
        } catch (error) {
          console.error(&#x60;Error checking availability for car ${location.carId}:&#x60;, error);
          return {
            ...location,
            availabilityStatus: &#x27;unavailable&#x27; as const,
            availableToday: false,
            availableTomorrow: false,
          };
        }
      }),
    );

    // Filter by instant booking if requested
    if (options?.instantBookingOnly) {
      return enriched.filter((loc) &#x3D;&gt; loc.instantBooking &#x3D;&#x3D;&#x3D; true);
    }

    return enriched;
  }

  subscribeToRealtime(onChange: () &#x3D;&gt; void): () &#x3D;&gt; void {
    if (this.realtimeChannel) {
      return () &#x3D;&gt; {
        if (this.realtimeChannel) {
          void this.supabase.removeChannel(this.realtimeChannel);
          this.realtimeChannel &#x3D; null;
        }
      };
    }

    const channel &#x3D; this.supabase.channel(&#x27;public:car_map_feed&#x27;);
    channel.on(
      &#x27;postgres_changes&#x27;,
      { schema: &#x27;public&#x27;, table: &#x27;car_locations&#x27;, event: &#x27;*&#x27; },
      (_payload: RealtimePostgresChangesPayload&lt;Record&lt;string, unknown&gt;&gt;) &#x3D;&gt; onChange(),
    );
    channel.on(
      &#x27;postgres_changes&#x27;,
      { schema: &#x27;public&#x27;, table: &#x27;cars&#x27;, event: &#x27;*&#x27; },
      (payload: RealtimePostgresChangesPayload&lt;Record&lt;string, unknown&gt;&gt;) &#x3D;&gt; {
        const newRecord &#x3D; payload.new as Record&lt;string, unknown&gt; | undefined;
        const oldRecord &#x3D; payload.old as Record&lt;string, unknown&gt; | undefined;
        const newStatus &#x3D; newRecord?.status;
        const oldStatus &#x3D; oldRecord?.status;
        if (newStatus &#x3D;&#x3D;&#x3D; &#x27;active&#x27; || oldStatus &#x3D;&#x3D;&#x3D; &#x27;active&#x27;) {
          onChange();
        }
      },
    );

    void channel.subscribe();
    this.realtimeChannel &#x3D; channel;

    return () &#x3D;&gt; {
      if (this.realtimeChannel) {
        void this.supabase.removeChannel(this.realtimeChannel);
        this.realtimeChannel &#x3D; null;
      }
    };
  }

  getRefreshInterval(): number {
    return this.refreshMs;
  }

  private async tryEdgeFunction(): Promise&lt;CarMapLocation[] | null&gt; {
    const functionName &#x3D; environment.carLocationsEdgeFunction;
    if (!functionName) {
      return null;
    }

    try {
      const { data, error } &#x3D; await this.supabase.functions.invoke(functionName, {
        body: {
          ttl: Math.round(this.cacheTtlMs / 1000),
          status: &#x27;active&#x27;,
        },
      });
      if (error) {
        throw error;
      }
      if (!Array.isArray(data)) {
        return null;
      }
      const normalized &#x3D; this.normalizePayloadArray(data);
      return normalized.length &gt; 0 ? normalized : null;
    } catch {
      return null;
    }
  }

  private async fetchFromDatabase(options?: {
    center?: { lat: number; lng: number };
    radiusKm?: number;
    dateRange?: { from: string; to: string };
    instantBookingOnly?: boolean;
  }): Promise&lt;CarMapLocation[]&gt; {
    // Build query with optional filters
    let query &#x3D; this.supabase
      .from(&#x27;v_cars_with_main_photo&#x27;)
      .select(
        &#x27;id, title, status, price_per_day, currency, location_city, location_state, location_country, location_lat, location_lng, main_photo_url, photo_gallery, description, updated_at, auto_approval, min_rental_days, max_rental_days, deposit_required, deposit_amount, insurance_included, uses_dynamic_pricing&#x27;,
      )
      .eq(&#x27;status&#x27;, &#x27;active&#x27;)
      .not(&#x27;location_lat&#x27;, &#x27;is&#x27;, null)
      .not(&#x27;location_lng&#x27;, &#x27;is&#x27;, null);

    // Filter by instant booking if requested
    if (options?.instantBookingOnly) {
      query &#x3D; query.eq(&#x27;auto_approval&#x27;, true);
    }

    // Note: Radius filtering should be done client-side or via PostGIS RPC
    // For now, we fetch all and filter client-side if center/radius provided

    const { data: cars, error: carsError } &#x3D; await query;

    if (carsError) {
      throw carsError;
    }

    const carsArray &#x3D; Array.isArray(cars) ? cars : [];
    if (carsArray.length &#x3D;&#x3D;&#x3D; 0) {
      return [];
    }

    // Normalize entries
    let normalized &#x3D; carsArray
      .map((car: unknown) &#x3D;&gt; this.normalizeEntry(car))
      .filter((value): value is CarMapLocation &#x3D;&gt; !!value);

    // Filter by radius if center and radius provided (client-side filtering)
    if (options?.center &amp;&amp; options?.radiusKm) {
      normalized &#x3D; normalized.filter((loc) &#x3D;&gt; {
        const distance &#x3D; this.calculateDistance(
          options.center!.lat,
          options.center!.lng,
          loc.lat,
          loc.lng,
        );
        return distance &lt;&#x3D; options.radiusKm!;
      });
    }

    return normalized;
  }

  /**
   * Calculate distance between two coordinates (Haversine formula)
   */
  private calculateDistance(lat1: number, lon1: number, lat2: number, lon2: number): number {
    const R &#x3D; 6371; // Earth radius in km
    const dLat &#x3D; this.toRad(lat2 - lat1);
    const dLon &#x3D; this.toRad(lon2 - lon1);
    const a &#x3D;
      Math.sin(dLat / 2) * Math.sin(dLat / 2) +
      Math.cos(this.toRad(lat1)) *
        Math.cos(this.toRad(lat2)) *
        Math.sin(dLon / 2) *
        Math.sin(dLon / 2);
    const c &#x3D; 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c;
  }

  private toRad(degrees: number): number {
    return degrees * (Math.PI / 180);
  }

  /**
   * Get review count for a car with caching
   * This avoids multiple queries when multiple tooltips request the same car&#x27;s reviews
   */
  async getReviewCount(carId: string, force &#x3D; false): Promise&lt;number&gt; {
    const now &#x3D; Date.now();
    const cached &#x3D; this.reviewsCache.get(carId);

    if (!force &amp;&amp; cached &amp;&amp; cached.expiresAt &gt; now) {
      return cached.reviewsCount;
    }

    try {
      // Use car_stats table for efficient query
      const { data, error } &#x3D; await this.supabase
        .from(&#x27;car_stats&#x27;)
        .select(&#x27;reviews_count&#x27;)
        .eq(&#x27;car_id&#x27;, carId)
        .maybeSingle();

      if (error) {
        console.warn(&#x60;Error fetching review count for car ${carId}:&#x60;, error);
        return 0;
      }

      const reviewsCount &#x3D; (data?.reviews_count as number | null | undefined) ?? 0;

      // Update cache
      this.reviewsCache.set(carId, {
        reviewsCount,
        expiresAt: now + this.reviewsCacheTtlMs,
      });

      return reviewsCount;
    } catch (error) {
      console.warn(&#x60;Exception fetching review count for car ${carId}:&#x60;, error);
      return 0;
    }
  }

  /**
   * Clear reviews cache for a specific car or all cars
   */
  clearReviewsCache(carId?: string): void {
    if (carId) {
      this.reviewsCache.delete(carId);
    } else {
      this.reviewsCache.clear();
    }
  }

  /**
   * Batch fetch review counts for multiple cars (more efficient)
   */
  async getReviewCountsBatch(carIds: string[]): Promise&lt;Map&lt;string, number&gt;&gt; {
    const now &#x3D; Date.now();
    const result &#x3D; new Map&lt;string, number&gt;();
    const uncachedIds: string[] &#x3D; [];

    // Check cache first
    for (const carId of carIds) {
      const cached &#x3D; this.reviewsCache.get(carId);
      if (cached &amp;&amp; cached.expiresAt &gt; now) {
        result.set(carId, cached.reviewsCount);
      } else {
        uncachedIds.push(carId);
      }
    }

    // Fetch uncached reviews in batch
    if (uncachedIds.length &gt; 0) {
      try {
        const { data, error } &#x3D; await this.supabase
          .from(&#x27;car_stats&#x27;)
          .select(&#x27;car_id, reviews_count&#x27;)
          .in(&#x27;car_id&#x27;, uncachedIds);

        if (error) {
          console.warn(&#x27;Error batch fetching review counts:&#x27;, error);
          // Set 0 for all uncached
          uncachedIds.forEach((id) &#x3D;&gt; result.set(id, 0));
        } else {
          // Update cache and result
          const stats &#x3D; (data || []) as Array&lt;{ car_id: string; reviews_count: number | null }&gt;;
          stats.forEach((stat) &#x3D;&gt; {
            const reviewsCount &#x3D; stat.reviews_count ?? 0;
            result.set(stat.car_id, reviewsCount);
            this.reviewsCache.set(stat.car_id, {
              reviewsCount,
              expiresAt: now + this.reviewsCacheTtlMs,
            });
          });

          // Set 0 for cars not found in stats
          uncachedIds.forEach((id) &#x3D;&gt; {
            if (!result.has(id)) {
              result.set(id, 0);
            }
          });
        }
      } catch (error) {
        console.warn(&#x27;Exception batch fetching review counts:&#x27;, error);
        uncachedIds.forEach((id) &#x3D;&gt; result.set(id, 0));
      }
    }

    return result;
  }

  private normalizePayloadArray(payload: unknown[]): CarMapLocation[] {
    return payload
      .map((entry) &#x3D;&gt; this.normalizeEntry(entry))
      .filter((value): value is CarMapLocation &#x3D;&gt; !!value);
  }

  private normalizeEntry(entry: unknown): CarMapLocation | null {
    if (!entry || typeof entry !&#x3D;&#x3D; &#x27;object&#x27;) {
      return null;
    }

    const record &#x3D; entry as Record&lt;string, unknown&gt;;
    const car &#x3D; (record.car ?? record) as Record&lt;string, unknown&gt;;
    const meta &#x3D; (record.meta ?? {}) as Record&lt;string, unknown&gt;;
    const carId &#x3D; String(record.car_id ?? car.id ?? meta.car_id ?? &#x27;&#x27;);
    if (!carId) {
      return null;
    }

    const latRaw &#x3D; record.lat ?? record.location_lat ?? car.location_lat;
    const lngRaw &#x3D; record.lng ?? record.location_lng ?? car.location_lng;
    const lat &#x3D; typeof latRaw &#x3D;&#x3D;&#x3D; &#x27;string&#x27; ? Number.parseFloat(latRaw) : (latRaw as number);
    const lng &#x3D; typeof lngRaw &#x3D;&#x3D;&#x3D; &#x27;string&#x27; ? Number.parseFloat(lngRaw) : (lngRaw as number);
    if (
      typeof lat !&#x3D;&#x3D; &#x27;number&#x27; ||
      Number.isNaN(lat) ||
      typeof lng !&#x3D;&#x3D; &#x27;number&#x27; ||
      Number.isNaN(lng)
    ) {
      return null;
    }

    const status &#x3D; car.status ?? record.status;
    if (status &amp;&amp; status !&#x3D;&#x3D; &#x27;active&#x27;) {
      return null;
    }

    const title &#x3D; String(car.title ?? record.title ?? &#x27;Auto disponible&#x27;);
    const pricePerDayRaw &#x3D; car.price_per_day ?? record.price_per_day ?? 0;
    const pricePerDay &#x3D;
      typeof pricePerDayRaw &#x3D;&#x3D;&#x3D; &#x27;string&#x27;
        ? Number.parseFloat(pricePerDayRaw)
        : Number(pricePerDayRaw ?? 0);
    const currency &#x3D; String(
      car.currency ?? record.currency ?? environment.defaultCurrency ?? &#x27;USD&#x27;,
    ).toUpperCase();

    const cityRaw &#x3D; car.location_city ?? record.city ?? record.location_city ?? null;
    const city &#x3D; typeof cityRaw &#x3D;&#x3D;&#x3D; &#x27;string&#x27; ? cityRaw : null;

    const stateRaw &#x3D; car.location_state ?? record.state ?? record.location_state ?? null;
    const state &#x3D; typeof stateRaw &#x3D;&#x3D;&#x3D; &#x27;string&#x27; ? stateRaw : null;

    const countryRaw &#x3D; car.location_country ?? record.country ?? record.location_country ?? null;
    const country &#x3D; typeof countryRaw &#x3D;&#x3D;&#x3D; &#x27;string&#x27; ? countryRaw : null;

    const formattedAddressRaw &#x3D;
      car.location_formatted_address ?? record.location_formatted_address ?? null;
    const formattedAddress &#x3D; typeof formattedAddressRaw &#x3D;&#x3D;&#x3D; &#x27;string&#x27; ? formattedAddressRaw : null;

    const updatedAt &#x3D; String(record.updated_at ?? car.updated_at ?? new Date().toISOString());

    // Get photo URL with fallback logic
    // La vista v_cars_with_main_photo ahora incluye photo_gallery como JSONB array
    const photoUrlRaw &#x3D; car.main_photo_url ?? record.main_photo_url ?? record.photo_url ?? null;
    let photoUrl &#x3D;
      typeof photoUrlRaw &#x3D;&#x3D;&#x3D; &#x27;string&#x27; &amp;&amp; photoUrlRaw.trim() ? photoUrlRaw.trim() : null;

    // Get photo_gallery from view (comes as JSONB, Supabase converts to array automatically)
    const photoGalleryRaw &#x3D;
      car.photo_gallery ?? record.photo_gallery ?? record.photoGallery ?? null;
    let photoGallery: string[] | null &#x3D; null;

    if (photoGalleryRaw) {
      if (Array.isArray(photoGalleryRaw)) {
        // Supabase convierte JSONB autom√°ticamente a array
        photoGallery &#x3D; photoGalleryRaw.filter(
          (url): url is string &#x3D;&gt; typeof url &#x3D;&#x3D;&#x3D; &#x27;string&#x27; &amp;&amp; url.trim().length &gt; 0,
        );
      } else if (typeof photoGalleryRaw &#x3D;&#x3D;&#x3D; &#x27;string&#x27;) {
        // Fallback: si viene como string JSON (de edge function o payload)
        try {
          const parsed &#x3D; JSON.parse(photoGalleryRaw);
          if (Array.isArray(parsed)) {
            photoGallery &#x3D; parsed.filter(
              (url): url is string &#x3D;&gt; typeof url &#x3D;&#x3D;&#x3D; &#x27;string&#x27; &amp;&amp; url.trim().length &gt; 0,
            );
          }
        } catch {
          // Invalid JSON, ignore
        }
      }
    }

    // Use first photo from gallery as fallback if main_photo_url is missing
    if (!photoUrl &amp;&amp; photoGallery &amp;&amp; photoGallery.length &gt; 0) {
      photoUrl &#x3D; photoGallery[0];
    }

    // If still no photo, photoUrl remains null (will use initials fallback in UI)

    const descriptionRaw &#x3D;
      car.description ??
      record.description ??
      (typeof meta.description &#x3D;&#x3D;&#x3D; &#x27;string&#x27; ? meta.description : &#x27;&#x27;);
    const description &#x3D; this.buildSummary(typeof descriptionRaw &#x3D;&#x3D;&#x3D; &#x27;string&#x27; ? descriptionRaw : &#x27;&#x27;);

    // Extract instant booking and rental terms
    const autoApprovalRaw &#x3D; car.auto_approval ?? record.auto_approval ?? meta.auto_approval ?? null;
    const instantBooking &#x3D;
      typeof autoApprovalRaw &#x3D;&#x3D;&#x3D; &#x27;boolean&#x27;
        ? autoApprovalRaw
        : autoApprovalRaw &#x3D;&#x3D;&#x3D; &#x27;true&#x27; || autoApprovalRaw &#x3D;&#x3D;&#x3D; true;

    const minRentalDaysRaw &#x3D;
      car.min_rental_days ?? record.min_rental_days ?? meta.min_rental_days ?? null;
    const minRentalDays &#x3D;
      typeof minRentalDaysRaw &#x3D;&#x3D;&#x3D; &#x27;number&#x27;
        ? minRentalDaysRaw
        : typeof minRentalDaysRaw &#x3D;&#x3D;&#x3D; &#x27;string&#x27;
          ? Number.parseInt(minRentalDaysRaw, 10)
          : undefined;

    const maxRentalDaysRaw &#x3D;
      car.max_rental_days ?? record.max_rental_days ?? meta.max_rental_days ?? null;
    const maxRentalDays &#x3D;
      typeof maxRentalDaysRaw &#x3D;&#x3D;&#x3D; &#x27;number&#x27;
        ? maxRentalDaysRaw
        : typeof maxRentalDaysRaw &#x3D;&#x3D;&#x3D; &#x27;string&#x27;
          ? Number.parseInt(maxRentalDaysRaw, 10)
          : undefined;

    const depositRequiredRaw &#x3D;
      car.deposit_required ?? record.deposit_required ?? meta.deposit_required ?? null;
    const depositRequired &#x3D;
      typeof depositRequiredRaw &#x3D;&#x3D;&#x3D; &#x27;boolean&#x27;
        ? depositRequiredRaw
        : depositRequiredRaw &#x3D;&#x3D;&#x3D; &#x27;true&#x27; || depositRequiredRaw &#x3D;&#x3D;&#x3D; true;

    const depositAmountRaw &#x3D;
      car.deposit_amount ?? record.deposit_amount ?? meta.deposit_amount ?? null;
    const depositAmount &#x3D;
      typeof depositAmountRaw &#x3D;&#x3D;&#x3D; &#x27;number&#x27;
        ? depositAmountRaw
        : typeof depositAmountRaw &#x3D;&#x3D;&#x3D; &#x27;string&#x27;
          ? Number.parseFloat(depositAmountRaw)
          : undefined;

    const insuranceIncludedRaw &#x3D;
      car.insurance_included ?? record.insurance_included ?? meta.insurance_included ?? null;
    const insuranceIncluded &#x3D;
      typeof insuranceIncludedRaw &#x3D;&#x3D;&#x3D; &#x27;boolean&#x27;
        ? insuranceIncludedRaw
        : insuranceIncludedRaw &#x3D;&#x3D;&#x3D; &#x27;true&#x27; || insuranceIncludedRaw &#x3D;&#x3D;&#x3D; true;

    const usesDynamicPricingRaw &#x3D;
      car.uses_dynamic_pricing ?? record.uses_dynamic_pricing ?? meta.uses_dynamic_pricing ?? null;
    const usesDynamicPricing &#x3D;
      typeof usesDynamicPricingRaw &#x3D;&#x3D;&#x3D; &#x27;boolean&#x27;
        ? usesDynamicPricingRaw
        : usesDynamicPricingRaw &#x3D;&#x3D;&#x3D; &#x27;true&#x27; || usesDynamicPricingRaw &#x3D;&#x3D;&#x3D; true;

    return {
      carId,
      title,
      pricePerDay: Number.isFinite(pricePerDay) ? pricePerDay : 0,
      currency,
      lat,
      lng,
      updatedAt,
      city,
      state,
      country,
      locationLabel: this.buildLocationLabel(city, state, country),
      formattedAddress,
      photoUrl,
      photoGallery,
      description,
      instantBooking,
      minRentalDays,
      maxRentalDays,
      depositRequired,
      depositAmount,
      insuranceIncluded,
      usesDynamicPricing,
    };
  }

  private buildSummary(value: string | null | undefined): string | null {
    if (!value) {
      return null;
    }
    const normalized &#x3D; value.trim().replace(/\s+/g, &#x27; &#x27;);
    if (normalized.length &lt;&#x3D; 140) {
      return normalized;
    }
    return &#x60;${normalized.slice(0, 137)}...&#x60;;
  }

  private buildLocationLabel(
    city: string | null | undefined,
    state: string | null | undefined,
    country: string | null | undefined,
  ): string {
    const parts &#x3D; [city, state, country].filter((part) &#x3D;&gt; !!part &amp;&amp; String(part).trim().length &gt; 0);
    return parts.length &gt; 0 ? parts.map((part) &#x3D;&gt; String(part).trim()).join(&#x27;, &#x27;) : &#x27;Uruguay&#x27;;
  }
}
</code></pre>
    </div>
</div>








                   </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div>
</div>
               <!-- END CONTENT -->
           </div>
       </div>

          <label class="dark-mode-switch">
               <input type="checkbox">
               <span class="slider">
                    <svg class="slider-icon" viewBox="0 0 24 24" fill="none" height="20" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" width="20" xmlns="http://www.w3.org/2000/svg">
                    <path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"></path>
                    </svg>
               </span>
          </label>

       <script>
            var COMPODOC_CURRENT_PAGE_DEPTH = 1;
            var COMPODOC_CURRENT_PAGE_CONTEXT = 'interface';
            var COMPODOC_CURRENT_PAGE_URL = 'ReviewsCacheEntry.html';
            var MAX_SEARCH_RESULTS = 15;
       </script>

       <script>
               $darkModeToggleSwitchers = document.querySelectorAll('.dark-mode-switch input');
               checkToggle(darkModeState);
               if ($darkModeToggleSwitchers.length > 0) {
                    for (var i = 0; i < $darkModeToggleSwitchers.length; i++) {
                         $darkModeToggleSwitchers[i].addEventListener('change', function (event) {
                              darkModeState = !darkModeState;
                              toggleDarkMode(darkModeState);
                         });
                    }
               }
          </script>

       <script src="../js/libs/custom-elements.min.js"></script>
       <script src="../js/libs/lit-html.js"></script>

       <script src="../js/menu-wc.js" defer></script>
       <script nomodule src="../js/menu-wc_es5.js" defer></script>

       <script src="../js/libs/bootstrap-native.js"></script>

       <script src="../js/libs/es6-shim.min.js"></script>
       <script src="../js/libs/EventDispatcher.js"></script>
       <script src="../js/libs/promise.min.js"></script>

       <script src="../js/compodoc.js"></script>

       <script src="../js/tabs.js"></script>
       <script src="../js/menu.js"></script>
       <script src="../js/libs/clipboard.min.js"></script>
       <script src="../js/libs/prism.js"></script>
       <script src="../js/sourceCode.js"></script>
          <script src="../js/search/search.js"></script>
          <script src="../js/search/lunr.min.js"></script>
          <script src="../js/search/search-lunr.js"></script>
          <script src="../js/search/search_index.js"></script>
       <script src="../js/lazy-load-graphs.js"></script>


    </body>
</html>
