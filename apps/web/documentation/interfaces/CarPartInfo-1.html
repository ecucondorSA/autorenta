<!doctype html>
<html class="no-js" lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>autorenta-web documentation</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="icon" type="image/x-icon" href="../images/favicon.ico">
	   <link rel="stylesheet" href="../styles/style.css">
        <link rel="stylesheet" href="../styles/dark.css">
    </head>
    <body>
          <script>
               // Blocking script to avoid flickering dark mode
               // Dark mode toggle button
               var useDark = window.matchMedia('(prefers-color-scheme: dark)');
               var darkModeState = useDark.matches;
               var $darkModeToggleSwitchers = document.querySelectorAll('.dark-mode-switch input');
               var $darkModeToggles = document.querySelectorAll('.dark-mode-switch');
               var darkModeStateLocal = localStorage.getItem('compodoc_darkmode-state');

               function checkToggle(check) {
                    for (var i = 0; i < $darkModeToggleSwitchers.length; i++) {
                         $darkModeToggleSwitchers[i].checked = check;
                    }
               }

               function toggleDarkMode(state) {
                    if (window.localStorage) {
                         localStorage.setItem('compodoc_darkmode-state', state);
                    }

                    checkToggle(state);

                    const hasClass = document.body.classList.contains('dark');

                    if (state) {
                         for (var i = 0; i < $darkModeToggles.length; i++) {
                              $darkModeToggles[i].classList.add('dark');
                         }
                         if (!hasClass) {
                              document.body.classList.add('dark');
                         }
                    } else {
                         for (var i = 0; i < $darkModeToggles.length; i++) {
                              $darkModeToggles[i].classList.remove('dark');
                         }
                         if (hasClass) {
                              document.body.classList.remove('dark');
                         }
                    }
               }

               useDark.addEventListener('change', function (evt) {
                    toggleDarkMode(evt.matches);
               });
               if (darkModeStateLocal) {
                    darkModeState = darkModeStateLocal === 'true';
               }
               toggleDarkMode(darkModeState);
          </script>
          <script>
              // --- Iframe navigation tracking for Template Playground ---
              function sendCurrentUrlToParent() {
                  if (window.parent && window.parent !== window) {
                      window.parent.postMessage({
                          type: 'compodoc-iframe-navigate',
                          url: window.location.pathname + window.location.hash
                      }, '*');
                  }
              }
              window.addEventListener('hashchange', sendCurrentUrlToParent, false);
              window.addEventListener('popstate', sendCurrentUrlToParent, false);
              window.addEventListener('DOMContentLoaded', sendCurrentUrlToParent, false);
          </script>

        <div class="navbar navbar-default navbar-fixed-top d-md-none p-0">
               <div class="d-flex">
                    <a href="../" class="navbar-brand">autorenta-web documentation</a>
                    <button type="button" class="btn btn-default btn-menu ion-ios-menu" id="btn-menu"></button>
               </div>
        </div>

        <div class="xs-menu menu" id="mobile-menu">
                <div id="book-search-input" role="search"><input type="text" placeholder="Type to search"></div>            <compodoc-menu></compodoc-menu>
        </div>

        <div class="container-fluid main">
           <div class="row main">
               <div class="d-none d-md-block menu">
                   <compodoc-menu mode="normal"></compodoc-menu>
               </div>
               <!-- START CONTENT -->
               <div class="content interface">
                   <div class="content-data">

















<ol class="breadcrumb">
  <li class="breadcrumb-item">Interfaces</li>
  <li class="breadcrumb-item"
  >
  CarPartInfo</li>
</ol>

<ul class="nav nav-tabs" role="tablist">
        <li class="nav-item">
            <a href="#info" 
                class="nav-link"
                class="nav-link active"
                role="tab" id="info-tab" data-bs-toggle="tab" data-link="info">Info</a>
        </li>
        <li class="nav-item">
            <a href="#source" 
                class="nav-link"
                
                role="tab" id="source-tab" data-bs-toggle="tab" data-link="source">Source</a>
        </li>
</ul>

<div class="tab-content">
    <div class="tab-pane fade active in" id="info">
        <p class="comment">
            <h3>File</h3>
        </p>
        <p class="comment">
            <code>src/app/shared/components/car-3d-viewer/car-3d-viewer.component.ts</code>
        </p>


            <p class="comment">
                <h3>Description</h3>
            </p>
            <p class="comment">
                <p>Informaci√≥n de una parte del veh√≠culo</p>

            </p>


        <section data-compodoc="block-index">
            <h3 id="index">Index</h3>
            <table class="table table-sm table-bordered index-table">
                <tbody>
                    <tr>
                        <td class="col-md-4">
                            <h6><b>Properties</b></h6>
                        </td>
                    </tr>
                    <tr>
                        <td class="col-md-4">
                            <ul class="index-list">
                                <li>
                                            <span class="modifier">Optional</span>
                                        <a href="#category" 
>
                                            category
                                        </a>
                                </li>
                                <li>
                                        <a href="#description" 
>
                                            description
                                        </a>
                                </li>
                                <li>
                                        <a href="#icon" 
>
                                            icon
                                        </a>
                                </li>
                                <li>
                                        <a href="#name" 
>
                                            name
                                        </a>
                                </li>
                            </ul>
                        </td>
                    </tr>
                </tbody>
            </table>
        </section>



            <section data-compodoc="block-properties">
                <h3 id="inputs">Properties</h3>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="category"></a>
                                        <span class="name "><b>category</b>
                                            <a href="#category">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>category:     <code>&quot;body&quot; | &quot;wheel&quot; | &quot;glass&quot; | &quot;light&quot; | &quot;interior&quot;</code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>    <code>&quot;body&quot; | &quot;wheel&quot; | &quot;glass&quot; | &quot;light&quot; | &quot;interior&quot;</code>

                                        </td>
                                    </tr>

                                    <tr>
                                        <td class="col-md-4">
                                            <i>Optional</i>
                                        </td>
                                    </tr>




                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="description"></a>
                                        <span class="name "><b>description</b>
                                            <a href="#description">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>description:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="icon"></a>
                                        <span class="name "><b>icon</b>
                                            <a href="#icon">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>icon:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="name"></a>
                                        <span class="name "><b>name</b>
                                            <a href="#name">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>name:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
            </section>
    </div>


    <div class="tab-pane fade  tab-source-code" id="source">
        <pre class="line-numbers compodoc-sourcecode"><code class="language-typescript">import { CommonModule, isPlatformBrowser } from &#x27;@angular/common&#x27;;
import {
  AfterViewInit,
  Component,
  ElementRef,
  EventEmitter,
  inject,
  Input,
  NgZone,
  OnChanges,
  OnDestroy,
  Output,
  PLATFORM_ID,
  SimpleChanges,
  ViewChild,
} from &#x27;@angular/core&#x27;;

/**
 * ‚úÖ OPTIMIZED: Dynamic imports for Three.js
 * Reduces initial bundle size by ~500KB
 * Three.js is only loaded when the component is rendered
 */
type THREE &#x3D; typeof import(&#x27;three&#x27;);
type GLTFLoaderType &#x3D; typeof import(&#x27;three/examples/jsm/loaders/GLTFLoader.js&#x27;).GLTFLoader;
type DRACOLoaderType &#x3D; typeof import(&#x27;three/examples/jsm/loaders/DRACOLoader.js&#x27;).DRACOLoader;
type OrbitControlsType &#x3D;
  typeof import(&#x27;three/examples/jsm/controls/OrbitControls.js&#x27;).OrbitControls;

/** Informaci√≥n de una parte del veh√≠culo */
export interface CarPartInfo {
  name: string;
  description: string;
  icon: string;
  category?: &#x27;body&#x27; | &#x27;wheel&#x27; | &#x27;glass&#x27; | &#x27;light&#x27; | &#x27;interior&#x27;;
}

@Component({
  selector: &#x27;app-car-3d-viewer&#x27;,
  standalone: true,
  imports: [CommonModule],
  template: &#x60;
    &lt;div
      class&#x3D;&quot;viewer-container&quot;
      (mouseenter)&#x3D;&quot;onMouseEnter()&quot;
      (mouseleave)&#x3D;&quot;onMouseLeave()&quot;
      (mousemove)&#x3D;&quot;onMouseMove($event)&quot;
      (click)&#x3D;&quot;onClick($event)&quot;
      (dblclick)&#x3D;&quot;onDoubleClick()&quot;
    &gt;
      &lt;canvas #rendererCanvas id&#x3D;&quot;webgl-canvas&quot;&gt;&lt;/canvas&gt;

      &lt;!-- Part Tooltip (hover) --&gt;
      @if (hoveredPartInfo &amp;&amp; !isLoading) {
        &lt;div
          class&#x3D;&quot;part-tooltip&quot;
          [style.left.px]&#x3D;&quot;tooltipPosition.x&quot;
          [style.top.px]&#x3D;&quot;tooltipPosition.y&quot;
        &gt;
          &lt;span class&#x3D;&quot;tooltip-icon&quot;&gt;{{ hoveredPartInfo.icon }}&lt;/span&gt;
          &lt;span class&#x3D;&quot;tooltip-text&quot;&gt;{{ hoveredPartInfo.name }}&lt;/span&gt;
        &lt;/div&gt;
      }

      &lt;!-- Selected Part Indicator --&gt;
      @if (selectedPartInfo) {
        &lt;div class&#x3D;&quot;selected-part-badge&quot;&gt;
          &lt;span class&#x3D;&quot;badge-icon&quot;&gt;{{ selectedPartInfo.icon }}&lt;/span&gt;
          &lt;span class&#x3D;&quot;badge-name&quot;&gt;{{ selectedPartInfo.name }}&lt;/span&gt;
          &lt;button class&#x3D;&quot;badge-close&quot; (click)&#x3D;&quot;deselectPart($event)&quot;&gt;x&lt;/button&gt;
        &lt;/div&gt;
      }

      &lt;!-- Loading Overlay --&gt;
      @if (isLoading) {
        &lt;div class&#x3D;&quot;loading-overlay&quot;&gt;
          &lt;div class&#x3D;&quot;loading-content&quot;&gt;
            &lt;div class&#x3D;&quot;car-silhouette&quot;&gt;
              &lt;svg viewBox&#x3D;&quot;0 0 100 40&quot; fill&#x3D;&quot;currentColor&quot;&gt;
                &lt;path
                  d&#x3D;&quot;M15 30c0-2.8 2.2-5 5-5s5 2.2 5 5H15zm60 0c0-2.8 2.2-5 5-5s5 2.2 5 5H75zM10 25l5-10h25l10-7h20l15 7h10v10l-5 5H15l-5-5z&quot;
                /&gt;
              &lt;/svg&gt;
            &lt;/div&gt;
            &lt;div class&#x3D;&quot;loading-bar&quot;&gt;
              &lt;div class&#x3D;&quot;loading-progress&quot;&gt;&lt;/div&gt;
            &lt;/div&gt;
            &lt;p class&#x3D;&quot;loading-text&quot;&gt;Cargando modelo 3D...&lt;/p&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      }

      &lt;!-- Interaction Hints --&gt;
      @if (!isLoading &amp;&amp; showHints) {
        &lt;div class&#x3D;&quot;interaction-hints&quot; [class.fade-out]&#x3D;&quot;hintsHiding&quot;&gt;
          &lt;div class&#x3D;&quot;hint-item&quot;&gt;
            &lt;span class&#x3D;&quot;hint-icon&quot;&gt;üñ±Ô∏è&lt;/span&gt;
            &lt;span&gt;Arrastra para rotar&lt;/span&gt;
          &lt;/div&gt;
          &lt;div class&#x3D;&quot;hint-item&quot;&gt;
            &lt;span class&#x3D;&quot;hint-icon&quot;&gt;üîç&lt;/span&gt;
            &lt;span&gt;Scroll para zoom&lt;/span&gt;
          &lt;/div&gt;
          &lt;div class&#x3D;&quot;hint-item&quot;&gt;
            &lt;span class&#x3D;&quot;hint-icon&quot;&gt;üëÜ&lt;/span&gt;
            &lt;span&gt;Doble click para reset&lt;/span&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      }

      &lt;!-- View Mode Indicator --&gt;
      &lt;div class&#x3D;&quot;view-mode-indicator&quot;&gt;
        &lt;span class&#x3D;&quot;mode-icon&quot;&gt;{{ getViewModeIcon() }}&lt;/span&gt;
        &lt;span&gt;{{ getViewModeLabel() }}&lt;/span&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &#x60;,
  styles: [
    &#x60;
      :host {
        display: block;
        width: 100%;
        height: 100%;
      }

      .viewer-container {
        width: 100%;
        height: 100%;
        position: relative;
        overflow: hidden;
        cursor: grab;
        transition: transform 0.3s ease;
      }

      .viewer-container:active {
        cursor: grabbing;
      }

      canvas {
        width: 100% !important;
        height: 100% !important;
        display: block;
        outline: none;
      }

      /* Loading Overlay - Autorentar Design */
      .loading-overlay {
        position: absolute;
        inset: 0;
        background: var(--surface-base); /* Use CSS variable */
        backdrop-filter: blur(20px);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10;
      }

      .loading-content {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 1.5rem;
      }

      .car-silhouette {
        width: 120px;
        height: 60px;
        color: var(--cta-default); /* Use CSS variable */
        animation: carPulse 2s ease-in-out infinite;
      }

      .car-silhouette svg {
        width: 100%;
        height: 100%;
      }

      @keyframes carPulse {
        0%,
        100% {
          opacity: 0.4;
          transform: scale(1);
        }
        50% {
          opacity: 1;
          transform: scale(1.05);
        }
      }

      .loading-bar {
        width: 200px;
        height: 3px;
        background: var(--border-subtle); /* Use CSS variable */
        border-radius: 10px;
        overflow: hidden;
      }

      .loading-progress {
        height: 100%;
        width: 30%;
        background-color: var(--cta-default);
        border-radius: 10px;
        animation: loadingSlide 1.2s ease-in-out infinite;
      }

      @keyframes loadingSlide {
        0% {
          transform: translateX(-100%);
        }
        100% {
          transform: translateX(400%);
        }
      }

      .loading-text {
        color: var(--text-secondary); /* Use CSS variable */
        font-size: 0.875rem;
        font-weight: 500;
        letter-spacing: 0.05em;
      }

      /* Interaction Hints - Autorentar Style */
      .interaction-hints {
        position: absolute;
        bottom: 2rem;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 1.5rem;
        padding: 0.75rem 1.5rem;
        background: var(--surface-raised); /* Use CSS variable */
        backdrop-filter: blur(12px);
        border-radius: 9999px;
        border: 1px solid var(--border-default); /* Use CSS variable */
        box-shadow: var(--elevation-2); /* Use CSS variable */
        z-index: 5;
        animation: hintsSlideUp 0.5s ease-out;
        transition:
          opacity 0.5s ease,
          transform 0.5s ease;
      }

      .interaction-hints.fade-out {
        opacity: 0;
        transform: translateX(-50%) translateY(20px);
      }

      @keyframes hintsSlideUp {
        from {
          opacity: 0;
          transform: translateX(-50%) translateY(20px);
        }
        to {
          opacity: 1;
          transform: translateX(-50%) translateY(0);
        }
      }

      .hint-item {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        color: var(--text-primary); /* Use CSS variable */
        font-size: 0.75rem;
        font-weight: 500;
        white-space: nowrap;
      }

      .hint-icon {
        font-size: 1rem;
      }

      /* View Mode Indicator - Autorentar Style */
      .view-mode-indicator {
        position: absolute;
        top: 1.5rem;
        right: 1.5rem;
        display: flex;
        align-items: center;
        gap: 0.5rem;
        padding: 0.5rem 1rem;
        background: var(--surface-raised); /* Use CSS variable */
        backdrop-filter: blur(12px);
        border-radius: 9999px;
        border: 1px solid var(--border-default); /* Use CSS variable */
        color: var(--text-primary); /* Use CSS variable */
        font-size: 0.75rem;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        z-index: 5;
        animation: modeSlideIn 0.3s ease-out;
      }

      @keyframes modeSlideIn {
        from {
          opacity: 0;
          transform: translateX(20px);
        }
        to {
          opacity: 1;
          transform: translateX(0);
        }
      }

      .mode-icon {
        font-size: 1rem;
      }

      /* Hover Glow Effect - Celeste Autorentar */
      .hover-glow {
        display: none;
      }

      /* Part Tooltip */
      .part-tooltip {
        position: absolute;
        display: flex;
        align-items: center;
        gap: 0.5rem;
        padding: 0.5rem 0.875rem;
        background: var(--surface-raised); /* Use CSS variable */
        backdrop-filter: blur(12px);
        border-radius: 8px;
        border: 1px solid var(--border-default); /* Use CSS variable */
        box-shadow: var(--elevation-3); /* Use CSS variable */
        pointer-events: none;
        z-index: 20;
        transform: translate(-50%, -120%);
        animation: tooltipFadeIn 0.2s ease-out;
        white-space: nowrap;
      }

      @keyframes tooltipFadeIn {
        from {
          opacity: 0;
          transform: translate(-50%, -100%);
        }
        to {
          opacity: 1;
          transform: translate(-50%, -120%);
        }
      }

      .tooltip-icon {
        font-size: 1.125rem;
      }

      .tooltip-text {
        font-size: 0.8125rem;
        font-weight: 600;
        color: var(--text-primary); /* Use CSS variable */
        letter-spacing: 0.01em;
      }

      /* Selected Part Badge */
      .selected-part-badge {
        position: absolute;
        bottom: 1.5rem;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        align-items: center;
        gap: 0.625rem;
        padding: 0.625rem 1rem;
        background: var(--surface-raised); /* Use CSS variable */
        backdrop-filter: blur(12px);
        border-radius: 9999px;
        border: 2px solid var(--cta-default); /* Use CSS variable */
        box-shadow: var(--elevation-4); /* Use CSS variable */
        z-index: 15;
        animation: badgeSlideUp 0.3s ease-out;
      }

      @keyframes badgeSlideUp {
        from {
          opacity: 0;
          transform: translateX(-50%) translateY(20px);
        }
        to {
          opacity: 1;
          transform: translateX(-50%) translateY(0);
        }
      }

      .badge-icon {
        font-size: 1.25rem;
      }

      .badge-name {
        font-size: 0.875rem;
        font-weight: 600;
        color: var(--text-primary); /* Use CSS variable */
      }

      .badge-close {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 20px;
        height: 20px;
        margin-left: 0.25rem;
        padding: 0;
        background: var(--surface-secondary); /* Use CSS variable */
        border: none;
        border-radius: 50%;
        color: var(--text-secondary); /* Use CSS variable */
        font-size: 0.75rem;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .badge-close:hover {
        background: var(--cta-secondary); /* Use CSS variable */
        color: var(--text-primary); /* Use CSS variable */
      }

      /* Mobile Responsive */
      @media (max-width: 768px) {
        .interaction-hints {
          flex-direction: column;
          gap: 0.5rem;
          bottom: 1rem;
          padding: 0.75rem 1rem;
        }

        .hint-item {
          font-size: 0.6875rem;
        }

        .view-mode-indicator {
          top: 1rem;
          right: 1rem;
          padding: 0.375rem 0.75rem;
          font-size: 0.6875rem;
        }
      }
    &#x60;,
  ],
})
export class Car3dViewerComponent implements AfterViewInit, OnDestroy, OnChanges {
  @Input() src &#x3D; &#x27;assets/models/car-model.glb&#x27;;
  @Input() alt &#x3D; &#x27;A 3D model of a car&#x27;;
  @Input() debugMode &#x3D; false;
  @Input() selectedColor: string | null | undefined;
  @Input() enableInteraction &#x3D; true;

  @Output() viewModeChange &#x3D; new EventEmitter&lt;string&gt;();
  @Output() modelClicked &#x3D; new EventEmitter&lt;void&gt;();
  @Output() modelLoaded &#x3D; new EventEmitter&lt;void&gt;();
  @Output() partHovered &#x3D; new EventEmitter&lt;{
    part: string;
    info: CarPartInfo | undefined;
    position: { x: number; y: number };
  }&gt;();
  @Output() partSelected &#x3D; new EventEmitter&lt;{ part: string; info: CarPartInfo | undefined }&gt;();
  @Output() partDeselected &#x3D; new EventEmitter&lt;void&gt;();

  @ViewChild(&#x27;rendererCanvas&#x27;) rendererCanvas!: ElementRef&lt;HTMLCanvasElement&gt;;

  private readonly platformId &#x3D; inject(PLATFORM_ID);
  private readonly isBrowser &#x3D; isPlatformBrowser(this.platformId);
  private readonly ngZone &#x3D; inject(NgZone);

  isLoading &#x3D; true;
  isHovered &#x3D; false;
  showHints &#x3D; false;
  hintsHiding &#x3D; false;
  currentViewMode: &#x27;default&#x27; | &#x27;front&#x27; | &#x27;side&#x27; | &#x27;interior&#x27; | &#x27;top&#x27; &#x3D; &#x27;default&#x27;;
  headlightsOn &#x3D; false;
  private headlightSpots: import(&#x27;three&#x27;).Object3D[] &#x3D; [];

  // Part interaction state (public for template)
  hoveredPartInfo: CarPartInfo | null &#x3D; null;
  selectedPartInfo: CarPartInfo | null &#x3D; null;
  tooltipPosition &#x3D; { x: 0, y: 0 };

  // Hint timeout
  private hintsTimeout: ReturnType&lt;typeof setTimeout&gt; | null &#x3D; null;
  private interactionTimeout: ReturnType&lt;typeof setTimeout&gt; | null &#x3D; null;

  // Camera presets for different views
  private readonly cameraPresets &#x3D; {
    default: { position: { x: 4, y: 1.5, z: 6 }, target: { x: 0, y: 0.8, z: 0 } },
    front: { position: { x: 0, y: 1.2, z: 8 }, target: { x: 0, y: 0.8, z: 0 } },
    side: { position: { x: 8, y: 1.5, z: 0 }, target: { x: 0, y: 0.8, z: 0 } },
    // Vista interior desde asiento del conductor - mirando hacia adelante
    interior: { position: { x: -0.35, y: 1.0, z: 0.2 }, target: { x: -0.35, y: 1.0, z: 5 } },
    // Vista alternativa desde asiento del copiloto
    passenger: { position: { x: 0.4, y: 1.1, z: -0.3 }, target: { x: 0.4, y: 1.0, z: 5 } },
    top: { position: { x: 0, y: 10, z: 2 }, target: { x: 0, y: 0, z: 0 } },
  };

  // Three.js module reference (lazy loaded)
  private THREE: THREE | null &#x3D; null;
  private GLTFLoader: GLTFLoaderType | null &#x3D; null;
  private DRACOLoader: DRACOLoaderType | null &#x3D; null;
  private OrbitControls: OrbitControlsType | null &#x3D; null;

  // Three.js objects (typed as any since we load dynamically)
  private scene: import(&#x27;three&#x27;).Scene | null &#x3D; null;
  private camera: import(&#x27;three&#x27;).PerspectiveCamera | null &#x3D; null;
  private renderer: import(&#x27;three&#x27;).WebGLRenderer | null &#x3D; null;
  private carModel: import(&#x27;three&#x27;).Group | null &#x3D; null;
  private animationId: number | null &#x3D; null;
  private resizeObserver: ResizeObserver | null &#x3D; null;
  private mixer: import(&#x27;three&#x27;).AnimationMixer | null &#x3D; null;
  private clock: import(&#x27;three&#x27;).Clock | null &#x3D; null;
  private controls: InstanceType&lt;OrbitControlsType&gt; | null &#x3D; null;

  // Animation state
  private targetCameraPosition: { x: number; y: number; z: number } | null &#x3D; null;
  private targetControlsTarget: { x: number; y: number; z: number } | null &#x3D; null;
  private animatingCamera &#x3D; false;

  // Raycaster for part detection
  private raycaster: import(&#x27;three&#x27;).Raycaster | null &#x3D; null;
  private mouse: import(&#x27;three&#x27;).Vector2 | null &#x3D; null;
  private hoveredMesh: import(&#x27;three&#x27;).Mesh | null &#x3D; null;
  private selectedMesh: import(&#x27;three&#x27;).Mesh | null &#x3D; null;
  private mouseMoveThrottle: ReturnType&lt;typeof setTimeout&gt; | null &#x3D; null;
  private lastMouseEvent: MouseEvent | null &#x3D; null;

  // Main directional light reference for dynamic shadows
  private mainLight: import(&#x27;three&#x27;).DirectionalLight | null &#x3D; null;

  // Part info mapping - detecta partes por nombre de mesh o caracter√≠sticas
  private readonly partInfoMap: Map&lt;string, CarPartInfo&gt; &#x3D; new Map([
    [
      &#x27;body&#x27;,
      {
        name: &#x27;Carroceria&#x27;,
        description: &#x27;Estructura principal del vehiculo&#x27;,
        icon: &#x27;üöó&#x27;,
        category: &#x27;body&#x27;,
      },
    ],
    [
      &#x27;chassis&#x27;,
      {
        name: &#x27;Chasis&#x27;,
        description: &#x27;Base estructural del vehiculo&#x27;,
        icon: &#x27;üîß&#x27;,
        category: &#x27;body&#x27;,
      },
    ],
    [&#x27;hood&#x27;, { name: &#x27;Capo&#x27;, description: &#x27;Cubierta del motor&#x27;, icon: &#x27;üî≤&#x27;, category: &#x27;body&#x27; }],
    [
      &#x27;trunk&#x27;,
      { name: &#x27;Maletero&#x27;, description: &#x27;Compartimiento de carga&#x27;, icon: &#x27;üì¶&#x27;, category: &#x27;body&#x27; },
    ],
    [&#x27;door&#x27;, { name: &#x27;Puerta&#x27;, description: &#x27;Acceso al habitaculo&#x27;, icon: &#x27;üö™&#x27;, category: &#x27;body&#x27; }],
    [
      &#x27;wheel&#x27;,
      { name: &#x27;Rueda&#x27;, description: &#x27;Sistema de rodamiento&#x27;, icon: &#x27;üõû&#x27;, category: &#x27;wheel&#x27; },
    ],
    [
      &#x27;tire&#x27;,
      { name: &#x27;Neumatico&#x27;, description: &#x27;Cubierta de caucho&#x27;, icon: &#x27;‚ö´&#x27;, category: &#x27;wheel&#x27; },
    ],
    [&#x27;rim&#x27;, { name: &#x27;Rin&#x27;, description: &#x27;Llanta de aleacion&#x27;, icon: &#x27;üíø&#x27;, category: &#x27;wheel&#x27; }],
    [&#x27;window&#x27;, { name: &#x27;Ventana&#x27;, description: &#x27;Cristal lateral&#x27;, icon: &#x27;ü™ü&#x27;, category: &#x27;glass&#x27; }],
    [
      &#x27;windshield&#x27;,
      { name: &#x27;Parabrisas&#x27;, description: &#x27;Cristal frontal&#x27;, icon: &#x27;üî≥&#x27;, category: &#x27;glass&#x27; },
    ],
    [
      &#x27;glass&#x27;,
      { name: &#x27;Cristal&#x27;, description: &#x27;Superficie transparente&#x27;, icon: &#x27;‚ú®&#x27;, category: &#x27;glass&#x27; },
    ],
    [
      &#x27;headlight&#x27;,
      { name: &#x27;Faro delantero&#x27;, description: &#x27;Iluminacion frontal&#x27;, icon: &#x27;üí°&#x27;, category: &#x27;light&#x27; },
    ],
    [
      &#x27;taillight&#x27;,
      { name: &#x27;Faro trasero&#x27;, description: &#x27;Iluminacion posterior&#x27;, icon: &#x27;üî¥&#x27;, category: &#x27;light&#x27; },
    ],
    [&#x27;mirror&#x27;, { name: &#x27;Espejo&#x27;, description: &#x27;Retrovisor lateral&#x27;, icon: &#x27;ü™û&#x27;, category: &#x27;body&#x27; }],
    [
      &#x27;bumper&#x27;,
      {
        name: &#x27;Paragolpes&#x27;,
        description: &#x27;Proteccion frontal/trasera&#x27;,
        icon: &#x27;üõ°Ô∏è&#x27;,
        category: &#x27;body&#x27;,
      },
    ],
    [&#x27;grille&#x27;, { name: &#x27;Parrilla&#x27;, description: &#x27;Rejilla frontal&#x27;, icon: &#x27;‚ñ¶&#x27;, category: &#x27;body&#x27; }],
    [
      &#x27;seat&#x27;,
      { name: &#x27;Asiento&#x27;, description: &#x27;Asiento del vehiculo&#x27;, icon: &#x27;ü™ë&#x27;, category: &#x27;interior&#x27; },
    ],
    [
      &#x27;dashboard&#x27;,
      { name: &#x27;Tablero&#x27;, description: &#x27;Panel de instrumentos&#x27;, icon: &#x27;üìä&#x27;, category: &#x27;interior&#x27; },
    ],
    [
      &#x27;steering&#x27;,
      { name: &#x27;Volante&#x27;, description: &#x27;Control de direccion&#x27;, icon: &#x27;üé°&#x27;, category: &#x27;interior&#x27; },
    ],
  ]);

  // Colors for mapping
  // Colores alineados a la paleta del sistema de dise√±o (sin hex legacy)
  colors &#x3D; [
    { name: &#x27;Celeste&#x27;, hex: &#x27;#a7d8f4&#x27; }, // CTA default
    { name: &#x27;Celeste Hover&#x27;, hex: &#x27;#8ec9ec&#x27; }, // CTA hover
    { name: &#x27;Marfil&#x27;, hex: &#x27;#f8f4ec&#x27; }, // Surface base
    { name: &#x27;Beige&#x27;, hex: &#x27;#dfd2bf&#x27; }, // Surface secondary
    { name: &#x27;Blanco&#x27;, hex: &#x27;#ffffff&#x27; }, // Surface raised
    { name: &#x27;Gris Claro&#x27;, hex: &#x27;#bcbcbc&#x27; }, // Border default
    { name: &#x27;Oliva&#x27;, hex: &#x27;#9db38b&#x27; }, // Success token
    { name: &#x27;√ìxido&#x27;, hex: &#x27;#b25e5e&#x27; }, // Error token
    { name: &#x27;Negro&#x27;, hex: &#x27;#050505&#x27; }, // Text primary
  ];

  private themeChangeListener: ((event: Event) &#x3D;&gt; void) | null &#x3D; null;

  async ngAfterViewInit(): Promise&lt;void&gt; {
    if (!this.isBrowser) {
      this.isLoading &#x3D; false;
      return;
    }

    try {
      // ‚úÖ OPTIMIZED: Dynamic import of Three.js
      const [threeModule, gltfModule, dracoModule, orbitModule] &#x3D; await Promise.all([
        import(&#x27;three&#x27;),
        import(&#x27;three/examples/jsm/loaders/GLTFLoader.js&#x27;),
        import(&#x27;three/examples/jsm/loaders/DRACOLoader.js&#x27;),
        import(&#x27;three/examples/jsm/controls/OrbitControls.js&#x27;),
      ]);

      this.THREE &#x3D; threeModule;
      this.GLTFLoader &#x3D; gltfModule.GLTFLoader;
      this.DRACOLoader &#x3D; dracoModule.DRACOLoader;
      this.OrbitControls &#x3D; orbitModule.OrbitControls;

      // Initialize Raycaster for part detection
      this.raycaster &#x3D; new this.THREE.Raycaster();
      this.mouse &#x3D; new this.THREE.Vector2();

      this.initScene();
      this.setupOrbitControls();
      this.setupLights();
      this.createRoad();
      this.loadCar();
      this.startAnimationLoop();
      this.setupResizeObserver();

      // Listen for theme changes
      this.themeChangeListener &#x3D; (_event: Event) &#x3D;&gt; {
        // const customEvent &#x3D; event as CustomEvent;
        this.updateThemeColors();
      };
      window.addEventListener(&#x27;autorenta:theme-change&#x27;, this.themeChangeListener);
    } catch (error) {
      console.error(&#x27;[Car3dViewer] Failed to load Three.js:&#x27;, error);
      this.isLoading &#x3D; false;
    }
  }

  ngOnChanges(changes: SimpleChanges): void {
    if (changes[&#x27;selectedColor&#x27;] &amp;&amp; !changes[&#x27;selectedColor&#x27;].firstChange) {
      if (this.selectedColor) {
        this.applyColor(this.selectedColor);
      }
    }
  }

  ngOnDestroy(): void {
    if (this.animationId) {
      cancelAnimationFrame(this.animationId);
    }
    if (this.resizeObserver) {
      this.resizeObserver.disconnect();
    }
    if (this.mixer) {
      this.mixer.stopAllAction();
    }
    if (this.controls) {
      this.controls.dispose();
    }
    if (this.renderer) {
      this.renderer.dispose();
    }
    if (this.mouseMoveThrottle) {
      clearTimeout(this.mouseMoveThrottle);
    }
    if (this.hintsTimeout) {
      clearTimeout(this.hintsTimeout);
    }
    if (this.themeChangeListener) {
      window.removeEventListener(&#x27;autorenta:theme-change&#x27;, this.themeChangeListener);
    }
  }

  private initScene(): void {
    if (!this.THREE) return;

    this.scene &#x3D; new this.THREE.Scene();

    // Initial theme colors update
    this.updateThemeColors();

    // 2. Camera - M√°s cerca y FOV m√°s estrecho para efecto inmersivo
    const width &#x3D; this.rendererCanvas.nativeElement.clientWidth;
    const height &#x3D; this.rendererCanvas.nativeElement.clientHeight;
    this.camera &#x3D; new this.THREE.PerspectiveCamera(35, width / height, 0.1, 1000);
    // Posici√≥n de c√°mara m√°s cercana y centrada
    this.camera.position.set(4, 1.5, 6);
    this.camera.lookAt(0, 0.8, 0);

    // 3. Renderer - alpha: true para fondo transparente (usa el fondo del HTML)
    this.renderer &#x3D; new this.THREE.WebGLRenderer({
      canvas: this.rendererCanvas.nativeElement,
      antialias: true,
      alpha: true,
    });
    this.renderer.setSize(width, height);
    this.renderer.setPixelRatio(window.devicePixelRatio);
    this.renderer.shadowMap.enabled &#x3D; true;
    this.renderer.shadowMap.type &#x3D; this.THREE.PCFSoftShadowMap;
    this.renderer.outputColorSpace &#x3D; this.THREE.SRGBColorSpace;
    this.renderer.toneMapping &#x3D; this.THREE.ACESFilmicToneMapping;
    this.renderer.toneMappingExposure &#x3D; 1.8; // AUMENTADO de 1.2 a 1.8 para m√°s brillo
  }

  private updateThemeColors(): void {
    if (!this.THREE || !this.scene || !this.renderer) return;

    const styles &#x3D; getComputedStyle(document.documentElement);
    const surfaceBase &#x3D; styles.getPropertyValue(&#x27;--surface-base&#x27;).trim();
    const surfaceSecondary &#x3D; styles.getPropertyValue(&#x27;--surface-secondary&#x27;).trim();

    // Fondo transparente - usa el fondo del HTML (marfil)
    this.scene.background &#x3D; null;
    this.renderer.setClearColor(0x000000, 0); // Transparente

    // Update environment for reflections
    this.createStudioEnvironment(surfaceBase, surfaceSecondary);
  }

  private setupOrbitControls(): void {
    if (!this.OrbitControls || !this.camera || !this.renderer) return;

    this.controls &#x3D; new this.OrbitControls(this.camera, this.renderer.domElement);

    // Configuraci√≥n para experiencia inmersiva - entrar/salir del auto
    this.controls.enableDamping &#x3D; true;
    this.controls.dampingFactor &#x3D; 0.08; // Movimiento m√°s suave
    this.controls.enableZoom &#x3D; true;
    this.controls.enablePan &#x3D; false; // Desactivar pan para mantener centrado
    this.controls.minDistance &#x3D; 0.1; // Permite entrar completamente dentro del auto
    this.controls.maxDistance &#x3D; 20; // Puede alejarse para vista completa
    this.controls.minPolarAngle &#x3D; 0; // Puede ver desde arriba
    this.controls.maxPolarAngle &#x3D; Math.PI / 1.8; // Casi hasta abajo
    this.controls.target.set(0, 0.8, 0); // Mirar al centro del auto
    this.controls.autoRotate &#x3D; true; // Rotaci√≥n autom√°tica
    this.controls.autoRotateSpeed &#x3D; 0.3; // Rotaci√≥n m√°s lenta
    this.controls.zoomSpeed &#x3D; 1.2; // Zoom m√°s r√°pido para transici√≥n suave
    this.controls.rotateSpeed &#x3D; 0.8; // Rotaci√≥n manual suave

    // Detener auto-rotaci√≥n cuando el usuario interact√∫a
    this.controls.addEventListener(&#x27;start&#x27;, () &#x3D;&gt; {
      this.controls!.autoRotate &#x3D; false;
    });

    // Reanudar auto-rotaci√≥n despu√©s de 3 segundos de inactividad
    this.controls.addEventListener(&#x27;end&#x27;, () &#x3D;&gt; {
      setTimeout(() &#x3D;&gt; {
        if (this.controls) {
          this.controls.autoRotate &#x3D; true;
        }
      }, 3000);
    });
  }

  private setupLights(): void {
    if (!this.THREE || !this.scene) return;

    // Ambient Light (Soft fill) - AUMENTADO para mejor visibilidad
    const ambientLight &#x3D; new this.THREE.AmbientLight(0xffffff, 1.2);
    this.scene.add(ambientLight);

    // Main Directional Light (Sun/Key Light) - INTENSIDAD AUMENTADA
    this.mainLight &#x3D; new this.THREE.DirectionalLight(0xffffff, 3.5);
    this.mainLight.position.set(8, 12, 10);
    this.mainLight.castShadow &#x3D; true;
    this.mainLight.shadow.mapSize.width &#x3D; 2048;
    this.mainLight.shadow.mapSize.height &#x3D; 2048;
    this.mainLight.shadow.camera.near &#x3D; 0.1;
    this.mainLight.shadow.camera.far &#x3D; 50;
    this.mainLight.shadow.bias &#x3D; -0.0001;
    this.mainLight.shadow.radius &#x3D; 4;
    this.scene.add(this.mainLight);

    // Fill Light (Cooler, from opposite side) - INTENSIDAD AUMENTADA
    const fillLight &#x3D; new this.THREE.DirectionalLight(0xddeeff, 1.8);
    fillLight.position.set(-8, 4, -8);
    this.scene.add(fillLight);

    // Rim Light (Backlight for edge definition) - INTENSIDAD AUMENTADA
    const rimLight &#x3D; new this.THREE.SpotLight(0xffffff, 5.0);
    rimLight.position.set(0, 8, -12);
    rimLight.lookAt(0, 0, 0);
    this.scene.add(rimLight);

    // Highlight Light - NUEVO PARA RESALTAR DETALLES
    const highlightLight &#x3D; new this.THREE.DirectionalLight(0xffffff, 2.0);
    highlightLight.position.set(10, 5, 0);
    this.scene.add(highlightLight);
  }

  private createRoad(): void {
    if (!this.THREE || !this.scene) return;

    // Shadow Catcher Plane
    const geometry &#x3D; new this.THREE.PlaneGeometry(100, 100);
    const material &#x3D; new this.THREE.ShadowMaterial({
      opacity: 0.3, // M√°s sutil para fondo claro
    });

    const plane &#x3D; new this.THREE.Mesh(geometry, material);
    plane.rotation.x &#x3D; -Math.PI / 2;
    plane.receiveShadow &#x3D; true;
    this.scene.add(plane);
  }

  /** Create procedural studio environment for realistic reflections */
  private createStudioEnvironment(
    baseColor: string &#x3D; &#x27;#f8f4ec&#x27;,
    _secondaryColor: string &#x3D; &#x27;#dfd2bf&#x27;,
  ): void {
    if (!this.THREE || !this.scene || !this.renderer) return;

    // Create a simple environment scene for reflections
    const pmremGenerator &#x3D; new this.THREE.PMREMGenerator(this.renderer);
    pmremGenerator.compileEquirectangularShader();

    // Create a soft, flat environment texture (sin gradientes)
    const envCanvas &#x3D; document.createElement(&#x27;canvas&#x27;);
    envCanvas.width &#x3D; 256;
    envCanvas.height &#x3D; 128;
    const envCtx &#x3D; envCanvas.getContext(&#x27;2d&#x27;);

    if (envCtx) {
      // Fondo uniforme basado en los tokens claros
      envCtx.fillStyle &#x3D; baseColor;
      envCtx.fillRect(0, 0, 256, 128);

      // Destellos sutiles para simular ventanas sin recurrir a gradientes
      envCtx.fillStyle &#x3D; &#x27;rgba(255, 255, 255, 0.25)&#x27;;
      envCtx.fillRect(50, 10, 40, 30); // Left window
      envCtx.fillRect(166, 10, 40, 30); // Right window

      // Acento celeste (CTA) muy tenue
      envCtx.fillStyle &#x3D; &#x27;rgba(167, 216, 244, 0.12)&#x27;;
      envCtx.fillRect(100, 5, 56, 40); // Center accent
    }

    const envTexture &#x3D; new this.THREE.CanvasTexture(envCanvas);
    envTexture.mapping &#x3D; this.THREE.EquirectangularReflectionMapping;
    envTexture.needsUpdate &#x3D; true;

    // Generate environment map from texture
    const renderTarget &#x3D; pmremGenerator.fromEquirectangular(envTexture);
    this.scene.environment &#x3D; renderTarget.texture;

    // Cleanup
    envTexture.dispose();
    pmremGenerator.dispose();
  }

  private loadCar(): void {
    if (!this.THREE || !this.GLTFLoader || !this.DRACOLoader || !this.scene) return;

    // Configure DRACO loader for compressed models
    const dracoLoader &#x3D; new this.DRACOLoader();
    // Use local path for DRACO decoder instead of CDN to avoid 504 Gateway Timeout
    dracoLoader.setDecoderPath(&#x27;/libs/draco/&#x27;);
    dracoLoader.setDecoderConfig({ type: &#x27;wasm&#x27; });

    const loader &#x3D; new this.GLTFLoader();
    loader.setDRACOLoader(dracoLoader);

    loader.load(
      this.src,
      (gltf) &#x3D;&gt; {
        if (!this.THREE || !this.scene) return;

        this.carModel &#x3D; gltf.scene;

        // Center the model
        const box &#x3D; new this.THREE.Box3().setFromObject(this.carModel);
        const center &#x3D; box.getCenter(new this.THREE.Vector3());
        const size &#x3D; box.getSize(new this.THREE.Vector3());

        // Adjust position so it sits on the ground
        this.carModel.position.x +&#x3D; this.carModel.position.x - center.x;
        this.carModel.position.y &#x3D; 0;
        this.carModel.position.z +&#x3D; this.carModel.position.z - center.z;

        // Escalar el modelo para que ocupe bien el espacio
        // Tama√±o objetivo: ~6 unidades para que sea prominente
        const maxDim &#x3D; Math.max(size.x, size.y, size.z);
        const targetSize &#x3D; 8; // M√°s grande para efecto inmersivo
        const scale &#x3D; targetSize / maxDim;
        this.carModel.scale.set(scale, scale, scale);

        // Reposicionar despu√©s de escalar para centrar correctamente
        const scaledBox &#x3D; new this.THREE.Box3().setFromObject(this.carModel);
        const scaledCenter &#x3D; scaledBox.getCenter(new this.THREE.Vector3());
        this.carModel.position.x &#x3D; -scaledCenter.x;
        this.carModel.position.z &#x3D; -scaledCenter.z;
        // Ajustar Y para que el modelo est√© sobre el suelo
        // const scaledSize &#x3D; scaledBox.getSize(new this.THREE.Vector3());
        this.carModel.position.y &#x3D; -scaledBox.min.y;

        // Enable shadows, enhance materials, and add edge outlines
        this.carModel.traverse((child) &#x3D;&gt; {
          if (!this.THREE) return;
          const mesh &#x3D; child as import(&#x27;three&#x27;).Mesh;
          if (mesh.isMesh) {
            mesh.castShadow &#x3D; true;
            mesh.receiveShadow &#x3D; true;

            if (mesh.material instanceof this.THREE.MeshStandardMaterial) {
              mesh.material.envMapIntensity &#x3D; 2.5; // AUMENTADO para mayor reflectividad
              mesh.material.metalness &#x3D; Math.max(mesh.material.metalness, 0.6); // Asegurar metallic
              mesh.material.roughness &#x3D; Math.min(mesh.material.roughness, 0.4); // Menos rugoso para brillo
              mesh.material.needsUpdate &#x3D; true;
            }

            // Add edge outlines to highlight parts - more visible
            if (mesh.geometry) {
              const edges &#x3D; new this.THREE.EdgesGeometry(mesh.geometry, 25); // 25 degree threshold (more edges)
              const lineMaterial &#x3D; new this.THREE.LineBasicMaterial({
                color: 0x2b5f72, // --text-secondary (azul celeste oscuro)
                transparent: true,
                opacity: 0.35, // M√°s visible
                linewidth: 1,
              });
              const edgeLines &#x3D; new this.THREE.LineSegments(edges, lineMaterial);
              edgeLines.userData[&#x27;isEdgeLine&#x27;] &#x3D; true; // Mark for later identification
              mesh.add(edgeLines);
            }
          }
        });

        // Setup animations
        if (gltf.animations &amp;&amp; gltf.animations.length &gt; 0) {
          this.mixer &#x3D; new this.THREE.AnimationMixer(this.carModel);
          const clip &#x3D; gltf.animations[0]; // &quot;Base Stack&quot; animation
          const action &#x3D; this.mixer.clipAction(clip);
          action.loop &#x3D; this.THREE.LoopRepeat; // Loop the animation
          action.play();

          // Start at sequence 3 (13.91 seconds / 27.83 seconds total)
          // This position will be set in the animation loop
          this.mixer.timeScale &#x3D; 1; // Normal speed
        }

        this.scene.add(this.carModel);
        this.isLoading &#x3D; false;
        this.modelLoaded.emit();

        // Apply initial color if set
        if (this.selectedColor) {
          this.applyColor(this.selectedColor);
        }
      },
      (_xhr) &#x3D;&gt; {
        // Progress callback - could add progress indicator
      },
      (error) &#x3D;&gt; {
        console.error(&#x27;[Car3dViewer] Error loading car model:&#x27;, error);
        this.isLoading &#x3D; false;
      },
    );
  }

  private startAnimationLoop(): void {
    if (!this.renderer || !this.scene || !this.camera) return;

    this.ngZone.runOutsideAngular(() &#x3D;&gt; {
      this.clock &#x3D; new this.THREE!.Clock();
      let isFirstFrame &#x3D; true;

      const animate &#x3D; () &#x3D;&gt; {
        this.animationId &#x3D; requestAnimationFrame(animate);
        const delta &#x3D; this.clock.getDelta();

        // Update animations
        if (this.mixer) {
          // On first frame, set the mixer time to sequence 3 (13.91 seconds)
          if (isFirstFrame) {
            this.mixer.setTime(13.91);
            isFirstFrame &#x3D; false;
          }
          this.mixer.update(delta);
        }

        // Update camera animation (smooth transitions)
        this.updateCameraAnimation();

        // Update dynamic shadows based on camera angle
        this.updateDynamicShadows();

        // Update orbit controls
        if (this.controls) {
          this.controls.update();
        }

        if (this.renderer &amp;&amp; this.scene &amp;&amp; this.camera) {
          this.renderer.render(this.scene, this.camera);
        }
      };
      animate();
    });
  }

  private setupResizeObserver(): void {
    this.resizeObserver &#x3D; new ResizeObserver(() &#x3D;&gt; {
      this.ngZone.run(() &#x3D;&gt; {
        this.onWindowResize();
      });
    });
    this.resizeObserver.observe(this.rendererCanvas.nativeElement.parentElement!);
  }

  private onWindowResize(): void {
    if (!this.rendererCanvas || !this.camera || !this.renderer) return;

    const parent &#x3D; this.rendererCanvas.nativeElement.parentElement;
    if (parent) {
      const width &#x3D; parent.clientWidth;
      const height &#x3D; parent.clientHeight;

      this.camera.aspect &#x3D; width / height;
      this.camera.updateProjectionMatrix();
      this.renderer.setSize(width, height);
    }
  }

  private applyColor(colorNameOrHex: string): void {
    if (!this.THREE || !this.carModel) return;

    let hexColor &#x3D; colorNameOrHex;

    // Check predefined colors
    const predefined &#x3D; this.colors.find(
      (c) &#x3D;&gt; c.name.toLowerCase() &#x3D;&#x3D;&#x3D; colorNameOrHex.toLowerCase(),
    );
    if (predefined) {
      hexColor &#x3D; predefined.hex;
    }

    if (!hexColor.startsWith(&#x27;#&#x27;)) return;

    this.carModel.traverse((child) &#x3D;&gt; {
      if (!this.THREE) return;
      const mesh &#x3D; child as import(&#x27;three&#x27;).Mesh;
      if (mesh.isMesh) {
        if (mesh.material instanceof this.THREE.MeshStandardMaterial) {
          const color &#x3D; mesh.material.color;
          // If it&#x27;s not very dark (tires) and not transparent (glass)
          if (color.r &gt; 0.1 || color.g &gt; 0.1 || color.b &gt; 0.1) {
            if (mesh.material.opacity &gt; 0.9) {
              mesh.material.color.set(hexColor);
            }
          }
        }
      }
    });
  }

  // &#x3D;&#x3D;&#x3D;&#x3D;&#x3D; INTERACTION METHODS &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;

  onMouseEnter(): void {
    if (!this.enableInteraction) return;
    this.isHovered &#x3D; true;

    // Show hints on first hover (only once)
    if (!this.showHints &amp;&amp; !this.isLoading) {
      this.showHints &#x3D; true;
      // Auto-hide hints after 5 seconds
      this.hintsTimeout &#x3D; setTimeout(() &#x3D;&gt; {
        this.hideHints();
      }, 5000);
    }

    // Slightly increase auto-rotate speed on hover
    if (this.controls) {
      this.controls.autoRotateSpeed &#x3D; 0.8;
    }
  }

  onMouseLeave(): void {
    this.isHovered &#x3D; false;

    // Restore normal auto-rotate speed
    if (this.controls) {
      this.controls.autoRotateSpeed &#x3D; 0.3;
    }
  }

  onClick(_event: MouseEvent): void {
    if (!this.enableInteraction) return;
    this.modelClicked.emit();

    // Hide hints on any interaction
    if (this.showHints) {
      this.hideHints();
    }

    // Select hovered part if any
    if (this.hoveredMesh) {
      this.selectPart(this.hoveredMesh);
    } else {
      // Click on empty space deselects
      if (this.selectedMesh) {
        this.deselectPart();
      }
    }
  }

  onDoubleClick(): void {
    if (!this.enableInteraction) return;

    // Reset to default view
    this.setViewMode(&#x27;default&#x27;);
  }

  private hideHints(): void {
    if (this.hintsTimeout) {
      clearTimeout(this.hintsTimeout);
      this.hintsTimeout &#x3D; null;
    }
    this.hintsHiding &#x3D; true;
    setTimeout(() &#x3D;&gt; {
      this.showHints &#x3D; false;
      this.hintsHiding &#x3D; false;
    }, 500);
  }

  /** Set camera to a preset view with smooth animation */
  setViewMode(mode: &#x27;default&#x27; | &#x27;front&#x27; | &#x27;side&#x27; | &#x27;interior&#x27; | &#x27;top&#x27;): void {
    if (!this.camera || !this.controls) return;

    const preset &#x3D; this.cameraPresets[mode];
    this.targetCameraPosition &#x3D; preset.position;
    this.targetControlsTarget &#x3D; preset.target;
    this.animatingCamera &#x3D; true;
    this.currentViewMode &#x3D; mode;
    this.viewModeChange.emit(mode);

    // Update part visibility based on mode
    this.updatePartVisibility(mode);

    // Stop auto-rotate during animation
    if (this.controls) {
      this.controls.autoRotate &#x3D; false;
    }

    // Re-enable auto-rotate after animation (unless in interior mode)
    setTimeout(() &#x3D;&gt; {
      this.animatingCamera &#x3D; false;
      if (this.controls &amp;&amp; mode &#x3D;&#x3D;&#x3D; &#x27;default&#x27;) {
        this.controls.autoRotate &#x3D; true;
      }
    }, 1000);
  }

  /** Update visibility of parts based on view mode */
  private updatePartVisibility(mode: string): void {
    if (!this.carModel || !this.THREE) return;

    const isInterior &#x3D; mode &#x3D;&#x3D;&#x3D; &#x27;interior&#x27;;

    this.carModel.traverse((child) &#x3D;&gt; {
      const mesh &#x3D; child as import(&#x27;three&#x27;).Mesh;
      if (mesh.isMesh) {
        const partInfo &#x3D; this.getPartInfoFromMesh(mesh);

        // If interior mode, hide exterior parts
        if (isInterior) {
          // Hide body, glass, wheels, etc.
          if (
            partInfo.category &#x3D;&#x3D;&#x3D; &#x27;body&#x27; ||
            partInfo.category &#x3D;&#x3D;&#x3D; &#x27;glass&#x27; ||
            partInfo.category &#x3D;&#x3D;&#x3D; &#x27;wheel&#x27; ||
            partInfo.category &#x3D;&#x3D;&#x3D; &#x27;light&#x27;
          ) {
            // Check if it&#x27;s a door (might want to keep door frames but usually better to hide for clear view)
            mesh.visible &#x3D; false;
          } else {
            // Ensure interior parts are visible
            mesh.visible &#x3D; true;
          }
        } else {
          // Show everything in other modes
          mesh.visible &#x3D; true;
        }
      }
    });
  }

  /** Toggle headlights on/off */
  toggleHeadlights(): void {
    if (!this.carModel || !this.THREE || !this.scene) return;

    this.headlightsOn &#x3D; !this.headlightsOn;

    // 1. Toggle Emissive Material
    this.carModel.traverse((child) &#x3D;&gt; {
      const mesh &#x3D; child as import(&#x27;three&#x27;).Mesh;
      if (mesh.isMesh) {
        const name &#x3D; mesh.name.toLowerCase();
        // Detect headlights
        if (name.includes(&#x27;headlight&#x27;) || name.includes(&#x27;light_front&#x27;) || name.includes(&#x27;lamp&#x27;)) {
          if (mesh.material instanceof this.THREE!.MeshStandardMaterial) {
            if (this.headlightsOn) {
              // Store original if not exists
              if (!mesh.userData[&#x27;originalEmissive&#x27;]) {
                mesh.userData[&#x27;originalEmissive&#x27;] &#x3D; mesh.material.emissive.clone();
                mesh.userData[&#x27;originalEmissiveIntensity&#x27;] &#x3D; mesh.material.emissiveIntensity;
              }
              // Turn on
              mesh.material.emissive.set(0xffffee); // Warm white
              mesh.material.emissiveIntensity &#x3D; 5;
            } else {
              // Restore
              if (mesh.userData[&#x27;originalEmissive&#x27;]) {
                mesh.material.emissive.copy(mesh.userData[&#x27;originalEmissive&#x27;]);
                mesh.material.emissiveIntensity &#x3D; mesh.userData[&#x27;originalEmissiveIntensity&#x27;] || 0;
              }
            }
            mesh.material.needsUpdate &#x3D; true;
          }
        }
      }
    });

    // 2. Manage SpotLights
    if (this.headlightsOn) {
      this.addHeadlightBeams();
    } else {
      this.removeHeadlightBeams();
    }
  }

  private addHeadlightBeams(): void {
    if (!this.THREE || !this.scene || !this.carModel) return;

    // Approximate headlight positions (relative to car)
    // Assuming car faces +Z or -Z. Based on camera presets, front is likely +Z or -Z.
    // Let&#x27;s guess positions based on car bounds or hardcoded for this model.
    // Front view preset is z&#x3D;8, target z&#x3D;0. So front of car is likely +Z.

    const box &#x3D; new this.THREE.Box3().setFromObject(this.carModel);
    const size &#x3D; box.getSize(new this.THREE.Vector3());
    const center &#x3D; box.getCenter(new this.THREE.Vector3());

    // Front is likely at max Z or min Z.
    // Let&#x27;s assume standard GLTF orientation: +Z is front.
    // Actually, usually +Z is front in Three.js if exported correctly, or -Z.
    // Let&#x27;s try placing lights at the &quot;front&quot; bounding box face.

    const zPos &#x3D; box.max.z - 0.5; // Slightly inside
    const yPos &#x3D; center.y;
    const xOffset &#x3D; size.x * 0.3; // 30% from center

    const leftLight &#x3D; new this.THREE.SpotLight(0xffffee, 10);
    leftLight.position.set(center.x + xOffset, yPos, zPos);
    leftLight.target.position.set(center.x + xOffset, yPos, zPos + 10);
    leftLight.angle &#x3D; Math.PI / 6;
    leftLight.penumbra &#x3D; 0.2;
    leftLight.distance &#x3D; 20;
    leftLight.castShadow &#x3D; true;

    const rightLight &#x3D; new this.THREE.SpotLight(0xffffee, 10);
    rightLight.position.set(center.x - xOffset, yPos, zPos);
    rightLight.target.position.set(center.x - xOffset, yPos, zPos + 10);
    rightLight.angle &#x3D; Math.PI / 6;
    rightLight.penumbra &#x3D; 0.2;
    rightLight.distance &#x3D; 20;
    rightLight.castShadow &#x3D; true;

    this.scene.add(leftLight);
    this.scene.add(leftLight.target);
    this.scene.add(rightLight);
    this.scene.add(rightLight.target);

    this.headlightSpots.push(leftLight, leftLight.target, rightLight, rightLight.target);
  }

  private removeHeadlightBeams(): void {
    if (!this.scene) return;

    this.headlightSpots.forEach((obj) &#x3D;&gt; {
      this.scene!.remove(obj);
    });
    this.headlightSpots &#x3D; [];
  }

  /** Cycle through view modes on click */
  cycleViewMode(): void {
    const modes: Array&lt;&#x27;default&#x27; | &#x27;front&#x27; | &#x27;side&#x27; | &#x27;interior&#x27; | &#x27;top&#x27;&gt; &#x3D; [
      &#x27;default&#x27;,
      &#x27;front&#x27;,
      &#x27;side&#x27;,
      &#x27;interior&#x27;,
      &#x27;top&#x27;,
    ];
    const currentIndex &#x3D; modes.indexOf(this.currentViewMode);
    const nextIndex &#x3D; (currentIndex + 1) % modes.length;
    this.setViewMode(modes[nextIndex]);
  }

  getViewModeIcon(): string {
    const icons: Record&lt;string, string&gt; &#x3D; {
      default: &#x27;üé¨&#x27;,
      front: &#x27;üëÅÔ∏è&#x27;,
      side: &#x27;‚ÜîÔ∏è&#x27;,
      interior: &#x27;üöó&#x27;,
      top: &#x27;üîù&#x27;,
    };
    return icons[this.currentViewMode] || &#x27;üé¨&#x27;;
  }

  getViewModeLabel(): string {
    const labels: Record&lt;string, string&gt; &#x3D; {
      default: &#x27;Vista General&#x27;,
      front: &#x27;Vista Frontal&#x27;,
      side: &#x27;Vista Lateral&#x27;,
      interior: &#x27;Interior&#x27;,
      top: &#x27;Vista Superior&#x27;,
    };
    return labels[this.currentViewMode] || &#x27;Vista General&#x27;;
  }

  /** Smooth lerp for camera animation */
  private lerp(start: number, end: number, t: number): number {
    return start + (end - start) * t;
  }

  /** Update camera position smoothly in animation loop */
  private updateCameraAnimation(): void {
    if (!this.animatingCamera || !this.camera || !this.controls) return;
    if (!this.targetCameraPosition || !this.targetControlsTarget) return;

    const lerpFactor &#x3D; 0.05;

    // Animate camera position
    this.camera.position.x &#x3D; this.lerp(
      this.camera.position.x,
      this.targetCameraPosition.x,
      lerpFactor,
    );
    this.camera.position.y &#x3D; this.lerp(
      this.camera.position.y,
      this.targetCameraPosition.y,
      lerpFactor,
    );
    this.camera.position.z &#x3D; this.lerp(
      this.camera.position.z,
      this.targetCameraPosition.z,
      lerpFactor,
    );

    // Animate controls target
    this.controls.target.x &#x3D; this.lerp(
      this.controls.target.x,
      this.targetControlsTarget.x,
      lerpFactor,
    );
    this.controls.target.y &#x3D; this.lerp(
      this.controls.target.y,
      this.targetControlsTarget.y,
      lerpFactor,
    );
    this.controls.target.z &#x3D; this.lerp(
      this.controls.target.z,
      this.targetControlsTarget.z,
      lerpFactor,
    );
  }

  // &#x3D;&#x3D;&#x3D;&#x3D;&#x3D; RAYCASTER &amp; PART INTERACTION METHODS &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;

  /** Handle mouse move for part hover detection */
  onMouseMove(event: MouseEvent): void {
    if (!this.enableInteraction || this.isLoading) return;
    if (!this.raycaster || !this.mouse || !this.camera || !this.carModel) return;

    // Throttle mousemove to 60fps for performance
    if (this.mouseMoveThrottle) return;
    this.lastMouseEvent &#x3D; event;

    this.mouseMoveThrottle &#x3D; setTimeout(() &#x3D;&gt; {
      this.mouseMoveThrottle &#x3D; null;
      if (this.lastMouseEvent) {
        this.performRaycast(this.lastMouseEvent);
      }
    }, 16); // ~60fps
  }

  /** Perform raycast to detect intersected mesh */
  private performRaycast(event: MouseEvent): void {
    if (!this.raycaster || !this.mouse || !this.camera || !this.carModel || !this.renderer) return;

    const rect &#x3D; this.renderer.domElement.getBoundingClientRect();
    this.mouse.x &#x3D; ((event.clientX - rect.left) / rect.width) * 2 - 1;
    this.mouse.y &#x3D; -((event.clientY - rect.top) / rect.height) * 2 + 1;

    this.raycaster.setFromCamera(this.mouse, this.camera);
    const intersects &#x3D; this.raycaster.intersectObject(this.carModel, true);

    if (intersects.length &gt; 0) {
      const mesh &#x3D; intersects[0].object as import(&#x27;three&#x27;).Mesh;
      if (mesh.isMesh &amp;&amp; mesh !&#x3D;&#x3D; this.hoveredMesh) {
        this.highlightPart(mesh);

        // Update tooltip position
        this.tooltipPosition &#x3D; {
          x:
            event.clientX -
            (this.rendererCanvas.nativeElement.parentElement?.getBoundingClientRect().left || 0),
          y:
            event.clientY -
            (this.rendererCanvas.nativeElement.parentElement?.getBoundingClientRect().top || 0),
        };

        // Emit hover event
        const partInfo &#x3D; this.getPartInfoFromMesh(mesh);
        this.hoveredPartInfo &#x3D; partInfo;
        this.partHovered.emit({
          part: mesh.name || &#x27;unknown&#x27;,
          info: partInfo,
          position: this.tooltipPosition,
        });
      } else if (mesh &#x3D;&#x3D;&#x3D; this.hoveredMesh) {
        // Update tooltip position even when same mesh
        this.tooltipPosition &#x3D; {
          x:
            event.clientX -
            (this.rendererCanvas.nativeElement.parentElement?.getBoundingClientRect().left || 0),
          y:
            event.clientY -
            (this.rendererCanvas.nativeElement.parentElement?.getBoundingClientRect().top || 0),
        };
      }
    } else {
      this.clearHighlight();
    }
  }

  /** Get part info based on mesh name or material properties */
  private getPartInfoFromMesh(mesh: import(&#x27;three&#x27;).Mesh): CarPartInfo {
    const name &#x3D; mesh.name.toLowerCase();

    // Try to match by mesh name
    for (const [key, info] of this.partInfoMap.entries()) {
      if (name.includes(key)) {
        return info;
      }
    }

    // Fallback: detect by material properties
    if (this.THREE &amp;&amp; mesh.material instanceof this.THREE.MeshStandardMaterial) {
      const mat &#x3D; mesh.material;

      // Dark color &#x3D; likely wheel/tire
      if (mat.color.r &lt; 0.15 &amp;&amp; mat.color.g &lt; 0.15 &amp;&amp; mat.color.b &lt; 0.15) {
        return (
          this.partInfoMap.get(&#x27;wheel&#x27;) || {
            name: &#x27;Rueda&#x27;,
            description: &#x27;Parte del sistema de rodamiento&#x27;,
            icon: &#x27;üõû&#x27;,
          }
        );
      }

      // Transparent &#x3D; glass
      if (mat.opacity &lt; 0.9 || mat.transparent) {
        return (
          this.partInfoMap.get(&#x27;glass&#x27;) || {
            name: &#x27;Cristal&#x27;,
            description: &#x27;Superficie de vidrio&#x27;,
            icon: &#x27;‚ú®&#x27;,
          }
        );
      }

      // High metalness &#x3D; body panels
      if (mat.metalness &gt; 0.5) {
        return (
          this.partInfoMap.get(&#x27;body&#x27;) || {
            name: &#x27;Carroceria&#x27;,
            description: &#x27;Estructura del vehiculo&#x27;,
            icon: &#x27;üöó&#x27;,
          }
        );
      }
    }

    // Default fallback
    return { name: &#x27;Parte del vehiculo&#x27;, description: &#x27;Componente del automovil&#x27;, icon: &#x27;üîß&#x27; };
  }

  /** Highlight a mesh with glow effect (Celeste Autorentar) */
  private highlightPart(mesh: import(&#x27;three&#x27;).Mesh): void {
    if (this.hoveredMesh &#x3D;&#x3D;&#x3D; mesh) return;

    // Clear previous highlight
    this.clearHighlight();

    this.hoveredMesh &#x3D; mesh;

    if (this.THREE &amp;&amp; mesh.material instanceof this.THREE.MeshStandardMaterial) {
      // Store original values
      mesh.userData[&#x27;originalEmissive&#x27;] &#x3D; mesh.material.emissive.clone();
      mesh.userData[&#x27;originalEmissiveIntensity&#x27;] &#x3D; mesh.material.emissiveIntensity;

      // Apply celeste pastel glow (#a7d8f4)
      mesh.material.emissive.set(0xa7d8f4);
      mesh.material.emissiveIntensity &#x3D; 0.25;
      mesh.material.needsUpdate &#x3D; true;
    }

    // Change cursor
    if (this.renderer) {
      this.renderer.domElement.style.cursor &#x3D; &#x27;pointer&#x27;;
    }
  }

  /** Clear highlight from hovered mesh */
  private clearHighlight(): void {
    if (!this.hoveredMesh || !this.THREE) return;

    const mesh &#x3D; this.hoveredMesh;
    if (mesh.material instanceof this.THREE.MeshStandardMaterial) {
      // Restore original emissive values
      if (mesh.userData[&#x27;originalEmissive&#x27;]) {
        mesh.material.emissive.copy(mesh.userData[&#x27;originalEmissive&#x27;]);
        mesh.material.emissiveIntensity &#x3D; mesh.userData[&#x27;originalEmissiveIntensity&#x27;] || 0;
        mesh.material.needsUpdate &#x3D; true;
      }
    }

    this.hoveredMesh &#x3D; null;
    this.hoveredPartInfo &#x3D; null;

    // Restore cursor
    if (this.renderer) {
      this.renderer.domElement.style.cursor &#x3D; &#x27;grab&#x27;;
    }
  }

  /** Select a part on click */
  selectPart(mesh: import(&#x27;three&#x27;).Mesh): void {
    // Deselect previous
    this.deselectPartInternal();

    this.selectedMesh &#x3D; mesh;

    if (this.THREE &amp;&amp; mesh.material instanceof this.THREE.MeshStandardMaterial) {
      // Store original values if not already stored
      if (!mesh.userData[&#x27;selectedOriginalEmissive&#x27;]) {
        mesh.userData[&#x27;selectedOriginalEmissive&#x27;] &#x3D; mesh.material.emissive.clone();
        mesh.userData[&#x27;selectedOriginalEmissiveIntensity&#x27;] &#x3D; mesh.material.emissiveIntensity;
      }

      // Apply stronger glow for selection
      mesh.material.emissive.set(0xa7d8f4);
      mesh.material.emissiveIntensity &#x3D; 0.5;
      mesh.material.needsUpdate &#x3D; true;
    }

    const partInfo &#x3D; this.getPartInfoFromMesh(mesh);
    this.selectedPartInfo &#x3D; partInfo;
    this.partSelected.emit({ part: mesh.name || &#x27;unknown&#x27;, info: partInfo });

    // Optional: Zoom to selected part
    this.zoomToPart(mesh);
  }

  /** Deselect the currently selected part (internal) */
  private deselectPartInternal(): void {
    if (!this.selectedMesh || !this.THREE) return;

    const mesh &#x3D; this.selectedMesh;
    if (mesh.material instanceof this.THREE.MeshStandardMaterial) {
      if (mesh.userData[&#x27;selectedOriginalEmissive&#x27;]) {
        mesh.material.emissive.copy(mesh.userData[&#x27;selectedOriginalEmissive&#x27;]);
        mesh.material.emissiveIntensity &#x3D; mesh.userData[&#x27;selectedOriginalEmissiveIntensity&#x27;] || 0;
        mesh.material.needsUpdate &#x3D; true;
        delete mesh.userData[&#x27;selectedOriginalEmissive&#x27;];
        delete mesh.userData[&#x27;selectedOriginalEmissiveIntensity&#x27;];
      }
    }

    this.selectedMesh &#x3D; null;
    this.selectedPartInfo &#x3D; null;
  }

  /** Public method to deselect part (called from template) */
  deselectPart(event?: MouseEvent): void {
    if (event) {
      event.stopPropagation();
    }
    this.deselectPartInternal();
    this.partDeselected.emit();
  }

  /** Zoom camera smoothly to a specific part */
  private zoomToPart(mesh: import(&#x27;three&#x27;).Mesh): void {
    if (!this.THREE || !this.camera || !this.controls) return;

    const box &#x3D; new this.THREE.Box3().setFromObject(mesh);
    const center &#x3D; box.getCenter(new this.THREE.Vector3());
    const size &#x3D; box.getSize(new this.THREE.Vector3());
    const maxDim &#x3D; Math.max(size.x, size.y, size.z);

    // Calculate optimal camera distance
    const distance &#x3D; Math.max(maxDim * 2.5, 3);

    // Direction from center to current camera
    const direction &#x3D; new this.THREE.Vector3()
      .subVectors(this.camera.position, this.controls.target)
      .normalize();

    this.targetCameraPosition &#x3D; {
      x: center.x + direction.x * distance,
      y: center.y + Math.max(direction.y * distance, 1),
      z: center.z + direction.z * distance,
    };
    this.targetControlsTarget &#x3D; { x: center.x, y: center.y, z: center.z };
    this.animatingCamera &#x3D; true;

    // Stop auto-rotate during zoom
    if (this.controls) {
      this.controls.autoRotate &#x3D; false;
    }

    setTimeout(() &#x3D;&gt; {
      this.animatingCamera &#x3D; false;
    }, 1200);
  }

  /** Update dynamic shadows based on camera angle */
  private updateDynamicShadows(): void {
    if (!this.mainLight || !this.controls) return;

    const azimuth &#x3D; this.controls.getAzimuthalAngle();
    const radius &#x3D; 12;

    // Move light opposite to camera for better shadow definition
    this.mainLight.position.x &#x3D; Math.cos(azimuth + Math.PI / 4) * radius;
    this.mainLight.position.z &#x3D; Math.sin(azimuth + Math.PI / 4) * radius;
  }
}
</code></pre>
    </div>
</div>








                   </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div>
</div>
               <!-- END CONTENT -->
           </div>
       </div>

          <label class="dark-mode-switch">
               <input type="checkbox">
               <span class="slider">
                    <svg class="slider-icon" viewBox="0 0 24 24" fill="none" height="20" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" width="20" xmlns="http://www.w3.org/2000/svg">
                    <path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"></path>
                    </svg>
               </span>
          </label>

       <script>
            var COMPODOC_CURRENT_PAGE_DEPTH = 1;
            var COMPODOC_CURRENT_PAGE_CONTEXT = 'interface';
            var COMPODOC_CURRENT_PAGE_URL = 'CarPartInfo-1.html';
            var MAX_SEARCH_RESULTS = 15;
       </script>

       <script>
               $darkModeToggleSwitchers = document.querySelectorAll('.dark-mode-switch input');
               checkToggle(darkModeState);
               if ($darkModeToggleSwitchers.length > 0) {
                    for (var i = 0; i < $darkModeToggleSwitchers.length; i++) {
                         $darkModeToggleSwitchers[i].addEventListener('change', function (event) {
                              darkModeState = !darkModeState;
                              toggleDarkMode(darkModeState);
                         });
                    }
               }
          </script>

       <script src="../js/libs/custom-elements.min.js"></script>
       <script src="../js/libs/lit-html.js"></script>

       <script src="../js/menu-wc.js" defer></script>
       <script nomodule src="../js/menu-wc_es5.js" defer></script>

       <script src="../js/libs/bootstrap-native.js"></script>

       <script src="../js/libs/es6-shim.min.js"></script>
       <script src="../js/libs/EventDispatcher.js"></script>
       <script src="../js/libs/promise.min.js"></script>

       <script src="../js/compodoc.js"></script>

       <script src="../js/tabs.js"></script>
       <script src="../js/menu.js"></script>
       <script src="../js/libs/clipboard.min.js"></script>
       <script src="../js/libs/prism.js"></script>
       <script src="../js/sourceCode.js"></script>
          <script src="../js/search/search.js"></script>
          <script src="../js/search/lunr.min.js"></script>
          <script src="../js/search/search-lunr.js"></script>
          <script src="../js/search/search_index.js"></script>
       <script src="../js/lazy-load-graphs.js"></script>


    </body>
</html>
